using System;
using System.Runtime.InteropServices;
using System.Text;

namespace DarkTech.DarkGL
{
    public delegate void GLDEBUGPROC(int source, int type, int id, int severity, int length, string message, IntPtr userParam);
    public delegate void GLDEBUGPROCAMD(uint id, int category, int severity, int length, string message, IntPtr userParam);

    public class gl
    {
        /// <summary>
        /// <para>Fullname: Accum</para>
        /// </summary>
        [GLEntry("Accum", Category = "1.0")]
        public static GLDelegate.Accum _Accum = null;
        /// <summary>
        /// <para>operate on the accumulation buffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Accum.</para>
        /// <para>Fullname: Accum</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="op">Specifies the accumulation buffer operation. Symbolic constants GL_ACCUM, GL_LOAD, GL_ADD, GL_MULT, and GL_RETURN are accepted.</param>
        /// <param name="value">Specifies a floating-point value used in the accumulation buffer operation. op determines how value is used.</param>
        public static void Accum(int op, float value)
        {
            if (gl._Accum != null) gl._Accum(op, value); else { }
        }
        /// <summary>
        /// <para>Fullname: AlphaFunc</para>
        /// </summary>
        [GLEntry("AlphaFunc", Category = "1.0")]
        public static GLDelegate.AlphaFunc _AlphaFunc = null;
        /// <summary>
        /// <para>specify the alpha test function</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _AlphaFunc.</para>
        /// <para>Fullname: AlphaFunc</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="func">Specifies the alpha comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_ALWAYS.</param>
        /// <param name="ref">Specifies the reference value that incoming alpha values are compared to. This value is clamped to the range 01, where 0 represents the lowest possible alpha value and 1 the highest possible value. The initial reference value is 0.</param>
        public static void AlphaFunc(int func, float reference)
        {
            if (gl._AlphaFunc != null) gl._AlphaFunc(func, reference); else { }
        }
        /// <summary>
        /// <para>Fullname: Begin</para>
        /// </summary>
        [GLEntry("Begin", Category = "1.0")]
        public static GLDelegate.Begin _Begin = null;
        /// <summary>
        /// <para>delimit the vertices of a primitive or a group of like primitives</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Begin.</para>
        /// <para>Fullname: Begin</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="mode">Specifies the primitive or primitives that will be created from vertices presented between glBegin and the subsequent glEnd. Ten symbolic constants are accepted: GL_POINTS, GL_LINES, GL_LINE_STRIP, GL_LINE_LOOP, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_QUADS, GL_QUAD_STRIP, and GL_POLYGON.</param>
        public static void Begin(int mode)
        {
            if (gl._Begin != null) gl._Begin(mode); else { }
        }
        /// <summary>
        /// <para>Fullname: Bitmap</para>
        /// </summary>
        [GLEntry("Bitmap", Category = "1.0")]
        public static GLDelegate.Bitmap _Bitmap = null;
        /// <summary>
        /// <para>draw a bitmap</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Bitmap.</para>
        /// <para>Fullname: Bitmap</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="width">Specify the pixel width and height of the bitmap image.</param>
        /// <param name="height">Specify the pixel width and height of the bitmap image.</param>
        /// <param name="xorig">Specify the location of the origin in the bitmap image. The origin is measured from the lower left corner of the bitmap, with right and up being the positive axes.</param>
        /// <param name="yorig">Specify the location of the origin in the bitmap image. The origin is measured from the lower left corner of the bitmap, with right and up being the positive axes.</param>
        /// <param name="xmove">Specify the x and y offsets to be added to the current raster position after the bitmap is drawn.</param>
        /// <param name="ymove">Specify the x and y offsets to be added to the current raster position after the bitmap is drawn.</param>
        /// <param name="bitmap">Specifies the address of the bitmap image.</param>
        public static void Bitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, byte[] bitmap)
        {
            if (gl._Bitmap != null) gl._Bitmap(width, height, xorig, yorig, xmove, ymove, bitmap); else { }
        }
        /// <summary>
        /// <para>Fullname: BlendFunc</para>
        /// </summary>
        [GLEntry("BlendFunc", Category = "1.0")]
        public static GLDelegate.BlendFunc _BlendFunc = null;
        /// <summary>
        /// <para>specify pixel arithmetic</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BlendFunc.</para>
        /// <para>Fullname: BlendFunc</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="buf">For glBlendFunci, specifies the index of the draw buffer for which to set the blend function.</param>
        /// <param name="sfactor">Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is GL_ONE.</param>
        /// <param name="dfactor">Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.</param>
        public static void BlendFunc(int sfactor, int dfactor)
        {
            if (gl._BlendFunc != null) gl._BlendFunc(sfactor, dfactor); else { }
        }
        /// <summary>
        /// <para>Fullname: CallList</para>
        /// </summary>
        [GLEntry("CallList", Category = "1.0")]
        public static GLDelegate.CallList _CallList = null;
        /// <summary>
        /// <para>execute a display list</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CallList.</para>
        /// <para>Fullname: CallList</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="list">Specifies the integer name of the display list to be executed.</param>
        public static void CallList(uint list)
        {
            if (gl._CallList != null) gl._CallList(list); else { }
        }
        /// <summary>
        /// <para>Fullname: CallLists</para>
        /// </summary>
        [GLEntry("CallLists", Category = "1.0")]
        public static GLDelegate.CallLists _CallLists = null;
        /// <summary>
        /// <para>execute a list of display lists</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CallLists.</para>
        /// <para>Fullname: CallLists</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="n">Specifies the number of display lists to be executed.</param>
        /// <param name="type">Specifies the type of values in lists. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_2_BYTES, GL_3_BYTES, and GL_4_BYTES are accepted.</param>
        /// <param name="lists">Specifies the address of an array of name offsets in the display list. The pointer type is void because the offsets can be bytes, shorts, ints, or floats, depending on the value of type.</param>
        public static void CallLists(int n, int type, IntPtr lists)
        {
            if (gl._CallLists != null) gl._CallLists(n, type, lists); else { }
        }
        /// <summary>
        /// <para>execute a list of display lists</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CallLists.</para>
        /// <para>Fullname: CallLists</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="n">Specifies the number of display lists to be executed.</param>
        /// <param name="type">Specifies the type of values in lists. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_2_BYTES, GL_3_BYTES, and GL_4_BYTES are accepted.</param>
        /// <param name="lists">Specifies the address of an array of name offsets in the display list. The pointer type is void because the offsets can be bytes, shorts, ints, or floats, depending on the value of type.</param>
        public static void CallLists(int n, int type, Array lists)
        {
            GCHandle h = GCHandle.Alloc(lists, GCHandleType.Pinned);
            try { if (gl._CallLists != null) gl._CallLists(n, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: Clear</para>
        /// </summary>
        [GLEntry("Clear", Category = "1.0")]
        public static GLDelegate.Clear _Clear = null;
        /// <summary>
        /// <para>clear buffers to preset values</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Clear.</para>
        /// <para>Fullname: Clear</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="mask">Bitwise OR of masks that indicate the buffers to be cleared. The three masks are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT.</param>
        public static void Clear(int mask)
        {
            if (gl._Clear != null) gl._Clear(mask); else { }
        }
        /// <summary>
        /// <para>Fullname: ClearAccum</para>
        /// </summary>
        [GLEntry("ClearAccum", Category = "1.0")]
        public static GLDelegate.ClearAccum _ClearAccum = null;
        /// <summary>
        /// <para>specify clear values for the accumulation buffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClearAccum.</para>
        /// <para>Fullname: ClearAccum</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The initial values are all 0.</param>
        /// <param name="green">Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The initial values are all 0.</param>
        /// <param name="blue">Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The initial values are all 0.</param>
        /// <param name="alpha">Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The initial values are all 0.</param>
        public static void ClearAccum(float red, float green, float blue, float alpha)
        {
            if (gl._ClearAccum != null) gl._ClearAccum(red, green, blue, alpha); else { }
        }
        /// <summary>
        /// <para>Fullname: ClearColor</para>
        /// </summary>
        [GLEntry("ClearColor", Category = "1.0")]
        public static GLDelegate.ClearColor _ClearColor = null;
        /// <summary>
        /// <para>specify clear values for the color buffers</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClearColor.</para>
        /// <para>Fullname: ClearColor</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="red">Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.</param>
        /// <param name="green">Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.</param>
        /// <param name="blue">Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.</param>
        /// <param name="alpha">Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.</param>
        public static void ClearColor(float red, float green, float blue, float alpha)
        {
            if (gl._ClearColor != null) gl._ClearColor(red, green, blue, alpha); else { }
        }
        /// <summary>
        /// <para>Fullname: ClearDepth</para>
        /// </summary>
        [GLEntry("ClearDepth", Category = "1.0")]
        public static GLDelegate.ClearDepth _ClearDepth = null;
        /// <summary>
        /// <para>specify the clear value for the depth buffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClearDepth.</para>
        /// <para>Fullname: ClearDepth</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="depth">Specifies the depth value used when the depth buffer is cleared. The initial value is 1.</param>
        public static void ClearDepth(double depth)
        {
            if (gl._ClearDepth != null) gl._ClearDepth(depth); else { }
        }
        /// <summary>
        /// <para>Fullname: ClearIndex</para>
        /// </summary>
        [GLEntry("ClearIndex", Category = "1.0")]
        public static GLDelegate.ClearIndex _ClearIndex = null;
        /// <summary>
        /// <para>specify the clear value for the color index buffers</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClearIndex.</para>
        /// <para>Fullname: ClearIndex</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="c">Specifies the index used when the color index buffers are cleared. The initial value is 0.</param>
        public static void ClearIndex(float c)
        {
            if (gl._ClearIndex != null) gl._ClearIndex(c); else { }
        }
        /// <summary>
        /// <para>Fullname: ClearStencil</para>
        /// </summary>
        [GLEntry("ClearStencil", Category = "1.0")]
        public static GLDelegate.ClearStencil _ClearStencil = null;
        /// <summary>
        /// <para>specify the clear value for the stencil buffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClearStencil.</para>
        /// <para>Fullname: ClearStencil</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="s">Specifies the index used when the stencil buffer is cleared. The initial value is 0.</param>
        public static void ClearStencil(int s)
        {
            if (gl._ClearStencil != null) gl._ClearStencil(s); else { }
        }
        /// <summary>
        /// <para>Fullname: ClipPlane</para>
        /// </summary>
        [GLEntry("ClipPlane", Category = "1.0")]
        public static GLDelegate.ClipPlane _ClipPlane = null;
        /// <summary>
        /// <para>specify a plane against which all geometry is clipped</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClipPlane.</para>
        /// <para>Fullname: ClipPlane</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="plane">Specifies which clipping plane is being positioned. Symbolic names of the form GL_CLIP_PLANEi, where i is an integer between 0 and GL_MAX_CLIP_PLANES-1, are accepted.</param>
        /// <param name="equation">Specifies the address of an array of four double-precision floating-point values. These values are interpreted as a plane equation.</param>
        public static void ClipPlane(int plane, double[] equation)
        {
            if (gl._ClipPlane != null) gl._ClipPlane(plane, equation); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3b</para>
        /// </summary>
        [GLEntry("Color3b", Category = "1.0")]
        public static GLDelegate.Color3b _Color3b = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3b.</para>
        /// <para>Fullname: Color3b</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color3b(byte red, byte green, byte blue)
        {
            if (gl._Color3b != null) gl._Color3b(red, green, blue); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3bv</para>
        /// </summary>
        [GLEntry("Color3bv", Category = "1.0")]
        public static GLDelegate.Color3bv _Color3bv = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3bv.</para>
        /// <para>Fullname: Color3bv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color3bv(byte[] v)
        {
            if (gl._Color3bv != null) gl._Color3bv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3d</para>
        /// </summary>
        [GLEntry("Color3d", Category = "1.0")]
        public static GLDelegate.Color3d _Color3d = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3d.</para>
        /// <para>Fullname: Color3d</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color3d(double red, double green, double blue)
        {
            if (gl._Color3d != null) gl._Color3d(red, green, blue); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3dv</para>
        /// </summary>
        [GLEntry("Color3dv", Category = "1.0")]
        public static GLDelegate.Color3dv _Color3dv = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3dv.</para>
        /// <para>Fullname: Color3dv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color3dv(double[] v)
        {
            if (gl._Color3dv != null) gl._Color3dv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3f</para>
        /// </summary>
        [GLEntry("Color3f", Category = "1.0")]
        public static GLDelegate.Color3f _Color3f = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3f.</para>
        /// <para>Fullname: Color3f</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color3f(float red, float green, float blue)
        {
            if (gl._Color3f != null) gl._Color3f(red, green, blue); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3fv</para>
        /// </summary>
        [GLEntry("Color3fv", Category = "1.0")]
        public static GLDelegate.Color3fv _Color3fv = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3fv.</para>
        /// <para>Fullname: Color3fv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color3fv(float[] v)
        {
            if (gl._Color3fv != null) gl._Color3fv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3i</para>
        /// </summary>
        [GLEntry("Color3i", Category = "1.0")]
        public static GLDelegate.Color3i _Color3i = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3i.</para>
        /// <para>Fullname: Color3i</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color3i(int red, int green, int blue)
        {
            if (gl._Color3i != null) gl._Color3i(red, green, blue); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3iv</para>
        /// </summary>
        [GLEntry("Color3iv", Category = "1.0")]
        public static GLDelegate.Color3iv _Color3iv = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3iv.</para>
        /// <para>Fullname: Color3iv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color3iv(int[] v)
        {
            if (gl._Color3iv != null) gl._Color3iv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3s</para>
        /// </summary>
        [GLEntry("Color3s", Category = "1.0")]
        public static GLDelegate.Color3s _Color3s = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3s.</para>
        /// <para>Fullname: Color3s</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color3s(short red, short green, short blue)
        {
            if (gl._Color3s != null) gl._Color3s(red, green, blue); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3sv</para>
        /// </summary>
        [GLEntry("Color3sv", Category = "1.0")]
        public static GLDelegate.Color3sv _Color3sv = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3sv.</para>
        /// <para>Fullname: Color3sv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color3sv(short[] v)
        {
            if (gl._Color3sv != null) gl._Color3sv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3ub</para>
        /// </summary>
        [GLEntry("Color3ub", Category = "1.0")]
        public static GLDelegate.Color3ub _Color3ub = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3ub.</para>
        /// <para>Fullname: Color3ub</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color3ub(byte red, byte green, byte blue)
        {
            if (gl._Color3ub != null) gl._Color3ub(red, green, blue); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3ubv</para>
        /// </summary>
        [GLEntry("Color3ubv", Category = "1.0")]
        public static GLDelegate.Color3ubv _Color3ubv = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3ubv.</para>
        /// <para>Fullname: Color3ubv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color3ubv(byte[] v)
        {
            if (gl._Color3ubv != null) gl._Color3ubv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3ui</para>
        /// </summary>
        [GLEntry("Color3ui", Category = "1.0")]
        public static GLDelegate.Color3ui _Color3ui = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3ui.</para>
        /// <para>Fullname: Color3ui</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color3ui(uint red, uint green, uint blue)
        {
            if (gl._Color3ui != null) gl._Color3ui(red, green, blue); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3uiv</para>
        /// </summary>
        [GLEntry("Color3uiv", Category = "1.0")]
        public static GLDelegate.Color3uiv _Color3uiv = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3uiv.</para>
        /// <para>Fullname: Color3uiv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color3uiv(uint[] v)
        {
            if (gl._Color3uiv != null) gl._Color3uiv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3us</para>
        /// </summary>
        [GLEntry("Color3us", Category = "1.0")]
        public static GLDelegate.Color3us _Color3us = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3us.</para>
        /// <para>Fullname: Color3us</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color3us(ushort red, ushort green, ushort blue)
        {
            if (gl._Color3us != null) gl._Color3us(red, green, blue); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3usv</para>
        /// </summary>
        [GLEntry("Color3usv", Category = "1.0")]
        public static GLDelegate.Color3usv _Color3usv = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3usv.</para>
        /// <para>Fullname: Color3usv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color3usv(ushort[] v)
        {
            if (gl._Color3usv != null) gl._Color3usv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4b</para>
        /// </summary>
        [GLEntry("Color4b", Category = "1.0")]
        public static GLDelegate.Color4b _Color4b = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4b.</para>
        /// <para>Fullname: Color4b</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color4b(byte red, byte green, byte blue, byte alpha)
        {
            if (gl._Color4b != null) gl._Color4b(red, green, blue, alpha); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4bv</para>
        /// </summary>
        [GLEntry("Color4bv", Category = "1.0")]
        public static GLDelegate.Color4bv _Color4bv = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4bv.</para>
        /// <para>Fullname: Color4bv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color4bv(byte[] v)
        {
            if (gl._Color4bv != null) gl._Color4bv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4d</para>
        /// </summary>
        [GLEntry("Color4d", Category = "1.0")]
        public static GLDelegate.Color4d _Color4d = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4d.</para>
        /// <para>Fullname: Color4d</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color4d(double red, double green, double blue, double alpha)
        {
            if (gl._Color4d != null) gl._Color4d(red, green, blue, alpha); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4dv</para>
        /// </summary>
        [GLEntry("Color4dv", Category = "1.0")]
        public static GLDelegate.Color4dv _Color4dv = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4dv.</para>
        /// <para>Fullname: Color4dv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color4dv(double[] v)
        {
            if (gl._Color4dv != null) gl._Color4dv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4f</para>
        /// </summary>
        [GLEntry("Color4f", Category = "1.0")]
        public static GLDelegate.Color4f _Color4f = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4f.</para>
        /// <para>Fullname: Color4f</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color4f(float red, float green, float blue, float alpha)
        {
            if (gl._Color4f != null) gl._Color4f(red, green, blue, alpha); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4fv</para>
        /// </summary>
        [GLEntry("Color4fv", Category = "1.0")]
        public static GLDelegate.Color4fv _Color4fv = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4fv.</para>
        /// <para>Fullname: Color4fv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color4fv(float[] v)
        {
            if (gl._Color4fv != null) gl._Color4fv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4i</para>
        /// </summary>
        [GLEntry("Color4i", Category = "1.0")]
        public static GLDelegate.Color4i _Color4i = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4i.</para>
        /// <para>Fullname: Color4i</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color4i(int red, int green, int blue, int alpha)
        {
            if (gl._Color4i != null) gl._Color4i(red, green, blue, alpha); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4iv</para>
        /// </summary>
        [GLEntry("Color4iv", Category = "1.0")]
        public static GLDelegate.Color4iv _Color4iv = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4iv.</para>
        /// <para>Fullname: Color4iv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color4iv(int[] v)
        {
            if (gl._Color4iv != null) gl._Color4iv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4s</para>
        /// </summary>
        [GLEntry("Color4s", Category = "1.0")]
        public static GLDelegate.Color4s _Color4s = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4s.</para>
        /// <para>Fullname: Color4s</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color4s(short red, short green, short blue, short alpha)
        {
            if (gl._Color4s != null) gl._Color4s(red, green, blue, alpha); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4sv</para>
        /// </summary>
        [GLEntry("Color4sv", Category = "1.0")]
        public static GLDelegate.Color4sv _Color4sv = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4sv.</para>
        /// <para>Fullname: Color4sv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color4sv(short[] v)
        {
            if (gl._Color4sv != null) gl._Color4sv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4ub</para>
        /// </summary>
        [GLEntry("Color4ub", Category = "1.0")]
        public static GLDelegate.Color4ub _Color4ub = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4ub.</para>
        /// <para>Fullname: Color4ub</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color4ub(byte red, byte green, byte blue, byte alpha)
        {
            if (gl._Color4ub != null) gl._Color4ub(red, green, blue, alpha); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4ubv</para>
        /// </summary>
        [GLEntry("Color4ubv", Category = "1.0")]
        public static GLDelegate.Color4ubv _Color4ubv = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4ubv.</para>
        /// <para>Fullname: Color4ubv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color4ubv(byte[] v)
        {
            if (gl._Color4ubv != null) gl._Color4ubv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4ui</para>
        /// </summary>
        [GLEntry("Color4ui", Category = "1.0")]
        public static GLDelegate.Color4ui _Color4ui = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4ui.</para>
        /// <para>Fullname: Color4ui</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color4ui(uint red, uint green, uint blue, uint alpha)
        {
            if (gl._Color4ui != null) gl._Color4ui(red, green, blue, alpha); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4uiv</para>
        /// </summary>
        [GLEntry("Color4uiv", Category = "1.0")]
        public static GLDelegate.Color4uiv _Color4uiv = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4uiv.</para>
        /// <para>Fullname: Color4uiv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color4uiv(uint[] v)
        {
            if (gl._Color4uiv != null) gl._Color4uiv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4us</para>
        /// </summary>
        [GLEntry("Color4us", Category = "1.0")]
        public static GLDelegate.Color4us _Color4us = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4us.</para>
        /// <para>Fullname: Color4us</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color4us(ushort red, ushort green, ushort blue, ushort alpha)
        {
            if (gl._Color4us != null) gl._Color4us(red, green, blue, alpha); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4usv</para>
        /// </summary>
        [GLEntry("Color4usv", Category = "1.0")]
        public static GLDelegate.Color4usv _Color4usv = null;
        /// <summary>
        /// <para>set the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4usv.</para>
        /// <para>Fullname: Color4usv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current color.</param>
        /// <param name="alpha">Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.</param>
        public static void Color4usv(ushort[] v)
        {
            if (gl._Color4usv != null) gl._Color4usv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: ColorMask</para>
        /// </summary>
        [GLEntry("ColorMask", Category = "1.0")]
        public static GLDelegate.ColorMask _ColorMask = null;
        /// <summary>
        /// <para>enable and disable writing of frame buffer color components</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorMask.</para>
        /// <para>Fullname: ColorMask</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="buf">For glColorMaski, specifies the index of the draw buffer whose color mask to set.</param>
        /// <param name="red">Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written.</param>
        /// <param name="green">Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written.</param>
        /// <param name="blue">Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written.</param>
        /// <param name="alpha">Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written.</param>
        public static void ColorMask(bool red, bool green, bool blue, bool alpha)
        {
            if (gl._ColorMask != null) gl._ColorMask(red, green, blue, alpha); else { }
        }
        /// <summary>
        /// <para>Fullname: ColorMaterial</para>
        /// </summary>
        [GLEntry("ColorMaterial", Category = "1.0")]
        public static GLDelegate.ColorMaterial _ColorMaterial = null;
        /// <summary>
        /// <para>cause a material color to track the current color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorMaterial.</para>
        /// <para>Fullname: ColorMaterial</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="face">Specifies whether front, back, or both front and back material parameters should track the current color. Accepted values are GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. The initial value is GL_FRONT_AND_BACK.</param>
        /// <param name="mode">Specifies which of several material parameters track the current color. Accepted values are GL_EMISSION, GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, and GL_AMBIENT_AND_DIFFUSE. The initial value is GL_AMBIENT_AND_DIFFUSE.</param>
        public static void ColorMaterial(int face, int mode)
        {
            if (gl._ColorMaterial != null) gl._ColorMaterial(face, mode); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyPixels</para>
        /// </summary>
        [GLEntry("CopyPixels", Category = "1.0")]
        public static GLDelegate.CopyPixels _CopyPixels = null;
        /// <summary>
        /// <para>copy pixels in the frame buffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyPixels.</para>
        /// <para>Fullname: CopyPixels</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specify the dimensions of the rectangular region of pixels to be copied. Both must be nonnegative.</param>
        /// <param name="height">Specify the dimensions of the rectangular region of pixels to be copied. Both must be nonnegative.</param>
        /// <param name="type">Specifies whether color values, depth values, or stencil values are to be copied. Symbolic constants GL_COLOR, GL_DEPTH, and GL_STENCIL are accepted.</param>
        public static void CopyPixels(int x, int y, int width, int height, int type)
        {
            if (gl._CopyPixels != null) gl._CopyPixels(x, y, width, height, type); else { }
        }
        /// <summary>
        /// <para>Fullname: CullFace</para>
        /// </summary>
        [GLEntry("CullFace", Category = "1.0")]
        public static GLDelegate.CullFace _CullFace = null;
        /// <summary>
        /// <para>specify whether front- or back-facing facets can be culled</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CullFace.</para>
        /// <para>Fullname: CullFace</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="mode">Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK are accepted. The initial value is GL_BACK.</param>
        public static void CullFace(int mode)
        {
            if (gl._CullFace != null) gl._CullFace(mode); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteLists</para>
        /// </summary>
        [GLEntry("DeleteLists", Category = "1.0")]
        public static GLDelegate.DeleteLists _DeleteLists = null;
        /// <summary>
        /// <para>delete a contiguous group of display lists</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteLists.</para>
        /// <para>Fullname: DeleteLists</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="list">Specifies the integer name of the first display list to delete.</param>
        /// <param name="range">Specifies the number of display lists to delete.</param>
        public static void DeleteLists(uint list, int range)
        {
            if (gl._DeleteLists != null) gl._DeleteLists(list, range); else { }
        }
        /// <summary>
        /// <para>Fullname: DepthFunc</para>
        /// </summary>
        [GLEntry("DepthFunc", Category = "1.0")]
        public static GLDelegate.DepthFunc _DepthFunc = null;
        /// <summary>
        /// <para>specify the value used for depth buffer comparisons</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DepthFunc.</para>
        /// <para>Fullname: DepthFunc</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="func">Specifies the depth comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_LESS.</param>
        public static void DepthFunc(int func)
        {
            if (gl._DepthFunc != null) gl._DepthFunc(func); else { }
        }
        /// <summary>
        /// <para>Fullname: DepthMask</para>
        /// </summary>
        [GLEntry("DepthMask", Category = "1.0")]
        public static GLDelegate.DepthMask _DepthMask = null;
        /// <summary>
        /// <para>enable or disable writing into the depth buffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DepthMask.</para>
        /// <para>Fullname: DepthMask</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="flag">Specifies whether the depth buffer is enabled for writing. If flag is GL_FALSE, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.</param>
        public static void DepthMask(bool flag)
        {
            if (gl._DepthMask != null) gl._DepthMask(flag); else { }
        }
        /// <summary>
        /// <para>Fullname: DepthRange</para>
        /// </summary>
        [GLEntry("DepthRange", Category = "1.0")]
        public static GLDelegate.DepthRange _DepthRange = null;
        /// <summary>
        /// <para>specify mapping of depth values from normalized device coordinates to window coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DepthRange.</para>
        /// <para>Fullname: DepthRange</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="nearVal">Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.</param>
        /// <param name="farVal">Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.</param>
        public static void DepthRange(double near, double far)
        {
            if (gl._DepthRange != null) gl._DepthRange(near, far); else { }
        }
        /// <summary>
        /// <para>Fullname: Disable</para>
        /// </summary>
        [GLEntry("Disable", Category = "1.0")]
        public static GLDelegate.Disable _Disable = null;
        /// <summary>
        /// <para>enable or disable server-side GL capabilities</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Disable.</para>
        /// <para>Fullname: Disable</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="cap">Specifies a symbolic constant indicating a GL capability.</param>
        public static void Disable(int cap)
        {
            if (gl._Disable != null) gl._Disable(cap); else { }
        }
        /// <summary>
        /// <para>Fullname: DrawBuffer</para>
        /// </summary>
        [GLEntry("DrawBuffer", Category = "1.0")]
        public static GLDelegate.DrawBuffer _DrawBuffer = null;
        /// <summary>
        /// <para>specify which color buffers are to be drawn into</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawBuffer.</para>
        /// <para>Fullname: DrawBuffer</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="mode">Specifies up to four color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT for single-buffered contexts, and GL_BACK for double-buffered contexts.</param>
        public static void DrawBuffer(int mode)
        {
            if (gl._DrawBuffer != null) gl._DrawBuffer(mode); else { }
        }
        /// <summary>
        /// <para>Fullname: DrawPixels</para>
        /// </summary>
        [GLEntry("DrawPixels", Category = "1.0")]
        public static GLDelegate.DrawPixels _DrawPixels = null;
        /// <summary>
        /// <para>write a block of pixels to the frame buffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawPixels.</para>
        /// <para>Fullname: DrawPixels</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="width">Specify the dimensions of the pixel rectangle to be written into the frame buffer.</param>
        /// <param name="height">Specify the dimensions of the pixel rectangle to be written into the frame buffer.</param>
        /// <param name="format">Specifies the format of the pixel data. Symbolic constants GL_COLOR_INDEX, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA are accepted.</param>
        /// <param name="type">Specifies the data type for data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.</param>
        /// <param name="data">Specifies a pointer to the pixel data.</param>
        public static void DrawPixels(int width, int height, int format, int type, IntPtr pixels)
        {
            if (gl._DrawPixels != null) gl._DrawPixels(width, height, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>Fullname: EdgeFlag</para>
        /// </summary>
        [GLEntry("EdgeFlag", Category = "1.0")]
        public static GLDelegate.EdgeFlag _EdgeFlag = null;
        /// <summary>
        /// <para>flag edges as either boundary or nonboundary</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EdgeFlag.</para>
        /// <para>Fullname: EdgeFlag</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="flag">Specifies the current edge flag value, either GL_TRUE or GL_FALSE. The initial value is GL_TRUE.</param>
        public static void EdgeFlag(bool flag)
        {
            if (gl._EdgeFlag != null) gl._EdgeFlag(flag); else { }
        }
        /// <summary>
        /// <para>Fullname: EdgeFlagv</para>
        /// </summary>
        [GLEntry("EdgeFlagv", Category = "1.0")]
        public static GLDelegate.EdgeFlagv _EdgeFlagv = null;
        /// <summary>
        /// <para>flag edges as either boundary or nonboundary</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EdgeFlagv.</para>
        /// <para>Fullname: EdgeFlagv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="flag">Specifies the current edge flag value, either GL_TRUE or GL_FALSE. The initial value is GL_TRUE.</param>
        public static void EdgeFlagv(bool[] flag)
        {
            if (gl._EdgeFlagv != null) gl._EdgeFlagv(flag); else { }
        }
        /// <summary>
        /// <para>Fullname: Enable</para>
        /// </summary>
        [GLEntry("Enable", Category = "1.0")]
        public static GLDelegate.Enable _Enable = null;
        /// <summary>
        /// <para>enable or disable server-side GL capabilities</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Enable.</para>
        /// <para>Fullname: Enable</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="cap">Specifies a symbolic constant indicating a GL capability.</param>
        public static void Enable(int cap)
        {
            if (gl._Enable != null) gl._Enable(cap); else { }
        }
        /// <summary>
        /// <para>Fullname: End</para>
        /// </summary>
        [GLEntry("End", Category = "1.0")]
        public static GLDelegate.End _End = null;
        /// <summary>
        /// <para>delimit the vertices of a primitive or a group of like primitives</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _End.</para>
        /// <para>Fullname: End</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="mode">Specifies the primitive or primitives that will be created from vertices presented between glBegin and the subsequent glEnd. Ten symbolic constants are accepted: GL_POINTS, GL_LINES, GL_LINE_STRIP, GL_LINE_LOOP, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_QUADS, GL_QUAD_STRIP, and GL_POLYGON.</param>
        public static void End()
        {
            if (gl._End != null) gl._End(); else { }
        }
        /// <summary>
        /// <para>Fullname: EndList</para>
        /// </summary>
        [GLEntry("EndList", Category = "1.0")]
        public static GLDelegate.EndList _EndList = null;
        /// <summary>
        /// <para>create or replace a display list</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EndList.</para>
        /// <para>Fullname: EndList</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="list">Specifies the display-list name.</param>
        /// <param name="mode">Specifies the compilation mode, which can be GL_COMPILE or GL_COMPILE_AND_EXECUTE.</param>
        public static void EndList()
        {
            if (gl._EndList != null) gl._EndList(); else { }
        }
        /// <summary>
        /// <para>Fullname: EvalCoord1d</para>
        /// </summary>
        [GLEntry("EvalCoord1d", Category = "1.0")]
        public static GLDelegate.EvalCoord1d _EvalCoord1d = null;
        /// <summary>
        /// <para>evaluate enabled one- and two-dimensional maps</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EvalCoord1d.</para>
        /// <para>Fullname: EvalCoord1d</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="u">Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command.</param>
        /// <param name="v">Specifies a value that is the domain coordinate v to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.</param>
        public static void EvalCoord1d(double u)
        {
            if (gl._EvalCoord1d != null) gl._EvalCoord1d(u); else { }
        }
        /// <summary>
        /// <para>Fullname: EvalCoord1dv</para>
        /// </summary>
        [GLEntry("EvalCoord1dv", Category = "1.0")]
        public static GLDelegate.EvalCoord1dv _EvalCoord1dv = null;
        /// <summary>
        /// <para>evaluate enabled one- and two-dimensional maps</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EvalCoord1dv.</para>
        /// <para>Fullname: EvalCoord1dv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="u">Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command.</param>
        /// <param name="v">Specifies a value that is the domain coordinate v to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.</param>
        public static void EvalCoord1dv(double[] u)
        {
            if (gl._EvalCoord1dv != null) gl._EvalCoord1dv(u); else { }
        }
        /// <summary>
        /// <para>Fullname: EvalCoord1dv</para>
        /// </summary>
        [GLEntry("EvalCoord1dv", Category = "1.0")]
        public static GLDelegate.EvalCoord1dv_double _EvalCoord1dv_double = null;
        /// <summary>
        /// <para>evaluate enabled one- and two-dimensional maps</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EvalCoord1dv_double.</para>
        /// <para>Fullname: EvalCoord1dv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="u">Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command.</param>
        /// <param name="v">Specifies a value that is the domain coordinate v to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.</param>
        public static void EvalCoord1dv(ref double u)
        {
            if (gl._EvalCoord1dv_double != null) gl._EvalCoord1dv_double(ref u); else { }
        }
        /// <summary>
        /// <para>Fullname: EvalCoord1f</para>
        /// </summary>
        [GLEntry("EvalCoord1f", Category = "1.0")]
        public static GLDelegate.EvalCoord1f _EvalCoord1f = null;
        /// <summary>
        /// <para>evaluate enabled one- and two-dimensional maps</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EvalCoord1f.</para>
        /// <para>Fullname: EvalCoord1f</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="u">Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command.</param>
        /// <param name="v">Specifies a value that is the domain coordinate v to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.</param>
        public static void EvalCoord1f(float u)
        {
            if (gl._EvalCoord1f != null) gl._EvalCoord1f(u); else { }
        }
        /// <summary>
        /// <para>Fullname: EvalCoord1fv</para>
        /// </summary>
        [GLEntry("EvalCoord1fv", Category = "1.0")]
        public static GLDelegate.EvalCoord1fv _EvalCoord1fv = null;
        /// <summary>
        /// <para>evaluate enabled one- and two-dimensional maps</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EvalCoord1fv.</para>
        /// <para>Fullname: EvalCoord1fv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="u">Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command.</param>
        /// <param name="v">Specifies a value that is the domain coordinate v to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.</param>
        public static void EvalCoord1fv(float[] u)
        {
            if (gl._EvalCoord1fv != null) gl._EvalCoord1fv(u); else { }
        }
        /// <summary>
        /// <para>Fullname: EvalCoord1fv</para>
        /// </summary>
        [GLEntry("EvalCoord1fv", Category = "1.0")]
        public static GLDelegate.EvalCoord1fv_float _EvalCoord1fv_float = null;
        /// <summary>
        /// <para>evaluate enabled one- and two-dimensional maps</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EvalCoord1fv_float.</para>
        /// <para>Fullname: EvalCoord1fv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="u">Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command.</param>
        /// <param name="v">Specifies a value that is the domain coordinate v to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.</param>
        public static void EvalCoord1fv(ref float u)
        {
            if (gl._EvalCoord1fv_float != null) gl._EvalCoord1fv_float(ref u); else { }
        }
        /// <summary>
        /// <para>Fullname: EvalCoord2d</para>
        /// </summary>
        [GLEntry("EvalCoord2d", Category = "1.0")]
        public static GLDelegate.EvalCoord2d _EvalCoord2d = null;
        /// <summary>
        /// <para>evaluate enabled one- and two-dimensional maps</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EvalCoord2d.</para>
        /// <para>Fullname: EvalCoord2d</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="u">Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command.</param>
        /// <param name="v">Specifies a value that is the domain coordinate v to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.</param>
        public static void EvalCoord2d(double u, double v)
        {
            if (gl._EvalCoord2d != null) gl._EvalCoord2d(u, v); else { }
        }
        /// <summary>
        /// <para>Fullname: EvalCoord2dv</para>
        /// </summary>
        [GLEntry("EvalCoord2dv", Category = "1.0")]
        public static GLDelegate.EvalCoord2dv _EvalCoord2dv = null;
        /// <summary>
        /// <para>evaluate enabled one- and two-dimensional maps</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EvalCoord2dv.</para>
        /// <para>Fullname: EvalCoord2dv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="u">Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command.</param>
        /// <param name="v">Specifies a value that is the domain coordinate v to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.</param>
        public static void EvalCoord2dv(double[] u)
        {
            if (gl._EvalCoord2dv != null) gl._EvalCoord2dv(u); else { }
        }
        /// <summary>
        /// <para>Fullname: EvalCoord2f</para>
        /// </summary>
        [GLEntry("EvalCoord2f", Category = "1.0")]
        public static GLDelegate.EvalCoord2f _EvalCoord2f = null;
        /// <summary>
        /// <para>evaluate enabled one- and two-dimensional maps</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EvalCoord2f.</para>
        /// <para>Fullname: EvalCoord2f</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="u">Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command.</param>
        /// <param name="v">Specifies a value that is the domain coordinate v to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.</param>
        public static void EvalCoord2f(float u, float v)
        {
            if (gl._EvalCoord2f != null) gl._EvalCoord2f(u, v); else { }
        }
        /// <summary>
        /// <para>Fullname: EvalCoord2fv</para>
        /// </summary>
        [GLEntry("EvalCoord2fv", Category = "1.0")]
        public static GLDelegate.EvalCoord2fv _EvalCoord2fv = null;
        /// <summary>
        /// <para>evaluate enabled one- and two-dimensional maps</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EvalCoord2fv.</para>
        /// <para>Fullname: EvalCoord2fv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="u">Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command.</param>
        /// <param name="v">Specifies a value that is the domain coordinate v to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.</param>
        public static void EvalCoord2fv(float[] u)
        {
            if (gl._EvalCoord2fv != null) gl._EvalCoord2fv(u); else { }
        }
        /// <summary>
        /// <para>Fullname: EvalMesh1</para>
        /// </summary>
        [GLEntry("EvalMesh1", Category = "1.0")]
        public static GLDelegate.EvalMesh1 _EvalMesh1 = null;
        /// <summary>
        /// <para>compute a one- or two-dimensional grid of points or lines</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EvalMesh1.</para>
        /// <para>Fullname: EvalMesh1</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="mode">In glEvalMesh1, specifies whether to compute a one-dimensional mesh of points or lines. Symbolic constants GL_POINT and GL_LINE are accepted.</param>
        /// <param name="i1">Specify the first and last integer values for grid domain variable i.</param>
        /// <param name="i2">Specify the first and last integer values for grid domain variable i.</param>
        public static void EvalMesh1(int mode, int i1, int i2)
        {
            if (gl._EvalMesh1 != null) gl._EvalMesh1(mode, i1, i2); else { }
        }
        /// <summary>
        /// <para>Fullname: EvalMesh2</para>
        /// </summary>
        [GLEntry("EvalMesh2", Category = "1.0")]
        public static GLDelegate.EvalMesh2 _EvalMesh2 = null;
        /// <summary>
        /// <para>compute a one- or two-dimensional grid of points or lines</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EvalMesh2.</para>
        /// <para>Fullname: EvalMesh2</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="mode">In glEvalMesh1, specifies whether to compute a one-dimensional mesh of points or lines. Symbolic constants GL_POINT and GL_LINE are accepted.</param>
        /// <param name="i1">Specify the first and last integer values for grid domain variable i.</param>
        /// <param name="i2">Specify the first and last integer values for grid domain variable i.</param>
        public static void EvalMesh2(int mode, int i1, int i2, int j1, int j2)
        {
            if (gl._EvalMesh2 != null) gl._EvalMesh2(mode, i1, i2, j1, j2); else { }
        }
        /// <summary>
        /// <para>Fullname: EvalPoint1</para>
        /// </summary>
        [GLEntry("EvalPoint1", Category = "1.0")]
        public static GLDelegate.EvalPoint1 _EvalPoint1 = null;
        /// <summary>
        /// <para>generate and evaluate a single point in a mesh</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EvalPoint1.</para>
        /// <para>Fullname: EvalPoint1</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="i">Specifies the integer value for grid domain variable i.</param>
        /// <param name="j">Specifies the integer value for grid domain variable j (glEvalPoint2 only).</param>
        public static void EvalPoint1(int i)
        {
            if (gl._EvalPoint1 != null) gl._EvalPoint1(i); else { }
        }
        /// <summary>
        /// <para>Fullname: EvalPoint2</para>
        /// </summary>
        [GLEntry("EvalPoint2", Category = "1.0")]
        public static GLDelegate.EvalPoint2 _EvalPoint2 = null;
        /// <summary>
        /// <para>generate and evaluate a single point in a mesh</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EvalPoint2.</para>
        /// <para>Fullname: EvalPoint2</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="i">Specifies the integer value for grid domain variable i.</param>
        /// <param name="j">Specifies the integer value for grid domain variable j (glEvalPoint2 only).</param>
        public static void EvalPoint2(int i, int j)
        {
            if (gl._EvalPoint2 != null) gl._EvalPoint2(i, j); else { }
        }
        /// <summary>
        /// <para>Fullname: FeedbackBuffer</para>
        /// </summary>
        [GLEntry("FeedbackBuffer", Category = "1.0")]
        public static GLDelegate.FeedbackBuffer _FeedbackBuffer = null;
        /// <summary>
        /// <para>controls feedback mode</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FeedbackBuffer.</para>
        /// <para>Fullname: FeedbackBuffer</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="size">Specifies the maximum number of values that can be written into buffer.</param>
        /// <param name="type">Specifies a symbolic constant that describes the information that will be returned for each vertex. GL_2D, GL_3D, GL_3D_COLOR, GL_3D_COLOR_TEXTURE, and GL_4D_COLOR_TEXTURE are accepted.</param>
        /// <param name="buffer">Returns the feedback data.</param>
        public static void FeedbackBuffer(int size, int type, IntPtr buffer)
        {
            if (gl._FeedbackBuffer != null) gl._FeedbackBuffer(size, type, buffer); else { }
        }
        /// <summary>
        /// <para>Fullname: Finish</para>
        /// </summary>
        [GLEntry("Finish", Category = "1.0")]
        public static GLDelegate.Finish _Finish = null;
        /// <summary>
        /// <para>block until all GL execution is complete</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Finish.</para>
        /// <para>Fullname: Finish</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        public static void Finish()
        {
            if (gl._Finish != null) gl._Finish(); else { }
        }
        /// <summary>
        /// <para>Fullname: Flush</para>
        /// </summary>
        [GLEntry("Flush", Category = "1.0")]
        public static GLDelegate.Flush _Flush = null;
        /// <summary>
        /// <para>force execution of GL commands in finite time</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Flush.</para>
        /// <para>Fullname: Flush</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        public static void Flush()
        {
            if (gl._Flush != null) gl._Flush(); else { }
        }
        /// <summary>
        /// <para>Fullname: Fogf</para>
        /// </summary>
        [GLEntry("Fogf", Category = "1.0")]
        public static GLDelegate.Fogf _Fogf = null;
        /// <summary>
        /// <para>specify fog parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Fogf.</para>
        /// <para>Fullname: Fogf</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="pname">Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.</param>
        /// <param name="param">Specifies the value that pname will be set to.</param>
        public static void Fogf(int pname, float param)
        {
            if (gl._Fogf != null) gl._Fogf(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: Fogfv</para>
        /// </summary>
        [GLEntry("Fogfv", Category = "1.0")]
        public static GLDelegate.Fogfv _Fogfv = null;
        /// <summary>
        /// <para>specify fog parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Fogfv.</para>
        /// <para>Fullname: Fogfv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="pname">Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.</param>
        /// <param name="param">Specifies the value that pname will be set to.</param>
        public static void Fogfv(int pname, float[] param)
        {
            if (gl._Fogfv != null) gl._Fogfv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: Fogi</para>
        /// </summary>
        [GLEntry("Fogi", Category = "1.0")]
        public static GLDelegate.Fogi _Fogi = null;
        /// <summary>
        /// <para>specify fog parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Fogi.</para>
        /// <para>Fullname: Fogi</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="pname">Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.</param>
        /// <param name="param">Specifies the value that pname will be set to.</param>
        public static void Fogi(int pname, int param)
        {
            if (gl._Fogi != null) gl._Fogi(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: Fogiv</para>
        /// </summary>
        [GLEntry("Fogiv", Category = "1.0")]
        public static GLDelegate.Fogiv _Fogiv = null;
        /// <summary>
        /// <para>specify fog parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Fogiv.</para>
        /// <para>Fullname: Fogiv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="pname">Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.</param>
        /// <param name="param">Specifies the value that pname will be set to.</param>
        public static void Fogiv(int pname, int[] param)
        {
            if (gl._Fogiv != null) gl._Fogiv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: FrontFace</para>
        /// </summary>
        [GLEntry("FrontFace", Category = "1.0")]
        public static GLDelegate.FrontFace _FrontFace = null;
        /// <summary>
        /// <para>define front- and back-facing polygons</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FrontFace.</para>
        /// <para>Fullname: FrontFace</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="mode">Specifies the orientation of front-facing polygons. GL_CW and GL_CCW are accepted. The initial value is GL_CCW.</param>
        public static void FrontFace(int mode)
        {
            if (gl._FrontFace != null) gl._FrontFace(mode); else { }
        }
        /// <summary>
        /// <para>Fullname: Frustum</para>
        /// </summary>
        [GLEntry("Frustum", Category = "1.0")]
        public static GLDelegate.Frustum _Frustum = null;
        /// <summary>
        /// <para>multiply the current matrix by a perspective matrix</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Frustum.</para>
        /// <para>Fullname: Frustum</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="left">Specify the coordinates for the left and right vertical clipping planes.</param>
        /// <param name="right">Specify the coordinates for the left and right vertical clipping planes.</param>
        /// <param name="bottom">Specify the coordinates for the bottom and top horizontal clipping planes.</param>
        /// <param name="top">Specify the coordinates for the bottom and top horizontal clipping planes.</param>
        /// <param name="nearVal">Specify the distances to the near and far depth clipping planes. Both distances must be positive.</param>
        /// <param name="farVal">Specify the distances to the near and far depth clipping planes. Both distances must be positive.</param>
        public static void Frustum(double left, double right, double bottom, double top, double zNear, double zFar)
        {
            if (gl._Frustum != null) gl._Frustum(left, right, bottom, top, zNear, zFar); else { }
        }
        /// <summary>
        /// <para>Fullname: GenLists</para>
        /// </summary>
        [GLEntry("GenLists", Category = "1.0")]
        public static GLDelegate.GenLists _GenLists = null;
        /// <summary>
        /// <para>generate a contiguous set of empty display lists</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenLists.</para>
        /// <para>Fullname: GenLists</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="range">Specifies the number of contiguous empty display lists to be generated.</param>
        public static uint GenLists(int range)
        {
            if (gl._GenLists != null) return gl._GenLists(range);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: GetBooleanv</para>
        /// </summary>
        [GLEntry("GetBooleanv", Category = "1.0")]
        public static GLDelegate.GetBooleanv_bool _GetBooleanv_bool = null;
        /// <summary>
        /// <para>return the value or values of a selected parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetBooleanv_bool.</para>
        /// <para>Fullname: GetBooleanv</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="pname">Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.</param>
        /// <param name="params">Returns the value or values of the specified parameter.</param>
        public static void GetBooleanv(int pname, out bool param)
        {
            if (gl._GetBooleanv_bool != null) gl._GetBooleanv_bool(pname, out param); else { param = new bool(); }
        }
        /// <summary>
        /// <para>Fullname: GetBooleanv</para>
        /// </summary>
        [GLEntry("GetBooleanv", Category = "1.0")]
        public static GLDelegate.GetBooleanv _GetBooleanv = null;
        /// <summary>
        /// <para>return the value or values of a selected parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetBooleanv.</para>
        /// <para>Fullname: GetBooleanv</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="pname">Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.</param>
        /// <param name="params">Returns the value or values of the specified parameter.</param>
        public static void GetBooleanv(int pname, bool[] param)
        {
            if (gl._GetBooleanv != null) gl._GetBooleanv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetClipPlane</para>
        /// </summary>
        [GLEntry("GetClipPlane", Category = "1.0")]
        public static GLDelegate.GetClipPlane _GetClipPlane = null;
        /// <summary>
        /// <para>return the coefficients of the specified clipping plane</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetClipPlane.</para>
        /// <para>Fullname: GetClipPlane</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="plane">Specifies a clipping plane. The number of clipping planes depends on the implementation, but at least six clipping planes are supported. They are identified by symbolic names of the form GL_CLIP_PLANEi where i ranges from 0 to the value of GL_MAX_CLIP_PLANES - 1.</param>
        /// <param name="equation">Returns four double-precision values that are the coefficients of the plane equation of plane in eye coordinates. The initial value is (0, 0, 0, 0).</param>
        public static void GetClipPlane(int plane, double[] equation)
        {
            if (gl._GetClipPlane != null) gl._GetClipPlane(plane, equation); else { }
        }
        /// <summary>
        /// <para>Fullname: GetDoublev</para>
        /// </summary>
        [GLEntry("GetDoublev", Category = "1.0")]
        public static GLDelegate.GetDoublev _GetDoublev = null;
        /// <summary>
        /// <para>return the value or values of a selected parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetDoublev.</para>
        /// <para>Fullname: GetDoublev</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="pname">Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.</param>
        /// <param name="params">Returns the value or values of the specified parameter.</param>
        public static void GetDoublev(int pname, double[] param)
        {
            if (gl._GetDoublev != null) gl._GetDoublev(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetDoublev</para>
        /// </summary>
        [GLEntry("GetDoublev", Category = "1.0")]
        public static GLDelegate.GetDoublev_double _GetDoublev_double = null;
        /// <summary>
        /// <para>return the value or values of a selected parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetDoublev_double.</para>
        /// <para>Fullname: GetDoublev</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="pname">Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.</param>
        /// <param name="params">Returns the value or values of the specified parameter.</param>
        public static void GetDoublev(int pname, out double param)
        {
            if (gl._GetDoublev_double != null) gl._GetDoublev_double(pname, out param); else { param = new double(); }
        }
        /// <summary>
        /// <para>Fullname: GetError</para>
        /// </summary>
        [GLEntry("GetError", Category = "1.0")]
        public static GLDelegate.GetError _GetError = null;
        /// <summary>
        /// <para>return error information</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetError.</para>
        /// <para>Fullname: GetError</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        public static int GetError()
        {
            if (gl._GetError != null) return gl._GetError();
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: GetFloatv</para>
        /// </summary>
        [GLEntry("GetFloatv", Category = "1.0")]
        public static GLDelegate.GetFloatv _GetFloatv = null;
        /// <summary>
        /// <para>return the value or values of a selected parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetFloatv.</para>
        /// <para>Fullname: GetFloatv</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="pname">Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.</param>
        /// <param name="params">Returns the value or values of the specified parameter.</param>
        public static void GetFloatv(int pname, float[] param)
        {
            if (gl._GetFloatv != null) gl._GetFloatv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetFloatv</para>
        /// </summary>
        [GLEntry("GetFloatv", Category = "1.0")]
        public static GLDelegate.GetFloatv_float _GetFloatv_float = null;
        /// <summary>
        /// <para>return the value or values of a selected parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetFloatv_float.</para>
        /// <para>Fullname: GetFloatv</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="pname">Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.</param>
        /// <param name="params">Returns the value or values of the specified parameter.</param>
        public static void GetFloatv(int pname, out float param)
        {
            if (gl._GetFloatv_float != null) gl._GetFloatv_float(pname, out param); else { param = new float(); }
        }
        /// <summary>
        /// <para>Fullname: GetIntegerv</para>
        /// </summary>
        [GLEntry("GetIntegerv", Category = "1.0")]
        public static GLDelegate.GetIntegerv _GetIntegerv = null;
        /// <summary>
        /// <para>return the value or values of a selected parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetIntegerv.</para>
        /// <para>Fullname: GetIntegerv</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="pname">Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.</param>
        /// <param name="params">Returns the value or values of the specified parameter.</param>
        public static void GetIntegerv(int pname, int[] param)
        {
            if (gl._GetIntegerv != null) gl._GetIntegerv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetIntegerv</para>
        /// </summary>
        [GLEntry("GetIntegerv", Category = "1.0")]
        public static GLDelegate.GetIntegerv_int _GetIntegerv_int = null;
        /// <summary>
        /// <para>return the value or values of a selected parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetIntegerv_int.</para>
        /// <para>Fullname: GetIntegerv</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="pname">Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.</param>
        /// <param name="params">Returns the value or values of the specified parameter.</param>
        public static void GetIntegerv(int pname, out int param)
        {
            if (gl._GetIntegerv_int != null) gl._GetIntegerv_int(pname, out param); else { param = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetLightfv</para>
        /// </summary>
        [GLEntry("GetLightfv", Category = "1.0")]
        public static GLDelegate.GetLightfv _GetLightfv = null;
        /// <summary>
        /// <para>return light source parameter values</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetLightfv.</para>
        /// <para>Fullname: GetLightfv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="light">Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHTi where i ranges from 0 to the value of GL_MAX_LIGHTS - 1.</param>
        /// <param name="pname">Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetLightfv(int light, int pname, float[] param)
        {
            if (gl._GetLightfv != null) gl._GetLightfv(light, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetLightiv</para>
        /// </summary>
        [GLEntry("GetLightiv", Category = "1.0")]
        public static GLDelegate.GetLightiv _GetLightiv = null;
        /// <summary>
        /// <para>return light source parameter values</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetLightiv.</para>
        /// <para>Fullname: GetLightiv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="light">Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHTi where i ranges from 0 to the value of GL_MAX_LIGHTS - 1.</param>
        /// <param name="pname">Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetLightiv(int light, int pname, int[] param)
        {
            if (gl._GetLightiv != null) gl._GetLightiv(light, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMapdv</para>
        /// </summary>
        [GLEntry("GetMapdv", Category = "1.0")]
        public static GLDelegate.GetMapdv _GetMapdv = null;
        /// <summary>
        /// <para>return evaluator parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMapdv.</para>
        /// <para>Fullname: GetMapdv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4.</param>
        /// <param name="query">Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted.</param>
        /// <param name="v">Returns the requested data.</param>
        public static void GetMapdv(int target, int query, double[] v)
        {
            if (gl._GetMapdv != null) gl._GetMapdv(target, query, v); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMapfv</para>
        /// </summary>
        [GLEntry("GetMapfv", Category = "1.0")]
        public static GLDelegate.GetMapfv _GetMapfv = null;
        /// <summary>
        /// <para>return evaluator parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMapfv.</para>
        /// <para>Fullname: GetMapfv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4.</param>
        /// <param name="query">Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted.</param>
        /// <param name="v">Returns the requested data.</param>
        public static void GetMapfv(int target, int query, float[] v)
        {
            if (gl._GetMapfv != null) gl._GetMapfv(target, query, v); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMapiv</para>
        /// </summary>
        [GLEntry("GetMapiv", Category = "1.0")]
        public static GLDelegate.GetMapiv _GetMapiv = null;
        /// <summary>
        /// <para>return evaluator parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMapiv.</para>
        /// <para>Fullname: GetMapiv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4.</param>
        /// <param name="query">Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted.</param>
        /// <param name="v">Returns the requested data.</param>
        public static void GetMapiv(int target, int query, int[] v)
        {
            if (gl._GetMapiv != null) gl._GetMapiv(target, query, v); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMaterialfv</para>
        /// </summary>
        [GLEntry("GetMaterialfv", Category = "1.0")]
        public static GLDelegate.GetMaterialfv _GetMaterialfv = null;
        /// <summary>
        /// <para>return material parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMaterialfv.</para>
        /// <para>Fullname: GetMaterialfv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="face">Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted, representing the front and back materials, respectively.</param>
        /// <param name="pname">Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION, GL_SHININESS, and GL_COLOR_INDEXES are accepted.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetMaterialfv(int face, int pname, float[] param)
        {
            if (gl._GetMaterialfv != null) gl._GetMaterialfv(face, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMaterialiv</para>
        /// </summary>
        [GLEntry("GetMaterialiv", Category = "1.0")]
        public static GLDelegate.GetMaterialiv _GetMaterialiv = null;
        /// <summary>
        /// <para>return material parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMaterialiv.</para>
        /// <para>Fullname: GetMaterialiv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="face">Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted, representing the front and back materials, respectively.</param>
        /// <param name="pname">Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION, GL_SHININESS, and GL_COLOR_INDEXES are accepted.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetMaterialiv(int face, int pname, int[] param)
        {
            if (gl._GetMaterialiv != null) gl._GetMaterialiv(face, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPixelMapfv</para>
        /// </summary>
        [GLEntry("GetPixelMapfv", Category = "1.0")]
        public static GLDelegate.GetPixelMapfv _GetPixelMapfv = null;
        /// <summary>
        /// <para>return the specified pixel map</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPixelMapfv.</para>
        /// <para>Fullname: GetPixelMapfv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="map">Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A.</param>
        /// <param name="data">Returns the pixel map contents.</param>
        public static void GetPixelMapfv(int map, float[] values)
        {
            if (gl._GetPixelMapfv != null) gl._GetPixelMapfv(map, values); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPixelMapuiv</para>
        /// </summary>
        [GLEntry("GetPixelMapuiv", Category = "1.0")]
        public static GLDelegate.GetPixelMapuiv _GetPixelMapuiv = null;
        /// <summary>
        /// <para>return the specified pixel map</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPixelMapuiv.</para>
        /// <para>Fullname: GetPixelMapuiv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="map">Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A.</param>
        /// <param name="data">Returns the pixel map contents.</param>
        public static void GetPixelMapuiv(int map, uint[] values)
        {
            if (gl._GetPixelMapuiv != null) gl._GetPixelMapuiv(map, values); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPixelMapusv</para>
        /// </summary>
        [GLEntry("GetPixelMapusv", Category = "1.0")]
        public static GLDelegate.GetPixelMapusv _GetPixelMapusv = null;
        /// <summary>
        /// <para>return the specified pixel map</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPixelMapusv.</para>
        /// <para>Fullname: GetPixelMapusv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="map">Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A.</param>
        /// <param name="data">Returns the pixel map contents.</param>
        public static void GetPixelMapusv(int map, ushort[] values)
        {
            if (gl._GetPixelMapusv != null) gl._GetPixelMapusv(map, values); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPolygonStipple</para>
        /// </summary>
        [GLEntry("GetPolygonStipple", Category = "1.0")]
        public static GLDelegate.GetPolygonStipple _GetPolygonStipple = null;
        /// <summary>
        /// <para>return the polygon stipple pattern</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPolygonStipple.</para>
        /// <para>Fullname: GetPolygonStipple</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="pattern">Returns the stipple pattern. The initial value is all 1's.</param>
        public static void GetPolygonStipple(byte[] mask)
        {
            if (gl._GetPolygonStipple != null) gl._GetPolygonStipple(mask); else { }
        }
        /// <summary>
        /// <para>Fullname: GetString</para>
        /// </summary>
        [GLEntry("GetString", Category = "1.0")]
        public static GLDelegate.GetString _GetString = null;
        /// <summary>
        /// <para>return a string describing the current GL connection</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetString.</para>
        /// <para>Fullname: GetString</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="name">Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token.</param>
        /// <param name="index">For glGetStringi, specifies the index of the string to return.</param>
        public static IntPtr GetString(int name)
        {
            if (gl._GetString != null) return gl._GetString(name);
            else { return (IntPtr)0; }
        }
        /// <summary>
        /// Wrapped glGetString function. Returns marshaled string instead of IntPtr
        /// </summary>
        public static string GetStringNet(int name)
        {
            IntPtr i = GetString(name);
            return Marshal.PtrToStringAnsi(i);
        }
        /// <summary>
        /// <para>Fullname: GetTexEnvfv</para>
        /// </summary>
        [GLEntry("GetTexEnvfv", Category = "1.0")]
        public static GLDelegate.GetTexEnvfv _GetTexEnvfv = null;
        /// <summary>
        /// <para>return texture environment parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTexEnvfv.</para>
        /// <para>Fullname: GetTexEnvfv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE.</param>
        /// <param name="pname">Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetTexEnvfv(int target, int pname, float[] param)
        {
            if (gl._GetTexEnvfv != null) gl._GetTexEnvfv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTexEnviv</para>
        /// </summary>
        [GLEntry("GetTexEnviv", Category = "1.0")]
        public static GLDelegate.GetTexEnviv _GetTexEnviv = null;
        /// <summary>
        /// <para>return texture environment parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTexEnviv.</para>
        /// <para>Fullname: GetTexEnviv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE.</param>
        /// <param name="pname">Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetTexEnviv(int target, int pname, int[] param)
        {
            if (gl._GetTexEnviv != null) gl._GetTexEnviv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTexGendv</para>
        /// </summary>
        [GLEntry("GetTexGendv", Category = "1.0")]
        public static GLDelegate.GetTexGendv _GetTexGendv = null;
        /// <summary>
        /// <para>return texture coordinate generation parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTexGendv.</para>
        /// <para>Fullname: GetTexGendv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="coord">Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.</param>
        /// <param name="pname">Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetTexGendv(int coord, int pname, double[] param)
        {
            if (gl._GetTexGendv != null) gl._GetTexGendv(coord, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTexGenfv</para>
        /// </summary>
        [GLEntry("GetTexGenfv", Category = "1.0")]
        public static GLDelegate.GetTexGenfv _GetTexGenfv = null;
        /// <summary>
        /// <para>return texture coordinate generation parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTexGenfv.</para>
        /// <para>Fullname: GetTexGenfv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="coord">Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.</param>
        /// <param name="pname">Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetTexGenfv(int coord, int pname, float[] param)
        {
            if (gl._GetTexGenfv != null) gl._GetTexGenfv(coord, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTexGeniv</para>
        /// </summary>
        [GLEntry("GetTexGeniv", Category = "1.0")]
        public static GLDelegate.GetTexGeniv _GetTexGeniv = null;
        /// <summary>
        /// <para>return texture coordinate generation parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTexGeniv.</para>
        /// <para>Fullname: GetTexGeniv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="coord">Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.</param>
        /// <param name="pname">Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetTexGeniv(int coord, int pname, int[] param)
        {
            if (gl._GetTexGeniv != null) gl._GetTexGeniv(coord, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTexImage</para>
        /// </summary>
        [GLEntry("GetTexImage", Category = "1.0")]
        public static GLDelegate.GetTexImage _GetTexImage = null;
        /// <summary>
        /// <para>return a texture image</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTexImage.</para>
        /// <para>Fullname: GetTexImage</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="target">Specifies which texture is to be obtained. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z are accepted.</param>
        /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="format">Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.</param>
        /// <param name="type">Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="img">Returns the texture image. Should be a pointer to an array of the type specified by type.</param>
        public static void GetTexImage(int target, int level, int format, int type, IntPtr pixels)
        {
            if (gl._GetTexImage != null) gl._GetTexImage(target, level, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTexLevelParameterfv</para>
        /// </summary>
        [GLEntry("GetTexLevelParameterfv", Category = "1.0")]
        public static GLDelegate.GetTexLevelParameterfv _GetTexLevelParameterfv = null;
        /// <summary>
        /// <para>return texture parameter values for a specific level of detail</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTexLevelParameterfv.</para>
        /// <para>Fullname: GetTexLevelParameterfv</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="target">Specifies the symbolic name of the target texture, one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_PROXY_TEXTURE_CUBE_MAP, or GL_TEXTURE_BUFFER.</param>
        /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_BORDER, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetTexLevelParameterfv(int target, int level, int pname, float[] param)
        {
            if (gl._GetTexLevelParameterfv != null) gl._GetTexLevelParameterfv(target, level, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTexLevelParameteriv</para>
        /// </summary>
        [GLEntry("GetTexLevelParameteriv", Category = "1.0")]
        public static GLDelegate.GetTexLevelParameteriv _GetTexLevelParameteriv = null;
        /// <summary>
        /// <para>return texture parameter values for a specific level of detail</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTexLevelParameteriv.</para>
        /// <para>Fullname: GetTexLevelParameteriv</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="target">Specifies the symbolic name of the target texture, one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_PROXY_TEXTURE_CUBE_MAP, or GL_TEXTURE_BUFFER.</param>
        /// <param name="level">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_BORDER, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetTexLevelParameteriv(int target, int level, int pname, int[] param)
        {
            if (gl._GetTexLevelParameteriv != null) gl._GetTexLevelParameteriv(target, level, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTexParameterfv</para>
        /// </summary>
        [GLEntry("GetTexParameterfv", Category = "1.0")]
        public static GLDelegate.GetTexParameterfv _GetTexParameterfv = null;
        /// <summary>
        /// <para>return texture parameter values</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTexParameterfv.</para>
        /// <para>Fullname: GetTexParameterfv</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="target">Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="params">Returns the texture parameters.</param>
        public static void GetTexParameterfv(int target, int pname, float[] param)
        {
            if (gl._GetTexParameterfv != null) gl._GetTexParameterfv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTexParameteriv</para>
        /// </summary>
        [GLEntry("GetTexParameteriv", Category = "1.0")]
        public static GLDelegate.GetTexParameteriv _GetTexParameteriv = null;
        /// <summary>
        /// <para>return texture parameter values</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTexParameteriv.</para>
        /// <para>Fullname: GetTexParameteriv</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="target">Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="params">Returns the texture parameters.</param>
        public static void GetTexParameteriv(int target, int pname, int[] param)
        {
            if (gl._GetTexParameteriv != null) gl._GetTexParameteriv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: Hint</para>
        /// </summary>
        [GLEntry("Hint", Category = "1.0", Alias = "HintPGI ")]
        public static GLDelegate.Hint _Hint = null;
        public static GLDelegate.Hint HintPGI = Hint;
        /// <summary>
        /// <para>specify implementation-specific hints</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Hint.</para>
        /// <para>Fullname: Hint</para>
        /// <para>Aliases: HintPGI, </para>
        /// <para>Extensions: VERSION_1_0 PGI_misc_hints</para>
        /// </summary>
        /// <param name="target">Specifies a symbolic constant indicating the behavior to be controlled. GL_LINE_SMOOTH_HINT, GL_POLYGON_SMOOTH_HINT, GL_TEXTURE_COMPRESSION_HINT, and GL_FRAGMENT_SHADER_DERIVATIVE_HINT are accepted.</param>
        /// <param name="mode">Specifies a symbolic constant indicating the desired behavior. GL_FASTEST, GL_NICEST, and GL_DONT_CARE are accepted.</param>
        public static void Hint(int target, int mode)
        {
            if (gl._Hint != null) gl._Hint(target, mode); else { }
        }
        /// <summary>
        /// <para>Fullname: Indexd</para>
        /// </summary>
        [GLEntry("Indexd", Category = "1.0")]
        public static GLDelegate.Indexd _Indexd = null;
        /// <summary>
        /// <para>set the current color index</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Indexd.</para>
        /// <para>Fullname: Indexd</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="c">Specifies the new value for the current color index.</param>
        public static void Indexd(double c)
        {
            if (gl._Indexd != null) gl._Indexd(c); else { }
        }
        /// <summary>
        /// <para>Fullname: Indexdv</para>
        /// </summary>
        [GLEntry("Indexdv", Category = "1.0")]
        public static GLDelegate.Indexdv_double _Indexdv_double = null;
        /// <summary>
        /// <para>set the current color index</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Indexdv_double.</para>
        /// <para>Fullname: Indexdv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="c">Specifies the new value for the current color index.</param>
        public static void Indexdv(ref double c)
        {
            if (gl._Indexdv_double != null) gl._Indexdv_double(ref c); else { }
        }
        /// <summary>
        /// <para>Fullname: Indexdv</para>
        /// </summary>
        [GLEntry("Indexdv", Category = "1.0")]
        public static GLDelegate.Indexdv _Indexdv = null;
        /// <summary>
        /// <para>set the current color index</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Indexdv.</para>
        /// <para>Fullname: Indexdv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="c">Specifies the new value for the current color index.</param>
        public static void Indexdv(double[] c)
        {
            if (gl._Indexdv != null) gl._Indexdv(c); else { }
        }
        /// <summary>
        /// <para>Fullname: Indexf</para>
        /// </summary>
        [GLEntry("Indexf", Category = "1.0")]
        public static GLDelegate.Indexf _Indexf = null;
        /// <summary>
        /// <para>set the current color index</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Indexf.</para>
        /// <para>Fullname: Indexf</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="c">Specifies the new value for the current color index.</param>
        public static void Indexf(float c)
        {
            if (gl._Indexf != null) gl._Indexf(c); else { }
        }
        /// <summary>
        /// <para>Fullname: Indexfv</para>
        /// </summary>
        [GLEntry("Indexfv", Category = "1.0")]
        public static GLDelegate.Indexfv_float _Indexfv_float = null;
        /// <summary>
        /// <para>set the current color index</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Indexfv_float.</para>
        /// <para>Fullname: Indexfv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="c">Specifies the new value for the current color index.</param>
        public static void Indexfv(ref float c)
        {
            if (gl._Indexfv_float != null) gl._Indexfv_float(ref c); else { }
        }
        /// <summary>
        /// <para>Fullname: Indexfv</para>
        /// </summary>
        [GLEntry("Indexfv", Category = "1.0")]
        public static GLDelegate.Indexfv _Indexfv = null;
        /// <summary>
        /// <para>set the current color index</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Indexfv.</para>
        /// <para>Fullname: Indexfv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="c">Specifies the new value for the current color index.</param>
        public static void Indexfv(float[] c)
        {
            if (gl._Indexfv != null) gl._Indexfv(c); else { }
        }
        /// <summary>
        /// <para>Fullname: Indexi</para>
        /// </summary>
        [GLEntry("Indexi", Category = "1.0")]
        public static GLDelegate.Indexi _Indexi = null;
        /// <summary>
        /// <para>set the current color index</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Indexi.</para>
        /// <para>Fullname: Indexi</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="c">Specifies the new value for the current color index.</param>
        public static void Indexi(int c)
        {
            if (gl._Indexi != null) gl._Indexi(c); else { }
        }
        /// <summary>
        /// <para>Fullname: Indexiv</para>
        /// </summary>
        [GLEntry("Indexiv", Category = "1.0")]
        public static GLDelegate.Indexiv_int _Indexiv_int = null;
        /// <summary>
        /// <para>set the current color index</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Indexiv_int.</para>
        /// <para>Fullname: Indexiv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="c">Specifies the new value for the current color index.</param>
        public static void Indexiv(ref int c)
        {
            if (gl._Indexiv_int != null) gl._Indexiv_int(ref c); else { }
        }
        /// <summary>
        /// <para>Fullname: Indexiv</para>
        /// </summary>
        [GLEntry("Indexiv", Category = "1.0")]
        public static GLDelegate.Indexiv _Indexiv = null;
        /// <summary>
        /// <para>set the current color index</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Indexiv.</para>
        /// <para>Fullname: Indexiv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="c">Specifies the new value for the current color index.</param>
        public static void Indexiv(int[] c)
        {
            if (gl._Indexiv != null) gl._Indexiv(c); else { }
        }
        /// <summary>
        /// <para>Fullname: IndexMask</para>
        /// </summary>
        [GLEntry("IndexMask", Category = "1.0")]
        public static GLDelegate.IndexMask _IndexMask = null;
        /// <summary>
        /// <para>control the writing of individual bits in the color index buffers</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IndexMask.</para>
        /// <para>Fullname: IndexMask</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="mask">Specifies a bit mask to enable and disable the writing of individual bits in the color index buffers. Initially, the mask is all 1's.</param>
        public static void IndexMask(uint mask)
        {
            if (gl._IndexMask != null) gl._IndexMask(mask); else { }
        }
        /// <summary>
        /// <para>Fullname: Indexs</para>
        /// </summary>
        [GLEntry("Indexs", Category = "1.0")]
        public static GLDelegate.Indexs _Indexs = null;
        /// <summary>
        /// <para>set the current color index</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Indexs.</para>
        /// <para>Fullname: Indexs</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="c">Specifies the new value for the current color index.</param>
        public static void Indexs(short c)
        {
            if (gl._Indexs != null) gl._Indexs(c); else { }
        }
        /// <summary>
        /// <para>Fullname: Indexsv</para>
        /// </summary>
        [GLEntry("Indexsv", Category = "1.0")]
        public static GLDelegate.Indexsv _Indexsv = null;
        /// <summary>
        /// <para>set the current color index</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Indexsv.</para>
        /// <para>Fullname: Indexsv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="c">Specifies the new value for the current color index.</param>
        public static void Indexsv(short[] c)
        {
            if (gl._Indexsv != null) gl._Indexsv(c); else { }
        }
        /// <summary>
        /// <para>Fullname: InitNames</para>
        /// </summary>
        [GLEntry("InitNames", Category = "1.0")]
        public static GLDelegate.InitNames _InitNames = null;
        /// <summary>
        /// <para>initialize the name stack</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _InitNames.</para>
        /// <para>Fullname: InitNames</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        public static void InitNames()
        {
            if (gl._InitNames != null) gl._InitNames(); else { }
        }
        /// <summary>
        /// <para>Fullname: IsEnabled</para>
        /// </summary>
        [GLEntry("IsEnabled", Category = "1.0")]
        public static GLDelegate.IsEnabled _IsEnabled = null;
        /// <summary>
        /// <para>test whether a capability is enabled</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsEnabled.</para>
        /// <para>Fullname: IsEnabled</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="cap">Specifies a symbolic constant indicating a GL capability.</param>
        /// <param name="index">Specifies the index of the capability.</param>
        public static bool IsEnabled(int cap)
        {
            if (gl._IsEnabled != null) return gl._IsEnabled(cap);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: IsList</para>
        /// </summary>
        [GLEntry("IsList", Category = "1.0")]
        public static GLDelegate.IsList _IsList = null;
        /// <summary>
        /// <para>determine if a name corresponds to a display list</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsList.</para>
        /// <para>Fullname: IsList</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="list">Specifies a potential display list name.</param>
        public static bool IsList(uint list)
        {
            if (gl._IsList != null) return gl._IsList(list);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: Lightf</para>
        /// </summary>
        [GLEntry("Lightf", Category = "1.0")]
        public static GLDelegate.Lightf _Lightf = null;
        /// <summary>
        /// <para>set light source parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Lightf.</para>
        /// <para>Fullname: Lightf</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="light">Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHTi, where i ranges from 0 to the value of GL_MAX_LIGHTS - 1.</param>
        /// <param name="pname">Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.</param>
        /// <param name="param">Specifies the value that parameter pname of light source light will be set to.</param>
        public static void Lightf(int light, int pname, float param)
        {
            if (gl._Lightf != null) gl._Lightf(light, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: Lightfv</para>
        /// </summary>
        [GLEntry("Lightfv", Category = "1.0")]
        public static GLDelegate.Lightfv _Lightfv = null;
        /// <summary>
        /// <para>set light source parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Lightfv.</para>
        /// <para>Fullname: Lightfv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="light">Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHTi, where i ranges from 0 to the value of GL_MAX_LIGHTS - 1.</param>
        /// <param name="pname">Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.</param>
        /// <param name="param">Specifies the value that parameter pname of light source light will be set to.</param>
        public static void Lightfv(int light, int pname, float[] param)
        {
            if (gl._Lightfv != null) gl._Lightfv(light, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: Lighti</para>
        /// </summary>
        [GLEntry("Lighti", Category = "1.0")]
        public static GLDelegate.Lighti _Lighti = null;
        /// <summary>
        /// <para>set light source parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Lighti.</para>
        /// <para>Fullname: Lighti</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="light">Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHTi, where i ranges from 0 to the value of GL_MAX_LIGHTS - 1.</param>
        /// <param name="pname">Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.</param>
        /// <param name="param">Specifies the value that parameter pname of light source light will be set to.</param>
        public static void Lighti(int light, int pname, int param)
        {
            if (gl._Lighti != null) gl._Lighti(light, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: Lightiv</para>
        /// </summary>
        [GLEntry("Lightiv", Category = "1.0")]
        public static GLDelegate.Lightiv _Lightiv = null;
        /// <summary>
        /// <para>set light source parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Lightiv.</para>
        /// <para>Fullname: Lightiv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="light">Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHTi, where i ranges from 0 to the value of GL_MAX_LIGHTS - 1.</param>
        /// <param name="pname">Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.</param>
        /// <param name="param">Specifies the value that parameter pname of light source light will be set to.</param>
        public static void Lightiv(int light, int pname, int[] param)
        {
            if (gl._Lightiv != null) gl._Lightiv(light, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: LightModelf</para>
        /// </summary>
        [GLEntry("LightModelf", Category = "1.0")]
        public static GLDelegate.LightModelf _LightModelf = null;
        /// <summary>
        /// <para>set the lighting model parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _LightModelf.</para>
        /// <para>Fullname: LightModelf</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="pname">Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.</param>
        /// <param name="param">Specifies the value that param will be set to.</param>
        public static void LightModelf(int pname, float param)
        {
            if (gl._LightModelf != null) gl._LightModelf(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: LightModelfv</para>
        /// </summary>
        [GLEntry("LightModelfv", Category = "1.0")]
        public static GLDelegate.LightModelfv _LightModelfv = null;
        /// <summary>
        /// <para>set the lighting model parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _LightModelfv.</para>
        /// <para>Fullname: LightModelfv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="pname">Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.</param>
        /// <param name="param">Specifies the value that param will be set to.</param>
        public static void LightModelfv(int pname, float[] param)
        {
            if (gl._LightModelfv != null) gl._LightModelfv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: LightModeli</para>
        /// </summary>
        [GLEntry("LightModeli", Category = "1.0")]
        public static GLDelegate.LightModeli _LightModeli = null;
        /// <summary>
        /// <para>set the lighting model parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _LightModeli.</para>
        /// <para>Fullname: LightModeli</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="pname">Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.</param>
        /// <param name="param">Specifies the value that param will be set to.</param>
        public static void LightModeli(int pname, int param)
        {
            if (gl._LightModeli != null) gl._LightModeli(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: LightModeliv</para>
        /// </summary>
        [GLEntry("LightModeliv", Category = "1.0")]
        public static GLDelegate.LightModeliv _LightModeliv = null;
        /// <summary>
        /// <para>set the lighting model parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _LightModeliv.</para>
        /// <para>Fullname: LightModeliv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="pname">Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.</param>
        /// <param name="param">Specifies the value that param will be set to.</param>
        public static void LightModeliv(int pname, int[] param)
        {
            if (gl._LightModeliv != null) gl._LightModeliv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: LineStipple</para>
        /// </summary>
        [GLEntry("LineStipple", Category = "1.0")]
        public static GLDelegate.LineStipple _LineStipple = null;
        /// <summary>
        /// <para>specify the line stipple pattern</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _LineStipple.</para>
        /// <para>Fullname: LineStipple</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="factor">Specifies a multiplier for each bit in the line stipple pattern. If factor is 3, for example, each bit in the pattern is used three times before the next bit in the pattern is used. factor is clamped to the range [1, 256] and defaults to 1.</param>
        /// <param name="pattern">Specifies a 16-bit integer whose bit pattern determines which fragments of a line will be drawn when the line is rasterized. Bit zero is used first; the default pattern is all 1's.</param>
        public static void LineStipple(int factor, ushort pattern)
        {
            if (gl._LineStipple != null) gl._LineStipple(factor, pattern); else { }
        }
        /// <summary>
        /// <para>Fullname: LineWidth</para>
        /// </summary>
        [GLEntry("LineWidth", Category = "1.0")]
        public static GLDelegate.LineWidth _LineWidth = null;
        /// <summary>
        /// <para>specify the width of rasterized lines</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _LineWidth.</para>
        /// <para>Fullname: LineWidth</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="width">Specifies the width of rasterized lines. The initial value is 1.</param>
        public static void LineWidth(float width)
        {
            if (gl._LineWidth != null) gl._LineWidth(width); else { }
        }
        /// <summary>
        /// <para>Fullname: ListBase</para>
        /// </summary>
        [GLEntry("ListBase", Category = "1.0")]
        public static GLDelegate.ListBase _ListBase = null;
        /// <summary>
        /// <para>set the display-list base for glCallLists</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ListBase.</para>
        /// <para>Fullname: ListBase</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="base">Specifies an integer offset that will be added to glCallLists offsets to generate display-list names. The initial value is 0.</param>
        public static void ListBase(uint listBase)
        {
            if (gl._ListBase != null) gl._ListBase(listBase); else { }
        }
        /// <summary>
        /// <para>Fullname: LoadIdentity</para>
        /// </summary>
        [GLEntry("LoadIdentity", Category = "1.0")]
        public static GLDelegate.LoadIdentity _LoadIdentity = null;
        /// <summary>
        /// <para>replace the current matrix with the identity matrix</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _LoadIdentity.</para>
        /// <para>Fullname: LoadIdentity</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        public static void LoadIdentity()
        {
            if (gl._LoadIdentity != null) gl._LoadIdentity(); else { }
        }
        /// <summary>
        /// <para>Fullname: LoadMatrixd</para>
        /// </summary>
        [GLEntry("LoadMatrixd", Category = "1.0")]
        public static GLDelegate.LoadMatrixd _LoadMatrixd = null;
        /// <summary>
        /// <para>replace the current matrix with the specified matrix</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _LoadMatrixd.</para>
        /// <para>Fullname: LoadMatrixd</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="m">Specifies a pointer to 16 consecutive values, which are used as the elements of a 4×4 column-major matrix.</param>
        public static void LoadMatrixd(double[] m)
        {
            if (gl._LoadMatrixd != null) gl._LoadMatrixd(m); else { }
        }
        /// <summary>
        /// <para>Fullname: LoadMatrixf</para>
        /// </summary>
        [GLEntry("LoadMatrixf", Category = "1.0")]
        public static GLDelegate.LoadMatrixf _LoadMatrixf = null;
        /// <summary>
        /// <para>replace the current matrix with the specified matrix</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _LoadMatrixf.</para>
        /// <para>Fullname: LoadMatrixf</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="m">Specifies a pointer to 16 consecutive values, which are used as the elements of a 4×4 column-major matrix.</param>
        public static void LoadMatrixf(float[] m)
        {
            if (gl._LoadMatrixf != null) gl._LoadMatrixf(m); else { }
        }
        /// <summary>
        /// <para>Fullname: LoadName</para>
        /// </summary>
        [GLEntry("LoadName", Category = "1.0")]
        public static GLDelegate.LoadName _LoadName = null;
        /// <summary>
        /// <para>load a name onto the name stack</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _LoadName.</para>
        /// <para>Fullname: LoadName</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="name">Specifies a name that will replace the top value on the name stack.</param>
        public static void LoadName(uint name)
        {
            if (gl._LoadName != null) gl._LoadName(name); else { }
        }
        /// <summary>
        /// <para>Fullname: LogicOp</para>
        /// </summary>
        [GLEntry("LogicOp", Category = "1.0")]
        public static GLDelegate.LogicOp _LogicOp = null;
        /// <summary>
        /// <para>specify a logical pixel operation for rendering</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _LogicOp.</para>
        /// <para>Fullname: LogicOp</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="opcode">Specifies a symbolic constant that selects a logical operation. The following symbols are accepted: GL_CLEAR, GL_SET, GL_COPY, GL_COPY_INVERTED, GL_NOOP, GL_INVERT, GL_AND, GL_NAND, GL_OR, GL_NOR, GL_XOR, GL_EQUIV, GL_AND_REVERSE, GL_AND_INVERTED, GL_OR_REVERSE, and GL_OR_INVERTED. The initial value is GL_COPY.</param>
        public static void LogicOp(int opcode)
        {
            if (gl._LogicOp != null) gl._LogicOp(opcode); else { }
        }
        /// <summary>
        /// <para>Fullname: Map1d</para>
        /// </summary>
        [GLEntry("Map1d", Category = "1.0")]
        public static GLDelegate.Map1d _Map1d = null;
        /// <summary>
        /// <para>define a one-dimensional evaluator</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Map1d.</para>
        /// <para>Fullname: Map1d</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP1_INDEX, GL_MAP1_COLOR_4, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, and GL_MAP1_TEXTURE_COORD_4 are accepted.</param>
        /// <param name="u1">Specify a linear mapping of u, as presented to glEvalCoord1, to û, the variable that is evaluated by the equations specified by this command.</param>
        /// <param name="u2">Specify a linear mapping of u, as presented to glEvalCoord1, to û, the variable that is evaluated by the equations specified by this command.</param>
        /// <param name="stride">Specifies the number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in points. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations.</param>
        /// <param name="order">Specifies the number of control points. Must be positive.</param>
        /// <param name="points">Specifies a pointer to the array of control points.</param>
        public static void Map1d(int target, double u1, double u2, int stride, int order, double[] points)
        {
            if (gl._Map1d != null) gl._Map1d(target, u1, u2, stride, order, points); else { }
        }
        /// <summary>
        /// <para>Fullname: Map1f</para>
        /// </summary>
        [GLEntry("Map1f", Category = "1.0")]
        public static GLDelegate.Map1f _Map1f = null;
        /// <summary>
        /// <para>define a one-dimensional evaluator</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Map1f.</para>
        /// <para>Fullname: Map1f</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP1_INDEX, GL_MAP1_COLOR_4, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, and GL_MAP1_TEXTURE_COORD_4 are accepted.</param>
        /// <param name="u1">Specify a linear mapping of u, as presented to glEvalCoord1, to û, the variable that is evaluated by the equations specified by this command.</param>
        /// <param name="u2">Specify a linear mapping of u, as presented to glEvalCoord1, to û, the variable that is evaluated by the equations specified by this command.</param>
        /// <param name="stride">Specifies the number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in points. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations.</param>
        /// <param name="order">Specifies the number of control points. Must be positive.</param>
        /// <param name="points">Specifies a pointer to the array of control points.</param>
        public static void Map1f(int target, float u1, float u2, int stride, int order, float[] points)
        {
            if (gl._Map1f != null) gl._Map1f(target, u1, u2, stride, order, points); else { }
        }
        /// <summary>
        /// <para>Fullname: Map2d</para>
        /// </summary>
        [GLEntry("Map2d", Category = "1.0")]
        public static GLDelegate.Map2d _Map2d = null;
        /// <summary>
        /// <para>define a two-dimensional evaluator</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Map2d.</para>
        /// <para>Fullname: Map2d</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MAP2_INDEX, GL_MAP2_COLOR_4, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, and GL_MAP2_TEXTURE_COORD_4 are accepted.</param>
        /// <param name="u1">Specify a linear mapping of u, as presented to glEvalCoord2, to û, one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1.</param>
        /// <param name="u2">Specify a linear mapping of u, as presented to glEvalCoord2, to û, one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1.</param>
        /// <param name="ustride">Specifies the number of floats or doubles between the beginning of control point Rij and the beginning of control point Ri+1⁢j, where i and j are the u and v control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of ustride is 0.</param>
        /// <param name="uorder">Specifies the dimension of the control point array in the u axis. Must be positive. The initial value is 1.</param>
        /// <param name="v1">Specify a linear mapping of v, as presented to glEvalCoord2, to v̂, one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1.</param>
        /// <param name="v2">Specify a linear mapping of v, as presented to glEvalCoord2, to v̂, one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1.</param>
        /// <param name="vstride">Specifies the number of floats or doubles between the beginning of control point Rij and the beginning of control point Ri⁡j+1, where i and j are the u and v control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of vstride is 0.</param>
        /// <param name="vorder">Specifies the dimension of the control point array in the v axis. Must be positive. The initial value is 1.</param>
        /// <param name="points">Specifies a pointer to the array of control points.</param>
        public static void Map2d(int target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double[] points)
        {
            if (gl._Map2d != null) gl._Map2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points); else { }
        }
        /// <summary>
        /// <para>Fullname: Map2f</para>
        /// </summary>
        [GLEntry("Map2f", Category = "1.0")]
        public static GLDelegate.Map2f _Map2f = null;
        /// <summary>
        /// <para>define a two-dimensional evaluator</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Map2f.</para>
        /// <para>Fullname: Map2f</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MAP2_INDEX, GL_MAP2_COLOR_4, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, and GL_MAP2_TEXTURE_COORD_4 are accepted.</param>
        /// <param name="u1">Specify a linear mapping of u, as presented to glEvalCoord2, to û, one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1.</param>
        /// <param name="u2">Specify a linear mapping of u, as presented to glEvalCoord2, to û, one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1.</param>
        /// <param name="ustride">Specifies the number of floats or doubles between the beginning of control point Rij and the beginning of control point Ri+1⁢j, where i and j are the u and v control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of ustride is 0.</param>
        /// <param name="uorder">Specifies the dimension of the control point array in the u axis. Must be positive. The initial value is 1.</param>
        /// <param name="v1">Specify a linear mapping of v, as presented to glEvalCoord2, to v̂, one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1.</param>
        /// <param name="v2">Specify a linear mapping of v, as presented to glEvalCoord2, to v̂, one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1.</param>
        /// <param name="vstride">Specifies the number of floats or doubles between the beginning of control point Rij and the beginning of control point Ri⁡j+1, where i and j are the u and v control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of vstride is 0.</param>
        /// <param name="vorder">Specifies the dimension of the control point array in the v axis. Must be positive. The initial value is 1.</param>
        /// <param name="points">Specifies a pointer to the array of control points.</param>
        public static void Map2f(int target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float[] points)
        {
            if (gl._Map2f != null) gl._Map2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points); else { }
        }
        /// <summary>
        /// <para>Fullname: MapGrid1d</para>
        /// </summary>
        [GLEntry("MapGrid1d", Category = "1.0")]
        public static GLDelegate.MapGrid1d _MapGrid1d = null;
        /// <summary>
        /// <para>define a one- or two-dimensional mesh</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MapGrid1d.</para>
        /// <para>Fullname: MapGrid1d</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="un">Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive.</param>
        /// <param name="u1">Specify the mappings for integer grid domain values i=0 and i=un.</param>
        /// <param name="u2">Specify the mappings for integer grid domain values i=0 and i=un.</param>
        /// <param name="vn">Specifies the number of partitions in the grid range interval [v1, v2] (glMapGrid2 only).</param>
        /// <param name="v1">Specify the mappings for integer grid domain values j=0 and j=vn (glMapGrid2 only).</param>
        /// <param name="v2">Specify the mappings for integer grid domain values j=0 and j=vn (glMapGrid2 only).</param>
        public static void MapGrid1d(int un, double u1, double u2)
        {
            if (gl._MapGrid1d != null) gl._MapGrid1d(un, u1, u2); else { }
        }
        /// <summary>
        /// <para>Fullname: MapGrid1f</para>
        /// </summary>
        [GLEntry("MapGrid1f", Category = "1.0")]
        public static GLDelegate.MapGrid1f _MapGrid1f = null;
        /// <summary>
        /// <para>define a one- or two-dimensional mesh</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MapGrid1f.</para>
        /// <para>Fullname: MapGrid1f</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="un">Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive.</param>
        /// <param name="u1">Specify the mappings for integer grid domain values i=0 and i=un.</param>
        /// <param name="u2">Specify the mappings for integer grid domain values i=0 and i=un.</param>
        /// <param name="vn">Specifies the number of partitions in the grid range interval [v1, v2] (glMapGrid2 only).</param>
        /// <param name="v1">Specify the mappings for integer grid domain values j=0 and j=vn (glMapGrid2 only).</param>
        /// <param name="v2">Specify the mappings for integer grid domain values j=0 and j=vn (glMapGrid2 only).</param>
        public static void MapGrid1f(int un, float u1, float u2)
        {
            if (gl._MapGrid1f != null) gl._MapGrid1f(un, u1, u2); else { }
        }
        /// <summary>
        /// <para>Fullname: MapGrid2d</para>
        /// </summary>
        [GLEntry("MapGrid2d", Category = "1.0")]
        public static GLDelegate.MapGrid2d _MapGrid2d = null;
        /// <summary>
        /// <para>define a one- or two-dimensional mesh</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MapGrid2d.</para>
        /// <para>Fullname: MapGrid2d</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="un">Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive.</param>
        /// <param name="u1">Specify the mappings for integer grid domain values i=0 and i=un.</param>
        /// <param name="u2">Specify the mappings for integer grid domain values i=0 and i=un.</param>
        /// <param name="vn">Specifies the number of partitions in the grid range interval [v1, v2] (glMapGrid2 only).</param>
        /// <param name="v1">Specify the mappings for integer grid domain values j=0 and j=vn (glMapGrid2 only).</param>
        /// <param name="v2">Specify the mappings for integer grid domain values j=0 and j=vn (glMapGrid2 only).</param>
        public static void MapGrid2d(int un, double u1, double u2, int vn, double v1, double v2)
        {
            if (gl._MapGrid2d != null) gl._MapGrid2d(un, u1, u2, vn, v1, v2); else { }
        }
        /// <summary>
        /// <para>Fullname: MapGrid2f</para>
        /// </summary>
        [GLEntry("MapGrid2f", Category = "1.0")]
        public static GLDelegate.MapGrid2f _MapGrid2f = null;
        /// <summary>
        /// <para>define a one- or two-dimensional mesh</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MapGrid2f.</para>
        /// <para>Fullname: MapGrid2f</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="un">Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive.</param>
        /// <param name="u1">Specify the mappings for integer grid domain values i=0 and i=un.</param>
        /// <param name="u2">Specify the mappings for integer grid domain values i=0 and i=un.</param>
        /// <param name="vn">Specifies the number of partitions in the grid range interval [v1, v2] (glMapGrid2 only).</param>
        /// <param name="v1">Specify the mappings for integer grid domain values j=0 and j=vn (glMapGrid2 only).</param>
        /// <param name="v2">Specify the mappings for integer grid domain values j=0 and j=vn (glMapGrid2 only).</param>
        public static void MapGrid2f(int un, float u1, float u2, int vn, float v1, float v2)
        {
            if (gl._MapGrid2f != null) gl._MapGrid2f(un, u1, u2, vn, v1, v2); else { }
        }
        /// <summary>
        /// <para>Fullname: Materialf</para>
        /// </summary>
        [GLEntry("Materialf", Category = "1.0")]
        public static GLDelegate.Materialf _Materialf = null;
        /// <summary>
        /// <para>specify material parameters for the lighting model</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Materialf.</para>
        /// <para>Fullname: Materialf</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="face">Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.</param>
        /// <param name="pname">Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS.</param>
        /// <param name="param">Specifies the value that parameter GL_SHININESS will be set to.</param>
        public static void Materialf(int face, int pname, float param)
        {
            if (gl._Materialf != null) gl._Materialf(face, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: Materialfv</para>
        /// </summary>
        [GLEntry("Materialfv", Category = "1.0")]
        public static GLDelegate.Materialfv _Materialfv = null;
        /// <summary>
        /// <para>specify material parameters for the lighting model</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Materialfv.</para>
        /// <para>Fullname: Materialfv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="face">Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.</param>
        /// <param name="pname">Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS.</param>
        /// <param name="param">Specifies the value that parameter GL_SHININESS will be set to.</param>
        public static void Materialfv(int face, int pname, float[] param)
        {
            if (gl._Materialfv != null) gl._Materialfv(face, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: Materiali</para>
        /// </summary>
        [GLEntry("Materiali", Category = "1.0")]
        public static GLDelegate.Materiali _Materiali = null;
        /// <summary>
        /// <para>specify material parameters for the lighting model</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Materiali.</para>
        /// <para>Fullname: Materiali</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="face">Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.</param>
        /// <param name="pname">Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS.</param>
        /// <param name="param">Specifies the value that parameter GL_SHININESS will be set to.</param>
        public static void Materiali(int face, int pname, int param)
        {
            if (gl._Materiali != null) gl._Materiali(face, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: Materialiv</para>
        /// </summary>
        [GLEntry("Materialiv", Category = "1.0")]
        public static GLDelegate.Materialiv _Materialiv = null;
        /// <summary>
        /// <para>specify material parameters for the lighting model</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Materialiv.</para>
        /// <para>Fullname: Materialiv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="face">Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.</param>
        /// <param name="pname">Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS.</param>
        /// <param name="param">Specifies the value that parameter GL_SHININESS will be set to.</param>
        public static void Materialiv(int face, int pname, int[] param)
        {
            if (gl._Materialiv != null) gl._Materialiv(face, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixMode</para>
        /// </summary>
        [GLEntry("MatrixMode", Category = "1.0")]
        public static GLDelegate.MatrixMode _MatrixMode = null;
        /// <summary>
        /// <para>specify which matrix is the current matrix</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixMode.</para>
        /// <para>Fullname: MatrixMode</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="mode">Specifies which matrix stack is the target for subsequent matrix operations. Three values are accepted: GL_MODELVIEW, GL_PROJECTION, and GL_TEXTURE. The initial value is GL_MODELVIEW. Additionally, if the ARB_imaging extension is supported, GL_COLOR is also accepted.</param>
        public static void MatrixMode(int mode)
        {
            if (gl._MatrixMode != null) gl._MatrixMode(mode); else { }
        }
        /// <summary>
        /// <para>Fullname: MultMatrixd</para>
        /// </summary>
        [GLEntry("MultMatrixd", Category = "1.0")]
        public static GLDelegate.MultMatrixd _MultMatrixd = null;
        /// <summary>
        /// <para>multiply the current matrix with the specified matrix</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultMatrixd.</para>
        /// <para>Fullname: MultMatrixd</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="m">Points to 16 consecutive values that are used as the elements of a 4×4 column-major matrix.</param>
        public static void MultMatrixd(double[] m)
        {
            if (gl._MultMatrixd != null) gl._MultMatrixd(m); else { }
        }
        /// <summary>
        /// <para>Fullname: MultMatrixf</para>
        /// </summary>
        [GLEntry("MultMatrixf", Category = "1.0")]
        public static GLDelegate.MultMatrixf _MultMatrixf = null;
        /// <summary>
        /// <para>multiply the current matrix with the specified matrix</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultMatrixf.</para>
        /// <para>Fullname: MultMatrixf</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="m">Points to 16 consecutive values that are used as the elements of a 4×4 column-major matrix.</param>
        public static void MultMatrixf(float[] m)
        {
            if (gl._MultMatrixf != null) gl._MultMatrixf(m); else { }
        }
        /// <summary>
        /// <para>Fullname: NewList</para>
        /// </summary>
        [GLEntry("NewList", Category = "1.0")]
        public static GLDelegate.NewList _NewList = null;
        /// <summary>
        /// <para>create or replace a display list</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NewList.</para>
        /// <para>Fullname: NewList</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="list">Specifies the display-list name.</param>
        /// <param name="mode">Specifies the compilation mode, which can be GL_COMPILE or GL_COMPILE_AND_EXECUTE.</param>
        public static void NewList(uint list, int mode)
        {
            if (gl._NewList != null) gl._NewList(list, mode); else { }
        }
        /// <summary>
        /// <para>Fullname: Normal3b</para>
        /// </summary>
        [GLEntry("Normal3b", Category = "1.0")]
        public static GLDelegate.Normal3b _Normal3b = null;
        /// <summary>
        /// <para>set the current normal vector</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Normal3b.</para>
        /// <para>Fullname: Normal3b</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="nx">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="ny">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="nz">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        public static void Normal3b(byte nx, byte ny, byte nz)
        {
            if (gl._Normal3b != null) gl._Normal3b(nx, ny, nz); else { }
        }
        /// <summary>
        /// <para>Fullname: Normal3bv</para>
        /// </summary>
        [GLEntry("Normal3bv", Category = "1.0")]
        public static GLDelegate.Normal3bv _Normal3bv = null;
        /// <summary>
        /// <para>set the current normal vector</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Normal3bv.</para>
        /// <para>Fullname: Normal3bv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="nx">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="ny">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="nz">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        public static void Normal3bv(byte[] v)
        {
            if (gl._Normal3bv != null) gl._Normal3bv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Normal3d</para>
        /// </summary>
        [GLEntry("Normal3d", Category = "1.0")]
        public static GLDelegate.Normal3d _Normal3d = null;
        /// <summary>
        /// <para>set the current normal vector</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Normal3d.</para>
        /// <para>Fullname: Normal3d</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="nx">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="ny">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="nz">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        public static void Normal3d(double nx, double ny, double nz)
        {
            if (gl._Normal3d != null) gl._Normal3d(nx, ny, nz); else { }
        }
        /// <summary>
        /// <para>Fullname: Normal3dv</para>
        /// </summary>
        [GLEntry("Normal3dv", Category = "1.0")]
        public static GLDelegate.Normal3dv _Normal3dv = null;
        /// <summary>
        /// <para>set the current normal vector</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Normal3dv.</para>
        /// <para>Fullname: Normal3dv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="nx">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="ny">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="nz">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        public static void Normal3dv(double[] v)
        {
            if (gl._Normal3dv != null) gl._Normal3dv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Normal3f</para>
        /// </summary>
        [GLEntry("Normal3f", Category = "1.0")]
        public static GLDelegate.Normal3f _Normal3f = null;
        /// <summary>
        /// <para>set the current normal vector</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Normal3f.</para>
        /// <para>Fullname: Normal3f</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="nx">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="ny">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="nz">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        public static void Normal3f(float nx, float ny, float nz)
        {
            if (gl._Normal3f != null) gl._Normal3f(nx, ny, nz); else { }
        }
        /// <summary>
        /// <para>Fullname: Normal3fv</para>
        /// </summary>
        [GLEntry("Normal3fv", Category = "1.0")]
        public static GLDelegate.Normal3fv _Normal3fv = null;
        /// <summary>
        /// <para>set the current normal vector</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Normal3fv.</para>
        /// <para>Fullname: Normal3fv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="nx">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="ny">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="nz">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        public static void Normal3fv(float[] v)
        {
            if (gl._Normal3fv != null) gl._Normal3fv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Normal3i</para>
        /// </summary>
        [GLEntry("Normal3i", Category = "1.0")]
        public static GLDelegate.Normal3i _Normal3i = null;
        /// <summary>
        /// <para>set the current normal vector</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Normal3i.</para>
        /// <para>Fullname: Normal3i</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="nx">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="ny">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="nz">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        public static void Normal3i(int nx, int ny, int nz)
        {
            if (gl._Normal3i != null) gl._Normal3i(nx, ny, nz); else { }
        }
        /// <summary>
        /// <para>Fullname: Normal3iv</para>
        /// </summary>
        [GLEntry("Normal3iv", Category = "1.0")]
        public static GLDelegate.Normal3iv _Normal3iv = null;
        /// <summary>
        /// <para>set the current normal vector</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Normal3iv.</para>
        /// <para>Fullname: Normal3iv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="nx">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="ny">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="nz">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        public static void Normal3iv(int[] v)
        {
            if (gl._Normal3iv != null) gl._Normal3iv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Normal3s</para>
        /// </summary>
        [GLEntry("Normal3s", Category = "1.0")]
        public static GLDelegate.Normal3s _Normal3s = null;
        /// <summary>
        /// <para>set the current normal vector</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Normal3s.</para>
        /// <para>Fullname: Normal3s</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="nx">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="ny">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="nz">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        public static void Normal3s(short nx, short ny, short nz)
        {
            if (gl._Normal3s != null) gl._Normal3s(nx, ny, nz); else { }
        }
        /// <summary>
        /// <para>Fullname: Normal3sv</para>
        /// </summary>
        [GLEntry("Normal3sv", Category = "1.0")]
        public static GLDelegate.Normal3sv _Normal3sv = null;
        /// <summary>
        /// <para>set the current normal vector</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Normal3sv.</para>
        /// <para>Fullname: Normal3sv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="nx">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="ny">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        /// <param name="nz">Specify the x, y, and z coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).</param>
        public static void Normal3sv(short[] v)
        {
            if (gl._Normal3sv != null) gl._Normal3sv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Ortho</para>
        /// </summary>
        [GLEntry("Ortho", Category = "1.0")]
        public static GLDelegate.Ortho _Ortho = null;
        /// <summary>
        /// <para>multiply the current matrix with an orthographic matrix</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Ortho.</para>
        /// <para>Fullname: Ortho</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="left">Specify the coordinates for the left and right vertical clipping planes.</param>
        /// <param name="right">Specify the coordinates for the left and right vertical clipping planes.</param>
        /// <param name="bottom">Specify the coordinates for the bottom and top horizontal clipping planes.</param>
        /// <param name="top">Specify the coordinates for the bottom and top horizontal clipping planes.</param>
        /// <param name="nearVal">Specify the distances to the nearer and farther depth clipping planes. These values are negative if the plane is to be behind the viewer.</param>
        /// <param name="farVal">Specify the distances to the nearer and farther depth clipping planes. These values are negative if the plane is to be behind the viewer.</param>
        public static void Ortho(double left, double right, double bottom, double top, double zNear, double zFar)
        {
            if (gl._Ortho != null) gl._Ortho(left, right, bottom, top, zNear, zFar); else { }
        }
        /// <summary>
        /// <para>Fullname: PassThrough</para>
        /// </summary>
        [GLEntry("PassThrough", Category = "1.0")]
        public static GLDelegate.PassThrough _PassThrough = null;
        /// <summary>
        /// <para>place a marker in the feedback buffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PassThrough.</para>
        /// <para>Fullname: PassThrough</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="token">Specifies a marker value to be placed in the feedback buffer following a GL_PASS_THROUGH_TOKEN.</param>
        public static void PassThrough(float token)
        {
            if (gl._PassThrough != null) gl._PassThrough(token); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelMapfv</para>
        /// </summary>
        [GLEntry("PixelMapfv", Category = "1.0")]
        public static GLDelegate.PixelMapfv _PixelMapfv = null;
        /// <summary>
        /// <para>set up pixel transfer maps</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelMapfv.</para>
        /// <para>Fullname: PixelMapfv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="map">Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A.</param>
        /// <param name="mapsize">Specifies the size of the map being defined.</param>
        /// <param name="values">Specifies an array of mapsize values.</param>
        public static void PixelMapfv(int map, int mapsize, float[] values)
        {
            if (gl._PixelMapfv != null) gl._PixelMapfv(map, mapsize, values); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelMapuiv</para>
        /// </summary>
        [GLEntry("PixelMapuiv", Category = "1.0")]
        public static GLDelegate.PixelMapuiv _PixelMapuiv = null;
        /// <summary>
        /// <para>set up pixel transfer maps</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelMapuiv.</para>
        /// <para>Fullname: PixelMapuiv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="map">Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A.</param>
        /// <param name="mapsize">Specifies the size of the map being defined.</param>
        /// <param name="values">Specifies an array of mapsize values.</param>
        public static void PixelMapuiv(int map, int mapsize, uint[] values)
        {
            if (gl._PixelMapuiv != null) gl._PixelMapuiv(map, mapsize, values); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelMapusv</para>
        /// </summary>
        [GLEntry("PixelMapusv", Category = "1.0")]
        public static GLDelegate.PixelMapusv _PixelMapusv = null;
        /// <summary>
        /// <para>set up pixel transfer maps</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelMapusv.</para>
        /// <para>Fullname: PixelMapusv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="map">Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A.</param>
        /// <param name="mapsize">Specifies the size of the map being defined.</param>
        /// <param name="values">Specifies an array of mapsize values.</param>
        public static void PixelMapusv(int map, int mapsize, ushort[] values)
        {
            if (gl._PixelMapusv != null) gl._PixelMapusv(map, mapsize, values); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelStoref</para>
        /// </summary>
        [GLEntry("PixelStoref", Category = "1.0")]
        public static GLDelegate.PixelStoref _PixelStoref = null;
        /// <summary>
        /// <para>set pixel storage modes</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelStoref.</para>
        /// <para>Fullname: PixelStoref</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="pname">Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT.</param>
        /// <param name="param">Specifies the value that pname is set to.</param>
        public static void PixelStoref(int pname, float param)
        {
            if (gl._PixelStoref != null) gl._PixelStoref(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelStorei</para>
        /// </summary>
        [GLEntry("PixelStorei", Category = "1.0")]
        public static GLDelegate.PixelStorei _PixelStorei = null;
        /// <summary>
        /// <para>set pixel storage modes</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelStorei.</para>
        /// <para>Fullname: PixelStorei</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="pname">Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT.</param>
        /// <param name="param">Specifies the value that pname is set to.</param>
        public static void PixelStorei(int pname, int param)
        {
            if (gl._PixelStorei != null) gl._PixelStorei(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelTransferf</para>
        /// </summary>
        [GLEntry("PixelTransferf", Category = "1.0")]
        public static GLDelegate.PixelTransferf _PixelTransferf = null;
        /// <summary>
        /// <para>set pixel transfer modes</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelTransferf.</para>
        /// <para>Fullname: PixelTransferf</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="pname">Specifies the symbolic name of the pixel transfer parameter to be set. Must be one of the following: GL_MAP_COLOR, GL_MAP_STENCIL, GL_INDEX_SHIFT, GL_INDEX_OFFSET, GL_RED_SCALE, GL_RED_BIAS, GL_GREEN_SCALE, GL_GREEN_BIAS, GL_BLUE_SCALE, GL_BLUE_BIAS, GL_ALPHA_SCALE, GL_ALPHA_BIAS, GL_DEPTH_SCALE, or GL_DEPTH_BIAS.</param>
        /// <param name="param">Additionally, if the ARB_imaging extension is supported, the following symbolic names are accepted: GL_POST_COLOR_MATRIX_RED_SCALE, GL_POST_COLOR_MATRIX_GREEN_SCALE, GL_POST_COLOR_MATRIX_BLUE_SCALE, GL_POST_COLOR_MATRIX_ALPHA_SCALE, GL_POST_COLOR_MATRIX_RED_BIAS, GL_POST_COLOR_MATRIX_GREEN_BIAS, GL_POST_COLOR_MATRIX_BLUE_BIAS, GL_POST_COLOR_MATRIX_ALPHA_BIAS, GL_POST_CONVOLUTION_RED_SCALE, GL_POST_CONVOLUTION_GREEN_SCALE, GL_POST_CONVOLUTION_BLUE_SCALE, GL_POST_CONVOLUTION_ALPHA_SCALE, GL_POST_CONVOLUTION_RED_BIAS, GL_POST_CONVOLUTION_GREEN_BIAS, GL_POST_CONVOLUTION_BLUE_BIAS, and GL_POST_CONVOLUTION_ALPHA_BIAS.</param>
        public static void PixelTransferf(int pname, float param)
        {
            if (gl._PixelTransferf != null) gl._PixelTransferf(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelTransferi</para>
        /// </summary>
        [GLEntry("PixelTransferi", Category = "1.0")]
        public static GLDelegate.PixelTransferi _PixelTransferi = null;
        /// <summary>
        /// <para>set pixel transfer modes</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelTransferi.</para>
        /// <para>Fullname: PixelTransferi</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="pname">Specifies the symbolic name of the pixel transfer parameter to be set. Must be one of the following: GL_MAP_COLOR, GL_MAP_STENCIL, GL_INDEX_SHIFT, GL_INDEX_OFFSET, GL_RED_SCALE, GL_RED_BIAS, GL_GREEN_SCALE, GL_GREEN_BIAS, GL_BLUE_SCALE, GL_BLUE_BIAS, GL_ALPHA_SCALE, GL_ALPHA_BIAS, GL_DEPTH_SCALE, or GL_DEPTH_BIAS.</param>
        /// <param name="param">Additionally, if the ARB_imaging extension is supported, the following symbolic names are accepted: GL_POST_COLOR_MATRIX_RED_SCALE, GL_POST_COLOR_MATRIX_GREEN_SCALE, GL_POST_COLOR_MATRIX_BLUE_SCALE, GL_POST_COLOR_MATRIX_ALPHA_SCALE, GL_POST_COLOR_MATRIX_RED_BIAS, GL_POST_COLOR_MATRIX_GREEN_BIAS, GL_POST_COLOR_MATRIX_BLUE_BIAS, GL_POST_COLOR_MATRIX_ALPHA_BIAS, GL_POST_CONVOLUTION_RED_SCALE, GL_POST_CONVOLUTION_GREEN_SCALE, GL_POST_CONVOLUTION_BLUE_SCALE, GL_POST_CONVOLUTION_ALPHA_SCALE, GL_POST_CONVOLUTION_RED_BIAS, GL_POST_CONVOLUTION_GREEN_BIAS, GL_POST_CONVOLUTION_BLUE_BIAS, and GL_POST_CONVOLUTION_ALPHA_BIAS.</param>
        public static void PixelTransferi(int pname, int param)
        {
            if (gl._PixelTransferi != null) gl._PixelTransferi(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelZoom</para>
        /// </summary>
        [GLEntry("PixelZoom", Category = "1.0")]
        public static GLDelegate.PixelZoom _PixelZoom = null;
        /// <summary>
        /// <para>specify the pixel zoom factors</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelZoom.</para>
        /// <para>Fullname: PixelZoom</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="xfactor">Specify the x and y zoom factors for pixel write operations.</param>
        /// <param name="yfactor">Specify the x and y zoom factors for pixel write operations.</param>
        public static void PixelZoom(float xfactor, float yfactor)
        {
            if (gl._PixelZoom != null) gl._PixelZoom(xfactor, yfactor); else { }
        }
        /// <summary>
        /// <para>Fullname: PointSize</para>
        /// </summary>
        [GLEntry("PointSize", Category = "1.0")]
        public static GLDelegate.PointSize _PointSize = null;
        /// <summary>
        /// <para>specify the diameter of rasterized points</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PointSize.</para>
        /// <para>Fullname: PointSize</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="size">Specifies the diameter of rasterized points. The initial value is 1.</param>
        public static void PointSize(float size)
        {
            if (gl._PointSize != null) gl._PointSize(size); else { }
        }
        /// <summary>
        /// <para>Fullname: PolygonMode</para>
        /// </summary>
        [GLEntry("PolygonMode", Category = "1.0")]
        public static GLDelegate.PolygonMode _PolygonMode = null;
        /// <summary>
        /// <para>select a polygon rasterization mode</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PolygonMode.</para>
        /// <para>Fullname: PolygonMode</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="face">Specifies the polygons that mode applies to. Must be GL_FRONT_AND_BACK for front- and back-facing polygons.</param>
        /// <param name="mode">Specifies how polygons will be rasterized. Accepted values are GL_POINT, GL_LINE, and GL_FILL. The initial value is GL_FILL for both front- and back-facing polygons.</param>
        public static void PolygonMode(int face, int mode)
        {
            if (gl._PolygonMode != null) gl._PolygonMode(face, mode); else { }
        }
        /// <summary>
        /// <para>Fullname: PolygonStipple</para>
        /// </summary>
        [GLEntry("PolygonStipple", Category = "1.0")]
        public static GLDelegate.PolygonStipple _PolygonStipple = null;
        /// <summary>
        /// <para>set the polygon stippling pattern</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PolygonStipple.</para>
        /// <para>Fullname: PolygonStipple</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="pattern">Specifies a pointer to a 32×32 stipple pattern that will be unpacked from memory in the same way that glDrawPixels unpacks pixels.</param>
        public static void PolygonStipple(byte[] mask)
        {
            if (gl._PolygonStipple != null) gl._PolygonStipple(mask); else { }
        }
        /// <summary>
        /// <para>Fullname: PopAttrib</para>
        /// </summary>
        [GLEntry("PopAttrib", Category = "1.0")]
        public static GLDelegate.PopAttrib _PopAttrib = null;
        /// <summary>
        /// <para>push and pop the server attribute stack</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PopAttrib.</para>
        /// <para>Fullname: PopAttrib</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="mask">Specifies a mask that indicates which attributes to save. Values for mask are listed below.</param>
        public static void PopAttrib()
        {
            if (gl._PopAttrib != null) gl._PopAttrib(); else { }
        }
        /// <summary>
        /// <para>Fullname: PopMatrix</para>
        /// </summary>
        [GLEntry("PopMatrix", Category = "1.0")]
        public static GLDelegate.PopMatrix _PopMatrix = null;
        /// <summary>
        /// <para>push and pop the current matrix stack</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PopMatrix.</para>
        /// <para>Fullname: PopMatrix</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        public static void PopMatrix()
        {
            if (gl._PopMatrix != null) gl._PopMatrix(); else { }
        }
        /// <summary>
        /// <para>Fullname: PopName</para>
        /// </summary>
        [GLEntry("PopName", Category = "1.0")]
        public static GLDelegate.PopName _PopName = null;
        /// <summary>
        /// <para>push and pop the name stack</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PopName.</para>
        /// <para>Fullname: PopName</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="name">Specifies a name that will be pushed onto the name stack.</param>
        public static void PopName()
        {
            if (gl._PopName != null) gl._PopName(); else { }
        }
        /// <summary>
        /// <para>Fullname: PushAttrib</para>
        /// </summary>
        [GLEntry("PushAttrib", Category = "1.0")]
        public static GLDelegate.PushAttrib _PushAttrib = null;
        /// <summary>
        /// <para>push and pop the server attribute stack</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PushAttrib.</para>
        /// <para>Fullname: PushAttrib</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="mask">Specifies a mask that indicates which attributes to save. Values for mask are listed below.</param>
        public static void PushAttrib(int mask)
        {
            if (gl._PushAttrib != null) gl._PushAttrib(mask); else { }
        }
        /// <summary>
        /// <para>Fullname: PushMatrix</para>
        /// </summary>
        [GLEntry("PushMatrix", Category = "1.0")]
        public static GLDelegate.PushMatrix _PushMatrix = null;
        /// <summary>
        /// <para>push and pop the current matrix stack</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PushMatrix.</para>
        /// <para>Fullname: PushMatrix</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        public static void PushMatrix()
        {
            if (gl._PushMatrix != null) gl._PushMatrix(); else { }
        }
        /// <summary>
        /// <para>Fullname: PushName</para>
        /// </summary>
        [GLEntry("PushName", Category = "1.0")]
        public static GLDelegate.PushName _PushName = null;
        /// <summary>
        /// <para>push and pop the name stack</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PushName.</para>
        /// <para>Fullname: PushName</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="name">Specifies a name that will be pushed onto the name stack.</param>
        public static void PushName(uint name)
        {
            if (gl._PushName != null) gl._PushName(name); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos2d</para>
        /// </summary>
        [GLEntry("RasterPos2d", Category = "1.0")]
        public static GLDelegate.RasterPos2d _RasterPos2d = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos2d.</para>
        /// <para>Fullname: RasterPos2d</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos2d(double x, double y)
        {
            if (gl._RasterPos2d != null) gl._RasterPos2d(x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos2dv</para>
        /// </summary>
        [GLEntry("RasterPos2dv", Category = "1.0")]
        public static GLDelegate.RasterPos2dv _RasterPos2dv = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos2dv.</para>
        /// <para>Fullname: RasterPos2dv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos2dv(double[] v)
        {
            if (gl._RasterPos2dv != null) gl._RasterPos2dv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos2f</para>
        /// </summary>
        [GLEntry("RasterPos2f", Category = "1.0")]
        public static GLDelegate.RasterPos2f _RasterPos2f = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos2f.</para>
        /// <para>Fullname: RasterPos2f</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos2f(float x, float y)
        {
            if (gl._RasterPos2f != null) gl._RasterPos2f(x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos2fv</para>
        /// </summary>
        [GLEntry("RasterPos2fv", Category = "1.0")]
        public static GLDelegate.RasterPos2fv _RasterPos2fv = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos2fv.</para>
        /// <para>Fullname: RasterPos2fv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos2fv(float[] v)
        {
            if (gl._RasterPos2fv != null) gl._RasterPos2fv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos2i</para>
        /// </summary>
        [GLEntry("RasterPos2i", Category = "1.0")]
        public static GLDelegate.RasterPos2i _RasterPos2i = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos2i.</para>
        /// <para>Fullname: RasterPos2i</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos2i(int x, int y)
        {
            if (gl._RasterPos2i != null) gl._RasterPos2i(x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos2iv</para>
        /// </summary>
        [GLEntry("RasterPos2iv", Category = "1.0")]
        public static GLDelegate.RasterPos2iv _RasterPos2iv = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos2iv.</para>
        /// <para>Fullname: RasterPos2iv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos2iv(int[] v)
        {
            if (gl._RasterPos2iv != null) gl._RasterPos2iv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos2s</para>
        /// </summary>
        [GLEntry("RasterPos2s", Category = "1.0")]
        public static GLDelegate.RasterPos2s _RasterPos2s = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos2s.</para>
        /// <para>Fullname: RasterPos2s</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos2s(short x, short y)
        {
            if (gl._RasterPos2s != null) gl._RasterPos2s(x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos2sv</para>
        /// </summary>
        [GLEntry("RasterPos2sv", Category = "1.0")]
        public static GLDelegate.RasterPos2sv _RasterPos2sv = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos2sv.</para>
        /// <para>Fullname: RasterPos2sv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos2sv(short[] v)
        {
            if (gl._RasterPos2sv != null) gl._RasterPos2sv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos3d</para>
        /// </summary>
        [GLEntry("RasterPos3d", Category = "1.0")]
        public static GLDelegate.RasterPos3d _RasterPos3d = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos3d.</para>
        /// <para>Fullname: RasterPos3d</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos3d(double x, double y, double z)
        {
            if (gl._RasterPos3d != null) gl._RasterPos3d(x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos3dv</para>
        /// </summary>
        [GLEntry("RasterPos3dv", Category = "1.0")]
        public static GLDelegate.RasterPos3dv _RasterPos3dv = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos3dv.</para>
        /// <para>Fullname: RasterPos3dv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos3dv(double[] v)
        {
            if (gl._RasterPos3dv != null) gl._RasterPos3dv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos3f</para>
        /// </summary>
        [GLEntry("RasterPos3f", Category = "1.0")]
        public static GLDelegate.RasterPos3f _RasterPos3f = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos3f.</para>
        /// <para>Fullname: RasterPos3f</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos3f(float x, float y, float z)
        {
            if (gl._RasterPos3f != null) gl._RasterPos3f(x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos3fv</para>
        /// </summary>
        [GLEntry("RasterPos3fv", Category = "1.0")]
        public static GLDelegate.RasterPos3fv _RasterPos3fv = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos3fv.</para>
        /// <para>Fullname: RasterPos3fv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos3fv(float[] v)
        {
            if (gl._RasterPos3fv != null) gl._RasterPos3fv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos3i</para>
        /// </summary>
        [GLEntry("RasterPos3i", Category = "1.0")]
        public static GLDelegate.RasterPos3i _RasterPos3i = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos3i.</para>
        /// <para>Fullname: RasterPos3i</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos3i(int x, int y, int z)
        {
            if (gl._RasterPos3i != null) gl._RasterPos3i(x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos3iv</para>
        /// </summary>
        [GLEntry("RasterPos3iv", Category = "1.0")]
        public static GLDelegate.RasterPos3iv _RasterPos3iv = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos3iv.</para>
        /// <para>Fullname: RasterPos3iv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos3iv(int[] v)
        {
            if (gl._RasterPos3iv != null) gl._RasterPos3iv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos3s</para>
        /// </summary>
        [GLEntry("RasterPos3s", Category = "1.0")]
        public static GLDelegate.RasterPos3s _RasterPos3s = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos3s.</para>
        /// <para>Fullname: RasterPos3s</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos3s(short x, short y, short z)
        {
            if (gl._RasterPos3s != null) gl._RasterPos3s(x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos3sv</para>
        /// </summary>
        [GLEntry("RasterPos3sv", Category = "1.0")]
        public static GLDelegate.RasterPos3sv _RasterPos3sv = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos3sv.</para>
        /// <para>Fullname: RasterPos3sv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos3sv(short[] v)
        {
            if (gl._RasterPos3sv != null) gl._RasterPos3sv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos4d</para>
        /// </summary>
        [GLEntry("RasterPos4d", Category = "1.0")]
        public static GLDelegate.RasterPos4d _RasterPos4d = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos4d.</para>
        /// <para>Fullname: RasterPos4d</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos4d(double x, double y, double z, double w)
        {
            if (gl._RasterPos4d != null) gl._RasterPos4d(x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos4dv</para>
        /// </summary>
        [GLEntry("RasterPos4dv", Category = "1.0")]
        public static GLDelegate.RasterPos4dv _RasterPos4dv = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos4dv.</para>
        /// <para>Fullname: RasterPos4dv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos4dv(double[] v)
        {
            if (gl._RasterPos4dv != null) gl._RasterPos4dv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos4f</para>
        /// </summary>
        [GLEntry("RasterPos4f", Category = "1.0")]
        public static GLDelegate.RasterPos4f _RasterPos4f = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos4f.</para>
        /// <para>Fullname: RasterPos4f</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos4f(float x, float y, float z, float w)
        {
            if (gl._RasterPos4f != null) gl._RasterPos4f(x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos4fv</para>
        /// </summary>
        [GLEntry("RasterPos4fv", Category = "1.0")]
        public static GLDelegate.RasterPos4fv _RasterPos4fv = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos4fv.</para>
        /// <para>Fullname: RasterPos4fv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos4fv(float[] v)
        {
            if (gl._RasterPos4fv != null) gl._RasterPos4fv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos4i</para>
        /// </summary>
        [GLEntry("RasterPos4i", Category = "1.0")]
        public static GLDelegate.RasterPos4i _RasterPos4i = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos4i.</para>
        /// <para>Fullname: RasterPos4i</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos4i(int x, int y, int z, int w)
        {
            if (gl._RasterPos4i != null) gl._RasterPos4i(x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos4iv</para>
        /// </summary>
        [GLEntry("RasterPos4iv", Category = "1.0")]
        public static GLDelegate.RasterPos4iv _RasterPos4iv = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos4iv.</para>
        /// <para>Fullname: RasterPos4iv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos4iv(int[] v)
        {
            if (gl._RasterPos4iv != null) gl._RasterPos4iv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos4s</para>
        /// </summary>
        [GLEntry("RasterPos4s", Category = "1.0")]
        public static GLDelegate.RasterPos4s _RasterPos4s = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos4s.</para>
        /// <para>Fullname: RasterPos4s</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos4s(short x, short y, short z, short w)
        {
            if (gl._RasterPos4s != null) gl._RasterPos4s(x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: RasterPos4sv</para>
        /// </summary>
        [GLEntry("RasterPos4sv", Category = "1.0")]
        public static GLDelegate.RasterPos4sv _RasterPos4sv = null;
        /// <summary>
        /// <para>specify the raster position for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RasterPos4sv.</para>
        /// <para>Fullname: RasterPos4sv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="y">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="z">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        /// <param name="w">Specify the x, y, z, and w object coordinates (if present) for the raster position.</param>
        public static void RasterPos4sv(short[] v)
        {
            if (gl._RasterPos4sv != null) gl._RasterPos4sv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: ReadBuffer</para>
        /// </summary>
        [GLEntry("ReadBuffer", Category = "1.0")]
        public static GLDelegate.ReadBuffer _ReadBuffer = null;
        /// <summary>
        /// <para>select a color buffer source for pixels</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReadBuffer.</para>
        /// <para>Fullname: ReadBuffer</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="mode">Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.</param>
        public static void ReadBuffer(int mode)
        {
            if (gl._ReadBuffer != null) gl._ReadBuffer(mode); else { }
        }
        /// <summary>
        /// <para>Fullname: ReadPixels</para>
        /// </summary>
        [GLEntry("ReadPixels", Category = "1.0")]
        public static GLDelegate.ReadPixels _ReadPixels = null;
        /// <summary>
        /// <para>read a block of pixels from the frame buffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReadPixels.</para>
        /// <para>Fullname: ReadPixels</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="x">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="y">Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.</param>
        /// <param name="width">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="height">Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="data">Returns the pixel data.</param>
        public static void ReadPixels(int x, int y, int width, int height, int format, int type, IntPtr pixels)
        {
            if (gl._ReadPixels != null) gl._ReadPixels(x, y, width, height, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>Fullname: Rectd</para>
        /// </summary>
        [GLEntry("Rectd", Category = "1.0")]
        public static GLDelegate.Rectd _Rectd = null;
        /// <summary>
        /// <para>draw a rectangle</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Rectd.</para>
        /// <para>Fullname: Rectd</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x1">Specify one vertex of a rectangle.</param>
        /// <param name="y1">Specify one vertex of a rectangle.</param>
        /// <param name="x2">Specify the opposite vertex of the rectangle.</param>
        /// <param name="y2">Specify the opposite vertex of the rectangle.</param>
        public static void Rectd(double x1, double y1, double x2, double y2)
        {
            if (gl._Rectd != null) gl._Rectd(x1, y1, x2, y2); else { }
        }
        /// <summary>
        /// <para>Fullname: Rectdv</para>
        /// </summary>
        [GLEntry("Rectdv", Category = "1.0")]
        public static GLDelegate.Rectdv _Rectdv = null;
        /// <summary>
        /// <para>draw a rectangle</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Rectdv.</para>
        /// <para>Fullname: Rectdv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x1">Specify one vertex of a rectangle.</param>
        /// <param name="y1">Specify one vertex of a rectangle.</param>
        /// <param name="x2">Specify the opposite vertex of the rectangle.</param>
        /// <param name="y2">Specify the opposite vertex of the rectangle.</param>
        public static void Rectdv(double[] v1, double[] v2)
        {
            if (gl._Rectdv != null) gl._Rectdv(v1, v2); else { }
        }
        /// <summary>
        /// <para>Fullname: Rectf</para>
        /// </summary>
        [GLEntry("Rectf", Category = "1.0")]
        public static GLDelegate.Rectf _Rectf = null;
        /// <summary>
        /// <para>draw a rectangle</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Rectf.</para>
        /// <para>Fullname: Rectf</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x1">Specify one vertex of a rectangle.</param>
        /// <param name="y1">Specify one vertex of a rectangle.</param>
        /// <param name="x2">Specify the opposite vertex of the rectangle.</param>
        /// <param name="y2">Specify the opposite vertex of the rectangle.</param>
        public static void Rectf(float x1, float y1, float x2, float y2)
        {
            if (gl._Rectf != null) gl._Rectf(x1, y1, x2, y2); else { }
        }
        /// <summary>
        /// <para>Fullname: Rectfv</para>
        /// </summary>
        [GLEntry("Rectfv", Category = "1.0")]
        public static GLDelegate.Rectfv _Rectfv = null;
        /// <summary>
        /// <para>draw a rectangle</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Rectfv.</para>
        /// <para>Fullname: Rectfv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x1">Specify one vertex of a rectangle.</param>
        /// <param name="y1">Specify one vertex of a rectangle.</param>
        /// <param name="x2">Specify the opposite vertex of the rectangle.</param>
        /// <param name="y2">Specify the opposite vertex of the rectangle.</param>
        public static void Rectfv(float[] v1, float[] v2)
        {
            if (gl._Rectfv != null) gl._Rectfv(v1, v2); else { }
        }
        /// <summary>
        /// <para>Fullname: Recti</para>
        /// </summary>
        [GLEntry("Recti", Category = "1.0")]
        public static GLDelegate.Recti _Recti = null;
        /// <summary>
        /// <para>draw a rectangle</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Recti.</para>
        /// <para>Fullname: Recti</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x1">Specify one vertex of a rectangle.</param>
        /// <param name="y1">Specify one vertex of a rectangle.</param>
        /// <param name="x2">Specify the opposite vertex of the rectangle.</param>
        /// <param name="y2">Specify the opposite vertex of the rectangle.</param>
        public static void Recti(int x1, int y1, int x2, int y2)
        {
            if (gl._Recti != null) gl._Recti(x1, y1, x2, y2); else { }
        }
        /// <summary>
        /// <para>Fullname: Rectiv</para>
        /// </summary>
        [GLEntry("Rectiv", Category = "1.0")]
        public static GLDelegate.Rectiv _Rectiv = null;
        /// <summary>
        /// <para>draw a rectangle</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Rectiv.</para>
        /// <para>Fullname: Rectiv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x1">Specify one vertex of a rectangle.</param>
        /// <param name="y1">Specify one vertex of a rectangle.</param>
        /// <param name="x2">Specify the opposite vertex of the rectangle.</param>
        /// <param name="y2">Specify the opposite vertex of the rectangle.</param>
        public static void Rectiv(int[] v1, int[] v2)
        {
            if (gl._Rectiv != null) gl._Rectiv(v1, v2); else { }
        }
        /// <summary>
        /// <para>Fullname: Rects</para>
        /// </summary>
        [GLEntry("Rects", Category = "1.0")]
        public static GLDelegate.Rects _Rects = null;
        /// <summary>
        /// <para>draw a rectangle</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Rects.</para>
        /// <para>Fullname: Rects</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x1">Specify one vertex of a rectangle.</param>
        /// <param name="y1">Specify one vertex of a rectangle.</param>
        /// <param name="x2">Specify the opposite vertex of the rectangle.</param>
        /// <param name="y2">Specify the opposite vertex of the rectangle.</param>
        public static void Rects(short x1, short y1, short x2, short y2)
        {
            if (gl._Rects != null) gl._Rects(x1, y1, x2, y2); else { }
        }
        /// <summary>
        /// <para>Fullname: Rectsv</para>
        /// </summary>
        [GLEntry("Rectsv", Category = "1.0")]
        public static GLDelegate.Rectsv _Rectsv = null;
        /// <summary>
        /// <para>draw a rectangle</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Rectsv.</para>
        /// <para>Fullname: Rectsv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x1">Specify one vertex of a rectangle.</param>
        /// <param name="y1">Specify one vertex of a rectangle.</param>
        /// <param name="x2">Specify the opposite vertex of the rectangle.</param>
        /// <param name="y2">Specify the opposite vertex of the rectangle.</param>
        public static void Rectsv(short[] v1, short[] v2)
        {
            if (gl._Rectsv != null) gl._Rectsv(v1, v2); else { }
        }
        /// <summary>
        /// <para>Fullname: RenderMode</para>
        /// </summary>
        [GLEntry("RenderMode", Category = "1.0")]
        public static GLDelegate.RenderMode _RenderMode = null;
        /// <summary>
        /// <para>set rasterization mode</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RenderMode.</para>
        /// <para>Fullname: RenderMode</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="mode">Specifies the rasterization mode. Three values are accepted: GL_RENDER, GL_SELECT, and GL_FEEDBACK. The initial value is GL_RENDER.</param>
        public static int RenderMode(int mode)
        {
            if (gl._RenderMode != null) return gl._RenderMode(mode);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: Rotated</para>
        /// </summary>
        [GLEntry("Rotated", Category = "1.0")]
        public static GLDelegate.Rotated _Rotated = null;
        /// <summary>
        /// <para>multiply the current matrix by a rotation matrix</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Rotated.</para>
        /// <para>Fullname: Rotated</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="angle">Specifies the angle of rotation, in degrees.</param>
        /// <param name="x">Specify the x, y, and z coordinates of a vector, respectively.</param>
        /// <param name="y">Specify the x, y, and z coordinates of a vector, respectively.</param>
        /// <param name="z">Specify the x, y, and z coordinates of a vector, respectively.</param>
        public static void Rotated(double angle, double x, double y, double z)
        {
            if (gl._Rotated != null) gl._Rotated(angle, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: Rotatef</para>
        /// </summary>
        [GLEntry("Rotatef", Category = "1.0")]
        public static GLDelegate.Rotatef _Rotatef = null;
        /// <summary>
        /// <para>multiply the current matrix by a rotation matrix</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Rotatef.</para>
        /// <para>Fullname: Rotatef</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="angle">Specifies the angle of rotation, in degrees.</param>
        /// <param name="x">Specify the x, y, and z coordinates of a vector, respectively.</param>
        /// <param name="y">Specify the x, y, and z coordinates of a vector, respectively.</param>
        /// <param name="z">Specify the x, y, and z coordinates of a vector, respectively.</param>
        public static void Rotatef(float angle, float x, float y, float z)
        {
            if (gl._Rotatef != null) gl._Rotatef(angle, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: Scaled</para>
        /// </summary>
        [GLEntry("Scaled", Category = "1.0")]
        public static GLDelegate.Scaled _Scaled = null;
        /// <summary>
        /// <para>multiply the current matrix by a general scaling matrix</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Scaled.</para>
        /// <para>Fullname: Scaled</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify scale factors along the x, y, and z axes, respectively.</param>
        /// <param name="y">Specify scale factors along the x, y, and z axes, respectively.</param>
        /// <param name="z">Specify scale factors along the x, y, and z axes, respectively.</param>
        public static void Scaled(double x, double y, double z)
        {
            if (gl._Scaled != null) gl._Scaled(x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: Scalef</para>
        /// </summary>
        [GLEntry("Scalef", Category = "1.0")]
        public static GLDelegate.Scalef _Scalef = null;
        /// <summary>
        /// <para>multiply the current matrix by a general scaling matrix</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Scalef.</para>
        /// <para>Fullname: Scalef</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify scale factors along the x, y, and z axes, respectively.</param>
        /// <param name="y">Specify scale factors along the x, y, and z axes, respectively.</param>
        /// <param name="z">Specify scale factors along the x, y, and z axes, respectively.</param>
        public static void Scalef(float x, float y, float z)
        {
            if (gl._Scalef != null) gl._Scalef(x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: Scissor</para>
        /// </summary>
        [GLEntry("Scissor", Category = "1.0")]
        public static GLDelegate.Scissor _Scissor = null;
        /// <summary>
        /// <para>define the scissor box</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Scissor.</para>
        /// <para>Fullname: Scissor</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="x">Specify the lower left corner of the scissor box. Initially (0, 0).</param>
        /// <param name="y">Specify the lower left corner of the scissor box. Initially (0, 0).</param>
        /// <param name="width">Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window.</param>
        /// <param name="height">Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window.</param>
        public static void Scissor(int x, int y, int width, int height)
        {
            if (gl._Scissor != null) gl._Scissor(x, y, width, height); else { }
        }
        /// <summary>
        /// <para>Fullname: SelectBuffer</para>
        /// </summary>
        [GLEntry("SelectBuffer", Category = "1.0")]
        public static GLDelegate.SelectBuffer _SelectBuffer = null;
        /// <summary>
        /// <para>establish a buffer for selection mode values</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SelectBuffer.</para>
        /// <para>Fullname: SelectBuffer</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="size">Specifies the size of buffer.</param>
        /// <param name="buffer">Returns the selection data.</param>
        public static void SelectBuffer(int size, IntPtr buffer)
        {
            if (gl._SelectBuffer != null) gl._SelectBuffer(size, buffer); else { }
        }
        /// <summary>
        /// <para>Fullname: ShadeModel</para>
        /// </summary>
        [GLEntry("ShadeModel", Category = "1.0")]
        public static GLDelegate.ShadeModel _ShadeModel = null;
        /// <summary>
        /// <para>select flat or smooth shading</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ShadeModel.</para>
        /// <para>Fullname: ShadeModel</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="mode">Specifies a symbolic value representing a shading technique. Accepted values are GL_FLAT and GL_SMOOTH. The initial value is GL_SMOOTH.</param>
        public static void ShadeModel(int mode)
        {
            if (gl._ShadeModel != null) gl._ShadeModel(mode); else { }
        }
        /// <summary>
        /// <para>Fullname: StencilFunc</para>
        /// </summary>
        [GLEntry("StencilFunc", Category = "1.0")]
        public static GLDelegate.StencilFunc _StencilFunc = null;
        /// <summary>
        /// <para>set front and back function and reference value for stencil testing</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _StencilFunc.</para>
        /// <para>Fullname: StencilFunc</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="func">Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.</param>
        /// <param name="ref">Specifies the reference value for the stencil test. ref is clamped to the range 02n-1, where n is the number of bitplanes in the stencil buffer. The initial value is 0.</param>
        /// <param name="mask">Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.</param>
        public static void StencilFunc(int func, int reference, uint mask)
        {
            if (gl._StencilFunc != null) gl._StencilFunc(func, reference, mask); else { }
        }
        /// <summary>
        /// <para>Fullname: StencilMask</para>
        /// </summary>
        [GLEntry("StencilMask", Category = "1.0")]
        public static GLDelegate.StencilMask _StencilMask = null;
        /// <summary>
        /// <para>control the front and back writing of individual bits in the stencil planes</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _StencilMask.</para>
        /// <para>Fullname: StencilMask</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="mask">Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.</param>
        public static void StencilMask(uint mask)
        {
            if (gl._StencilMask != null) gl._StencilMask(mask); else { }
        }
        /// <summary>
        /// <para>Fullname: StencilOp</para>
        /// </summary>
        [GLEntry("StencilOp", Category = "1.0")]
        public static GLDelegate.StencilOp _StencilOp = null;
        /// <summary>
        /// <para>set front and back stencil test actions</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _StencilOp.</para>
        /// <para>Fullname: StencilOp</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="sfail">Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP.</param>
        /// <param name="dpfail">Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP.</param>
        /// <param name="dppass">Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP.</param>
        public static void StencilOp(int fail, int zfail, int zpass)
        {
            if (gl._StencilOp != null) gl._StencilOp(fail, zfail, zpass); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord1d</para>
        /// </summary>
        [GLEntry("TexCoord1d", Category = "1.0")]
        public static GLDelegate.TexCoord1d _TexCoord1d = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord1d.</para>
        /// <para>Fullname: TexCoord1d</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord1d(double s)
        {
            if (gl._TexCoord1d != null) gl._TexCoord1d(s); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord1dv</para>
        /// </summary>
        [GLEntry("TexCoord1dv", Category = "1.0")]
        public static GLDelegate.TexCoord1dv _TexCoord1dv = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord1dv.</para>
        /// <para>Fullname: TexCoord1dv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord1dv(double[] v)
        {
            if (gl._TexCoord1dv != null) gl._TexCoord1dv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord1dv</para>
        /// </summary>
        [GLEntry("TexCoord1dv", Category = "1.0")]
        public static GLDelegate.TexCoord1dv_double _TexCoord1dv_double = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord1dv_double.</para>
        /// <para>Fullname: TexCoord1dv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord1dv(ref double v)
        {
            if (gl._TexCoord1dv_double != null) gl._TexCoord1dv_double(ref v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord1f</para>
        /// </summary>
        [GLEntry("TexCoord1f", Category = "1.0")]
        public static GLDelegate.TexCoord1f _TexCoord1f = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord1f.</para>
        /// <para>Fullname: TexCoord1f</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord1f(float s)
        {
            if (gl._TexCoord1f != null) gl._TexCoord1f(s); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord1fv</para>
        /// </summary>
        [GLEntry("TexCoord1fv", Category = "1.0")]
        public static GLDelegate.TexCoord1fv _TexCoord1fv = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord1fv.</para>
        /// <para>Fullname: TexCoord1fv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord1fv(float[] v)
        {
            if (gl._TexCoord1fv != null) gl._TexCoord1fv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord1fv</para>
        /// </summary>
        [GLEntry("TexCoord1fv", Category = "1.0")]
        public static GLDelegate.TexCoord1fv_float _TexCoord1fv_float = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord1fv_float.</para>
        /// <para>Fullname: TexCoord1fv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord1fv(ref float v)
        {
            if (gl._TexCoord1fv_float != null) gl._TexCoord1fv_float(ref v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord1i</para>
        /// </summary>
        [GLEntry("TexCoord1i", Category = "1.0")]
        public static GLDelegate.TexCoord1i _TexCoord1i = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord1i.</para>
        /// <para>Fullname: TexCoord1i</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord1i(int s)
        {
            if (gl._TexCoord1i != null) gl._TexCoord1i(s); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord1iv</para>
        /// </summary>
        [GLEntry("TexCoord1iv", Category = "1.0")]
        public static GLDelegate.TexCoord1iv _TexCoord1iv = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord1iv.</para>
        /// <para>Fullname: TexCoord1iv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord1iv(int[] v)
        {
            if (gl._TexCoord1iv != null) gl._TexCoord1iv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord1iv</para>
        /// </summary>
        [GLEntry("TexCoord1iv", Category = "1.0")]
        public static GLDelegate.TexCoord1iv_int _TexCoord1iv_int = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord1iv_int.</para>
        /// <para>Fullname: TexCoord1iv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord1iv(ref int v)
        {
            if (gl._TexCoord1iv_int != null) gl._TexCoord1iv_int(ref v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord1s</para>
        /// </summary>
        [GLEntry("TexCoord1s", Category = "1.0")]
        public static GLDelegate.TexCoord1s _TexCoord1s = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord1s.</para>
        /// <para>Fullname: TexCoord1s</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord1s(short s)
        {
            if (gl._TexCoord1s != null) gl._TexCoord1s(s); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord1sv</para>
        /// </summary>
        [GLEntry("TexCoord1sv", Category = "1.0")]
        public static GLDelegate.TexCoord1sv _TexCoord1sv = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord1sv.</para>
        /// <para>Fullname: TexCoord1sv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord1sv(short[] v)
        {
            if (gl._TexCoord1sv != null) gl._TexCoord1sv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2d</para>
        /// </summary>
        [GLEntry("TexCoord2d", Category = "1.0")]
        public static GLDelegate.TexCoord2d _TexCoord2d = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2d.</para>
        /// <para>Fullname: TexCoord2d</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord2d(double s, double t)
        {
            if (gl._TexCoord2d != null) gl._TexCoord2d(s, t); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2dv</para>
        /// </summary>
        [GLEntry("TexCoord2dv", Category = "1.0")]
        public static GLDelegate.TexCoord2dv _TexCoord2dv = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2dv.</para>
        /// <para>Fullname: TexCoord2dv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord2dv(double[] v)
        {
            if (gl._TexCoord2dv != null) gl._TexCoord2dv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2f</para>
        /// </summary>
        [GLEntry("TexCoord2f", Category = "1.0")]
        public static GLDelegate.TexCoord2f _TexCoord2f = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2f.</para>
        /// <para>Fullname: TexCoord2f</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord2f(float s, float t)
        {
            if (gl._TexCoord2f != null) gl._TexCoord2f(s, t); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2fv</para>
        /// </summary>
        [GLEntry("TexCoord2fv", Category = "1.0")]
        public static GLDelegate.TexCoord2fv _TexCoord2fv = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2fv.</para>
        /// <para>Fullname: TexCoord2fv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord2fv(float[] v)
        {
            if (gl._TexCoord2fv != null) gl._TexCoord2fv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2i</para>
        /// </summary>
        [GLEntry("TexCoord2i", Category = "1.0")]
        public static GLDelegate.TexCoord2i _TexCoord2i = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2i.</para>
        /// <para>Fullname: TexCoord2i</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord2i(int s, int t)
        {
            if (gl._TexCoord2i != null) gl._TexCoord2i(s, t); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2iv</para>
        /// </summary>
        [GLEntry("TexCoord2iv", Category = "1.0")]
        public static GLDelegate.TexCoord2iv _TexCoord2iv = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2iv.</para>
        /// <para>Fullname: TexCoord2iv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord2iv(int[] v)
        {
            if (gl._TexCoord2iv != null) gl._TexCoord2iv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2s</para>
        /// </summary>
        [GLEntry("TexCoord2s", Category = "1.0")]
        public static GLDelegate.TexCoord2s _TexCoord2s = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2s.</para>
        /// <para>Fullname: TexCoord2s</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord2s(short s, short t)
        {
            if (gl._TexCoord2s != null) gl._TexCoord2s(s, t); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2sv</para>
        /// </summary>
        [GLEntry("TexCoord2sv", Category = "1.0")]
        public static GLDelegate.TexCoord2sv _TexCoord2sv = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2sv.</para>
        /// <para>Fullname: TexCoord2sv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord2sv(short[] v)
        {
            if (gl._TexCoord2sv != null) gl._TexCoord2sv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord3d</para>
        /// </summary>
        [GLEntry("TexCoord3d", Category = "1.0")]
        public static GLDelegate.TexCoord3d _TexCoord3d = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord3d.</para>
        /// <para>Fullname: TexCoord3d</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord3d(double s, double t, double r)
        {
            if (gl._TexCoord3d != null) gl._TexCoord3d(s, t, r); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord3dv</para>
        /// </summary>
        [GLEntry("TexCoord3dv", Category = "1.0")]
        public static GLDelegate.TexCoord3dv _TexCoord3dv = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord3dv.</para>
        /// <para>Fullname: TexCoord3dv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord3dv(double[] v)
        {
            if (gl._TexCoord3dv != null) gl._TexCoord3dv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord3f</para>
        /// </summary>
        [GLEntry("TexCoord3f", Category = "1.0")]
        public static GLDelegate.TexCoord3f _TexCoord3f = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord3f.</para>
        /// <para>Fullname: TexCoord3f</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord3f(float s, float t, float r)
        {
            if (gl._TexCoord3f != null) gl._TexCoord3f(s, t, r); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord3fv</para>
        /// </summary>
        [GLEntry("TexCoord3fv", Category = "1.0")]
        public static GLDelegate.TexCoord3fv _TexCoord3fv = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord3fv.</para>
        /// <para>Fullname: TexCoord3fv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord3fv(float[] v)
        {
            if (gl._TexCoord3fv != null) gl._TexCoord3fv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord3i</para>
        /// </summary>
        [GLEntry("TexCoord3i", Category = "1.0")]
        public static GLDelegate.TexCoord3i _TexCoord3i = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord3i.</para>
        /// <para>Fullname: TexCoord3i</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord3i(int s, int t, int r)
        {
            if (gl._TexCoord3i != null) gl._TexCoord3i(s, t, r); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord3iv</para>
        /// </summary>
        [GLEntry("TexCoord3iv", Category = "1.0")]
        public static GLDelegate.TexCoord3iv _TexCoord3iv = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord3iv.</para>
        /// <para>Fullname: TexCoord3iv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord3iv(int[] v)
        {
            if (gl._TexCoord3iv != null) gl._TexCoord3iv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord3s</para>
        /// </summary>
        [GLEntry("TexCoord3s", Category = "1.0")]
        public static GLDelegate.TexCoord3s _TexCoord3s = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord3s.</para>
        /// <para>Fullname: TexCoord3s</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord3s(short s, short t, short r)
        {
            if (gl._TexCoord3s != null) gl._TexCoord3s(s, t, r); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord3sv</para>
        /// </summary>
        [GLEntry("TexCoord3sv", Category = "1.0")]
        public static GLDelegate.TexCoord3sv _TexCoord3sv = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord3sv.</para>
        /// <para>Fullname: TexCoord3sv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord3sv(short[] v)
        {
            if (gl._TexCoord3sv != null) gl._TexCoord3sv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord4d</para>
        /// </summary>
        [GLEntry("TexCoord4d", Category = "1.0")]
        public static GLDelegate.TexCoord4d _TexCoord4d = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord4d.</para>
        /// <para>Fullname: TexCoord4d</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord4d(double s, double t, double r, double q)
        {
            if (gl._TexCoord4d != null) gl._TexCoord4d(s, t, r, q); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord4dv</para>
        /// </summary>
        [GLEntry("TexCoord4dv", Category = "1.0")]
        public static GLDelegate.TexCoord4dv _TexCoord4dv = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord4dv.</para>
        /// <para>Fullname: TexCoord4dv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord4dv(double[] v)
        {
            if (gl._TexCoord4dv != null) gl._TexCoord4dv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord4f</para>
        /// </summary>
        [GLEntry("TexCoord4f", Category = "1.0")]
        public static GLDelegate.TexCoord4f _TexCoord4f = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord4f.</para>
        /// <para>Fullname: TexCoord4f</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord4f(float s, float t, float r, float q)
        {
            if (gl._TexCoord4f != null) gl._TexCoord4f(s, t, r, q); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord4fv</para>
        /// </summary>
        [GLEntry("TexCoord4fv", Category = "1.0")]
        public static GLDelegate.TexCoord4fv _TexCoord4fv = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord4fv.</para>
        /// <para>Fullname: TexCoord4fv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord4fv(float[] v)
        {
            if (gl._TexCoord4fv != null) gl._TexCoord4fv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord4i</para>
        /// </summary>
        [GLEntry("TexCoord4i", Category = "1.0")]
        public static GLDelegate.TexCoord4i _TexCoord4i = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord4i.</para>
        /// <para>Fullname: TexCoord4i</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord4i(int s, int t, int r, int q)
        {
            if (gl._TexCoord4i != null) gl._TexCoord4i(s, t, r, q); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord4iv</para>
        /// </summary>
        [GLEntry("TexCoord4iv", Category = "1.0")]
        public static GLDelegate.TexCoord4iv _TexCoord4iv = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord4iv.</para>
        /// <para>Fullname: TexCoord4iv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord4iv(int[] v)
        {
            if (gl._TexCoord4iv != null) gl._TexCoord4iv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord4s</para>
        /// </summary>
        [GLEntry("TexCoord4s", Category = "1.0")]
        public static GLDelegate.TexCoord4s _TexCoord4s = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord4s.</para>
        /// <para>Fullname: TexCoord4s</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord4s(short s, short t, short r, short q)
        {
            if (gl._TexCoord4s != null) gl._TexCoord4s(s, t, r, q); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord4sv</para>
        /// </summary>
        [GLEntry("TexCoord4sv", Category = "1.0")]
        public static GLDelegate.TexCoord4sv _TexCoord4sv = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord4sv.</para>
        /// <para>Fullname: TexCoord4sv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="s">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.</param>
        public static void TexCoord4sv(short[] v)
        {
            if (gl._TexCoord4sv != null) gl._TexCoord4sv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexEnvf</para>
        /// </summary>
        [GLEntry("TexEnvf", Category = "1.0")]
        public static GLDelegate.TexEnvf _TexEnvf = null;
        /// <summary>
        /// <para>set texture environment parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexEnvf.</para>
        /// <para>Fullname: TexEnvf</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.</param>
        /// <param name="param">Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE.</param>
        public static void TexEnvf(int target, int pname, float param)
        {
            if (gl._TexEnvf != null) gl._TexEnvf(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TexEnvfv</para>
        /// </summary>
        [GLEntry("TexEnvfv", Category = "1.0")]
        public static GLDelegate.TexEnvfv _TexEnvfv = null;
        /// <summary>
        /// <para>set texture environment parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexEnvfv.</para>
        /// <para>Fullname: TexEnvfv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.</param>
        /// <param name="param">Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE.</param>
        public static void TexEnvfv(int target, int pname, float[] param)
        {
            if (gl._TexEnvfv != null) gl._TexEnvfv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TexEnvi</para>
        /// </summary>
        [GLEntry("TexEnvi", Category = "1.0")]
        public static GLDelegate.TexEnvi _TexEnvi = null;
        /// <summary>
        /// <para>set texture environment parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexEnvi.</para>
        /// <para>Fullname: TexEnvi</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.</param>
        /// <param name="param">Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE.</param>
        public static void TexEnvi(int target, int pname, int param)
        {
            if (gl._TexEnvi != null) gl._TexEnvi(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TexEnviv</para>
        /// </summary>
        [GLEntry("TexEnviv", Category = "1.0")]
        public static GLDelegate.TexEnviv _TexEnviv = null;
        /// <summary>
        /// <para>set texture environment parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexEnviv.</para>
        /// <para>Fullname: TexEnviv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.</param>
        /// <param name="param">Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE.</param>
        public static void TexEnviv(int target, int pname, int[] param)
        {
            if (gl._TexEnviv != null) gl._TexEnviv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TexGend</para>
        /// </summary>
        [GLEntry("TexGend", Category = "1.0")]
        public static GLDelegate.TexGend _TexGend = null;
        /// <summary>
        /// <para>control the generation of texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexGend.</para>
        /// <para>Fullname: TexGend</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="coord">Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.</param>
        /// <param name="pname">Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.</param>
        /// <param name="param">Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.</param>
        public static void TexGend(int coord, int pname, double param)
        {
            if (gl._TexGend != null) gl._TexGend(coord, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TexGendv</para>
        /// </summary>
        [GLEntry("TexGendv", Category = "1.0")]
        public static GLDelegate.TexGendv _TexGendv = null;
        /// <summary>
        /// <para>control the generation of texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexGendv.</para>
        /// <para>Fullname: TexGendv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="coord">Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.</param>
        /// <param name="pname">Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.</param>
        /// <param name="param">Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.</param>
        public static void TexGendv(int coord, int pname, double[] param)
        {
            if (gl._TexGendv != null) gl._TexGendv(coord, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TexGenf</para>
        /// </summary>
        [GLEntry("TexGenf", Category = "1.0")]
        public static GLDelegate.TexGenf _TexGenf = null;
        /// <summary>
        /// <para>control the generation of texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexGenf.</para>
        /// <para>Fullname: TexGenf</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="coord">Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.</param>
        /// <param name="pname">Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.</param>
        /// <param name="param">Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.</param>
        public static void TexGenf(int coord, int pname, float param)
        {
            if (gl._TexGenf != null) gl._TexGenf(coord, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TexGenfv</para>
        /// </summary>
        [GLEntry("TexGenfv", Category = "1.0")]
        public static GLDelegate.TexGenfv _TexGenfv = null;
        /// <summary>
        /// <para>control the generation of texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexGenfv.</para>
        /// <para>Fullname: TexGenfv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="coord">Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.</param>
        /// <param name="pname">Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.</param>
        /// <param name="param">Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.</param>
        public static void TexGenfv(int coord, int pname, float[] param)
        {
            if (gl._TexGenfv != null) gl._TexGenfv(coord, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TexGeni</para>
        /// </summary>
        [GLEntry("TexGeni", Category = "1.0")]
        public static GLDelegate.TexGeni _TexGeni = null;
        /// <summary>
        /// <para>control the generation of texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexGeni.</para>
        /// <para>Fullname: TexGeni</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="coord">Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.</param>
        /// <param name="pname">Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.</param>
        /// <param name="param">Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.</param>
        public static void TexGeni(int coord, int pname, int param)
        {
            if (gl._TexGeni != null) gl._TexGeni(coord, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TexGeniv</para>
        /// </summary>
        [GLEntry("TexGeniv", Category = "1.0")]
        public static GLDelegate.TexGeniv _TexGeniv = null;
        /// <summary>
        /// <para>control the generation of texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexGeniv.</para>
        /// <para>Fullname: TexGeniv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="coord">Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.</param>
        /// <param name="pname">Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.</param>
        /// <param name="param">Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.</param>
        public static void TexGeniv(int coord, int pname, int[] param)
        {
            if (gl._TexGeniv != null) gl._TexGeniv(coord, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TexImage1D</para>
        /// </summary>
        [GLEntry("TexImage1D", Category = "1.0")]
        public static GLDelegate.TexImage1D _TexImage1D = null;
        /// <summary>
        /// <para>specify a one-dimensional texture image</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexImage1D.</para>
        /// <para>Fullname: TexImage1D</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="internalFormat">Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.</param>
        /// <param name="width">Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide. The height of the 1D texture image is 1.</param>
        /// <param name="border">This value must be 0.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="data">Specifies a pointer to the image data in memory.</param>
        public static void TexImage1D(int target, int level, int internalformat, int width, int border, int format, int type, IntPtr pixels)
        {
            if (gl._TexImage1D != null) gl._TexImage1D(target, level, internalformat, width, border, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>specify a one-dimensional texture image</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexImage1D.</para>
        /// <para>Fullname: TexImage1D</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="internalFormat">Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.</param>
        /// <param name="width">Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide. The height of the 1D texture image is 1.</param>
        /// <param name="border">This value must be 0.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="data">Specifies a pointer to the image data in memory.</param>
        public static void TexImage1D(int target, int level, int internalformat, int width, int border, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._TexImage1D != null) gl._TexImage1D(target, level, internalformat, width, border, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: TexImage2D</para>
        /// </summary>
        [GLEntry("TexImage2D", Category = "1.0")]
        public static GLDelegate.TexImage2D _TexImage2D = null;
        /// <summary>
        /// <para>specify a two-dimensional texture image</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexImage2D.</para>
        /// <para>Fullname: TexImage2D</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.</param>
        /// <param name="internalFormat">Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.</param>
        /// <param name="width">Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.</param>
        /// <param name="height">Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.</param>
        /// <param name="border">This value must be 0.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="data">Specifies a pointer to the image data in memory.</param>
        public static void TexImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, IntPtr pixels)
        {
            if (gl._TexImage2D != null) gl._TexImage2D(target, level, internalformat, width, height, border, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>specify a two-dimensional texture image</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexImage2D.</para>
        /// <para>Fullname: TexImage2D</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.</param>
        /// <param name="internalFormat">Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.</param>
        /// <param name="width">Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.</param>
        /// <param name="height">Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.</param>
        /// <param name="border">This value must be 0.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="data">Specifies a pointer to the image data in memory.</param>
        public static void TexImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._TexImage2D != null) gl._TexImage2D(target, level, internalformat, width, height, border, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>specify a two-dimensional texture image</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="internalFormat">Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.</param>
        /// <param name="border">Specifies the width of the border. Must be either 0 or 1.</param>
        /// <param name="bmp">Instance of Bitmap class.</param>
        //public static void TexImage2D(int target, int level, Bitmap bmp)
        //{
        //    BitmapData data = bmp.LockBits(new Rectangle(0, 0, bmp.Size.Width, bmp.Size.Height), ImageLockMode.ReadOnly, PixelFormat.Format32bppArgb);
        //    if (_TexImage2D != null) _TexImage2D(target, level, GL.RGBA, bmp.Size.Width, bmp.Size.Height, 0, GL.BGRA, GL.UNSIGNED_BYTE, data.Scan0);
        //    bmp.UnlockBits(data);
        //}
        /// <summary>
        /// <para>specify a two-dimensional texture image</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="internalFormat">Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.</param>
        /// <param name="border">Specifies the width of the border. Must be either 0 or 1.</param>
        /// <param name="filename">Filename of bitmap.</param>
        //public static void TexImage2D(int target, int level, string filename)
        //{
        //    using (Bitmap bmp = new Bitmap(filename))
        //    {
        //        TexImage2D(target, level, bmp);
        //    }
        //}
        /*/// <summary>
        /// <para>specify a two-dimensional texture image</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="internalFormat">Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.</param>
        /// <param name="width">Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2n+2⁡border for some integer n. All implementations support texture images that are at least 64 texels wide.</param>
        /// <param name="height">Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2m+2⁡border for some integer m. All implementations support texture images that are at least 64 texels high.</param>
        /// <param name="border">Specifies the width of the border. Must be either 0 or 1.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.</param>
        /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="data">Array of data.</param>
            public static void TexImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, Array data)
            {
                GCHandle h = GCHandle.Alloc(data, GCHandleType.Pinned);
                try
                    {
                    if(_TexImage2D!=null) _TexImage2D(target, level, internalformat, width, height, border, format, type, h.AddrOfPinnedObject());
                    }
                    finally
                    {
                    h.Free();
                    }
            }
        */
        /// <summary>
        /// <para>Fullname: TexParameterf</para>
        /// </summary>
        [GLEntry("TexParameterf", Category = "1.0")]
        public static GLDelegate.TexParameterf _TexParameterf = null;
        /// <summary>
        /// <para>set texture parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexParameterf.</para>
        /// <para>Fullname: TexParameterf</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="target">Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">Specifies the value of pname.</param>
        public static void TexParameterf(int target, int pname, float param)
        {
            if (gl._TexParameterf != null) gl._TexParameterf(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TexParameterfv</para>
        /// </summary>
        [GLEntry("TexParameterfv", Category = "1.0")]
        public static GLDelegate.TexParameterfv _TexParameterfv = null;
        /// <summary>
        /// <para>set texture parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexParameterfv.</para>
        /// <para>Fullname: TexParameterfv</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="target">Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">Specifies the value of pname.</param>
        public static void TexParameterfv(int target, int pname, float[] param)
        {
            if (gl._TexParameterfv != null) gl._TexParameterfv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TexParameteri</para>
        /// </summary>
        [GLEntry("TexParameteri", Category = "1.0")]
        public static GLDelegate.TexParameteri _TexParameteri = null;
        /// <summary>
        /// <para>set texture parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexParameteri.</para>
        /// <para>Fullname: TexParameteri</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="target">Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">Specifies the value of pname.</param>
        public static void TexParameteri(int target, int pname, int param)
        {
            if (gl._TexParameteri != null) gl._TexParameteri(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TexParameteriv</para>
        /// </summary>
        [GLEntry("TexParameteriv", Category = "1.0")]
        public static GLDelegate.TexParameteriv _TexParameteriv = null;
        /// <summary>
        /// <para>set texture parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexParameteriv.</para>
        /// <para>Fullname: TexParameteriv</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="target">Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">Specifies the value of pname.</param>
        public static void TexParameteriv(int target, int pname, int[] param)
        {
            if (gl._TexParameteriv != null) gl._TexParameteriv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: Translated</para>
        /// </summary>
        [GLEntry("Translated", Category = "1.0")]
        public static GLDelegate.Translated _Translated = null;
        /// <summary>
        /// <para>multiply the current matrix by a translation matrix</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Translated.</para>
        /// <para>Fullname: Translated</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, and z coordinates of a translation vector.</param>
        /// <param name="y">Specify the x, y, and z coordinates of a translation vector.</param>
        /// <param name="z">Specify the x, y, and z coordinates of a translation vector.</param>
        public static void Translated(double x, double y, double z)
        {
            if (gl._Translated != null) gl._Translated(x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: Translatef</para>
        /// </summary>
        [GLEntry("Translatef", Category = "1.0")]
        public static GLDelegate.Translatef _Translatef = null;
        /// <summary>
        /// <para>multiply the current matrix by a translation matrix</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Translatef.</para>
        /// <para>Fullname: Translatef</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, and z coordinates of a translation vector.</param>
        /// <param name="y">Specify the x, y, and z coordinates of a translation vector.</param>
        /// <param name="z">Specify the x, y, and z coordinates of a translation vector.</param>
        public static void Translatef(float x, float y, float z)
        {
            if (gl._Translatef != null) gl._Translatef(x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex2d</para>
        /// </summary>
        [GLEntry("Vertex2d", Category = "1.0")]
        public static GLDelegate.Vertex2d _Vertex2d = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex2d.</para>
        /// <para>Fullname: Vertex2d</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex2d(double x, double y)
        {
            if (gl._Vertex2d != null) gl._Vertex2d(x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex2dv</para>
        /// </summary>
        [GLEntry("Vertex2dv", Category = "1.0")]
        public static GLDelegate.Vertex2dv _Vertex2dv = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex2dv.</para>
        /// <para>Fullname: Vertex2dv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex2dv(double[] v)
        {
            if (gl._Vertex2dv != null) gl._Vertex2dv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex2f</para>
        /// </summary>
        [GLEntry("Vertex2f", Category = "1.0")]
        public static GLDelegate.Vertex2f _Vertex2f = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex2f.</para>
        /// <para>Fullname: Vertex2f</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex2f(float x, float y)
        {
            if (gl._Vertex2f != null) gl._Vertex2f(x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex2fv</para>
        /// </summary>
        [GLEntry("Vertex2fv", Category = "1.0")]
        public static GLDelegate.Vertex2fv _Vertex2fv = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex2fv.</para>
        /// <para>Fullname: Vertex2fv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex2fv(float[] v)
        {
            if (gl._Vertex2fv != null) gl._Vertex2fv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex2i</para>
        /// </summary>
        [GLEntry("Vertex2i", Category = "1.0")]
        public static GLDelegate.Vertex2i _Vertex2i = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex2i.</para>
        /// <para>Fullname: Vertex2i</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex2i(int x, int y)
        {
            if (gl._Vertex2i != null) gl._Vertex2i(x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex2iv</para>
        /// </summary>
        [GLEntry("Vertex2iv", Category = "1.0")]
        public static GLDelegate.Vertex2iv _Vertex2iv = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex2iv.</para>
        /// <para>Fullname: Vertex2iv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex2iv(int[] v)
        {
            if (gl._Vertex2iv != null) gl._Vertex2iv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex2s</para>
        /// </summary>
        [GLEntry("Vertex2s", Category = "1.0")]
        public static GLDelegate.Vertex2s _Vertex2s = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex2s.</para>
        /// <para>Fullname: Vertex2s</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex2s(short x, short y)
        {
            if (gl._Vertex2s != null) gl._Vertex2s(x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex2sv</para>
        /// </summary>
        [GLEntry("Vertex2sv", Category = "1.0")]
        public static GLDelegate.Vertex2sv _Vertex2sv = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex2sv.</para>
        /// <para>Fullname: Vertex2sv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex2sv(short[] v)
        {
            if (gl._Vertex2sv != null) gl._Vertex2sv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex3d</para>
        /// </summary>
        [GLEntry("Vertex3d", Category = "1.0")]
        public static GLDelegate.Vertex3d _Vertex3d = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex3d.</para>
        /// <para>Fullname: Vertex3d</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex3d(double x, double y, double z)
        {
            if (gl._Vertex3d != null) gl._Vertex3d(x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex3dv</para>
        /// </summary>
        [GLEntry("Vertex3dv", Category = "1.0")]
        public static GLDelegate.Vertex3dv _Vertex3dv = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex3dv.</para>
        /// <para>Fullname: Vertex3dv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex3dv(double[] v)
        {
            if (gl._Vertex3dv != null) gl._Vertex3dv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex3f</para>
        /// </summary>
        [GLEntry("Vertex3f", Category = "1.0")]
        public static GLDelegate.Vertex3f _Vertex3f = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex3f.</para>
        /// <para>Fullname: Vertex3f</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex3f(float x, float y, float z)
        {
            if (gl._Vertex3f != null) gl._Vertex3f(x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex3fv</para>
        /// </summary>
        [GLEntry("Vertex3fv", Category = "1.0")]
        public static GLDelegate.Vertex3fv _Vertex3fv = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex3fv.</para>
        /// <para>Fullname: Vertex3fv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex3fv(float[] v)
        {
            if (gl._Vertex3fv != null) gl._Vertex3fv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex3i</para>
        /// </summary>
        [GLEntry("Vertex3i", Category = "1.0")]
        public static GLDelegate.Vertex3i _Vertex3i = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex3i.</para>
        /// <para>Fullname: Vertex3i</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex3i(int x, int y, int z)
        {
            if (gl._Vertex3i != null) gl._Vertex3i(x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex3iv</para>
        /// </summary>
        [GLEntry("Vertex3iv", Category = "1.0")]
        public static GLDelegate.Vertex3iv _Vertex3iv = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex3iv.</para>
        /// <para>Fullname: Vertex3iv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex3iv(int[] v)
        {
            if (gl._Vertex3iv != null) gl._Vertex3iv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex3s</para>
        /// </summary>
        [GLEntry("Vertex3s", Category = "1.0")]
        public static GLDelegate.Vertex3s _Vertex3s = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex3s.</para>
        /// <para>Fullname: Vertex3s</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex3s(short x, short y, short z)
        {
            if (gl._Vertex3s != null) gl._Vertex3s(x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex3sv</para>
        /// </summary>
        [GLEntry("Vertex3sv", Category = "1.0")]
        public static GLDelegate.Vertex3sv _Vertex3sv = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex3sv.</para>
        /// <para>Fullname: Vertex3sv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex3sv(short[] v)
        {
            if (gl._Vertex3sv != null) gl._Vertex3sv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex4d</para>
        /// </summary>
        [GLEntry("Vertex4d", Category = "1.0")]
        public static GLDelegate.Vertex4d _Vertex4d = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex4d.</para>
        /// <para>Fullname: Vertex4d</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex4d(double x, double y, double z, double w)
        {
            if (gl._Vertex4d != null) gl._Vertex4d(x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex4dv</para>
        /// </summary>
        [GLEntry("Vertex4dv", Category = "1.0")]
        public static GLDelegate.Vertex4dv _Vertex4dv = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex4dv.</para>
        /// <para>Fullname: Vertex4dv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex4dv(double[] v)
        {
            if (gl._Vertex4dv != null) gl._Vertex4dv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex4f</para>
        /// </summary>
        [GLEntry("Vertex4f", Category = "1.0")]
        public static GLDelegate.Vertex4f _Vertex4f = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex4f.</para>
        /// <para>Fullname: Vertex4f</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex4f(float x, float y, float z, float w)
        {
            if (gl._Vertex4f != null) gl._Vertex4f(x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex4fv</para>
        /// </summary>
        [GLEntry("Vertex4fv", Category = "1.0")]
        public static GLDelegate.Vertex4fv _Vertex4fv = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex4fv.</para>
        /// <para>Fullname: Vertex4fv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex4fv(float[] v)
        {
            if (gl._Vertex4fv != null) gl._Vertex4fv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex4i</para>
        /// </summary>
        [GLEntry("Vertex4i", Category = "1.0")]
        public static GLDelegate.Vertex4i _Vertex4i = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex4i.</para>
        /// <para>Fullname: Vertex4i</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex4i(int x, int y, int z, int w)
        {
            if (gl._Vertex4i != null) gl._Vertex4i(x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex4iv</para>
        /// </summary>
        [GLEntry("Vertex4iv", Category = "1.0")]
        public static GLDelegate.Vertex4iv _Vertex4iv = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex4iv.</para>
        /// <para>Fullname: Vertex4iv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex4iv(int[] v)
        {
            if (gl._Vertex4iv != null) gl._Vertex4iv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex4s</para>
        /// </summary>
        [GLEntry("Vertex4s", Category = "1.0")]
        public static GLDelegate.Vertex4s _Vertex4s = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex4s.</para>
        /// <para>Fullname: Vertex4s</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex4s(short x, short y, short z, short w)
        {
            if (gl._Vertex4s != null) gl._Vertex4s(x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex4sv</para>
        /// </summary>
        [GLEntry("Vertex4sv", Category = "1.0")]
        public static GLDelegate.Vertex4sv _Vertex4sv = null;
        /// <summary>
        /// <para>specify a vertex</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex4sv.</para>
        /// <para>Fullname: Vertex4sv</para>
        /// <para>Extensions: VERSION_1_0_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="y">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="z">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        /// <param name="w">Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.</param>
        public static void Vertex4sv(short[] v)
        {
            if (gl._Vertex4sv != null) gl._Vertex4sv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Viewport</para>
        /// </summary>
        [GLEntry("Viewport", Category = "1.0")]
        public static GLDelegate.Viewport _Viewport = null;
        /// <summary>
        /// <para>set the viewport</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Viewport.</para>
        /// <para>Fullname: Viewport</para>
        /// <para>Extensions: VERSION_1_0</para>
        /// </summary>
        /// <param name="x">Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).</param>
        /// <param name="y">Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).</param>
        /// <param name="width">Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.</param>
        /// <param name="height">Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.</param>
        public static void Viewport(int x, int y, int width, int height)
        {
            if (gl._Viewport != null) gl._Viewport(x, y, width, height); else { }
        }
        /// <summary>
        /// <para>Fullname: AreTexturesResident</para>
        /// </summary>
        [GLEntry("AreTexturesResident", Category = "1.1", Alias = "AreTexturesResidentEXT ")]
        public static GLDelegate.AreTexturesResident _AreTexturesResident = null;
        public static GLDelegate.AreTexturesResident AreTexturesResidentEXT = AreTexturesResident;
        /// <summary>
        /// <para>determine if textures are loaded in texture memory</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _AreTexturesResident.</para>
        /// <para>Fullname: AreTexturesResident</para>
        /// <para>Aliases: AreTexturesResidentEXT, </para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED EXT_texture_object</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="n">Specifies the number of textures to be queried.</param>
        /// <param name="textures">Specifies an array containing the names of the textures to be queried.</param>
        /// <param name="residences">Specifies an array in which the texture residence status is returned. The residence status of a texture named by an element of textures is returned in the corresponding element of residences.</param>
        public static bool AreTexturesResident(int n, uint[] textures, bool[] residences)
        {
            if (gl._AreTexturesResident != null) return gl._AreTexturesResident(n, textures, residences);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: AreTexturesResident</para>
        /// </summary>
        [GLEntry("AreTexturesResident", Category = "1.1", Alias = "AreTexturesResidentEXT ")]
        public static GLDelegate.AreTexturesResident_uint_bool _AreTexturesResident_uint_bool = null;
        /// <summary>
        /// <para>determine if textures are loaded in texture memory</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _AreTexturesResident_uint_bool.</para>
        /// <para>Fullname: AreTexturesResident</para>
        /// <para>Aliases: AreTexturesResidentEXT, </para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED EXT_texture_object</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="n">Specifies the number of textures to be queried.</param>
        /// <param name="textures">Specifies an array containing the names of the textures to be queried.</param>
        /// <param name="residences">Specifies an array in which the texture residence status is returned. The residence status of a texture named by an element of textures is returned in the corresponding element of residences.</param>
        public static bool AreTexturesResident(int n, ref uint textures, out bool residences)
        {
            if (gl._AreTexturesResident_uint_bool != null) return gl._AreTexturesResident_uint_bool(n, ref textures, out residences);
            else { residences = new bool(); return false; }
        }
        /// <summary>
        /// <para>Fullname: ArrayElement</para>
        /// </summary>
        [GLEntry("ArrayElement", Category = "1.1", Alias = "ArrayElementEXT ")]
        public static GLDelegate.ArrayElement _ArrayElement = null;
        public static GLDelegate.ArrayElement ArrayElementEXT = ArrayElement;
        /// <summary>
        /// <para>render a vertex using the specified vertex array element</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ArrayElement.</para>
        /// <para>Fullname: ArrayElement</para>
        /// <para>Aliases: ArrayElementEXT, </para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED EXT_vertex_array</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="i">Specifies an index into the enabled vertex data arrays.</param>
        public static void ArrayElement(int i)
        {
            if (gl._ArrayElement != null) gl._ArrayElement(i); else { }
        }
        /// <summary>
        /// <para>Fullname: BindTexture</para>
        /// </summary>
        [GLEntry("BindTexture", Category = "1.1", Alias = "BindTextureEXT ")]
        public static GLDelegate.BindTexture _BindTexture = null;
        public static GLDelegate.BindTexture BindTextureEXT = BindTexture;
        /// <summary>
        /// <para>bind a named texture to a texturing target</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindTexture.</para>
        /// <para>Fullname: BindTexture</para>
        /// <para>Aliases: BindTextureEXT, </para>
        /// <para>Extensions: VERSION_1_1 EXT_texture_object</para>
        /// </summary>
        /// <param name="target">Specifies the target to which the texture is bound. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.</param>
        /// <param name="texture">Specifies the name of a texture.</param>
        public static void BindTexture(int target, uint texture)
        {
            if (gl._BindTexture != null) gl._BindTexture(target, texture); else { }
        }
        /// <summary>
        /// <para>Fullname: ColorPointer</para>
        /// </summary>
        [GLEntry("ColorPointer", Category = "1.1")]
        public static GLDelegate.ColorPointer _ColorPointer = null;
        /// <summary>
        /// <para>define an array of colors</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorPointer.</para>
        /// <para>Fullname: ColorPointer</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="size">Specifies the number of components per color. Must be 3 or 4. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a pointer to the first component of the first color element in the array. The initial value is 0.</param>
        public static void ColorPointer(int size, int type, int stride, IntPtr pointer)
        {
            if (gl._ColorPointer != null) gl._ColorPointer(size, type, stride, pointer); else { }
        }
        /// <summary>
        /// <para>define an array of colors</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorPointer.</para>
        /// <para>Fullname: ColorPointer</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="size">Specifies the number of components per color. Must be 3 or 4. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a pointer to the first component of the first color element in the array. The initial value is 0.</param>
        public static void ColorPointer(int size, int type, int stride, Array pointer)
        {
            GCHandle h = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try { if (gl._ColorPointer != null) gl._ColorPointer(size, type, stride, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: CopyTexImage1D</para>
        /// </summary>
        [GLEntry("CopyTexImage1D", Category = "1.1", Alias = "CopyTexImage1DEXT ")]
        public static GLDelegate.CopyTexImage1D _CopyTexImage1D = null;
        public static GLDelegate.CopyTexImage1D CopyTexImage1DEXT = CopyTexImage1D;
        /// <summary>
        /// <para>copy pixels into a 1D texture image</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyTexImage1D.</para>
        /// <para>Fullname: CopyTexImage1D</para>
        /// <para>Aliases: CopyTexImage1DEXT, </para>
        /// <para>Extensions: VERSION_1_1 EXT_copy_texture</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="internalformat">Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.</param>
        /// <param name="x">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture image. Must be 0 or 2n+2⁡border for some integer n. The height of the texture image is 1.</param>
        /// <param name="border">Specifies the width of the border. Must be either 0 or 1.</param>
        public static void CopyTexImage1D(int target, int level, int internalformat, int x, int y, int width, int border)
        {
            if (gl._CopyTexImage1D != null) gl._CopyTexImage1D(target, level, internalformat, x, y, width, border); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyTexImage2D</para>
        /// </summary>
        [GLEntry("CopyTexImage2D", Category = "1.1", Alias = "CopyTexImage2DEXT ")]
        public static GLDelegate.CopyTexImage2D _CopyTexImage2D = null;
        public static GLDelegate.CopyTexImage2D CopyTexImage2DEXT = CopyTexImage2D;
        /// <summary>
        /// <para>copy pixels into a 2D texture image</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyTexImage2D.</para>
        /// <para>Fullname: CopyTexImage2D</para>
        /// <para>Aliases: CopyTexImage2DEXT, </para>
        /// <para>Extensions: VERSION_1_1 EXT_copy_texture</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="internalformat">Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture image. Must be 0 or 2n+2⁡border for some integer n.</param>
        /// <param name="height">Specifies the height of the texture image. Must be 0 or 2m+2⁡border for some integer m.</param>
        /// <param name="border">Specifies the width of the border. Must be either 0 or 1.</param>
        public static void CopyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border)
        {
            if (gl._CopyTexImage2D != null) gl._CopyTexImage2D(target, level, internalformat, x, y, width, height, border); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyTexSubImage1D</para>
        /// </summary>
        [GLEntry("CopyTexSubImage1D", Category = "1.1", Alias = "CopyTexSubImage1DEXT ")]
        public static GLDelegate.CopyTexSubImage1D _CopyTexSubImage1D = null;
        public static GLDelegate.CopyTexSubImage1D CopyTexSubImage1DEXT = CopyTexSubImage1D;
        /// <summary>
        /// <para>copy a one-dimensional texture subimage</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyTexSubImage1D.</para>
        /// <para>Fullname: CopyTexSubImage1D</para>
        /// <para>Aliases: CopyTexSubImage1DEXT, </para>
        /// <para>Extensions: VERSION_1_1 EXT_copy_texture</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies the texel offset within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        public static void CopyTexSubImage1D(int target, int level, int xoffset, int x, int y, int width)
        {
            if (gl._CopyTexSubImage1D != null) gl._CopyTexSubImage1D(target, level, xoffset, x, y, width); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyTexSubImage2D</para>
        /// </summary>
        [GLEntry("CopyTexSubImage2D", Category = "1.1", Alias = "CopyTexSubImage2DEXT ")]
        public static GLDelegate.CopyTexSubImage2D _CopyTexSubImage2D = null;
        public static GLDelegate.CopyTexSubImage2D CopyTexSubImage2DEXT = CopyTexSubImage2D;
        /// <summary>
        /// <para>copy a two-dimensional texture subimage</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyTexSubImage2D.</para>
        /// <para>Fullname: CopyTexSubImage2D</para>
        /// <para>Aliases: CopyTexSubImage2DEXT, </para>
        /// <para>Extensions: VERSION_1_1 EXT_copy_texture</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        public static void CopyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
        {
            if (gl._CopyTexSubImage2D != null) gl._CopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteTextures</para>
        /// </summary>
        [GLEntry("DeleteTextures", Category = "1.1", Alias = "DeleteTexturesEXT ")]
        public static GLDelegate.DeleteTextures_uint _DeleteTextures_uint = null;
        /// <summary>
        /// <para>delete named textures</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteTextures_uint.</para>
        /// <para>Fullname: DeleteTextures</para>
        /// <para>Aliases: DeleteTexturesEXT, </para>
        /// <para>Extensions: VERSION_1_1 EXT_texture_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of textures to be deleted.</param>
        /// <param name="textures">Specifies an array of textures to be deleted.</param>
        public static void DeleteTextures(int n, ref uint textures)
        {
            if (gl._DeleteTextures_uint != null) gl._DeleteTextures_uint(n, ref textures); else { }
        }
        /// <summary>
        /// <para>delete named textures</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteTextures.</para>
        /// <para>Fullname: DeleteTextures</para>
        /// <para>Aliases: DeleteTexturesEXT, </para>
        /// <para>Extensions: VERSION_1_1 EXT_texture_object</para>
        /// </summary>
        /// <param name="texture">Specifies an array of textures to be deleted.</param>
        public static void DeleteTexture(uint texture)
        {
            if (gl._DeleteTextures != null) gl._DeleteTextures(1, new uint[] { texture });
        }
        /// <summary>
        /// <para>Fullname: DeleteTextures</para>
        /// </summary>
        [GLEntry("DeleteTextures", Category = "1.1", Alias = "DeleteTexturesEXT ")]
        public static GLDelegate.DeleteTextures _DeleteTextures = null;
        public static GLDelegate.DeleteTextures DeleteTexturesEXT = DeleteTextures;
        /// <summary>
        /// <para>delete named textures</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteTextures.</para>
        /// <para>Fullname: DeleteTextures</para>
        /// <para>Aliases: DeleteTexturesEXT, </para>
        /// <para>Extensions: VERSION_1_1 EXT_texture_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of textures to be deleted.</param>
        /// <param name="textures">Specifies an array of textures to be deleted.</param>
        public static void DeleteTextures(int n, uint[] textures)
        {
            if (gl._DeleteTextures != null) gl._DeleteTextures(n, textures); else { }
        }
        /// <summary>
        /// <para>Fullname: DisableClientState</para>
        /// </summary>
        [GLEntry("DisableClientState", Category = "1.1")]
        public static GLDelegate.DisableClientState _DisableClientState = null;
        /// <summary>
        /// <para>enable or disable client-side capability</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DisableClientState.</para>
        /// <para>Fullname: DisableClientState</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="cap">Specifies the capability to enable. Symbolic constants GL_COLOR_ARRAY, GL_EDGE_FLAG_ARRAY, GL_FOG_COORD_ARRAY, GL_INDEX_ARRAY, GL_NORMAL_ARRAY, GL_SECONDARY_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY, and GL_VERTEX_ARRAY are accepted.</param>
        public static void DisableClientState(int array)
        {
            if (gl._DisableClientState != null) gl._DisableClientState(array); else { }
        }
        /// <summary>
        /// <para>Fullname: DrawArrays</para>
        /// </summary>
        [GLEntry("DrawArrays", Category = "1.1", Alias = "DrawArraysEXT ")]
        public static GLDelegate.DrawArrays _DrawArrays = null;
        public static GLDelegate.DrawArrays DrawArraysEXT = DrawArrays;
        /// <summary>
        /// <para>render primitives from array data</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawArrays.</para>
        /// <para>Fullname: DrawArrays</para>
        /// <para>Aliases: DrawArraysEXT, </para>
        /// <para>Extensions: VERSION_1_1 EXT_vertex_array</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="first">Specifies the starting index in the enabled arrays.</param>
        /// <param name="count">Specifies the number of indices to be rendered.</param>
        public static void DrawArrays(int mode, int first, int count)
        {
            if (gl._DrawArrays != null) gl._DrawArrays(mode, first, count); else { }
        }
        /// <summary>
        /// <para>Fullname: DrawElements</para>
        /// </summary>
        [GLEntry("DrawElements", Category = "1.1")]
        public static GLDelegate.DrawElements _DrawElements = null;
        /// <summary>
        /// <para>render primitives from array data</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawElements.</para>
        /// <para>Fullname: DrawElements</para>
        /// <para>Extensions: VERSION_1_1</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        public static void DrawElements(int mode, int count, int type, IntPtr indices)
        {
            if (gl._DrawElements != null) gl._DrawElements(mode, count, type, indices); else { }
        }
        /// <summary>
        /// <para>render primitives from array data</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawElements.</para>
        /// <para>Fullname: DrawElements</para>
        /// <para>Extensions: VERSION_1_1</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        public static void DrawElements(int mode, int count, int type, Array indices)
        {
            GCHandle h = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try { if (gl._DrawElements != null) gl._DrawElements(mode, count, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: EdgeFlagPointer</para>
        /// </summary>
        [GLEntry("EdgeFlagPointer", Category = "1.1")]
        public static GLDelegate.EdgeFlagPointer _EdgeFlagPointer = null;
        /// <summary>
        /// <para>define an array of edge flags</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EdgeFlagPointer.</para>
        /// <para>Fullname: EdgeFlagPointer</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="stride">Specifies the byte offset between consecutive edge flags. If stride is 0, the edge flags are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a pointer to the first edge flag in the array. The initial value is 0.</param>
        public static void EdgeFlagPointer(int stride, IntPtr pointer)
        {
            if (gl._EdgeFlagPointer != null) gl._EdgeFlagPointer(stride, pointer); else { }
        }
        /// <summary>
        /// <para>define an array of edge flags</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EdgeFlagPointer.</para>
        /// <para>Fullname: EdgeFlagPointer</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="stride">Specifies the byte offset between consecutive edge flags. If stride is 0, the edge flags are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a pointer to the first edge flag in the array. The initial value is 0.</param>
        public static void EdgeFlagPointer(int stride, Array pointer)
        {
            GCHandle h = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try { if (gl._EdgeFlagPointer != null) gl._EdgeFlagPointer(stride, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: EnableClientState</para>
        /// </summary>
        [GLEntry("EnableClientState", Category = "1.1")]
        public static GLDelegate.EnableClientState _EnableClientState = null;
        /// <summary>
        /// <para>enable or disable client-side capability</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EnableClientState.</para>
        /// <para>Fullname: EnableClientState</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="cap">Specifies the capability to enable. Symbolic constants GL_COLOR_ARRAY, GL_EDGE_FLAG_ARRAY, GL_FOG_COORD_ARRAY, GL_INDEX_ARRAY, GL_NORMAL_ARRAY, GL_SECONDARY_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY, and GL_VERTEX_ARRAY are accepted.</param>
        public static void EnableClientState(int array)
        {
            if (gl._EnableClientState != null) gl._EnableClientState(array); else { }
        }
        /// <summary>
        /// <para>Fullname: GenTextures</para>
        /// </summary>
        [GLEntry("GenTextures", Category = "1.1", Alias = "GenTexturesEXT ")]
        public static GLDelegate.GenTextures_uint _GenTextures_uint = null;
        /// <summary>
        /// <para>generate texture names</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenTextures_uint.</para>
        /// <para>Fullname: GenTextures</para>
        /// <para>Aliases: GenTexturesEXT, </para>
        /// <para>Extensions: VERSION_1_1 EXT_texture_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of texture names to be generated.</param>
        /// <param name="textures">Specifies an array in which the generated texture names are stored.</param>
        public static void GenTextures(int n, out uint textures)
        {
            if (gl._GenTextures_uint != null) gl._GenTextures_uint(n, out textures); else { textures = new uint(); }
        }
        /// <summary>
        /// <para>generate texture name</para>
        /// </summary>
        public static uint GenTexture()
        {
            uint[] res = new uint[1];
            if (_GenTextures != null) _GenTextures(1, res);
            return res[0];
        }
        /// <summary>
        /// <para>generate texture names</para>
        /// </summary>
        /// <param name="n">Specifies the number of texture names to be generated.</param>
        public static uint[] GenTextures(int n)
        {
            uint[] res = new uint[n];
            if (_GenTextures != null) _GenTextures(n, res);
            return res;
        }
        /// <summary>
        /// <para>Fullname: GenTextures</para>
        /// </summary>
        [GLEntry("GenTextures", Category = "1.1", Alias = "GenTexturesEXT ")]
        public static GLDelegate.GenTextures _GenTextures = null;
        public static GLDelegate.GenTextures GenTexturesEXT = GenTextures;
        /// <summary>
        /// <para>generate texture names</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenTextures.</para>
        /// <para>Fullname: GenTextures</para>
        /// <para>Aliases: GenTexturesEXT, </para>
        /// <para>Extensions: VERSION_1_1 EXT_texture_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of texture names to be generated.</param>
        /// <param name="textures">Specifies an array in which the generated texture names are stored.</param>
        public static void GenTextures(int n, uint[] textures)
        {
            if (gl._GenTextures != null) gl._GenTextures(n, textures); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPointerv</para>
        /// </summary>
        [GLEntry("GetPointerv", Category = "1.1", Alias = "GetPointervEXT ")]
        public static GLDelegate.GetPointerv _GetPointerv = null;
        public static GLDelegate.GetPointerv GetPointervEXT = GetPointerv;
        /// <summary>
        /// <para>return the address of the specified pointer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPointerv.</para>
        /// <para>Fullname: GetPointerv</para>
        /// <para>Aliases: GetPointervEXT, </para>
        /// <para>Extensions: VERSION_1_1 EXT_vertex_array</para>
        /// </summary>
        /// <param name="pname">Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.</param>
        /// <param name="params">Returns the pointer value specified by pname.</param>
        public static void GetPointerv(int pname, IntPtr[] param)
        {
            if (gl._GetPointerv != null) gl._GetPointerv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: IndexPointer</para>
        /// </summary>
        [GLEntry("IndexPointer", Category = "1.1")]
        public static GLDelegate.IndexPointer _IndexPointer = null;
        /// <summary>
        /// <para>define an array of color indexes</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IndexPointer.</para>
        /// <para>Fullname: IndexPointer</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="type">Specifies the data type of each color index in the array. Symbolic constants GL_UNSIGNED_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive color indexes. If stride is 0, the color indexes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a pointer to the first index in the array. The initial value is 0.</param>
        public static void IndexPointer(int type, int stride, IntPtr pointer)
        {
            if (gl._IndexPointer != null) gl._IndexPointer(type, stride, pointer); else { }
        }
        /// <summary>
        /// <para>define an array of color indexes</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IndexPointer.</para>
        /// <para>Fullname: IndexPointer</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="type">Specifies the data type of each color index in the array. Symbolic constants GL_UNSIGNED_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive color indexes. If stride is 0, the color indexes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a pointer to the first index in the array. The initial value is 0.</param>
        public static void IndexPointer(int type, int stride, Array pointer)
        {
            GCHandle h = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try { if (gl._IndexPointer != null) gl._IndexPointer(type, stride, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: Indexub</para>
        /// </summary>
        [GLEntry("Indexub", Category = "1.1")]
        public static GLDelegate.Indexub _Indexub = null;
        /// <summary>
        /// <para>set the current color index</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Indexub.</para>
        /// <para>Fullname: Indexub</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// </summary>
        /// <param name="c">Specifies the new value for the current color index.</param>
        public static void Indexub(byte c)
        {
            if (gl._Indexub != null) gl._Indexub(c); else { }
        }
        /// <summary>
        /// <para>Fullname: Indexubv</para>
        /// </summary>
        [GLEntry("Indexubv", Category = "1.1")]
        public static GLDelegate.Indexubv _Indexubv = null;
        /// <summary>
        /// <para>set the current color index</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Indexubv.</para>
        /// <para>Fullname: Indexubv</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// </summary>
        /// <param name="c">Specifies the new value for the current color index.</param>
        public static void Indexubv(byte[] c)
        {
            if (gl._Indexubv != null) gl._Indexubv(c); else { }
        }
        /// <summary>
        /// <para>Fullname: InterleavedArrays</para>
        /// </summary>
        [GLEntry("InterleavedArrays", Category = "1.1")]
        public static GLDelegate.InterleavedArrays _InterleavedArrays = null;
        /// <summary>
        /// <para>simultaneously specify and enable several interleaved arrays</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _InterleavedArrays.</para>
        /// <para>Fullname: InterleavedArrays</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="format">Specifies the type of array to enable. Symbolic constants GL_V2F, GL_V3F, GL_C4UB_V2F, GL_C4UB_V3F, GL_C3F_V3F, GL_N3F_V3F, GL_C4F_N3F_V3F, GL_T2F_V3F, GL_T4F_V4F, GL_T2F_C4UB_V3F, GL_T2F_C3F_V3F, GL_T2F_N3F_V3F, GL_T2F_C4F_N3F_V3F, and GL_T4F_C4F_N3F_V4F are accepted.</param>
        /// <param name="stride">Specifies the offset in bytes between each aggregate array element.</param>
        public static void InterleavedArrays(int format, int stride, IntPtr pointer)
        {
            if (gl._InterleavedArrays != null) gl._InterleavedArrays(format, stride, pointer); else { }
        }
        /// <summary>
        /// <para>simultaneously specify and enable several interleaved arrays</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _InterleavedArrays.</para>
        /// <para>Fullname: InterleavedArrays</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="format">Specifies the type of array to enable. Symbolic constants GL_V2F, GL_V3F, GL_C4UB_V2F, GL_C4UB_V3F, GL_C3F_V3F, GL_N3F_V3F, GL_C4F_N3F_V3F, GL_T2F_V3F, GL_T4F_V4F, GL_T2F_C4UB_V3F, GL_T2F_C3F_V3F, GL_T2F_N3F_V3F, GL_T2F_C4F_N3F_V3F, and GL_T4F_C4F_N3F_V4F are accepted.</param>
        /// <param name="stride">Specifies the offset in bytes between each aggregate array element.</param>
        public static void InterleavedArrays(int format, int stride, Array pointer)
        {
            GCHandle h = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try { if (gl._InterleavedArrays != null) gl._InterleavedArrays(format, stride, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: IsTexture</para>
        /// </summary>
        [GLEntry("IsTexture", Category = "1.1", Alias = "IsTextureEXT ")]
        public static GLDelegate.IsTexture _IsTexture = null;
        public static GLDelegate.IsTexture IsTextureEXT = IsTexture;
        /// <summary>
        /// <para>determine if a name corresponds to a texture</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsTexture.</para>
        /// <para>Fullname: IsTexture</para>
        /// <para>Aliases: IsTextureEXT, </para>
        /// <para>Extensions: VERSION_1_1 EXT_texture_object</para>
        /// </summary>
        /// <param name="texture">Specifies a value that may be the name of a texture.</param>
        public static bool IsTexture(uint texture)
        {
            if (gl._IsTexture != null) return gl._IsTexture(texture);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: NormalPointer</para>
        /// </summary>
        [GLEntry("NormalPointer", Category = "1.1")]
        public static GLDelegate.NormalPointer _NormalPointer = null;
        /// <summary>
        /// <para>define an array of normals</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NormalPointer.</para>
        /// <para>Fullname: NormalPointer</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="type">Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.</param>
        public static void NormalPointer(int type, int stride, IntPtr pointer)
        {
            if (gl._NormalPointer != null) gl._NormalPointer(type, stride, pointer); else { }
        }
        /// <summary>
        /// <para>define an array of normals</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NormalPointer.</para>
        /// <para>Fullname: NormalPointer</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="type">Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.</param>
        public static void NormalPointer(int type, int stride, Array pointer)
        {
            GCHandle h = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try { if (gl._NormalPointer != null) gl._NormalPointer(type, stride, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: PolygonOffset</para>
        /// </summary>
        [GLEntry("PolygonOffset", Category = "1.1", Alias = "PolygonOffsetEXT ")]
        public static GLDelegate.PolygonOffset _PolygonOffset = null;
        public static GLDelegate.PolygonOffset PolygonOffsetEXT = PolygonOffset;
        /// <summary>
        /// <para>set the scale and units used to calculate depth values</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PolygonOffset.</para>
        /// <para>Fullname: PolygonOffset</para>
        /// <para>Aliases: PolygonOffsetEXT, </para>
        /// <para>Extensions: VERSION_1_1 EXT_polygon_offset</para>
        /// </summary>
        /// <param name="factor">Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0.</param>
        /// <param name="units">Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.</param>
        public static void PolygonOffset(float factor, float units)
        {
            if (gl._PolygonOffset != null) gl._PolygonOffset(factor, units); else { }
        }
        /// <summary>
        /// <para>Fullname: PopClientAttrib</para>
        /// </summary>
        [GLEntry("PopClientAttrib", Category = "1.1")]
        public static GLDelegate.PopClientAttrib _PopClientAttrib = null;
        /// <summary>
        /// <para>push and pop the client attribute stack</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PopClientAttrib.</para>
        /// <para>Fullname: PopClientAttrib</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="mask">Specifies a mask that indicates which attributes to save. Values for mask are listed below.</param>
        public static void PopClientAttrib()
        {
            if (gl._PopClientAttrib != null) gl._PopClientAttrib(); else { }
        }
        /// <summary>
        /// <para>Fullname: PrioritizeTextures</para>
        /// </summary>
        [GLEntry("PrioritizeTextures", Category = "1.1", Alias = "PrioritizeTexturesEXT ")]
        public static GLDelegate.PrioritizeTextures_uint_float _PrioritizeTextures_uint_float = null;
        /// <summary>
        /// <para>set texture residence priority</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PrioritizeTextures_uint_float.</para>
        /// <para>Fullname: PrioritizeTextures</para>
        /// <para>Aliases: PrioritizeTexturesEXT, </para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED EXT_texture_object</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="n">Specifies the number of textures to be prioritized.</param>
        /// <param name="textures">Specifies an array containing the names of the textures to be prioritized.</param>
        /// <param name="priorities">Specifies an array containing the texture priorities. A priority given in an element of priorities applies to the texture named by the corresponding element of textures.</param>
        public static void PrioritizeTextures(int n, ref uint textures, ref float priorities)
        {
            if (gl._PrioritizeTextures_uint_float != null) gl._PrioritizeTextures_uint_float(n, ref textures, ref priorities); else { }
        }
        /// <summary>
        /// <para>Fullname: PrioritizeTextures</para>
        /// </summary>
        [GLEntry("PrioritizeTextures", Category = "1.1", Alias = "PrioritizeTexturesEXT ")]
        public static GLDelegate.PrioritizeTextures _PrioritizeTextures = null;
        public static GLDelegate.PrioritizeTextures PrioritizeTexturesEXT = PrioritizeTextures;
        /// <summary>
        /// <para>set texture residence priority</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PrioritizeTextures.</para>
        /// <para>Fullname: PrioritizeTextures</para>
        /// <para>Aliases: PrioritizeTexturesEXT, </para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED EXT_texture_object</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="n">Specifies the number of textures to be prioritized.</param>
        /// <param name="textures">Specifies an array containing the names of the textures to be prioritized.</param>
        /// <param name="priorities">Specifies an array containing the texture priorities. A priority given in an element of priorities applies to the texture named by the corresponding element of textures.</param>
        public static void PrioritizeTextures(int n, uint[] textures, float[] priorities)
        {
            if (gl._PrioritizeTextures != null) gl._PrioritizeTextures(n, textures, priorities); else { }
        }
        /// <summary>
        /// <para>Fullname: PushClientAttrib</para>
        /// </summary>
        [GLEntry("PushClientAttrib", Category = "1.1")]
        public static GLDelegate.PushClientAttrib _PushClientAttrib = null;
        /// <summary>
        /// <para>push and pop the client attribute stack</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PushClientAttrib.</para>
        /// <para>Fullname: PushClientAttrib</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="mask">Specifies a mask that indicates which attributes to save. Values for mask are listed below.</param>
        public static void PushClientAttrib(int mask)
        {
            if (gl._PushClientAttrib != null) gl._PushClientAttrib(mask); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoordPointer</para>
        /// </summary>
        [GLEntry("TexCoordPointer", Category = "1.1")]
        public static GLDelegate.TexCoordPointer _TexCoordPointer = null;
        /// <summary>
        /// <para>define an array of texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoordPointer.</para>
        /// <para>Fullname: TexCoordPointer</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="size">Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.</param>
        /// <param name="pointer">Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.</param>
        public static void TexCoordPointer(int size, int type, int stride, IntPtr pointer)
        {
            if (gl._TexCoordPointer != null) gl._TexCoordPointer(size, type, stride, pointer); else { }
        }
        /// <summary>
        /// <para>define an array of texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoordPointer.</para>
        /// <para>Fullname: TexCoordPointer</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="size">Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.</param>
        /// <param name="pointer">Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.</param>
        public static void TexCoordPointer(int size, int type, int stride, Array pointer)
        {
            GCHandle h = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try { if (gl._TexCoordPointer != null) gl._TexCoordPointer(size, type, stride, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: TexSubImage1D</para>
        /// </summary>
        [GLEntry("TexSubImage1D", Category = "1.1", Alias = "TexSubImage1DEXT ")]
        public static GLDelegate.TexSubImage1D _TexSubImage1D = null;
        public static GLDelegate.TexSubImage1D TexSubImage1DEXT = TexSubImage1D;
        /// <summary>
        /// <para>specify a one-dimensional texture subimage</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexSubImage1D.</para>
        /// <para>Fullname: TexSubImage1D</para>
        /// <para>Aliases: TexSubImage1DEXT, </para>
        /// <para>Extensions: VERSION_1_1 EXT_subtexture</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="data">Specifies a pointer to the image data in memory.</param>
        public static void TexSubImage1D(int target, int level, int xoffset, int width, int format, int type, IntPtr pixels)
        {
            if (gl._TexSubImage1D != null) gl._TexSubImage1D(target, level, xoffset, width, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>specify a one-dimensional texture subimage</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexSubImage1D.</para>
        /// <para>Fullname: TexSubImage1D</para>
        /// <para>Aliases: TexSubImage1DEXT, </para>
        /// <para>Extensions: VERSION_1_1 EXT_subtexture</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="data">Specifies a pointer to the image data in memory.</param>
        public static void TexSubImage1D(int target, int level, int xoffset, int width, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._TexSubImage1D != null) gl._TexSubImage1D(target, level, xoffset, width, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: TexSubImage2D</para>
        /// </summary>
        [GLEntry("TexSubImage2D", Category = "1.1", Alias = "TexSubImage2DEXT ")]
        public static GLDelegate.TexSubImage2D _TexSubImage2D = null;
        public static GLDelegate.TexSubImage2D TexSubImage2DEXT = TexSubImage2D;
        /// <summary>
        /// <para>specify a two-dimensional texture subimage</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexSubImage2D.</para>
        /// <para>Fullname: TexSubImage2D</para>
        /// <para>Aliases: TexSubImage2DEXT, </para>
        /// <para>Extensions: VERSION_1_1 EXT_subtexture</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="data">Specifies a pointer to the image data in memory.</param>
        public static void TexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, IntPtr pixels)
        {
            if (gl._TexSubImage2D != null) gl._TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>specify a two-dimensional texture subimage</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexSubImage2D.</para>
        /// <para>Fullname: TexSubImage2D</para>
        /// <para>Aliases: TexSubImage2DEXT, </para>
        /// <para>Extensions: VERSION_1_1 EXT_subtexture</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="data">Specifies a pointer to the image data in memory.</param>
        public static void TexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._TexSubImage2D != null) gl._TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: VertexPointer</para>
        /// </summary>
        [GLEntry("VertexPointer", Category = "1.1")]
        public static GLDelegate.VertexPointer _VertexPointer = null;
        /// <summary>
        /// <para>define an array of vertex data</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexPointer.</para>
        /// <para>Fullname: VertexPointer</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="size">Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.</param>
        public static void VertexPointer(int size, int type, int stride, IntPtr pointer)
        {
            if (gl._VertexPointer != null) gl._VertexPointer(size, type, stride, pointer); else { }
        }
        /// <summary>
        /// <para>define an array of vertex data</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexPointer.</para>
        /// <para>Fullname: VertexPointer</para>
        /// <para>Extensions: VERSION_1_1_DEPRECATED</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="size">Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.</param>
        public static void VertexPointer(int size, int type, int stride, Array pointer)
        {
            GCHandle h = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try { if (gl._VertexPointer != null) gl._VertexPointer(size, type, stride, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: BlendColor</para>
        /// </summary>
        [GLEntry("BlendColor", Category = "1.2", Alias = "BlendColorEXT ")]
        public static GLDelegate.BlendColor _BlendColor = null;
        public static GLDelegate.BlendColor BlendColorEXT = BlendColor;
        /// <summary>
        /// <para>set the blend color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BlendColor.</para>
        /// <para>Fullname: BlendColor</para>
        /// <para>Aliases: BlendColorEXT, </para>
        /// <para>Extensions: VERSION_1_2 EXT_blend_color</para>
        /// </summary>
        /// <param name="red">specify the components of GL_BLEND_COLOR</param>
        /// <param name="green">specify the components of GL_BLEND_COLOR</param>
        /// <param name="blue">specify the components of GL_BLEND_COLOR</param>
        /// <param name="alpha">specify the components of GL_BLEND_COLOR</param>
        public static void BlendColor(float red, float green, float blue, float alpha)
        {
            if (gl._BlendColor != null) gl._BlendColor(red, green, blue, alpha); else { }
        }
        /// <summary>
        /// <para>Fullname: BlendEquation</para>
        /// </summary>
        [GLEntry("BlendEquation", Category = "1.2", Alias = "BlendEquationEXT ")]
        public static GLDelegate.BlendEquation _BlendEquation = null;
        public static GLDelegate.BlendEquation BlendEquationEXT = BlendEquation;
        /// <summary>
        /// <para>specify the equation used for both the RGB blend equation and the Alpha blend equation</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BlendEquation.</para>
        /// <para>Fullname: BlendEquation</para>
        /// <para>Aliases: BlendEquationEXT, </para>
        /// <para>Extensions: VERSION_1_2 EXT_blend_minmax</para>
        /// </summary>
        /// <param name="buf">for glBlendEquationi, specifies the index of the draw buffer for which to set the blend equation.</param>
        /// <param name="mode">specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.</param>
        public static void BlendEquation(int mode)
        {
            if (gl._BlendEquation != null) gl._BlendEquation(mode); else { }
        }
        /// <summary>
        /// <para>Fullname: ColorSubTable</para>
        /// </summary>
        [GLEntry("ColorSubTable", Category = "1.2", Alias = "ColorSubTableEXT ")]
        public static GLDelegate.ColorSubTable _ColorSubTable = null;
        public static GLDelegate.ColorSubTable ColorSubTableEXT = ColorSubTable;
        /// <summary>
        /// <para>respecify a portion of a color table</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorSubTable.</para>
        /// <para>Fullname: ColorSubTable</para>
        /// <para>Aliases: ColorSubTableEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_color_subtable</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.</param>
        /// <param name="start">The starting index of the portion of the color table to be replaced.</param>
        /// <param name="count">The number of table entries to replace.</param>
        /// <param name="format">The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="data">Pointer to a one-dimensional array of pixel data that is processed to replace the specified region of the color table.</param>
        public static void ColorSubTable(int target, int start, int count, int format, int type, IntPtr data)
        {
            if (gl._ColorSubTable != null) gl._ColorSubTable(target, start, count, format, type, data); else { }
        }
        /// <summary>
        /// <para>respecify a portion of a color table</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorSubTable.</para>
        /// <para>Fullname: ColorSubTable</para>
        /// <para>Aliases: ColorSubTableEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_color_subtable</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.</param>
        /// <param name="start">The starting index of the portion of the color table to be replaced.</param>
        /// <param name="count">The number of table entries to replace.</param>
        /// <param name="format">The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="data">Pointer to a one-dimensional array of pixel data that is processed to replace the specified region of the color table.</param>
        public static void ColorSubTable(int target, int start, int count, int format, int type, Array data)
        {
            GCHandle h = GCHandle.Alloc(data, GCHandleType.Pinned);
            try { if (gl._ColorSubTable != null) gl._ColorSubTable(target, start, count, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: ColorTable</para>
        /// </summary>
        [GLEntry("ColorTable", Category = "1.2", Alias = "ColorTableEXT ColorTableSGI ")]
        public static GLDelegate.ColorTable _ColorTable = null;
        public static GLDelegate.ColorTable ColorTableEXT = ColorTable;
        public static GLDelegate.ColorTable ColorTableSGI = ColorTable;
        /// <summary>
        /// <para>define a color lookup table</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorTable.</para>
        /// <para>Fullname: ColorTable</para>
        /// <para>Aliases: ColorTableEXT, ColorTableSGI, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_paletted_texture SGI_color_table</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.</param>
        /// <param name="internalformat">The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16.</param>
        /// <param name="width">The number of entries in the color lookup table specified by data.</param>
        /// <param name="format">The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="data">Pointer to a one-dimensional array of pixel data that is processed to build the color table.</param>
        public static void ColorTable(int target, int internalformat, int width, int format, int type, IntPtr table)
        {
            if (gl._ColorTable != null) gl._ColorTable(target, internalformat, width, format, type, table); else { }
        }
        /// <summary>
        /// <para>define a color lookup table</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorTable.</para>
        /// <para>Fullname: ColorTable</para>
        /// <para>Aliases: ColorTableEXT, ColorTableSGI, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_paletted_texture SGI_color_table</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.</param>
        /// <param name="internalformat">The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16.</param>
        /// <param name="width">The number of entries in the color lookup table specified by data.</param>
        /// <param name="format">The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="data">Pointer to a one-dimensional array of pixel data that is processed to build the color table.</param>
        public static void ColorTable(int target, int internalformat, int width, int format, int type, Array table)
        {
            GCHandle h = GCHandle.Alloc(table, GCHandleType.Pinned);
            try { if (gl._ColorTable != null) gl._ColorTable(target, internalformat, width, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: ColorTableParameterfv</para>
        /// </summary>
        [GLEntry("ColorTableParameterfv", Category = "1.2", Alias = "ColorTableParameterfvSGI ")]
        public static GLDelegate.ColorTableParameterfv _ColorTableParameterfv = null;
        public static GLDelegate.ColorTableParameterfv ColorTableParameterfvSGI = ColorTableParameterfv;
        /// <summary>
        /// <para>set color lookup table parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorTableParameterfv.</para>
        /// <para>Fullname: ColorTableParameterfv</para>
        /// <para>Aliases: ColorTableParameterfvSGI, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED SGI_color_table</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.</param>
        /// <param name="pname">The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS.</param>
        /// <param name="params">A pointer to an array where the values of the parameters are stored.</param>
        public static void ColorTableParameterfv(int target, int pname, float[] param)
        {
            if (gl._ColorTableParameterfv != null) gl._ColorTableParameterfv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ColorTableParameteriv</para>
        /// </summary>
        [GLEntry("ColorTableParameteriv", Category = "1.2", Alias = "ColorTableParameterivSGI ")]
        public static GLDelegate.ColorTableParameteriv _ColorTableParameteriv = null;
        public static GLDelegate.ColorTableParameteriv ColorTableParameterivSGI = ColorTableParameteriv;
        /// <summary>
        /// <para>set color lookup table parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorTableParameteriv.</para>
        /// <para>Fullname: ColorTableParameteriv</para>
        /// <para>Aliases: ColorTableParameterivSGI, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED SGI_color_table</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.</param>
        /// <param name="pname">The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS.</param>
        /// <param name="params">A pointer to an array where the values of the parameters are stored.</param>
        public static void ColorTableParameteriv(int target, int pname, int[] param)
        {
            if (gl._ColorTableParameteriv != null) gl._ColorTableParameteriv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ConvolutionFilter1D</para>
        /// </summary>
        [GLEntry("ConvolutionFilter1D", Category = "1.2", Alias = "ConvolutionFilter1DEXT ")]
        public static GLDelegate.ConvolutionFilter1D _ConvolutionFilter1D = null;
        public static GLDelegate.ConvolutionFilter1D ConvolutionFilter1DEXT = ConvolutionFilter1D;
        /// <summary>
        /// <para>define a one-dimensional convolution filter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ConvolutionFilter1D.</para>
        /// <para>Fullname: ConvolutionFilter1D</para>
        /// <para>Aliases: ConvolutionFilter1DEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_convolution</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be GL_CONVOLUTION_1D.</param>
        /// <param name="internalformat">The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.</param>
        /// <param name="width">The width of the pixel array referenced by data.</param>
        /// <param name="format">The format of the pixel data in data. The allowable values are GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_RGB, and GL_RGBA.</param>
        /// <param name="type">The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.</param>
        /// <param name="data">Pointer to a one-dimensional array of pixel data that is processed to build the convolution filter kernel.</param>
        public static void ConvolutionFilter1D(int target, int internalformat, int width, int format, int type, IntPtr image)
        {
            if (gl._ConvolutionFilter1D != null) gl._ConvolutionFilter1D(target, internalformat, width, format, type, image); else { }
        }
        /// <summary>
        /// <para>define a one-dimensional convolution filter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ConvolutionFilter1D.</para>
        /// <para>Fullname: ConvolutionFilter1D</para>
        /// <para>Aliases: ConvolutionFilter1DEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_convolution</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be GL_CONVOLUTION_1D.</param>
        /// <param name="internalformat">The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.</param>
        /// <param name="width">The width of the pixel array referenced by data.</param>
        /// <param name="format">The format of the pixel data in data. The allowable values are GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_RGB, and GL_RGBA.</param>
        /// <param name="type">The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.</param>
        /// <param name="data">Pointer to a one-dimensional array of pixel data that is processed to build the convolution filter kernel.</param>
        public static void ConvolutionFilter1D(int target, int internalformat, int width, int format, int type, Array image)
        {
            GCHandle h = GCHandle.Alloc(image, GCHandleType.Pinned);
            try { if (gl._ConvolutionFilter1D != null) gl._ConvolutionFilter1D(target, internalformat, width, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: ConvolutionFilter2D</para>
        /// </summary>
        [GLEntry("ConvolutionFilter2D", Category = "1.2", Alias = "ConvolutionFilter2DEXT ")]
        public static GLDelegate.ConvolutionFilter2D _ConvolutionFilter2D = null;
        public static GLDelegate.ConvolutionFilter2D ConvolutionFilter2DEXT = ConvolutionFilter2D;
        /// <summary>
        /// <para>define a two-dimensional convolution filter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ConvolutionFilter2D.</para>
        /// <para>Fullname: ConvolutionFilter2D</para>
        /// <para>Aliases: ConvolutionFilter2DEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_convolution</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be GL_CONVOLUTION_2D.</param>
        /// <param name="internalformat">The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.</param>
        /// <param name="width">The width of the pixel array referenced by data.</param>
        /// <param name="height">The height of the pixel array referenced by data.</param>
        /// <param name="format">The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.</param>
        /// <param name="type">The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.</param>
        /// <param name="data">Pointer to a two-dimensional array of pixel data that is processed to build the convolution filter kernel.</param>
        public static void ConvolutionFilter2D(int target, int internalformat, int width, int height, int format, int type, IntPtr image)
        {
            if (gl._ConvolutionFilter2D != null) gl._ConvolutionFilter2D(target, internalformat, width, height, format, type, image); else { }
        }
        /// <summary>
        /// <para>define a two-dimensional convolution filter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ConvolutionFilter2D.</para>
        /// <para>Fullname: ConvolutionFilter2D</para>
        /// <para>Aliases: ConvolutionFilter2DEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_convolution</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be GL_CONVOLUTION_2D.</param>
        /// <param name="internalformat">The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.</param>
        /// <param name="width">The width of the pixel array referenced by data.</param>
        /// <param name="height">The height of the pixel array referenced by data.</param>
        /// <param name="format">The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.</param>
        /// <param name="type">The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.</param>
        /// <param name="data">Pointer to a two-dimensional array of pixel data that is processed to build the convolution filter kernel.</param>
        public static void ConvolutionFilter2D(int target, int internalformat, int width, int height, int format, int type, Array image)
        {
            GCHandle h = GCHandle.Alloc(image, GCHandleType.Pinned);
            try { if (gl._ConvolutionFilter2D != null) gl._ConvolutionFilter2D(target, internalformat, width, height, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: ConvolutionParameterf</para>
        /// </summary>
        [GLEntry("ConvolutionParameterf", Category = "1.2", Alias = "ConvolutionParameterfEXT ")]
        public static GLDelegate.ConvolutionParameterf _ConvolutionParameterf = null;
        public static GLDelegate.ConvolutionParameterf ConvolutionParameterfEXT = ConvolutionParameterf;
        /// <summary>
        /// <para>set convolution parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ConvolutionParameterf.</para>
        /// <para>Fullname: ConvolutionParameterf</para>
        /// <para>Aliases: ConvolutionParameterfEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_convolution</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.</param>
        /// <param name="pname">The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.</param>
        /// <param name="params">The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.</param>
        public static void ConvolutionParameterf(int target, int pname, float param)
        {
            if (gl._ConvolutionParameterf != null) gl._ConvolutionParameterf(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ConvolutionParameterfv</para>
        /// </summary>
        [GLEntry("ConvolutionParameterfv", Category = "1.2", Alias = "ConvolutionParameterfvEXT ")]
        public static GLDelegate.ConvolutionParameterfv _ConvolutionParameterfv = null;
        public static GLDelegate.ConvolutionParameterfv ConvolutionParameterfvEXT = ConvolutionParameterfv;
        /// <summary>
        /// <para>set convolution parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ConvolutionParameterfv.</para>
        /// <para>Fullname: ConvolutionParameterfv</para>
        /// <para>Aliases: ConvolutionParameterfvEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_convolution</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.</param>
        /// <param name="pname">The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.</param>
        /// <param name="params">The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.</param>
        public static void ConvolutionParameterfv(int target, int pname, float[] param)
        {
            if (gl._ConvolutionParameterfv != null) gl._ConvolutionParameterfv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ConvolutionParameteri</para>
        /// </summary>
        [GLEntry("ConvolutionParameteri", Category = "1.2", Alias = "ConvolutionParameteriEXT ")]
        public static GLDelegate.ConvolutionParameteri _ConvolutionParameteri = null;
        public static GLDelegate.ConvolutionParameteri ConvolutionParameteriEXT = ConvolutionParameteri;
        /// <summary>
        /// <para>set convolution parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ConvolutionParameteri.</para>
        /// <para>Fullname: ConvolutionParameteri</para>
        /// <para>Aliases: ConvolutionParameteriEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_convolution</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.</param>
        /// <param name="pname">The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.</param>
        /// <param name="params">The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.</param>
        public static void ConvolutionParameteri(int target, int pname, int param)
        {
            if (gl._ConvolutionParameteri != null) gl._ConvolutionParameteri(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ConvolutionParameteriv</para>
        /// </summary>
        [GLEntry("ConvolutionParameteriv", Category = "1.2", Alias = "ConvolutionParameterivEXT ")]
        public static GLDelegate.ConvolutionParameteriv _ConvolutionParameteriv = null;
        public static GLDelegate.ConvolutionParameteriv ConvolutionParameterivEXT = ConvolutionParameteriv;
        /// <summary>
        /// <para>set convolution parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ConvolutionParameteriv.</para>
        /// <para>Fullname: ConvolutionParameteriv</para>
        /// <para>Aliases: ConvolutionParameterivEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_convolution</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.</param>
        /// <param name="pname">The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.</param>
        /// <param name="params">The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.</param>
        public static void ConvolutionParameteriv(int target, int pname, int[] param)
        {
            if (gl._ConvolutionParameteriv != null) gl._ConvolutionParameteriv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyColorSubTable</para>
        /// </summary>
        [GLEntry("CopyColorSubTable", Category = "1.2", Alias = "CopyColorSubTableEXT ")]
        public static GLDelegate.CopyColorSubTable _CopyColorSubTable = null;
        public static GLDelegate.CopyColorSubTable CopyColorSubTableEXT = CopyColorSubTable;
        /// <summary>
        /// <para>respecify a portion of a color table</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyColorSubTable.</para>
        /// <para>Fullname: CopyColorSubTable</para>
        /// <para>Aliases: CopyColorSubTableEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_color_subtable</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.</param>
        /// <param name="start">The starting index of the portion of the color table to be replaced.</param>
        /// <param name="x">The window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="y">The window coordinates of the left corner of the row of pixels to be copied.</param>
        /// <param name="width">The number of table entries to replace.</param>
        public static void CopyColorSubTable(int target, int start, int x, int y, int width)
        {
            if (gl._CopyColorSubTable != null) gl._CopyColorSubTable(target, start, x, y, width); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyColorTable</para>
        /// </summary>
        [GLEntry("CopyColorTable", Category = "1.2", Alias = "CopyColorTableSGI ")]
        public static GLDelegate.CopyColorTable _CopyColorTable = null;
        public static GLDelegate.CopyColorTable CopyColorTableSGI = CopyColorTable;
        /// <summary>
        /// <para>copy pixels into a color table</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyColorTable.</para>
        /// <para>Fullname: CopyColorTable</para>
        /// <para>Aliases: CopyColorTableSGI, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED SGI_color_table</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">The color table target. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.</param>
        /// <param name="internalformat">The internal storage format of the texture image. Must be one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.</param>
        /// <param name="x">The x coordinate of the lower-left corner of the pixel rectangle to be transferred to the color table.</param>
        /// <param name="y">The y coordinate of the lower-left corner of the pixel rectangle to be transferred to the color table.</param>
        /// <param name="width">The width of the pixel rectangle.</param>
        public static void CopyColorTable(int target, int internalformat, int x, int y, int width)
        {
            if (gl._CopyColorTable != null) gl._CopyColorTable(target, internalformat, x, y, width); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyConvolutionFilter1D</para>
        /// </summary>
        [GLEntry("CopyConvolutionFilter1D", Category = "1.2", Alias = "CopyConvolutionFilter1DEXT ")]
        public static GLDelegate.CopyConvolutionFilter1D _CopyConvolutionFilter1D = null;
        public static GLDelegate.CopyConvolutionFilter1D CopyConvolutionFilter1DEXT = CopyConvolutionFilter1D;
        /// <summary>
        /// <para>copy pixels into a one-dimensional convolution filter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyConvolutionFilter1D.</para>
        /// <para>Fullname: CopyConvolutionFilter1D</para>
        /// <para>Aliases: CopyConvolutionFilter1DEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_convolution</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be GL_CONVOLUTION_1D.</param>
        /// <param name="internalformat">The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.</param>
        /// <param name="x">The window space coordinates of the lower-left coordinate of the pixel array to copy.</param>
        /// <param name="y">The window space coordinates of the lower-left coordinate of the pixel array to copy.</param>
        /// <param name="width">The width of the pixel array to copy.</param>
        public static void CopyConvolutionFilter1D(int target, int internalformat, int x, int y, int width)
        {
            if (gl._CopyConvolutionFilter1D != null) gl._CopyConvolutionFilter1D(target, internalformat, x, y, width); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyConvolutionFilter2D</para>
        /// </summary>
        [GLEntry("CopyConvolutionFilter2D", Category = "1.2", Alias = "CopyConvolutionFilter2DEXT ")]
        public static GLDelegate.CopyConvolutionFilter2D _CopyConvolutionFilter2D = null;
        public static GLDelegate.CopyConvolutionFilter2D CopyConvolutionFilter2DEXT = CopyConvolutionFilter2D;
        /// <summary>
        /// <para>copy pixels into a two-dimensional convolution filter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyConvolutionFilter2D.</para>
        /// <para>Fullname: CopyConvolutionFilter2D</para>
        /// <para>Aliases: CopyConvolutionFilter2DEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_convolution</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be GL_CONVOLUTION_2D.</param>
        /// <param name="internalformat">The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.</param>
        /// <param name="x">The window space coordinates of the lower-left coordinate of the pixel array to copy.</param>
        /// <param name="y">The window space coordinates of the lower-left coordinate of the pixel array to copy.</param>
        /// <param name="width">The width of the pixel array to copy.</param>
        /// <param name="height">The height of the pixel array to copy.</param>
        public static void CopyConvolutionFilter2D(int target, int internalformat, int x, int y, int width, int height)
        {
            if (gl._CopyConvolutionFilter2D != null) gl._CopyConvolutionFilter2D(target, internalformat, x, y, width, height); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyTexSubImage3D</para>
        /// </summary>
        [GLEntry("CopyTexSubImage3D", Category = "1.2", Alias = "CopyTexSubImage3DEXT ")]
        public static GLDelegate.CopyTexSubImage3D _CopyTexSubImage3D = null;
        public static GLDelegate.CopyTexSubImage3D CopyTexSubImage3DEXT = CopyTexSubImage3D;
        /// <summary>
        /// <para>copy a three-dimensional texture subimage</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyTexSubImage3D.</para>
        /// <para>Fullname: CopyTexSubImage3D</para>
        /// <para>Aliases: CopyTexSubImage3DEXT, </para>
        /// <para>Extensions: VERSION_1_2 EXT_copy_texture</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="x">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        public static void CopyTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
        {
            if (gl._CopyTexSubImage3D != null) gl._CopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height); else { }
        }
        /// <summary>
        /// <para>Fullname: DrawRangeElements</para>
        /// </summary>
        [GLEntry("DrawRangeElements", Category = "1.2", Alias = "DrawRangeElementsEXT ")]
        public static GLDelegate.DrawRangeElements _DrawRangeElements = null;
        public static GLDelegate.DrawRangeElements DrawRangeElementsEXT = DrawRangeElements;
        /// <summary>
        /// <para>render primitives from array data</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawRangeElements.</para>
        /// <para>Fullname: DrawRangeElements</para>
        /// <para>Aliases: DrawRangeElementsEXT, </para>
        /// <para>Extensions: VERSION_1_2 EXT_draw_range_elements</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="start">Specifies the minimum array index contained in indices.</param>
        /// <param name="end">Specifies the maximum array index contained in indices.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        public static void DrawRangeElements(int mode, uint start, uint end, int count, int type, IntPtr indices)
        {
            if (gl._DrawRangeElements != null) gl._DrawRangeElements(mode, start, end, count, type, indices); else { }
        }
        /// <summary>
        /// <para>render primitives from array data</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawRangeElements.</para>
        /// <para>Fullname: DrawRangeElements</para>
        /// <para>Aliases: DrawRangeElementsEXT, </para>
        /// <para>Extensions: VERSION_1_2 EXT_draw_range_elements</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="start">Specifies the minimum array index contained in indices.</param>
        /// <param name="end">Specifies the maximum array index contained in indices.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        public static void DrawRangeElements(int mode, uint start, uint end, int count, int type, Array indices)
        {
            GCHandle h = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try { if (gl._DrawRangeElements != null) gl._DrawRangeElements(mode, start, end, count, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: GetColorTable</para>
        /// </summary>
        [GLEntry("GetColorTable", Category = "1.2", Alias = "GetColorTableEXT GetColorTableSGI ")]
        public static GLDelegate.GetColorTable _GetColorTable = null;
        public static GLDelegate.GetColorTable GetColorTableEXT = GetColorTable;
        public static GLDelegate.GetColorTable GetColorTableSGI = GetColorTable;
        /// <summary>
        /// <para>retrieve contents of a color lookup table</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetColorTable.</para>
        /// <para>Fullname: GetColorTable</para>
        /// <para>Aliases: GetColorTableEXT, GetColorTableSGI, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_paletted_texture SGI_color_table</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.</param>
        /// <param name="format">The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.</param>
        /// <param name="table">Pointer to a one-dimensional array of pixel data containing the contents of the color table.</param>
        public static void GetColorTable(int target, int format, int type, IntPtr table)
        {
            if (gl._GetColorTable != null) gl._GetColorTable(target, format, type, table); else { }
        }
        /// <summary>
        /// <para>Fullname: GetColorTableParameterfv</para>
        /// </summary>
        [GLEntry("GetColorTableParameterfv", Category = "1.2", Alias = "GetColorTableParameterfvEXT GetColorTableParameterfvSGI ")]
        public static GLDelegate.GetColorTableParameterfv _GetColorTableParameterfv = null;
        public static GLDelegate.GetColorTableParameterfv GetColorTableParameterfvEXT = GetColorTableParameterfv;
        public static GLDelegate.GetColorTableParameterfv GetColorTableParameterfvSGI = GetColorTableParameterfv;
        /// <summary>
        /// <para>get color lookup table parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetColorTableParameterfv.</para>
        /// <para>Fullname: GetColorTableParameterfv</para>
        /// <para>Aliases: GetColorTableParameterfvEXT, GetColorTableParameterfvSGI, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_paletted_texture SGI_color_table</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.</param>
        /// <param name="pname">The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.</param>
        /// <param name="params">A pointer to an array where the values of the parameter will be stored.</param>
        public static void GetColorTableParameterfv(int target, int pname, float[] param)
        {
            if (gl._GetColorTableParameterfv != null) gl._GetColorTableParameterfv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetColorTableParameteriv</para>
        /// </summary>
        [GLEntry("GetColorTableParameteriv", Category = "1.2", Alias = "GetColorTableParameterivEXT GetColorTableParameterivSGI ")]
        public static GLDelegate.GetColorTableParameteriv _GetColorTableParameteriv = null;
        public static GLDelegate.GetColorTableParameteriv GetColorTableParameterivEXT = GetColorTableParameteriv;
        public static GLDelegate.GetColorTableParameteriv GetColorTableParameterivSGI = GetColorTableParameteriv;
        /// <summary>
        /// <para>get color lookup table parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetColorTableParameteriv.</para>
        /// <para>Fullname: GetColorTableParameteriv</para>
        /// <para>Aliases: GetColorTableParameterivEXT, GetColorTableParameterivSGI, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_paletted_texture SGI_color_table</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.</param>
        /// <param name="pname">The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.</param>
        /// <param name="params">A pointer to an array where the values of the parameter will be stored.</param>
        public static void GetColorTableParameteriv(int target, int pname, int[] param)
        {
            if (gl._GetColorTableParameteriv != null) gl._GetColorTableParameteriv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetConvolutionFilter</para>
        /// </summary>
        [GLEntry("GetConvolutionFilter", Category = "1.2", Alias = "GetConvolutionFilterEXT ")]
        public static GLDelegate.GetConvolutionFilter _GetConvolutionFilter = null;
        public static GLDelegate.GetConvolutionFilter GetConvolutionFilterEXT = GetConvolutionFilter;
        /// <summary>
        /// <para>get current 1D or 2D convolution filter kernel</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetConvolutionFilter.</para>
        /// <para>Fullname: GetConvolutionFilter</para>
        /// <para>Aliases: GetConvolutionFilterEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_convolution</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">The filter to be retrieved. Must be one of GL_CONVOLUTION_1D or GL_CONVOLUTION_2D.</param>
        /// <param name="format">Format of the output image. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.</param>
        /// <param name="type">Data type of components in the output image. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.</param>
        /// <param name="image">Pointer to storage for the output image.</param>
        public static void GetConvolutionFilter(int target, int format, int type, IntPtr image)
        {
            if (gl._GetConvolutionFilter != null) gl._GetConvolutionFilter(target, format, type, image); else { }
        }
        /// <summary>
        /// <para>Fullname: GetConvolutionParameterfv</para>
        /// </summary>
        [GLEntry("GetConvolutionParameterfv", Category = "1.2", Alias = "GetConvolutionParameterfvEXT ")]
        public static GLDelegate.GetConvolutionParameterfv _GetConvolutionParameterfv = null;
        public static GLDelegate.GetConvolutionParameterfv GetConvolutionParameterfvEXT = GetConvolutionParameterfv;
        /// <summary>
        /// <para>get convolution parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetConvolutionParameterfv.</para>
        /// <para>Fullname: GetConvolutionParameterfv</para>
        /// <para>Aliases: GetConvolutionParameterfvEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_convolution</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.</param>
        /// <param name="pname">The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT.</param>
        /// <param name="params">Pointer to storage for the parameters to be retrieved.</param>
        public static void GetConvolutionParameterfv(int target, int pname, float[] param)
        {
            if (gl._GetConvolutionParameterfv != null) gl._GetConvolutionParameterfv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetConvolutionParameteriv</para>
        /// </summary>
        [GLEntry("GetConvolutionParameteriv", Category = "1.2", Alias = "GetConvolutionParameterivEXT ")]
        public static GLDelegate.GetConvolutionParameteriv _GetConvolutionParameteriv = null;
        public static GLDelegate.GetConvolutionParameteriv GetConvolutionParameterivEXT = GetConvolutionParameteriv;
        /// <summary>
        /// <para>get convolution parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetConvolutionParameteriv.</para>
        /// <para>Fullname: GetConvolutionParameteriv</para>
        /// <para>Aliases: GetConvolutionParameterivEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_convolution</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.</param>
        /// <param name="pname">The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT.</param>
        /// <param name="params">Pointer to storage for the parameters to be retrieved.</param>
        public static void GetConvolutionParameteriv(int target, int pname, int[] param)
        {
            if (gl._GetConvolutionParameteriv != null) gl._GetConvolutionParameteriv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetHistogram</para>
        /// </summary>
        [GLEntry("GetHistogram", Category = "1.2", Alias = "GetHistogramEXT ")]
        public static GLDelegate.GetHistogram _GetHistogram = null;
        public static GLDelegate.GetHistogram GetHistogramEXT = GetHistogram;
        /// <summary>
        /// <para>get histogram table</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetHistogram.</para>
        /// <para>Fullname: GetHistogram</para>
        /// <para>Aliases: GetHistogramEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_histogram</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be GL_HISTOGRAM.</param>
        /// <param name="reset">If GL_TRUE, each component counter that is actually returned is reset to zero. (Other counters are unaffected.) If GL_FALSE, none of the counters in the histogram table is modified.</param>
        /// <param name="format">The format of values to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.</param>
        /// <param name="type">The type of values to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.</param>
        /// <param name="values">A pointer to storage for the returned histogram table.</param>
        public static void GetHistogram(int target, bool reset, int format, int type, IntPtr values)
        {
            if (gl._GetHistogram != null) gl._GetHistogram(target, reset, format, type, values); else { }
        }
        /// <summary>
        /// <para>Fullname: GetHistogramParameterfv</para>
        /// </summary>
        [GLEntry("GetHistogramParameterfv", Category = "1.2", Alias = "GetHistogramParameterfvEXT ")]
        public static GLDelegate.GetHistogramParameterfv _GetHistogramParameterfv = null;
        public static GLDelegate.GetHistogramParameterfv GetHistogramParameterfvEXT = GetHistogramParameterfv;
        /// <summary>
        /// <para>get histogram parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetHistogramParameterfv.</para>
        /// <para>Fullname: GetHistogramParameterfv</para>
        /// <para>Aliases: GetHistogramParameterfvEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_histogram</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.</param>
        /// <param name="pname">The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK.</param>
        /// <param name="params">Pointer to storage for the returned values.</param>
        public static void GetHistogramParameterfv(int target, int pname, float[] param)
        {
            if (gl._GetHistogramParameterfv != null) gl._GetHistogramParameterfv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetHistogramParameteriv</para>
        /// </summary>
        [GLEntry("GetHistogramParameteriv", Category = "1.2", Alias = "GetHistogramParameterivEXT ")]
        public static GLDelegate.GetHistogramParameteriv _GetHistogramParameteriv = null;
        public static GLDelegate.GetHistogramParameteriv GetHistogramParameterivEXT = GetHistogramParameteriv;
        /// <summary>
        /// <para>get histogram parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetHistogramParameteriv.</para>
        /// <para>Fullname: GetHistogramParameteriv</para>
        /// <para>Aliases: GetHistogramParameterivEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_histogram</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.</param>
        /// <param name="pname">The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK.</param>
        /// <param name="params">Pointer to storage for the returned values.</param>
        public static void GetHistogramParameteriv(int target, int pname, int[] param)
        {
            if (gl._GetHistogramParameteriv != null) gl._GetHistogramParameteriv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMinmax</para>
        /// </summary>
        [GLEntry("GetMinmax", Category = "1.2", Alias = "GetMinmaxEXT ")]
        public static GLDelegate.GetMinmax _GetMinmax = null;
        public static GLDelegate.GetMinmax GetMinmaxEXT = GetMinmax;
        /// <summary>
        /// <para>get minimum and maximum pixel values</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMinmax.</para>
        /// <para>Fullname: GetMinmax</para>
        /// <para>Aliases: GetMinmaxEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_histogram</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be GL_MINMAX.</param>
        /// <param name="reset">If GL_TRUE, all entries in the minmax table that are actually returned are reset to their initial values. (Other entries are unaltered.) If GL_FALSE, the minmax table is unaltered.</param>
        /// <param name="format">The format of the data to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.</param>
        /// <param name="types">The type of the data to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.</param>
        /// <param name="values">A pointer to storage for the returned values.</param>
        public static void GetMinmax(int target, bool reset, int format, int type, IntPtr values)
        {
            if (gl._GetMinmax != null) gl._GetMinmax(target, reset, format, type, values); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMinmaxParameterfv</para>
        /// </summary>
        [GLEntry("GetMinmaxParameterfv", Category = "1.2", Alias = "GetMinmaxParameterfvEXT ")]
        public static GLDelegate.GetMinmaxParameterfv _GetMinmaxParameterfv = null;
        public static GLDelegate.GetMinmaxParameterfv GetMinmaxParameterfvEXT = GetMinmaxParameterfv;
        /// <summary>
        /// <para>get minmax parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMinmaxParameterfv.</para>
        /// <para>Fullname: GetMinmaxParameterfv</para>
        /// <para>Aliases: GetMinmaxParameterfvEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_histogram</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be GL_MINMAX.</param>
        /// <param name="pname">The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK.</param>
        /// <param name="params">A pointer to storage for the retrieved parameters.</param>
        public static void GetMinmaxParameterfv(int target, int pname, float[] param)
        {
            if (gl._GetMinmaxParameterfv != null) gl._GetMinmaxParameterfv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMinmaxParameteriv</para>
        /// </summary>
        [GLEntry("GetMinmaxParameteriv", Category = "1.2", Alias = "GetMinmaxParameterivEXT ")]
        public static GLDelegate.GetMinmaxParameteriv _GetMinmaxParameteriv = null;
        public static GLDelegate.GetMinmaxParameteriv GetMinmaxParameterivEXT = GetMinmaxParameteriv;
        /// <summary>
        /// <para>get minmax parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMinmaxParameteriv.</para>
        /// <para>Fullname: GetMinmaxParameteriv</para>
        /// <para>Aliases: GetMinmaxParameterivEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_histogram</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be GL_MINMAX.</param>
        /// <param name="pname">The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK.</param>
        /// <param name="params">A pointer to storage for the retrieved parameters.</param>
        public static void GetMinmaxParameteriv(int target, int pname, int[] param)
        {
            if (gl._GetMinmaxParameteriv != null) gl._GetMinmaxParameteriv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetSeparableFilter</para>
        /// </summary>
        [GLEntry("GetSeparableFilter", Category = "1.2", Alias = "GetSeparableFilterEXT ")]
        public static GLDelegate.GetSeparableFilter _GetSeparableFilter = null;
        public static GLDelegate.GetSeparableFilter GetSeparableFilterEXT = GetSeparableFilter;
        /// <summary>
        /// <para>get separable convolution filter kernel images</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetSeparableFilter.</para>
        /// <para>Fullname: GetSeparableFilter</para>
        /// <para>Aliases: GetSeparableFilterEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_convolution</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">The separable filter to be retrieved. Must be GL_SEPARABLE_2D.</param>
        /// <param name="format">Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGRGL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.</param>
        /// <param name="type">Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.</param>
        /// <param name="row">Pointer to storage for the row filter image.</param>
        /// <param name="column">Pointer to storage for the column filter image.</param>
        /// <param name="span">Pointer to storage for the span filter image (currently unused).</param>
        public static void GetSeparableFilter(int target, int format, int type, IntPtr row, IntPtr column, IntPtr span)
        {
            if (gl._GetSeparableFilter != null) gl._GetSeparableFilter(target, format, type, row, column, span); else { }
        }
        /// <summary>
        /// <para>Fullname: Histogram</para>
        /// </summary>
        [GLEntry("Histogram", Category = "1.2", Alias = "HistogramEXT ")]
        public static GLDelegate.Histogram _Histogram = null;
        public static GLDelegate.Histogram HistogramEXT = Histogram;
        /// <summary>
        /// <para>define histogram table</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Histogram.</para>
        /// <para>Fullname: Histogram</para>
        /// <para>Aliases: HistogramEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_histogram</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">The histogram whose parameters are to be set. Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.</param>
        /// <param name="width">The number of entries in the histogram table. Must be a power of 2.</param>
        /// <param name="internalformat">The format of entries in the histogram table. Must be one of GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.</param>
        /// <param name="sink">If GL_TRUE, pixels will be consumed by the histogramming process and no drawing or texture loading will take place. If GL_FALSE, pixels will proceed to the minmax process after histogramming.</param>
        public static void Histogram(int target, int width, int internalformat, bool sink)
        {
            if (gl._Histogram != null) gl._Histogram(target, width, internalformat, sink); else { }
        }
        /// <summary>
        /// <para>Fullname: Minmax</para>
        /// </summary>
        [GLEntry("Minmax", Category = "1.2", Alias = "MinmaxEXT ")]
        public static GLDelegate.Minmax _Minmax = null;
        public static GLDelegate.Minmax MinmaxEXT = Minmax;
        /// <summary>
        /// <para>define minmax table</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Minmax.</para>
        /// <para>Fullname: Minmax</para>
        /// <para>Aliases: MinmaxEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_histogram</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">The minmax table whose parameters are to be set. Must be GL_MINMAX.</param>
        /// <param name="internalformat">The format of entries in the minmax table. Must be one of GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.</param>
        /// <param name="sink">If GL_TRUE, pixels will be consumed by the minmax process and no drawing or texture loading will take place. If GL_FALSE, pixels will proceed to the final conversion process after minmax.</param>
        public static void Minmax(int target, int internalformat, bool sink)
        {
            if (gl._Minmax != null) gl._Minmax(target, internalformat, sink); else { }
        }
        /// <summary>
        /// <para>Fullname: ResetHistogram</para>
        /// </summary>
        [GLEntry("ResetHistogram", Category = "1.2", Alias = "ResetHistogramEXT ")]
        public static GLDelegate.ResetHistogram _ResetHistogram = null;
        public static GLDelegate.ResetHistogram ResetHistogramEXT = ResetHistogram;
        /// <summary>
        /// <para>reset histogram table entries to zero</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ResetHistogram.</para>
        /// <para>Fullname: ResetHistogram</para>
        /// <para>Aliases: ResetHistogramEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_histogram</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be GL_HISTOGRAM.</param>
        public static void ResetHistogram(int target)
        {
            if (gl._ResetHistogram != null) gl._ResetHistogram(target); else { }
        }
        /// <summary>
        /// <para>Fullname: ResetMinmax</para>
        /// </summary>
        [GLEntry("ResetMinmax", Category = "1.2", Alias = "ResetMinmaxEXT ")]
        public static GLDelegate.ResetMinmax _ResetMinmax = null;
        public static GLDelegate.ResetMinmax ResetMinmaxEXT = ResetMinmax;
        /// <summary>
        /// <para>reset minmax table entries to initial values</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ResetMinmax.</para>
        /// <para>Fullname: ResetMinmax</para>
        /// <para>Aliases: ResetMinmaxEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_histogram</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be GL_MINMAX.</param>
        public static void ResetMinmax(int target)
        {
            if (gl._ResetMinmax != null) gl._ResetMinmax(target); else { }
        }
        /// <summary>
        /// <para>Fullname: SeparableFilter2D</para>
        /// </summary>
        [GLEntry("SeparableFilter2D", Category = "1.2", Alias = "SeparableFilter2DEXT ")]
        public static GLDelegate.SeparableFilter2D _SeparableFilter2D = null;
        public static GLDelegate.SeparableFilter2D SeparableFilter2DEXT = SeparableFilter2D;
        /// <summary>
        /// <para>define a separable two-dimensional convolution filter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SeparableFilter2D.</para>
        /// <para>Fullname: SeparableFilter2D</para>
        /// <para>Aliases: SeparableFilter2DEXT, </para>
        /// <para>Extensions: VERSION_1_2_DEPRECATED EXT_convolution</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Must be GL_SEPARABLE_2D.</param>
        /// <param name="internalformat">The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.</param>
        /// <param name="width">The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)</param>
        /// <param name="height">The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)</param>
        /// <param name="format">The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.</param>
        /// <param name="type">The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.</param>
        /// <param name="row">Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.</param>
        /// <param name="column">Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.</param>
        public static void SeparableFilter2D(int target, int internalformat, int width, int height, int format, int type, IntPtr row, IntPtr column)
        {
            if (gl._SeparableFilter2D != null) gl._SeparableFilter2D(target, internalformat, width, height, format, type, row, column); else { }
        }
        /// <summary>
        /// <para>Fullname: TexImage3D</para>
        /// </summary>
        [GLEntry("TexImage3D", Category = "1.2", Alias = "TexImage3DEXT ")]
        public static GLDelegate.TexImage3D _TexImage3D = null;
        public static GLDelegate.TexImage3D TexImage3DEXT = TexImage3D;
        /// <summary>
        /// <para>specify a three-dimensional texture image</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexImage3D.</para>
        /// <para>Fullname: TexImage3D</para>
        /// <para>Aliases: TexImage3DEXT, </para>
        /// <para>Extensions: VERSION_1_2 EXT_texture3D</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="internalFormat">Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.</param>
        /// <param name="width">Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.</param>
        /// <param name="height">Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.</param>
        /// <param name="depth">Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.</param>
        /// <param name="border">This value must be 0.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="data">Specifies a pointer to the image data in memory.</param>
        public static void TexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, IntPtr pixels)
        {
            if (gl._TexImage3D != null) gl._TexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>specify a three-dimensional texture image</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexImage3D.</para>
        /// <para>Fullname: TexImage3D</para>
        /// <para>Aliases: TexImage3DEXT, </para>
        /// <para>Extensions: VERSION_1_2 EXT_texture3D</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="internalFormat">Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.</param>
        /// <param name="width">Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.</param>
        /// <param name="height">Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.</param>
        /// <param name="depth">Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.</param>
        /// <param name="border">This value must be 0.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="data">Specifies a pointer to the image data in memory.</param>
        public static void TexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._TexImage3D != null) gl._TexImage3D(target, level, internalformat, width, height, depth, border, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: TexSubImage3D</para>
        /// </summary>
        [GLEntry("TexSubImage3D", Category = "1.2", Alias = "TexSubImage3DEXT ")]
        public static GLDelegate.TexSubImage3D _TexSubImage3D = null;
        public static GLDelegate.TexSubImage3D TexSubImage3DEXT = TexSubImage3D;
        /// <summary>
        /// <para>specify a three-dimensional texture subimage</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexSubImage3D.</para>
        /// <para>Fullname: TexSubImage3D</para>
        /// <para>Aliases: TexSubImage3DEXT, </para>
        /// <para>Extensions: VERSION_1_2 EXT_texture3D</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="data">Specifies a pointer to the image data in memory.</param>
        public static void TexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, IntPtr pixels)
        {
            if (gl._TexSubImage3D != null) gl._TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>specify a three-dimensional texture subimage</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexSubImage3D.</para>
        /// <para>Fullname: TexSubImage3D</para>
        /// <para>Aliases: TexSubImage3DEXT, </para>
        /// <para>Extensions: VERSION_1_2 EXT_texture3D</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="data">Specifies a pointer to the image data in memory.</param>
        public static void TexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._TexSubImage3D != null) gl._TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: ActiveTexture</para>
        /// </summary>
        [GLEntry("ActiveTexture", Category = "1.3", Alias = "ActiveTextureARB ")]
        public static GLDelegate.ActiveTexture _ActiveTexture = null;
        public static GLDelegate.ActiveTexture ActiveTextureARB = ActiveTexture;
        /// <summary>
        /// <para>select active texture unit</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ActiveTexture.</para>
        /// <para>Fullname: ActiveTexture</para>
        /// <para>Aliases: ActiveTextureARB, </para>
        /// <para>Extensions: VERSION_1_3 ARB_multitexture</para>
        /// </summary>
        /// <param name="texture">Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least 80. texture must be one of GL_TEXTUREi, where i ranges from 0 (GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1). The initial value is GL_TEXTURE0.</param>
        public static void ActiveTexture(int texture)
        {
            if (gl._ActiveTexture != null) gl._ActiveTexture(texture); else { }
        }
        /// <summary>
        /// <para>Fullname: ClientActiveTexture</para>
        /// </summary>
        [GLEntry("ClientActiveTexture", Category = "1.3", Alias = "ClientActiveTextureARB ")]
        public static GLDelegate.ClientActiveTexture _ClientActiveTexture = null;
        public static GLDelegate.ClientActiveTexture ClientActiveTextureARB = ClientActiveTexture;
        /// <summary>
        /// <para>select active texture unit</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClientActiveTexture.</para>
        /// <para>Fullname: ClientActiveTexture</para>
        /// <para>Aliases: ClientActiveTextureARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="texture">Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least two. texture must be one of GL_TEXTUREi, where i ranges from 0 to the value of GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. The initial value is GL_TEXTURE0.</param>
        public static void ClientActiveTexture(int texture)
        {
            if (gl._ClientActiveTexture != null) gl._ClientActiveTexture(texture); else { }
        }
        /// <summary>
        /// <para>Fullname: CompressedTexImage1D</para>
        /// </summary>
        [GLEntry("CompressedTexImage1D", Category = "1.3", Alias = "CompressedTexImage1DARB ")]
        public static GLDelegate.CompressedTexImage1D _CompressedTexImage1D = null;
        public static GLDelegate.CompressedTexImage1D CompressedTexImage1DARB = CompressedTexImage1D;
        /// <summary>
        /// <para>specify a one-dimensional texture image in a compressed format</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTexImage1D.</para>
        /// <para>Fullname: CompressedTexImage1D</para>
        /// <para>Aliases: CompressedTexImage1DARB, </para>
        /// <para>Extensions: VERSION_1_3 ARB_texture_compression</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="internalformat">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="width">Specifies the width of the texture image. All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1.</param>
        /// <param name="border">This value must be 0.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        public static void CompressedTexImage1D(int target, int level, int internalformat, int width, int border, int imageSize, IntPtr data)
        {
            if (gl._CompressedTexImage1D != null) gl._CompressedTexImage1D(target, level, internalformat, width, border, imageSize, data); else { }
        }
        /// <summary>
        /// <para>specify a one-dimensional texture image in a compressed format</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTexImage1D.</para>
        /// <para>Fullname: CompressedTexImage1D</para>
        /// <para>Aliases: CompressedTexImage1DARB, </para>
        /// <para>Extensions: VERSION_1_3 ARB_texture_compression</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="internalformat">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="width">Specifies the width of the texture image. All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1.</param>
        /// <param name="border">This value must be 0.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        public static void CompressedTexImage1D(int target, int level, int internalformat, int width, int border, int imageSize, Array data)
        {
            GCHandle h = GCHandle.Alloc(data, GCHandleType.Pinned);
            try { if (gl._CompressedTexImage1D != null) gl._CompressedTexImage1D(target, level, internalformat, width, border, imageSize, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: CompressedTexImage2D</para>
        /// </summary>
        [GLEntry("CompressedTexImage2D", Category = "1.3", Alias = "CompressedTexImage2DARB ")]
        public static GLDelegate.CompressedTexImage2D _CompressedTexImage2D = null;
        public static GLDelegate.CompressedTexImage2D CompressedTexImage2DARB = CompressedTexImage2D;
        /// <summary>
        /// <para>specify a two-dimensional texture image in a compressed format</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTexImage2D.</para>
        /// <para>Fullname: CompressedTexImage2D</para>
        /// <para>Aliases: CompressedTexImage2DARB, </para>
        /// <para>Extensions: VERSION_1_3 ARB_texture_compression</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="internalformat">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="width">Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide.</param>
        /// <param name="height">Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high.</param>
        /// <param name="border">This value must be 0.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        public static void CompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, IntPtr data)
        {
            if (gl._CompressedTexImage2D != null) gl._CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data); else { }
        }
        /// <summary>
        /// <para>specify a two-dimensional texture image in a compressed format</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTexImage2D.</para>
        /// <para>Fullname: CompressedTexImage2D</para>
        /// <para>Aliases: CompressedTexImage2DARB, </para>
        /// <para>Extensions: VERSION_1_3 ARB_texture_compression</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="internalformat">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="width">Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide.</param>
        /// <param name="height">Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high.</param>
        /// <param name="border">This value must be 0.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        public static void CompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, Array data)
        {
            GCHandle h = GCHandle.Alloc(data, GCHandleType.Pinned);
            try { if (gl._CompressedTexImage2D != null) gl._CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: CompressedTexImage3D</para>
        /// </summary>
        [GLEntry("CompressedTexImage3D", Category = "1.3", Alias = "CompressedTexImage3DARB ")]
        public static GLDelegate.CompressedTexImage3D _CompressedTexImage3D = null;
        public static GLDelegate.CompressedTexImage3D CompressedTexImage3DARB = CompressedTexImage3D;
        /// <summary>
        /// <para>specify a three-dimensional texture image in a compressed format</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTexImage3D.</para>
        /// <para>Fullname: CompressedTexImage3D</para>
        /// <para>Aliases: CompressedTexImage3DARB, </para>
        /// <para>Extensions: VERSION_1_3 ARB_texture_compression</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="internalformat">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="width">Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.</param>
        /// <param name="height">Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.</param>
        /// <param name="depth">Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.</param>
        /// <param name="border">This value must be 0.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        public static void CompressedTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, IntPtr data)
        {
            if (gl._CompressedTexImage3D != null) gl._CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data); else { }
        }
        /// <summary>
        /// <para>specify a three-dimensional texture image in a compressed format</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTexImage3D.</para>
        /// <para>Fullname: CompressedTexImage3D</para>
        /// <para>Aliases: CompressedTexImage3DARB, </para>
        /// <para>Extensions: VERSION_1_3 ARB_texture_compression</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="internalformat">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="width">Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.</param>
        /// <param name="height">Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.</param>
        /// <param name="depth">Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.</param>
        /// <param name="border">This value must be 0.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        public static void CompressedTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Array data)
        {
            GCHandle h = GCHandle.Alloc(data, GCHandleType.Pinned);
            try { if (gl._CompressedTexImage3D != null) gl._CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: CompressedTexSubImage1D</para>
        /// </summary>
        [GLEntry("CompressedTexSubImage1D", Category = "1.3", Alias = "CompressedTexSubImage1DARB ")]
        public static GLDelegate.CompressedTexSubImage1D _CompressedTexSubImage1D = null;
        public static GLDelegate.CompressedTexSubImage1D CompressedTexSubImage1DARB = CompressedTexSubImage1D;
        /// <summary>
        /// <para>specify a one-dimensional texture subimage in a compressed format</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTexSubImage1D.</para>
        /// <para>Fullname: CompressedTexSubImage1D</para>
        /// <para>Aliases: CompressedTexSubImage1DARB, </para>
        /// <para>Extensions: VERSION_1_3 ARB_texture_compression</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        public static void CompressedTexSubImage1D(int target, int level, int xoffset, int width, int format, int imageSize, IntPtr data)
        {
            if (gl._CompressedTexSubImage1D != null) gl._CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data); else { }
        }
        /// <summary>
        /// <para>specify a one-dimensional texture subimage in a compressed format</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTexSubImage1D.</para>
        /// <para>Fullname: CompressedTexSubImage1D</para>
        /// <para>Aliases: CompressedTexSubImage1DARB, </para>
        /// <para>Extensions: VERSION_1_3 ARB_texture_compression</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        public static void CompressedTexSubImage1D(int target, int level, int xoffset, int width, int format, int imageSize, Array data)
        {
            GCHandle h = GCHandle.Alloc(data, GCHandleType.Pinned);
            try { if (gl._CompressedTexSubImage1D != null) gl._CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: CompressedTexSubImage2D</para>
        /// </summary>
        [GLEntry("CompressedTexSubImage2D", Category = "1.3", Alias = "CompressedTexSubImage2DARB ")]
        public static GLDelegate.CompressedTexSubImage2D _CompressedTexSubImage2D = null;
        public static GLDelegate.CompressedTexSubImage2D CompressedTexSubImage2DARB = CompressedTexSubImage2D;
        /// <summary>
        /// <para>specify a two-dimensional texture subimage in a compressed format</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTexSubImage2D.</para>
        /// <para>Fullname: CompressedTexSubImage2D</para>
        /// <para>Aliases: CompressedTexSubImage2DARB, </para>
        /// <para>Extensions: VERSION_1_3 ARB_texture_compression</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        public static void CompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, IntPtr data)
        {
            if (gl._CompressedTexSubImage2D != null) gl._CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data); else { }
        }
        /// <summary>
        /// <para>specify a two-dimensional texture subimage in a compressed format</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTexSubImage2D.</para>
        /// <para>Fullname: CompressedTexSubImage2D</para>
        /// <para>Aliases: CompressedTexSubImage2DARB, </para>
        /// <para>Extensions: VERSION_1_3 ARB_texture_compression</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        public static void CompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Array data)
        {
            GCHandle h = GCHandle.Alloc(data, GCHandleType.Pinned);
            try { if (gl._CompressedTexSubImage2D != null) gl._CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: CompressedTexSubImage3D</para>
        /// </summary>
        [GLEntry("CompressedTexSubImage3D", Category = "1.3", Alias = "CompressedTexSubImage3DARB ")]
        public static GLDelegate.CompressedTexSubImage3D _CompressedTexSubImage3D = null;
        public static GLDelegate.CompressedTexSubImage3D CompressedTexSubImage3DARB = CompressedTexSubImage3D;
        /// <summary>
        /// <para>specify a three-dimensional texture subimage in a compressed format</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTexSubImage3D.</para>
        /// <para>Fullname: CompressedTexSubImage3D</para>
        /// <para>Aliases: CompressedTexSubImage3DARB, </para>
        /// <para>Extensions: VERSION_1_3 ARB_texture_compression</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_3D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        public static void CompressedTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, IntPtr data)
        {
            if (gl._CompressedTexSubImage3D != null) gl._CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data); else { }
        }
        /// <summary>
        /// <para>specify a three-dimensional texture subimage in a compressed format</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTexSubImage3D.</para>
        /// <para>Fullname: CompressedTexSubImage3D</para>
        /// <para>Aliases: CompressedTexSubImage3DARB, </para>
        /// <para>Extensions: VERSION_1_3 ARB_texture_compression</para>
        /// </summary>
        /// <param name="target">Specifies the target texture. Must be GL_TEXTURE_3D.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        public static void CompressedTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Array data)
        {
            GCHandle h = GCHandle.Alloc(data, GCHandleType.Pinned);
            try { if (gl._CompressedTexSubImage3D != null) gl._CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: GetCompressedTexImage</para>
        /// </summary>
        [GLEntry("GetCompressedTexImage", Category = "1.3", Alias = "GetCompressedTexImageARB ")]
        public static GLDelegate.GetCompressedTexImage _GetCompressedTexImage = null;
        public static GLDelegate.GetCompressedTexImage GetCompressedTexImageARB = GetCompressedTexImage;
        /// <summary>
        /// <para>return a compressed texture image</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetCompressedTexImage.</para>
        /// <para>Fullname: GetCompressedTexImage</para>
        /// <para>Aliases: GetCompressedTexImageARB, </para>
        /// <para>Extensions: VERSION_1_3 ARB_texture_compression</para>
        /// </summary>
        /// <param name="target">Specifies which texture is to be obtained. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z are accepted.</param>
        /// <param name="lod">Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the nth mipmap reduction image.</param>
        /// <param name="img">Returns the compressed texture image.</param>
        public static void GetCompressedTexImage(int target, int level, IntPtr img)
        {
            if (gl._GetCompressedTexImage != null) gl._GetCompressedTexImage(target, level, img); else { }
        }
        /// <summary>
        /// <para>Fullname: LoadTransposeMatrixd</para>
        /// </summary>
        [GLEntry("LoadTransposeMatrixd", Category = "1.3", Alias = "LoadTransposeMatrixdARB ")]
        public static GLDelegate.LoadTransposeMatrixd _LoadTransposeMatrixd = null;
        public static GLDelegate.LoadTransposeMatrixd LoadTransposeMatrixdARB = LoadTransposeMatrixd;
        /// <summary>
        /// <para>replace the current matrix with the specified row-major ordered matrix</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _LoadTransposeMatrixd.</para>
        /// <para>Fullname: LoadTransposeMatrixd</para>
        /// <para>Aliases: LoadTransposeMatrixdARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_transpose_matrix</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="m">Specifies a pointer to 16 consecutive values, which are used as the elements of a 4×4 row-major matrix.</param>
        public static void LoadTransposeMatrixd(double[] m)
        {
            if (gl._LoadTransposeMatrixd != null) gl._LoadTransposeMatrixd(m); else { }
        }
        /// <summary>
        /// <para>Fullname: LoadTransposeMatrixf</para>
        /// </summary>
        [GLEntry("LoadTransposeMatrixf", Category = "1.3", Alias = "LoadTransposeMatrixfARB ")]
        public static GLDelegate.LoadTransposeMatrixf _LoadTransposeMatrixf = null;
        public static GLDelegate.LoadTransposeMatrixf LoadTransposeMatrixfARB = LoadTransposeMatrixf;
        /// <summary>
        /// <para>replace the current matrix with the specified row-major ordered matrix</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _LoadTransposeMatrixf.</para>
        /// <para>Fullname: LoadTransposeMatrixf</para>
        /// <para>Aliases: LoadTransposeMatrixfARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_transpose_matrix</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="m">Specifies a pointer to 16 consecutive values, which are used as the elements of a 4×4 row-major matrix.</param>
        public static void LoadTransposeMatrixf(float[] m)
        {
            if (gl._LoadTransposeMatrixf != null) gl._LoadTransposeMatrixf(m); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord1d</para>
        /// </summary>
        [GLEntry("MultiTexCoord1d", Category = "1.3", Alias = "MultiTexCoord1dARB ")]
        public static GLDelegate.MultiTexCoord1d _MultiTexCoord1d = null;
        public static GLDelegate.MultiTexCoord1d MultiTexCoord1dARB = MultiTexCoord1d;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord1d.</para>
        /// <para>Fullname: MultiTexCoord1d</para>
        /// <para>Aliases: MultiTexCoord1dARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord1d(int target, double s)
        {
            if (gl._MultiTexCoord1d != null) gl._MultiTexCoord1d(target, s); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord1dv</para>
        /// </summary>
        [GLEntry("MultiTexCoord1dv", Category = "1.3", Alias = "MultiTexCoord1dvARB ")]
        public static GLDelegate.MultiTexCoord1dv _MultiTexCoord1dv = null;
        public static GLDelegate.MultiTexCoord1dv MultiTexCoord1dvARB = MultiTexCoord1dv;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord1dv.</para>
        /// <para>Fullname: MultiTexCoord1dv</para>
        /// <para>Aliases: MultiTexCoord1dvARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord1dv(int target, double[] v)
        {
            if (gl._MultiTexCoord1dv != null) gl._MultiTexCoord1dv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord1dv</para>
        /// </summary>
        [GLEntry("MultiTexCoord1dv", Category = "1.3", Alias = "MultiTexCoord1dvARB ")]
        public static GLDelegate.MultiTexCoord1dv_double _MultiTexCoord1dv_double = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord1dv_double.</para>
        /// <para>Fullname: MultiTexCoord1dv</para>
        /// <para>Aliases: MultiTexCoord1dvARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord1dv(int target, ref double v)
        {
            if (gl._MultiTexCoord1dv_double != null) gl._MultiTexCoord1dv_double(target, ref v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord1f</para>
        /// </summary>
        [GLEntry("MultiTexCoord1f", Category = "1.3", Alias = "MultiTexCoord1fARB ")]
        public static GLDelegate.MultiTexCoord1f _MultiTexCoord1f = null;
        public static GLDelegate.MultiTexCoord1f MultiTexCoord1fARB = MultiTexCoord1f;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord1f.</para>
        /// <para>Fullname: MultiTexCoord1f</para>
        /// <para>Aliases: MultiTexCoord1fARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord1f(int target, float s)
        {
            if (gl._MultiTexCoord1f != null) gl._MultiTexCoord1f(target, s); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord1fv</para>
        /// </summary>
        [GLEntry("MultiTexCoord1fv", Category = "1.3", Alias = "MultiTexCoord1fvARB ")]
        public static GLDelegate.MultiTexCoord1fv _MultiTexCoord1fv = null;
        public static GLDelegate.MultiTexCoord1fv MultiTexCoord1fvARB = MultiTexCoord1fv;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord1fv.</para>
        /// <para>Fullname: MultiTexCoord1fv</para>
        /// <para>Aliases: MultiTexCoord1fvARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord1fv(int target, float[] v)
        {
            if (gl._MultiTexCoord1fv != null) gl._MultiTexCoord1fv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord1fv</para>
        /// </summary>
        [GLEntry("MultiTexCoord1fv", Category = "1.3", Alias = "MultiTexCoord1fvARB ")]
        public static GLDelegate.MultiTexCoord1fv_float _MultiTexCoord1fv_float = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord1fv_float.</para>
        /// <para>Fullname: MultiTexCoord1fv</para>
        /// <para>Aliases: MultiTexCoord1fvARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord1fv(int target, ref float v)
        {
            if (gl._MultiTexCoord1fv_float != null) gl._MultiTexCoord1fv_float(target, ref v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord1i</para>
        /// </summary>
        [GLEntry("MultiTexCoord1i", Category = "1.3", Alias = "MultiTexCoord1iARB ")]
        public static GLDelegate.MultiTexCoord1i _MultiTexCoord1i = null;
        public static GLDelegate.MultiTexCoord1i MultiTexCoord1iARB = MultiTexCoord1i;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord1i.</para>
        /// <para>Fullname: MultiTexCoord1i</para>
        /// <para>Aliases: MultiTexCoord1iARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord1i(int target, int s)
        {
            if (gl._MultiTexCoord1i != null) gl._MultiTexCoord1i(target, s); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord1iv</para>
        /// </summary>
        [GLEntry("MultiTexCoord1iv", Category = "1.3", Alias = "MultiTexCoord1ivARB ")]
        public static GLDelegate.MultiTexCoord1iv _MultiTexCoord1iv = null;
        public static GLDelegate.MultiTexCoord1iv MultiTexCoord1ivARB = MultiTexCoord1iv;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord1iv.</para>
        /// <para>Fullname: MultiTexCoord1iv</para>
        /// <para>Aliases: MultiTexCoord1ivARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord1iv(int target, int[] v)
        {
            if (gl._MultiTexCoord1iv != null) gl._MultiTexCoord1iv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord1iv</para>
        /// </summary>
        [GLEntry("MultiTexCoord1iv", Category = "1.3", Alias = "MultiTexCoord1ivARB ")]
        public static GLDelegate.MultiTexCoord1iv_int _MultiTexCoord1iv_int = null;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord1iv_int.</para>
        /// <para>Fullname: MultiTexCoord1iv</para>
        /// <para>Aliases: MultiTexCoord1ivARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord1iv(int target, ref int v)
        {
            if (gl._MultiTexCoord1iv_int != null) gl._MultiTexCoord1iv_int(target, ref v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord1s</para>
        /// </summary>
        [GLEntry("MultiTexCoord1s", Category = "1.3", Alias = "MultiTexCoord1sARB ")]
        public static GLDelegate.MultiTexCoord1s _MultiTexCoord1s = null;
        public static GLDelegate.MultiTexCoord1s MultiTexCoord1sARB = MultiTexCoord1s;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord1s.</para>
        /// <para>Fullname: MultiTexCoord1s</para>
        /// <para>Aliases: MultiTexCoord1sARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord1s(int target, short s)
        {
            if (gl._MultiTexCoord1s != null) gl._MultiTexCoord1s(target, s); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord1sv</para>
        /// </summary>
        [GLEntry("MultiTexCoord1sv", Category = "1.3", Alias = "MultiTexCoord1svARB ")]
        public static GLDelegate.MultiTexCoord1sv _MultiTexCoord1sv = null;
        public static GLDelegate.MultiTexCoord1sv MultiTexCoord1svARB = MultiTexCoord1sv;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord1sv.</para>
        /// <para>Fullname: MultiTexCoord1sv</para>
        /// <para>Aliases: MultiTexCoord1svARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord1sv(int target, short[] v)
        {
            if (gl._MultiTexCoord1sv != null) gl._MultiTexCoord1sv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord2d</para>
        /// </summary>
        [GLEntry("MultiTexCoord2d", Category = "1.3", Alias = "MultiTexCoord2dARB ")]
        public static GLDelegate.MultiTexCoord2d _MultiTexCoord2d = null;
        public static GLDelegate.MultiTexCoord2d MultiTexCoord2dARB = MultiTexCoord2d;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord2d.</para>
        /// <para>Fullname: MultiTexCoord2d</para>
        /// <para>Aliases: MultiTexCoord2dARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord2d(int target, double s, double t)
        {
            if (gl._MultiTexCoord2d != null) gl._MultiTexCoord2d(target, s, t); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord2dv</para>
        /// </summary>
        [GLEntry("MultiTexCoord2dv", Category = "1.3", Alias = "MultiTexCoord2dvARB ")]
        public static GLDelegate.MultiTexCoord2dv _MultiTexCoord2dv = null;
        public static GLDelegate.MultiTexCoord2dv MultiTexCoord2dvARB = MultiTexCoord2dv;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord2dv.</para>
        /// <para>Fullname: MultiTexCoord2dv</para>
        /// <para>Aliases: MultiTexCoord2dvARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord2dv(int target, double[] v)
        {
            if (gl._MultiTexCoord2dv != null) gl._MultiTexCoord2dv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord2f</para>
        /// </summary>
        [GLEntry("MultiTexCoord2f", Category = "1.3", Alias = "MultiTexCoord2fARB ")]
        public static GLDelegate.MultiTexCoord2f _MultiTexCoord2f = null;
        public static GLDelegate.MultiTexCoord2f MultiTexCoord2fARB = MultiTexCoord2f;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord2f.</para>
        /// <para>Fullname: MultiTexCoord2f</para>
        /// <para>Aliases: MultiTexCoord2fARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord2f(int target, float s, float t)
        {
            if (gl._MultiTexCoord2f != null) gl._MultiTexCoord2f(target, s, t); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord2fv</para>
        /// </summary>
        [GLEntry("MultiTexCoord2fv", Category = "1.3", Alias = "MultiTexCoord2fvARB ")]
        public static GLDelegate.MultiTexCoord2fv _MultiTexCoord2fv = null;
        public static GLDelegate.MultiTexCoord2fv MultiTexCoord2fvARB = MultiTexCoord2fv;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord2fv.</para>
        /// <para>Fullname: MultiTexCoord2fv</para>
        /// <para>Aliases: MultiTexCoord2fvARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord2fv(int target, float[] v)
        {
            if (gl._MultiTexCoord2fv != null) gl._MultiTexCoord2fv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord2i</para>
        /// </summary>
        [GLEntry("MultiTexCoord2i", Category = "1.3", Alias = "MultiTexCoord2iARB ")]
        public static GLDelegate.MultiTexCoord2i _MultiTexCoord2i = null;
        public static GLDelegate.MultiTexCoord2i MultiTexCoord2iARB = MultiTexCoord2i;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord2i.</para>
        /// <para>Fullname: MultiTexCoord2i</para>
        /// <para>Aliases: MultiTexCoord2iARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord2i(int target, int s, int t)
        {
            if (gl._MultiTexCoord2i != null) gl._MultiTexCoord2i(target, s, t); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord2iv</para>
        /// </summary>
        [GLEntry("MultiTexCoord2iv", Category = "1.3", Alias = "MultiTexCoord2ivARB ")]
        public static GLDelegate.MultiTexCoord2iv _MultiTexCoord2iv = null;
        public static GLDelegate.MultiTexCoord2iv MultiTexCoord2ivARB = MultiTexCoord2iv;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord2iv.</para>
        /// <para>Fullname: MultiTexCoord2iv</para>
        /// <para>Aliases: MultiTexCoord2ivARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord2iv(int target, int[] v)
        {
            if (gl._MultiTexCoord2iv != null) gl._MultiTexCoord2iv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord2s</para>
        /// </summary>
        [GLEntry("MultiTexCoord2s", Category = "1.3", Alias = "MultiTexCoord2sARB ")]
        public static GLDelegate.MultiTexCoord2s _MultiTexCoord2s = null;
        public static GLDelegate.MultiTexCoord2s MultiTexCoord2sARB = MultiTexCoord2s;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord2s.</para>
        /// <para>Fullname: MultiTexCoord2s</para>
        /// <para>Aliases: MultiTexCoord2sARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord2s(int target, short s, short t)
        {
            if (gl._MultiTexCoord2s != null) gl._MultiTexCoord2s(target, s, t); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord2sv</para>
        /// </summary>
        [GLEntry("MultiTexCoord2sv", Category = "1.3", Alias = "MultiTexCoord2svARB ")]
        public static GLDelegate.MultiTexCoord2sv _MultiTexCoord2sv = null;
        public static GLDelegate.MultiTexCoord2sv MultiTexCoord2svARB = MultiTexCoord2sv;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord2sv.</para>
        /// <para>Fullname: MultiTexCoord2sv</para>
        /// <para>Aliases: MultiTexCoord2svARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord2sv(int target, short[] v)
        {
            if (gl._MultiTexCoord2sv != null) gl._MultiTexCoord2sv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord3d</para>
        /// </summary>
        [GLEntry("MultiTexCoord3d", Category = "1.3", Alias = "MultiTexCoord3dARB ")]
        public static GLDelegate.MultiTexCoord3d _MultiTexCoord3d = null;
        public static GLDelegate.MultiTexCoord3d MultiTexCoord3dARB = MultiTexCoord3d;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord3d.</para>
        /// <para>Fullname: MultiTexCoord3d</para>
        /// <para>Aliases: MultiTexCoord3dARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord3d(int target, double s, double t, double r)
        {
            if (gl._MultiTexCoord3d != null) gl._MultiTexCoord3d(target, s, t, r); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord3dv</para>
        /// </summary>
        [GLEntry("MultiTexCoord3dv", Category = "1.3", Alias = "MultiTexCoord3dvARB ")]
        public static GLDelegate.MultiTexCoord3dv _MultiTexCoord3dv = null;
        public static GLDelegate.MultiTexCoord3dv MultiTexCoord3dvARB = MultiTexCoord3dv;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord3dv.</para>
        /// <para>Fullname: MultiTexCoord3dv</para>
        /// <para>Aliases: MultiTexCoord3dvARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord3dv(int target, double[] v)
        {
            if (gl._MultiTexCoord3dv != null) gl._MultiTexCoord3dv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord3f</para>
        /// </summary>
        [GLEntry("MultiTexCoord3f", Category = "1.3", Alias = "MultiTexCoord3fARB ")]
        public static GLDelegate.MultiTexCoord3f _MultiTexCoord3f = null;
        public static GLDelegate.MultiTexCoord3f MultiTexCoord3fARB = MultiTexCoord3f;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord3f.</para>
        /// <para>Fullname: MultiTexCoord3f</para>
        /// <para>Aliases: MultiTexCoord3fARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord3f(int target, float s, float t, float r)
        {
            if (gl._MultiTexCoord3f != null) gl._MultiTexCoord3f(target, s, t, r); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord3fv</para>
        /// </summary>
        [GLEntry("MultiTexCoord3fv", Category = "1.3", Alias = "MultiTexCoord3fvARB ")]
        public static GLDelegate.MultiTexCoord3fv _MultiTexCoord3fv = null;
        public static GLDelegate.MultiTexCoord3fv MultiTexCoord3fvARB = MultiTexCoord3fv;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord3fv.</para>
        /// <para>Fullname: MultiTexCoord3fv</para>
        /// <para>Aliases: MultiTexCoord3fvARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord3fv(int target, float[] v)
        {
            if (gl._MultiTexCoord3fv != null) gl._MultiTexCoord3fv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord3i</para>
        /// </summary>
        [GLEntry("MultiTexCoord3i", Category = "1.3", Alias = "MultiTexCoord3iARB ")]
        public static GLDelegate.MultiTexCoord3i _MultiTexCoord3i = null;
        public static GLDelegate.MultiTexCoord3i MultiTexCoord3iARB = MultiTexCoord3i;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord3i.</para>
        /// <para>Fullname: MultiTexCoord3i</para>
        /// <para>Aliases: MultiTexCoord3iARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord3i(int target, int s, int t, int r)
        {
            if (gl._MultiTexCoord3i != null) gl._MultiTexCoord3i(target, s, t, r); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord3iv</para>
        /// </summary>
        [GLEntry("MultiTexCoord3iv", Category = "1.3", Alias = "MultiTexCoord3ivARB ")]
        public static GLDelegate.MultiTexCoord3iv _MultiTexCoord3iv = null;
        public static GLDelegate.MultiTexCoord3iv MultiTexCoord3ivARB = MultiTexCoord3iv;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord3iv.</para>
        /// <para>Fullname: MultiTexCoord3iv</para>
        /// <para>Aliases: MultiTexCoord3ivARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord3iv(int target, int[] v)
        {
            if (gl._MultiTexCoord3iv != null) gl._MultiTexCoord3iv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord3s</para>
        /// </summary>
        [GLEntry("MultiTexCoord3s", Category = "1.3", Alias = "MultiTexCoord3sARB ")]
        public static GLDelegate.MultiTexCoord3s _MultiTexCoord3s = null;
        public static GLDelegate.MultiTexCoord3s MultiTexCoord3sARB = MultiTexCoord3s;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord3s.</para>
        /// <para>Fullname: MultiTexCoord3s</para>
        /// <para>Aliases: MultiTexCoord3sARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord3s(int target, short s, short t, short r)
        {
            if (gl._MultiTexCoord3s != null) gl._MultiTexCoord3s(target, s, t, r); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord3sv</para>
        /// </summary>
        [GLEntry("MultiTexCoord3sv", Category = "1.3", Alias = "MultiTexCoord3svARB ")]
        public static GLDelegate.MultiTexCoord3sv _MultiTexCoord3sv = null;
        public static GLDelegate.MultiTexCoord3sv MultiTexCoord3svARB = MultiTexCoord3sv;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord3sv.</para>
        /// <para>Fullname: MultiTexCoord3sv</para>
        /// <para>Aliases: MultiTexCoord3svARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord3sv(int target, short[] v)
        {
            if (gl._MultiTexCoord3sv != null) gl._MultiTexCoord3sv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord4d</para>
        /// </summary>
        [GLEntry("MultiTexCoord4d", Category = "1.3", Alias = "MultiTexCoord4dARB ")]
        public static GLDelegate.MultiTexCoord4d _MultiTexCoord4d = null;
        public static GLDelegate.MultiTexCoord4d MultiTexCoord4dARB = MultiTexCoord4d;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord4d.</para>
        /// <para>Fullname: MultiTexCoord4d</para>
        /// <para>Aliases: MultiTexCoord4dARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord4d(int target, double s, double t, double r, double q)
        {
            if (gl._MultiTexCoord4d != null) gl._MultiTexCoord4d(target, s, t, r, q); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord4dv</para>
        /// </summary>
        [GLEntry("MultiTexCoord4dv", Category = "1.3", Alias = "MultiTexCoord4dvARB ")]
        public static GLDelegate.MultiTexCoord4dv _MultiTexCoord4dv = null;
        public static GLDelegate.MultiTexCoord4dv MultiTexCoord4dvARB = MultiTexCoord4dv;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord4dv.</para>
        /// <para>Fullname: MultiTexCoord4dv</para>
        /// <para>Aliases: MultiTexCoord4dvARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord4dv(int target, double[] v)
        {
            if (gl._MultiTexCoord4dv != null) gl._MultiTexCoord4dv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord4f</para>
        /// </summary>
        [GLEntry("MultiTexCoord4f", Category = "1.3", Alias = "MultiTexCoord4fARB ")]
        public static GLDelegate.MultiTexCoord4f _MultiTexCoord4f = null;
        public static GLDelegate.MultiTexCoord4f MultiTexCoord4fARB = MultiTexCoord4f;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord4f.</para>
        /// <para>Fullname: MultiTexCoord4f</para>
        /// <para>Aliases: MultiTexCoord4fARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord4f(int target, float s, float t, float r, float q)
        {
            if (gl._MultiTexCoord4f != null) gl._MultiTexCoord4f(target, s, t, r, q); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord4fv</para>
        /// </summary>
        [GLEntry("MultiTexCoord4fv", Category = "1.3", Alias = "MultiTexCoord4fvARB ")]
        public static GLDelegate.MultiTexCoord4fv _MultiTexCoord4fv = null;
        public static GLDelegate.MultiTexCoord4fv MultiTexCoord4fvARB = MultiTexCoord4fv;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord4fv.</para>
        /// <para>Fullname: MultiTexCoord4fv</para>
        /// <para>Aliases: MultiTexCoord4fvARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord4fv(int target, float[] v)
        {
            if (gl._MultiTexCoord4fv != null) gl._MultiTexCoord4fv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord4i</para>
        /// </summary>
        [GLEntry("MultiTexCoord4i", Category = "1.3", Alias = "MultiTexCoord4iARB ")]
        public static GLDelegate.MultiTexCoord4i _MultiTexCoord4i = null;
        public static GLDelegate.MultiTexCoord4i MultiTexCoord4iARB = MultiTexCoord4i;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord4i.</para>
        /// <para>Fullname: MultiTexCoord4i</para>
        /// <para>Aliases: MultiTexCoord4iARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord4i(int target, int s, int t, int r, int q)
        {
            if (gl._MultiTexCoord4i != null) gl._MultiTexCoord4i(target, s, t, r, q); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord4iv</para>
        /// </summary>
        [GLEntry("MultiTexCoord4iv", Category = "1.3", Alias = "MultiTexCoord4ivARB ")]
        public static GLDelegate.MultiTexCoord4iv _MultiTexCoord4iv = null;
        public static GLDelegate.MultiTexCoord4iv MultiTexCoord4ivARB = MultiTexCoord4iv;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord4iv.</para>
        /// <para>Fullname: MultiTexCoord4iv</para>
        /// <para>Aliases: MultiTexCoord4ivARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord4iv(int target, int[] v)
        {
            if (gl._MultiTexCoord4iv != null) gl._MultiTexCoord4iv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord4s</para>
        /// </summary>
        [GLEntry("MultiTexCoord4s", Category = "1.3", Alias = "MultiTexCoord4sARB ")]
        public static GLDelegate.MultiTexCoord4s _MultiTexCoord4s = null;
        public static GLDelegate.MultiTexCoord4s MultiTexCoord4sARB = MultiTexCoord4s;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord4s.</para>
        /// <para>Fullname: MultiTexCoord4s</para>
        /// <para>Aliases: MultiTexCoord4sARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord4s(int target, short s, short t, short r, short q)
        {
            if (gl._MultiTexCoord4s != null) gl._MultiTexCoord4s(target, s, t, r, q); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord4sv</para>
        /// </summary>
        [GLEntry("MultiTexCoord4sv", Category = "1.3", Alias = "MultiTexCoord4svARB ")]
        public static GLDelegate.MultiTexCoord4sv _MultiTexCoord4sv = null;
        public static GLDelegate.MultiTexCoord4sv MultiTexCoord4svARB = MultiTexCoord4sv;
        /// <summary>
        /// <para>set the current texture coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord4sv.</para>
        /// <para>Fullname: MultiTexCoord4sv</para>
        /// <para>Aliases: MultiTexCoord4svARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_multitexture</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="target">Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.</param>
        /// <param name="s">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="t">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="r">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        /// <param name="q">Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.</param>
        public static void MultiTexCoord4sv(int target, short[] v)
        {
            if (gl._MultiTexCoord4sv != null) gl._MultiTexCoord4sv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultTransposeMatrixd</para>
        /// </summary>
        [GLEntry("MultTransposeMatrixd", Category = "1.3", Alias = "MultTransposeMatrixdARB ")]
        public static GLDelegate.MultTransposeMatrixd _MultTransposeMatrixd = null;
        public static GLDelegate.MultTransposeMatrixd MultTransposeMatrixdARB = MultTransposeMatrixd;
        /// <summary>
        /// <para>multiply the current matrix with the specified row-major ordered matrix</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultTransposeMatrixd.</para>
        /// <para>Fullname: MultTransposeMatrixd</para>
        /// <para>Aliases: MultTransposeMatrixdARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_transpose_matrix</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="m">Points to 16 consecutive values that are used as the elements of a 4×4 row-major matrix.</param>
        public static void MultTransposeMatrixd(double[] m)
        {
            if (gl._MultTransposeMatrixd != null) gl._MultTransposeMatrixd(m); else { }
        }
        /// <summary>
        /// <para>Fullname: MultTransposeMatrixf</para>
        /// </summary>
        [GLEntry("MultTransposeMatrixf", Category = "1.3", Alias = "MultTransposeMatrixfARB ")]
        public static GLDelegate.MultTransposeMatrixf _MultTransposeMatrixf = null;
        public static GLDelegate.MultTransposeMatrixf MultTransposeMatrixfARB = MultTransposeMatrixf;
        /// <summary>
        /// <para>multiply the current matrix with the specified row-major ordered matrix</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultTransposeMatrixf.</para>
        /// <para>Fullname: MultTransposeMatrixf</para>
        /// <para>Aliases: MultTransposeMatrixfARB, </para>
        /// <para>Extensions: VERSION_1_3_DEPRECATED ARB_transpose_matrix</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="m">Points to 16 consecutive values that are used as the elements of a 4×4 row-major matrix.</param>
        public static void MultTransposeMatrixf(float[] m)
        {
            if (gl._MultTransposeMatrixf != null) gl._MultTransposeMatrixf(m); else { }
        }
        /// <summary>
        /// <para>Fullname: SampleCoverage</para>
        /// </summary>
        [GLEntry("SampleCoverage", Category = "1.3", Alias = "SampleCoverageARB ")]
        public static GLDelegate.SampleCoverage _SampleCoverage = null;
        public static GLDelegate.SampleCoverage SampleCoverageARB = SampleCoverage;
        /// <summary>
        /// <para>specify multisample coverage parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SampleCoverage.</para>
        /// <para>Fullname: SampleCoverage</para>
        /// <para>Aliases: SampleCoverageARB, </para>
        /// <para>Extensions: VERSION_1_3 ARB_multisample</para>
        /// </summary>
        /// <param name="value">Specify a single floating-point sample coverage value. The value is clamped to the range 01. The initial value is 1.0.</param>
        /// <param name="invert">Specify a single boolean value representing if the coverage masks should be inverted. GL_TRUE and GL_FALSE are accepted. The initial value is GL_FALSE.</param>
        public static void SampleCoverage(float value, bool invert)
        {
            if (gl._SampleCoverage != null) gl._SampleCoverage(value, invert); else { }
        }
        /// <summary>
        /// <para>Fullname: BlendFuncSeparate</para>
        /// </summary>
        [GLEntry("BlendFuncSeparate", Category = "1.4", Alias = "BlendFuncSeparateEXT BlendFuncSeparateINGR ")]
        public static GLDelegate.BlendFuncSeparate _BlendFuncSeparate = null;
        public static GLDelegate.BlendFuncSeparate BlendFuncSeparateEXT = BlendFuncSeparate;
        public static GLDelegate.BlendFuncSeparate BlendFuncSeparateINGR = BlendFuncSeparate;
        /// <summary>
        /// <para>specify pixel arithmetic for RGB and alpha components separately</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BlendFuncSeparate.</para>
        /// <para>Fullname: BlendFuncSeparate</para>
        /// <para>Aliases: BlendFuncSeparateEXT, BlendFuncSeparateINGR, </para>
        /// <para>Extensions: VERSION_1_4 EXT_blend_func_separate INGR_blend_func_separate</para>
        /// </summary>
        /// <param name="buf">For glBlendFuncSeparatei, specifies the index of the draw buffer for which to set the blend functions.</param>
        /// <param name="srcRGB">Specifies how the red, green, and blue blending factors are computed. The initial value is GL_ONE.</param>
        /// <param name="dstRGB">Specifies how the red, green, and blue destination blending factors are computed. The initial value is GL_ZERO.</param>
        /// <param name="srcAlpha">Specified how the alpha source blending factor is computed. The initial value is GL_ONE.</param>
        /// <param name="dstAlpha">Specified how the alpha destination blending factor is computed. The initial value is GL_ZERO.</param>
        public static void BlendFuncSeparate(int sfactorRGB, int dfactorRGB, int sfactorAlpha, int dfactorAlpha)
        {
            if (gl._BlendFuncSeparate != null) gl._BlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha); else { }
        }
        /// <summary>
        /// <para>Fullname: FogCoordd</para>
        /// </summary>
        [GLEntry("FogCoordd", Category = "1.4", Alias = "FogCoorddEXT ")]
        public static GLDelegate.FogCoordd _FogCoordd = null;
        public static GLDelegate.FogCoordd FogCoorddEXT = FogCoordd;
        /// <summary>
        /// <para>set the current fog coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FogCoordd.</para>
        /// <para>Fullname: FogCoordd</para>
        /// <para>Aliases: FogCoorddEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_fog_coord</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="coord">Specify the fog distance.</param>
        public static void FogCoordd(double coord)
        {
            if (gl._FogCoordd != null) gl._FogCoordd(coord); else { }
        }
        /// <summary>
        /// <para>Fullname: FogCoorddv</para>
        /// </summary>
        [GLEntry("FogCoorddv", Category = "1.4", Alias = "FogCoorddvEXT ")]
        public static GLDelegate.FogCoorddv_double _FogCoorddv_double = null;
        /// <summary>
        /// <para>set the current fog coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FogCoorddv_double.</para>
        /// <para>Fullname: FogCoorddv</para>
        /// <para>Aliases: FogCoorddvEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_fog_coord</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="coord">Specify the fog distance.</param>
        public static void FogCoorddv(ref double coord)
        {
            if (gl._FogCoorddv_double != null) gl._FogCoorddv_double(ref coord); else { }
        }
        /// <summary>
        /// <para>Fullname: FogCoorddv</para>
        /// </summary>
        [GLEntry("FogCoorddv", Category = "1.4", Alias = "FogCoorddvEXT ")]
        public static GLDelegate.FogCoorddv _FogCoorddv = null;
        public static GLDelegate.FogCoorddv FogCoorddvEXT = FogCoorddv;
        /// <summary>
        /// <para>set the current fog coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FogCoorddv.</para>
        /// <para>Fullname: FogCoorddv</para>
        /// <para>Aliases: FogCoorddvEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_fog_coord</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="coord">Specify the fog distance.</param>
        public static void FogCoorddv(double[] coord)
        {
            if (gl._FogCoorddv != null) gl._FogCoorddv(coord); else { }
        }
        /// <summary>
        /// <para>Fullname: FogCoordf</para>
        /// </summary>
        [GLEntry("FogCoordf", Category = "1.4", Alias = "FogCoordfEXT ")]
        public static GLDelegate.FogCoordf _FogCoordf = null;
        public static GLDelegate.FogCoordf FogCoordfEXT = FogCoordf;
        /// <summary>
        /// <para>set the current fog coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FogCoordf.</para>
        /// <para>Fullname: FogCoordf</para>
        /// <para>Aliases: FogCoordfEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_fog_coord</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="coord">Specify the fog distance.</param>
        public static void FogCoordf(float coord)
        {
            if (gl._FogCoordf != null) gl._FogCoordf(coord); else { }
        }
        /// <summary>
        /// <para>Fullname: FogCoordfv</para>
        /// </summary>
        [GLEntry("FogCoordfv", Category = "1.4", Alias = "FogCoordfvEXT ")]
        public static GLDelegate.FogCoordfv _FogCoordfv = null;
        public static GLDelegate.FogCoordfv FogCoordfvEXT = FogCoordfv;
        /// <summary>
        /// <para>set the current fog coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FogCoordfv.</para>
        /// <para>Fullname: FogCoordfv</para>
        /// <para>Aliases: FogCoordfvEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_fog_coord</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="coord">Specify the fog distance.</param>
        public static void FogCoordfv(float[] coord)
        {
            if (gl._FogCoordfv != null) gl._FogCoordfv(coord); else { }
        }
        /// <summary>
        /// <para>Fullname: FogCoordfv</para>
        /// </summary>
        [GLEntry("FogCoordfv", Category = "1.4", Alias = "FogCoordfvEXT ")]
        public static GLDelegate.FogCoordfv_float _FogCoordfv_float = null;
        /// <summary>
        /// <para>set the current fog coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FogCoordfv_float.</para>
        /// <para>Fullname: FogCoordfv</para>
        /// <para>Aliases: FogCoordfvEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_fog_coord</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="coord">Specify the fog distance.</param>
        public static void FogCoordfv(ref float coord)
        {
            if (gl._FogCoordfv_float != null) gl._FogCoordfv_float(ref coord); else { }
        }
        /// <summary>
        /// <para>Fullname: FogCoordPointer</para>
        /// </summary>
        [GLEntry("FogCoordPointer", Category = "1.4", Alias = "FogCoordPointerEXT ")]
        public static GLDelegate.FogCoordPointer _FogCoordPointer = null;
        public static GLDelegate.FogCoordPointer FogCoordPointerEXT = FogCoordPointer;
        /// <summary>
        /// <para>define an array of fog coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FogCoordPointer.</para>
        /// <para>Fullname: FogCoordPointer</para>
        /// <para>Aliases: FogCoordPointerEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_fog_coord</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="type">Specifies the data type of each fog coordinate. Symbolic constants GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive fog coordinates. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.</param>
        /// <param name="pointer">Specifies a pointer to the first coordinate of the first fog coordinate in the array. The initial value is 0.</param>
        public static void FogCoordPointer(int type, int stride, IntPtr pointer)
        {
            if (gl._FogCoordPointer != null) gl._FogCoordPointer(type, stride, pointer); else { }
        }
        /// <summary>
        /// <para>define an array of fog coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FogCoordPointer.</para>
        /// <para>Fullname: FogCoordPointer</para>
        /// <para>Aliases: FogCoordPointerEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_fog_coord</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="type">Specifies the data type of each fog coordinate. Symbolic constants GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive fog coordinates. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.</param>
        /// <param name="pointer">Specifies a pointer to the first coordinate of the first fog coordinate in the array. The initial value is 0.</param>
        public static void FogCoordPointer(int type, int stride, Array pointer)
        {
            GCHandle h = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try { if (gl._FogCoordPointer != null) gl._FogCoordPointer(type, stride, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: MultiDrawArrays</para>
        /// </summary>
        [GLEntry("MultiDrawArrays", Category = "1.4", Alias = "MultiDrawArraysEXT ")]
        public static GLDelegate.MultiDrawArrays _MultiDrawArrays = null;
        public static GLDelegate.MultiDrawArrays MultiDrawArraysEXT = MultiDrawArrays;
        /// <summary>
        /// <para>render multiple sets of primitives from array data</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiDrawArrays.</para>
        /// <para>Fullname: MultiDrawArrays</para>
        /// <para>Aliases: MultiDrawArraysEXT, </para>
        /// <para>Extensions: VERSION_1_4 EXT_multi_draw_arrays</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="first">Points to an array of starting indices in the enabled arrays.</param>
        /// <param name="count">Points to an array of the number of indices to be rendered.</param>
        /// <param name="primcount">Specifies the size of the first and count</param>
        public static void MultiDrawArrays(int mode, int[] first, int[] count, int drawcount)
        {
            if (gl._MultiDrawArrays != null) gl._MultiDrawArrays(mode, first, count, drawcount); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiDrawElements</para>
        /// </summary>
        [GLEntry("MultiDrawElements", Category = "1.4")]
        public static GLDelegate.MultiDrawElements _MultiDrawElements = null;
        /// <summary>
        /// <para>render multiple sets of primitives by specifying indices of array data elements</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiDrawElements.</para>
        /// <para>Fullname: MultiDrawElements</para>
        /// <para>Extensions: VERSION_1_4</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="count">Points to an array of the elements counts.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="primcount">Specifies the size of the count array.</param>
        public static void MultiDrawElements(int mode, int[] count, int type, IntPtr indices, int drawcount)
        {
            if (gl._MultiDrawElements != null) gl._MultiDrawElements(mode, count, type, indices, drawcount); else { }
        }
        /// <summary>
        /// <para>Fullname: PointParameterf</para>
        /// </summary>
        [GLEntry("PointParameterf", Category = "1.4", Alias = "PointParameterfARB PointParameterfEXT PointParameterfSGIS ")]
        public static GLDelegate.PointParameterf _PointParameterf = null;
        public static GLDelegate.PointParameterf PointParameterfARB = PointParameterf;
        public static GLDelegate.PointParameterf PointParameterfEXT = PointParameterf;
        public static GLDelegate.PointParameterf PointParameterfSGIS = PointParameterf;
        /// <summary>
        /// <para>specify point parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PointParameterf.</para>
        /// <para>Fullname: PointParameterf</para>
        /// <para>Aliases: PointParameterfARB, PointParameterfEXT, PointParameterfSGIS, </para>
        /// <para>Extensions: VERSION_1_4 ARB_point_parameters EXT_point_parameters SGIS_point_parameters</para>
        /// </summary>
        /// <param name="pname">Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted.</param>
        /// <param name="param">Specifies the value that pname will be set to.</param>
        public static void PointParameterf(int pname, float param)
        {
            if (gl._PointParameterf != null) gl._PointParameterf(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: PointParameterfv</para>
        /// </summary>
        [GLEntry("PointParameterfv", Category = "1.4", Alias = "PointParameterfvARB PointParameterfvEXT PointParameterfvSGIS ")]
        public static GLDelegate.PointParameterfv _PointParameterfv = null;
        public static GLDelegate.PointParameterfv PointParameterfvARB = PointParameterfv;
        public static GLDelegate.PointParameterfv PointParameterfvEXT = PointParameterfv;
        public static GLDelegate.PointParameterfv PointParameterfvSGIS = PointParameterfv;
        /// <summary>
        /// <para>specify point parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PointParameterfv.</para>
        /// <para>Fullname: PointParameterfv</para>
        /// <para>Aliases: PointParameterfvARB, PointParameterfvEXT, PointParameterfvSGIS, </para>
        /// <para>Extensions: VERSION_1_4 ARB_point_parameters EXT_point_parameters SGIS_point_parameters</para>
        /// </summary>
        /// <param name="pname">Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted.</param>
        /// <param name="param">Specifies the value that pname will be set to.</param>
        public static void PointParameterfv(int pname, float[] param)
        {
            if (gl._PointParameterfv != null) gl._PointParameterfv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: PointParameteri</para>
        /// </summary>
        [GLEntry("PointParameteri", Category = "1.4", Alias = "PointParameteriNV ")]
        public static GLDelegate.PointParameteri _PointParameteri = null;
        public static GLDelegate.PointParameteri PointParameteriNV = PointParameteri;
        /// <summary>
        /// <para>specify point parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PointParameteri.</para>
        /// <para>Fullname: PointParameteri</para>
        /// <para>Aliases: PointParameteriNV, </para>
        /// <para>Extensions: VERSION_1_4 NV_point_sprite</para>
        /// </summary>
        /// <param name="pname">Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted.</param>
        /// <param name="param">Specifies the value that pname will be set to.</param>
        public static void PointParameteri(int pname, int param)
        {
            if (gl._PointParameteri != null) gl._PointParameteri(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: PointParameteriv</para>
        /// </summary>
        [GLEntry("PointParameteriv", Category = "1.4", Alias = "PointParameterivNV ")]
        public static GLDelegate.PointParameteriv _PointParameteriv = null;
        public static GLDelegate.PointParameteriv PointParameterivNV = PointParameteriv;
        /// <summary>
        /// <para>specify point parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PointParameteriv.</para>
        /// <para>Fullname: PointParameteriv</para>
        /// <para>Aliases: PointParameterivNV, </para>
        /// <para>Extensions: VERSION_1_4 NV_point_sprite</para>
        /// </summary>
        /// <param name="pname">Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted.</param>
        /// <param name="param">Specifies the value that pname will be set to.</param>
        public static void PointParameteriv(int pname, int[] param)
        {
            if (gl._PointParameteriv != null) gl._PointParameteriv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColor3b</para>
        /// </summary>
        [GLEntry("SecondaryColor3b", Category = "1.4", Alias = "SecondaryColor3bEXT ")]
        public static GLDelegate.SecondaryColor3b _SecondaryColor3b = null;
        public static GLDelegate.SecondaryColor3b SecondaryColor3bEXT = SecondaryColor3b;
        /// <summary>
        /// <para>set the current secondary color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColor3b.</para>
        /// <para>Fullname: SecondaryColor3b</para>
        /// <para>Aliases: SecondaryColor3bEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_secondary_color</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current secondary color.</param>
        public static void SecondaryColor3b(byte red, byte green, byte blue)
        {
            if (gl._SecondaryColor3b != null) gl._SecondaryColor3b(red, green, blue); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColor3bv</para>
        /// </summary>
        [GLEntry("SecondaryColor3bv", Category = "1.4", Alias = "SecondaryColor3bvEXT ")]
        public static GLDelegate.SecondaryColor3bv _SecondaryColor3bv = null;
        public static GLDelegate.SecondaryColor3bv SecondaryColor3bvEXT = SecondaryColor3bv;
        /// <summary>
        /// <para>set the current secondary color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColor3bv.</para>
        /// <para>Fullname: SecondaryColor3bv</para>
        /// <para>Aliases: SecondaryColor3bvEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_secondary_color</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current secondary color.</param>
        public static void SecondaryColor3bv(byte[] v)
        {
            if (gl._SecondaryColor3bv != null) gl._SecondaryColor3bv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColor3d</para>
        /// </summary>
        [GLEntry("SecondaryColor3d", Category = "1.4", Alias = "SecondaryColor3dEXT ")]
        public static GLDelegate.SecondaryColor3d _SecondaryColor3d = null;
        public static GLDelegate.SecondaryColor3d SecondaryColor3dEXT = SecondaryColor3d;
        /// <summary>
        /// <para>set the current secondary color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColor3d.</para>
        /// <para>Fullname: SecondaryColor3d</para>
        /// <para>Aliases: SecondaryColor3dEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_secondary_color</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current secondary color.</param>
        public static void SecondaryColor3d(double red, double green, double blue)
        {
            if (gl._SecondaryColor3d != null) gl._SecondaryColor3d(red, green, blue); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColor3dv</para>
        /// </summary>
        [GLEntry("SecondaryColor3dv", Category = "1.4", Alias = "SecondaryColor3dvEXT ")]
        public static GLDelegate.SecondaryColor3dv _SecondaryColor3dv = null;
        public static GLDelegate.SecondaryColor3dv SecondaryColor3dvEXT = SecondaryColor3dv;
        /// <summary>
        /// <para>set the current secondary color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColor3dv.</para>
        /// <para>Fullname: SecondaryColor3dv</para>
        /// <para>Aliases: SecondaryColor3dvEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_secondary_color</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current secondary color.</param>
        public static void SecondaryColor3dv(double[] v)
        {
            if (gl._SecondaryColor3dv != null) gl._SecondaryColor3dv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColor3f</para>
        /// </summary>
        [GLEntry("SecondaryColor3f", Category = "1.4", Alias = "SecondaryColor3fEXT ")]
        public static GLDelegate.SecondaryColor3f _SecondaryColor3f = null;
        public static GLDelegate.SecondaryColor3f SecondaryColor3fEXT = SecondaryColor3f;
        /// <summary>
        /// <para>set the current secondary color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColor3f.</para>
        /// <para>Fullname: SecondaryColor3f</para>
        /// <para>Aliases: SecondaryColor3fEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_secondary_color</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current secondary color.</param>
        public static void SecondaryColor3f(float red, float green, float blue)
        {
            if (gl._SecondaryColor3f != null) gl._SecondaryColor3f(red, green, blue); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColor3fv</para>
        /// </summary>
        [GLEntry("SecondaryColor3fv", Category = "1.4", Alias = "SecondaryColor3fvEXT ")]
        public static GLDelegate.SecondaryColor3fv _SecondaryColor3fv = null;
        public static GLDelegate.SecondaryColor3fv SecondaryColor3fvEXT = SecondaryColor3fv;
        /// <summary>
        /// <para>set the current secondary color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColor3fv.</para>
        /// <para>Fullname: SecondaryColor3fv</para>
        /// <para>Aliases: SecondaryColor3fvEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_secondary_color</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current secondary color.</param>
        public static void SecondaryColor3fv(float[] v)
        {
            if (gl._SecondaryColor3fv != null) gl._SecondaryColor3fv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColor3i</para>
        /// </summary>
        [GLEntry("SecondaryColor3i", Category = "1.4", Alias = "SecondaryColor3iEXT ")]
        public static GLDelegate.SecondaryColor3i _SecondaryColor3i = null;
        public static GLDelegate.SecondaryColor3i SecondaryColor3iEXT = SecondaryColor3i;
        /// <summary>
        /// <para>set the current secondary color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColor3i.</para>
        /// <para>Fullname: SecondaryColor3i</para>
        /// <para>Aliases: SecondaryColor3iEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_secondary_color</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current secondary color.</param>
        public static void SecondaryColor3i(int red, int green, int blue)
        {
            if (gl._SecondaryColor3i != null) gl._SecondaryColor3i(red, green, blue); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColor3iv</para>
        /// </summary>
        [GLEntry("SecondaryColor3iv", Category = "1.4", Alias = "SecondaryColor3ivEXT ")]
        public static GLDelegate.SecondaryColor3iv _SecondaryColor3iv = null;
        public static GLDelegate.SecondaryColor3iv SecondaryColor3ivEXT = SecondaryColor3iv;
        /// <summary>
        /// <para>set the current secondary color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColor3iv.</para>
        /// <para>Fullname: SecondaryColor3iv</para>
        /// <para>Aliases: SecondaryColor3ivEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_secondary_color</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current secondary color.</param>
        public static void SecondaryColor3iv(int[] v)
        {
            if (gl._SecondaryColor3iv != null) gl._SecondaryColor3iv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColor3s</para>
        /// </summary>
        [GLEntry("SecondaryColor3s", Category = "1.4", Alias = "SecondaryColor3sEXT ")]
        public static GLDelegate.SecondaryColor3s _SecondaryColor3s = null;
        public static GLDelegate.SecondaryColor3s SecondaryColor3sEXT = SecondaryColor3s;
        /// <summary>
        /// <para>set the current secondary color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColor3s.</para>
        /// <para>Fullname: SecondaryColor3s</para>
        /// <para>Aliases: SecondaryColor3sEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_secondary_color</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current secondary color.</param>
        public static void SecondaryColor3s(short red, short green, short blue)
        {
            if (gl._SecondaryColor3s != null) gl._SecondaryColor3s(red, green, blue); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColor3sv</para>
        /// </summary>
        [GLEntry("SecondaryColor3sv", Category = "1.4", Alias = "SecondaryColor3svEXT ")]
        public static GLDelegate.SecondaryColor3sv _SecondaryColor3sv = null;
        public static GLDelegate.SecondaryColor3sv SecondaryColor3svEXT = SecondaryColor3sv;
        /// <summary>
        /// <para>set the current secondary color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColor3sv.</para>
        /// <para>Fullname: SecondaryColor3sv</para>
        /// <para>Aliases: SecondaryColor3svEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_secondary_color</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current secondary color.</param>
        public static void SecondaryColor3sv(short[] v)
        {
            if (gl._SecondaryColor3sv != null) gl._SecondaryColor3sv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColor3ub</para>
        /// </summary>
        [GLEntry("SecondaryColor3ub", Category = "1.4", Alias = "SecondaryColor3ubEXT ")]
        public static GLDelegate.SecondaryColor3ub _SecondaryColor3ub = null;
        public static GLDelegate.SecondaryColor3ub SecondaryColor3ubEXT = SecondaryColor3ub;
        /// <summary>
        /// <para>set the current secondary color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColor3ub.</para>
        /// <para>Fullname: SecondaryColor3ub</para>
        /// <para>Aliases: SecondaryColor3ubEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_secondary_color</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current secondary color.</param>
        public static void SecondaryColor3ub(byte red, byte green, byte blue)
        {
            if (gl._SecondaryColor3ub != null) gl._SecondaryColor3ub(red, green, blue); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColor3ubv</para>
        /// </summary>
        [GLEntry("SecondaryColor3ubv", Category = "1.4", Alias = "SecondaryColor3ubvEXT ")]
        public static GLDelegate.SecondaryColor3ubv _SecondaryColor3ubv = null;
        public static GLDelegate.SecondaryColor3ubv SecondaryColor3ubvEXT = SecondaryColor3ubv;
        /// <summary>
        /// <para>set the current secondary color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColor3ubv.</para>
        /// <para>Fullname: SecondaryColor3ubv</para>
        /// <para>Aliases: SecondaryColor3ubvEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_secondary_color</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current secondary color.</param>
        public static void SecondaryColor3ubv(byte[] v)
        {
            if (gl._SecondaryColor3ubv != null) gl._SecondaryColor3ubv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColor3ui</para>
        /// </summary>
        [GLEntry("SecondaryColor3ui", Category = "1.4", Alias = "SecondaryColor3uiEXT ")]
        public static GLDelegate.SecondaryColor3ui _SecondaryColor3ui = null;
        public static GLDelegate.SecondaryColor3ui SecondaryColor3uiEXT = SecondaryColor3ui;
        /// <summary>
        /// <para>set the current secondary color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColor3ui.</para>
        /// <para>Fullname: SecondaryColor3ui</para>
        /// <para>Aliases: SecondaryColor3uiEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_secondary_color</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current secondary color.</param>
        public static void SecondaryColor3ui(uint red, uint green, uint blue)
        {
            if (gl._SecondaryColor3ui != null) gl._SecondaryColor3ui(red, green, blue); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColor3uiv</para>
        /// </summary>
        [GLEntry("SecondaryColor3uiv", Category = "1.4", Alias = "SecondaryColor3uivEXT ")]
        public static GLDelegate.SecondaryColor3uiv _SecondaryColor3uiv = null;
        public static GLDelegate.SecondaryColor3uiv SecondaryColor3uivEXT = SecondaryColor3uiv;
        /// <summary>
        /// <para>set the current secondary color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColor3uiv.</para>
        /// <para>Fullname: SecondaryColor3uiv</para>
        /// <para>Aliases: SecondaryColor3uivEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_secondary_color</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current secondary color.</param>
        public static void SecondaryColor3uiv(uint[] v)
        {
            if (gl._SecondaryColor3uiv != null) gl._SecondaryColor3uiv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColor3us</para>
        /// </summary>
        [GLEntry("SecondaryColor3us", Category = "1.4", Alias = "SecondaryColor3usEXT ")]
        public static GLDelegate.SecondaryColor3us _SecondaryColor3us = null;
        public static GLDelegate.SecondaryColor3us SecondaryColor3usEXT = SecondaryColor3us;
        /// <summary>
        /// <para>set the current secondary color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColor3us.</para>
        /// <para>Fullname: SecondaryColor3us</para>
        /// <para>Aliases: SecondaryColor3usEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_secondary_color</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current secondary color.</param>
        public static void SecondaryColor3us(ushort red, ushort green, ushort blue)
        {
            if (gl._SecondaryColor3us != null) gl._SecondaryColor3us(red, green, blue); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColor3usv</para>
        /// </summary>
        [GLEntry("SecondaryColor3usv", Category = "1.4", Alias = "SecondaryColor3usvEXT ")]
        public static GLDelegate.SecondaryColor3usv _SecondaryColor3usv = null;
        public static GLDelegate.SecondaryColor3usv SecondaryColor3usvEXT = SecondaryColor3usv;
        /// <summary>
        /// <para>set the current secondary color</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColor3usv.</para>
        /// <para>Fullname: SecondaryColor3usv</para>
        /// <para>Aliases: SecondaryColor3usvEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_secondary_color</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="red">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="green">Specify new red, green, and blue values for the current secondary color.</param>
        /// <param name="blue">Specify new red, green, and blue values for the current secondary color.</param>
        public static void SecondaryColor3usv(ushort[] v)
        {
            if (gl._SecondaryColor3usv != null) gl._SecondaryColor3usv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColorPointer</para>
        /// </summary>
        [GLEntry("SecondaryColorPointer", Category = "1.4", Alias = "SecondaryColorPointerEXT ")]
        public static GLDelegate.SecondaryColorPointer _SecondaryColorPointer = null;
        public static GLDelegate.SecondaryColorPointer SecondaryColorPointerEXT = SecondaryColorPointer;
        /// <summary>
        /// <para>define an array of secondary colors</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColorPointer.</para>
        /// <para>Fullname: SecondaryColorPointer</para>
        /// <para>Aliases: SecondaryColorPointerEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_secondary_color</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="size">Specifies the number of components per color. Must be 3.</param>
        /// <param name="type">Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a pointer to the first component of the first color element in the array. The initial value is 0.</param>
        public static void SecondaryColorPointer(int size, int type, int stride, IntPtr pointer)
        {
            if (gl._SecondaryColorPointer != null) gl._SecondaryColorPointer(size, type, stride, pointer); else { }
        }
        /// <summary>
        /// <para>define an array of secondary colors</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColorPointer.</para>
        /// <para>Fullname: SecondaryColorPointer</para>
        /// <para>Aliases: SecondaryColorPointerEXT, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED EXT_secondary_color</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="size">Specifies the number of components per color. Must be 3.</param>
        /// <param name="type">Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.</param>
        /// <param name="stride">Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a pointer to the first component of the first color element in the array. The initial value is 0.</param>
        public static void SecondaryColorPointer(int size, int type, int stride, Array pointer)
        {
            GCHandle h = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try { if (gl._SecondaryColorPointer != null) gl._SecondaryColorPointer(size, type, stride, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: WindowPos2d</para>
        /// </summary>
        [GLEntry("WindowPos2d", Category = "1.4", Alias = "WindowPos2dARB WindowPos2dMESA ")]
        public static GLDelegate.WindowPos2d _WindowPos2d = null;
        public static GLDelegate.WindowPos2d WindowPos2dARB = WindowPos2d;
        public static GLDelegate.WindowPos2d WindowPos2dMESA = WindowPos2d;
        /// <summary>
        /// <para>specify the raster position in window coordinates for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos2d.</para>
        /// <para>Fullname: WindowPos2d</para>
        /// <para>Aliases: WindowPos2dARB, WindowPos2dMESA, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED ARB_window_pos MESA_window_pos</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="y">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="z">Specify the x, y, z coordinates for the raster position.</param>
        public static void WindowPos2d(double x, double y)
        {
            if (gl._WindowPos2d != null) gl._WindowPos2d(x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos2dv</para>
        /// </summary>
        [GLEntry("WindowPos2dv", Category = "1.4", Alias = "WindowPos2dvARB WindowPos2dvMESA ")]
        public static GLDelegate.WindowPos2dv _WindowPos2dv = null;
        public static GLDelegate.WindowPos2dv WindowPos2dvARB = WindowPos2dv;
        public static GLDelegate.WindowPos2dv WindowPos2dvMESA = WindowPos2dv;
        /// <summary>
        /// <para>specify the raster position in window coordinates for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos2dv.</para>
        /// <para>Fullname: WindowPos2dv</para>
        /// <para>Aliases: WindowPos2dvARB, WindowPos2dvMESA, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED ARB_window_pos MESA_window_pos</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="y">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="z">Specify the x, y, z coordinates for the raster position.</param>
        public static void WindowPos2dv(double[] v)
        {
            if (gl._WindowPos2dv != null) gl._WindowPos2dv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos2f</para>
        /// </summary>
        [GLEntry("WindowPos2f", Category = "1.4", Alias = "WindowPos2fARB WindowPos2fMESA ")]
        public static GLDelegate.WindowPos2f _WindowPos2f = null;
        public static GLDelegate.WindowPos2f WindowPos2fARB = WindowPos2f;
        public static GLDelegate.WindowPos2f WindowPos2fMESA = WindowPos2f;
        /// <summary>
        /// <para>specify the raster position in window coordinates for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos2f.</para>
        /// <para>Fullname: WindowPos2f</para>
        /// <para>Aliases: WindowPos2fARB, WindowPos2fMESA, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED ARB_window_pos MESA_window_pos</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="y">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="z">Specify the x, y, z coordinates for the raster position.</param>
        public static void WindowPos2f(float x, float y)
        {
            if (gl._WindowPos2f != null) gl._WindowPos2f(x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos2fv</para>
        /// </summary>
        [GLEntry("WindowPos2fv", Category = "1.4", Alias = "WindowPos2fvARB WindowPos2fvMESA ")]
        public static GLDelegate.WindowPos2fv _WindowPos2fv = null;
        public static GLDelegate.WindowPos2fv WindowPos2fvARB = WindowPos2fv;
        public static GLDelegate.WindowPos2fv WindowPos2fvMESA = WindowPos2fv;
        /// <summary>
        /// <para>specify the raster position in window coordinates for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos2fv.</para>
        /// <para>Fullname: WindowPos2fv</para>
        /// <para>Aliases: WindowPos2fvARB, WindowPos2fvMESA, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED ARB_window_pos MESA_window_pos</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="y">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="z">Specify the x, y, z coordinates for the raster position.</param>
        public static void WindowPos2fv(float[] v)
        {
            if (gl._WindowPos2fv != null) gl._WindowPos2fv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos2i</para>
        /// </summary>
        [GLEntry("WindowPos2i", Category = "1.4", Alias = "WindowPos2iARB WindowPos2iMESA ")]
        public static GLDelegate.WindowPos2i _WindowPos2i = null;
        public static GLDelegate.WindowPos2i WindowPos2iARB = WindowPos2i;
        public static GLDelegate.WindowPos2i WindowPos2iMESA = WindowPos2i;
        /// <summary>
        /// <para>specify the raster position in window coordinates for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos2i.</para>
        /// <para>Fullname: WindowPos2i</para>
        /// <para>Aliases: WindowPos2iARB, WindowPos2iMESA, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED ARB_window_pos MESA_window_pos</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="y">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="z">Specify the x, y, z coordinates for the raster position.</param>
        public static void WindowPos2i(int x, int y)
        {
            if (gl._WindowPos2i != null) gl._WindowPos2i(x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos2iv</para>
        /// </summary>
        [GLEntry("WindowPos2iv", Category = "1.4", Alias = "WindowPos2ivARB WindowPos2ivMESA ")]
        public static GLDelegate.WindowPos2iv _WindowPos2iv = null;
        public static GLDelegate.WindowPos2iv WindowPos2ivARB = WindowPos2iv;
        public static GLDelegate.WindowPos2iv WindowPos2ivMESA = WindowPos2iv;
        /// <summary>
        /// <para>specify the raster position in window coordinates for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos2iv.</para>
        /// <para>Fullname: WindowPos2iv</para>
        /// <para>Aliases: WindowPos2ivARB, WindowPos2ivMESA, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED ARB_window_pos MESA_window_pos</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="y">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="z">Specify the x, y, z coordinates for the raster position.</param>
        public static void WindowPos2iv(int[] v)
        {
            if (gl._WindowPos2iv != null) gl._WindowPos2iv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos2s</para>
        /// </summary>
        [GLEntry("WindowPos2s", Category = "1.4", Alias = "WindowPos2sARB WindowPos2sMESA ")]
        public static GLDelegate.WindowPos2s _WindowPos2s = null;
        public static GLDelegate.WindowPos2s WindowPos2sARB = WindowPos2s;
        public static GLDelegate.WindowPos2s WindowPos2sMESA = WindowPos2s;
        /// <summary>
        /// <para>specify the raster position in window coordinates for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos2s.</para>
        /// <para>Fullname: WindowPos2s</para>
        /// <para>Aliases: WindowPos2sARB, WindowPos2sMESA, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED ARB_window_pos MESA_window_pos</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="y">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="z">Specify the x, y, z coordinates for the raster position.</param>
        public static void WindowPos2s(short x, short y)
        {
            if (gl._WindowPos2s != null) gl._WindowPos2s(x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos2sv</para>
        /// </summary>
        [GLEntry("WindowPos2sv", Category = "1.4", Alias = "WindowPos2svARB WindowPos2svMESA ")]
        public static GLDelegate.WindowPos2sv _WindowPos2sv = null;
        public static GLDelegate.WindowPos2sv WindowPos2svARB = WindowPos2sv;
        public static GLDelegate.WindowPos2sv WindowPos2svMESA = WindowPos2sv;
        /// <summary>
        /// <para>specify the raster position in window coordinates for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos2sv.</para>
        /// <para>Fullname: WindowPos2sv</para>
        /// <para>Aliases: WindowPos2svARB, WindowPos2svMESA, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED ARB_window_pos MESA_window_pos</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="y">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="z">Specify the x, y, z coordinates for the raster position.</param>
        public static void WindowPos2sv(short[] v)
        {
            if (gl._WindowPos2sv != null) gl._WindowPos2sv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos3d</para>
        /// </summary>
        [GLEntry("WindowPos3d", Category = "1.4", Alias = "WindowPos3dARB WindowPos3dMESA ")]
        public static GLDelegate.WindowPos3d _WindowPos3d = null;
        public static GLDelegate.WindowPos3d WindowPos3dARB = WindowPos3d;
        public static GLDelegate.WindowPos3d WindowPos3dMESA = WindowPos3d;
        /// <summary>
        /// <para>specify the raster position in window coordinates for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos3d.</para>
        /// <para>Fullname: WindowPos3d</para>
        /// <para>Aliases: WindowPos3dARB, WindowPos3dMESA, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED ARB_window_pos MESA_window_pos</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="y">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="z">Specify the x, y, z coordinates for the raster position.</param>
        public static void WindowPos3d(double x, double y, double z)
        {
            if (gl._WindowPos3d != null) gl._WindowPos3d(x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos3dv</para>
        /// </summary>
        [GLEntry("WindowPos3dv", Category = "1.4", Alias = "WindowPos3dvARB WindowPos3dvMESA ")]
        public static GLDelegate.WindowPos3dv _WindowPos3dv = null;
        public static GLDelegate.WindowPos3dv WindowPos3dvARB = WindowPos3dv;
        public static GLDelegate.WindowPos3dv WindowPos3dvMESA = WindowPos3dv;
        /// <summary>
        /// <para>specify the raster position in window coordinates for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos3dv.</para>
        /// <para>Fullname: WindowPos3dv</para>
        /// <para>Aliases: WindowPos3dvARB, WindowPos3dvMESA, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED ARB_window_pos MESA_window_pos</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="y">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="z">Specify the x, y, z coordinates for the raster position.</param>
        public static void WindowPos3dv(double[] v)
        {
            if (gl._WindowPos3dv != null) gl._WindowPos3dv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos3f</para>
        /// </summary>
        [GLEntry("WindowPos3f", Category = "1.4", Alias = "WindowPos3fARB WindowPos3fMESA ")]
        public static GLDelegate.WindowPos3f _WindowPos3f = null;
        public static GLDelegate.WindowPos3f WindowPos3fARB = WindowPos3f;
        public static GLDelegate.WindowPos3f WindowPos3fMESA = WindowPos3f;
        /// <summary>
        /// <para>specify the raster position in window coordinates for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos3f.</para>
        /// <para>Fullname: WindowPos3f</para>
        /// <para>Aliases: WindowPos3fARB, WindowPos3fMESA, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED ARB_window_pos MESA_window_pos</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="y">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="z">Specify the x, y, z coordinates for the raster position.</param>
        public static void WindowPos3f(float x, float y, float z)
        {
            if (gl._WindowPos3f != null) gl._WindowPos3f(x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos3fv</para>
        /// </summary>
        [GLEntry("WindowPos3fv", Category = "1.4", Alias = "WindowPos3fvARB WindowPos3fvMESA ")]
        public static GLDelegate.WindowPos3fv _WindowPos3fv = null;
        public static GLDelegate.WindowPos3fv WindowPos3fvARB = WindowPos3fv;
        public static GLDelegate.WindowPos3fv WindowPos3fvMESA = WindowPos3fv;
        /// <summary>
        /// <para>specify the raster position in window coordinates for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos3fv.</para>
        /// <para>Fullname: WindowPos3fv</para>
        /// <para>Aliases: WindowPos3fvARB, WindowPos3fvMESA, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED ARB_window_pos MESA_window_pos</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="y">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="z">Specify the x, y, z coordinates for the raster position.</param>
        public static void WindowPos3fv(float[] v)
        {
            if (gl._WindowPos3fv != null) gl._WindowPos3fv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos3i</para>
        /// </summary>
        [GLEntry("WindowPos3i", Category = "1.4", Alias = "WindowPos3iARB WindowPos3iMESA ")]
        public static GLDelegate.WindowPos3i _WindowPos3i = null;
        public static GLDelegate.WindowPos3i WindowPos3iARB = WindowPos3i;
        public static GLDelegate.WindowPos3i WindowPos3iMESA = WindowPos3i;
        /// <summary>
        /// <para>specify the raster position in window coordinates for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos3i.</para>
        /// <para>Fullname: WindowPos3i</para>
        /// <para>Aliases: WindowPos3iARB, WindowPos3iMESA, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED ARB_window_pos MESA_window_pos</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="y">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="z">Specify the x, y, z coordinates for the raster position.</param>
        public static void WindowPos3i(int x, int y, int z)
        {
            if (gl._WindowPos3i != null) gl._WindowPos3i(x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos3iv</para>
        /// </summary>
        [GLEntry("WindowPos3iv", Category = "1.4", Alias = "WindowPos3ivARB WindowPos3ivMESA ")]
        public static GLDelegate.WindowPos3iv _WindowPos3iv = null;
        public static GLDelegate.WindowPos3iv WindowPos3ivARB = WindowPos3iv;
        public static GLDelegate.WindowPos3iv WindowPos3ivMESA = WindowPos3iv;
        /// <summary>
        /// <para>specify the raster position in window coordinates for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos3iv.</para>
        /// <para>Fullname: WindowPos3iv</para>
        /// <para>Aliases: WindowPos3ivARB, WindowPos3ivMESA, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED ARB_window_pos MESA_window_pos</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="y">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="z">Specify the x, y, z coordinates for the raster position.</param>
        public static void WindowPos3iv(int[] v)
        {
            if (gl._WindowPos3iv != null) gl._WindowPos3iv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos3s</para>
        /// </summary>
        [GLEntry("WindowPos3s", Category = "1.4", Alias = "WindowPos3sARB WindowPos3sMESA ")]
        public static GLDelegate.WindowPos3s _WindowPos3s = null;
        public static GLDelegate.WindowPos3s WindowPos3sARB = WindowPos3s;
        public static GLDelegate.WindowPos3s WindowPos3sMESA = WindowPos3s;
        /// <summary>
        /// <para>specify the raster position in window coordinates for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos3s.</para>
        /// <para>Fullname: WindowPos3s</para>
        /// <para>Aliases: WindowPos3sARB, WindowPos3sMESA, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED ARB_window_pos MESA_window_pos</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="y">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="z">Specify the x, y, z coordinates for the raster position.</param>
        public static void WindowPos3s(short x, short y, short z)
        {
            if (gl._WindowPos3s != null) gl._WindowPos3s(x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos3sv</para>
        /// </summary>
        [GLEntry("WindowPos3sv", Category = "1.4", Alias = "WindowPos3svARB WindowPos3svMESA ")]
        public static GLDelegate.WindowPos3sv _WindowPos3sv = null;
        public static GLDelegate.WindowPos3sv WindowPos3svARB = WindowPos3sv;
        public static GLDelegate.WindowPos3sv WindowPos3svMESA = WindowPos3sv;
        /// <summary>
        /// <para>specify the raster position in window coordinates for pixel operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos3sv.</para>
        /// <para>Fullname: WindowPos3sv</para>
        /// <para>Aliases: WindowPos3svARB, WindowPos3svMESA, </para>
        /// <para>Extensions: VERSION_1_4_DEPRECATED ARB_window_pos MESA_window_pos</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="x">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="y">Specify the x, y, z coordinates for the raster position.</param>
        /// <param name="z">Specify the x, y, z coordinates for the raster position.</param>
        public static void WindowPos3sv(short[] v)
        {
            if (gl._WindowPos3sv != null) gl._WindowPos3sv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: BeginQuery</para>
        /// </summary>
        [GLEntry("BeginQuery", Category = "1.5", Alias = "BeginQueryARB ")]
        public static GLDelegate.BeginQuery _BeginQuery = null;
        public static GLDelegate.BeginQuery BeginQueryARB = BeginQuery;
        /// <summary>
        /// <para>delimit the boundaries of a query object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BeginQuery.</para>
        /// <para>Fullname: BeginQuery</para>
        /// <para>Aliases: BeginQueryARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_occlusion_query</para>
        /// </summary>
        /// <param name="target">Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED.</param>
        /// <param name="id">Specifies the name of a query object.</param>
        public static void BeginQuery(int target, uint id)
        {
            if (gl._BeginQuery != null) gl._BeginQuery(target, id); else { }
        }
        /// <summary>
        /// <para>Fullname: BindBuffer</para>
        /// </summary>
        [GLEntry("BindBuffer", Category = "1.5", Alias = "BindBufferARB ")]
        public static GLDelegate.BindBuffer _BindBuffer = null;
        public static GLDelegate.BindBuffer BindBufferARB = BindBuffer;
        /// <summary>
        /// <para>bind a named buffer object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindBuffer.</para>
        /// <para>Fullname: BindBuffer</para>
        /// <para>Aliases: BindBufferARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_vertex_buffer_object</para>
        /// </summary>
        /// <param name="target">Specifies the target to which the buffer object is bound. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.</param>
        /// <param name="buffer">Specifies the name of a buffer object.</param>
        public static void BindBuffer(int target, uint buffer)
        {
            if (gl._BindBuffer != null) gl._BindBuffer(target, buffer); else { }
        }
        /// <summary>
        /// <para>Fullname: BufferData</para>
        /// </summary>
        [GLEntry("BufferData", Category = "1.5", Alias = "BufferDataARB ")]
        public static GLDelegate.BufferData _BufferData = null;
        public static GLDelegate.BufferData BufferDataARB = BufferData;
        /// <summary>
        /// <para>creates and initializes a buffer object's data store</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BufferData.</para>
        /// <para>Fullname: BufferData</para>
        /// <para>Aliases: BufferDataARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_vertex_buffer_object</para>
        /// </summary>
        /// <param name="target">Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.</param>
        /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="usage">Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.</param>
        public static void BufferData(int target, int size, IntPtr data, int usage)
        {
            if (gl._BufferData != null) gl._BufferData(target, size, data, usage); else { }
        }
        /// <summary>
        /// <para>creates and initializes a buffer object's data store</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BufferData.</para>
        /// <para>Fullname: BufferData</para>
        /// <para>Aliases: BufferDataARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_vertex_buffer_object</para>
        /// </summary>
        /// <param name="target">Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.</param>
        /// <param name="size">Specifies the size in bytes of the buffer object's new data store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.</param>
        /// <param name="usage">Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.</param>
        public static void BufferData(int target, int size, Array data, int usage)
        {
            GCHandle h = GCHandle.Alloc(data, GCHandleType.Pinned);
            try { if (gl._BufferData != null) gl._BufferData(target, size, h.AddrOfPinnedObject(), usage); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: BufferSubData</para>
        /// </summary>
        [GLEntry("BufferSubData", Category = "1.5", Alias = "BufferSubDataARB ")]
        public static GLDelegate.BufferSubData _BufferSubData = null;
        public static GLDelegate.BufferSubData BufferSubDataARB = BufferSubData;
        /// <summary>
        /// <para>updates a subset of a buffer object's data store</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BufferSubData.</para>
        /// <para>Fullname: BufferSubData</para>
        /// <para>Aliases: BufferSubDataARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_vertex_buffer_object</para>
        /// </summary>
        /// <param name="target">Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.</param>
        /// <param name="offset">Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.</param>
        /// <param name="size">Specifies the size in bytes of the data store region being replaced.</param>
        /// <param name="data">Specifies a pointer to the new data that will be copied into the data store.</param>
        public static void BufferSubData(int target, int offset, int size, IntPtr data)
        {
            if (gl._BufferSubData != null) gl._BufferSubData(target, offset, size, data); else { }
        }
        /// <summary>
        /// <para>updates a subset of a buffer object's data store</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BufferSubData.</para>
        /// <para>Fullname: BufferSubData</para>
        /// <para>Aliases: BufferSubDataARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_vertex_buffer_object</para>
        /// </summary>
        /// <param name="target">Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.</param>
        /// <param name="offset">Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.</param>
        /// <param name="size">Specifies the size in bytes of the data store region being replaced.</param>
        /// <param name="data">Specifies a pointer to the new data that will be copied into the data store.</param>
        public static void BufferSubData(int target, int offset, int size, Array data)
        {
            GCHandle h = GCHandle.Alloc(data, GCHandleType.Pinned);
            try { if (gl._BufferSubData != null) gl._BufferSubData(target, offset, size, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: DeleteBuffers</para>
        /// </summary>
        [GLEntry("DeleteBuffers", Category = "1.5", Alias = "DeleteBuffersARB ")]
        public static GLDelegate.DeleteBuffers _DeleteBuffers = null;
        public static GLDelegate.DeleteBuffers DeleteBuffersARB = DeleteBuffers;
        /// <summary>
        /// <para>delete named buffer objects</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteBuffers.</para>
        /// <para>Fullname: DeleteBuffers</para>
        /// <para>Aliases: DeleteBuffersARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_vertex_buffer_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of buffer objects to be deleted.</param>
        /// <param name="buffers">Specifies an array of buffer objects to be deleted.</param>
        public static void DeleteBuffers(int n, uint[] buffers)
        {
            if (gl._DeleteBuffers != null) gl._DeleteBuffers(n, buffers); else { }
        }
        /// <summary>
        /// <para>delete named buffer objects</para>
        /// <para>Fullname: DeleteBuffers</para>
        /// <para>Aliases: DeleteBuffersARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_vertex_buffer_object</para>
        /// </summary>
        /// <param name="buffer">Specifies a buffer object to be deleted.</param>
        public static void DeleteBuffer(uint buffer)
        {
            if (gl._DeleteBuffers != null) gl._DeleteBuffers(1, new uint[] { buffer });
        }
        /// <summary>
        /// <para>Fullname: DeleteBuffers</para>
        /// </summary>
        [GLEntry("DeleteBuffers", Category = "1.5", Alias = "DeleteBuffersARB ")]
        public static GLDelegate.DeleteBuffers_uint _DeleteBuffers_uint = null;
        /// <summary>
        /// <para>delete named buffer objects</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteBuffers_uint.</para>
        /// <para>Fullname: DeleteBuffers</para>
        /// <para>Aliases: DeleteBuffersARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_vertex_buffer_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of buffer objects to be deleted.</param>
        /// <param name="buffers">Specifies an array of buffer objects to be deleted.</param>
        public static void DeleteBuffers(int n, ref uint buffers)
        {
            if (gl._DeleteBuffers_uint != null) gl._DeleteBuffers_uint(n, ref buffers); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteQueries</para>
        /// </summary>
        [GLEntry("DeleteQueries", Category = "1.5", Alias = "DeleteQueriesARB ")]
        public static GLDelegate.DeleteQueries _DeleteQueries = null;
        public static GLDelegate.DeleteQueries DeleteQueriesARB = DeleteQueries;
        /// <summary>
        /// <para>delete named query objects</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteQueries.</para>
        /// <para>Fullname: DeleteQueries</para>
        /// <para>Aliases: DeleteQueriesARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_occlusion_query</para>
        /// </summary>
        /// <param name="n">Specifies the number of query objects to be deleted.</param>
        /// <param name="ids">Specifies an array of query objects to be deleted.</param>
        public static void DeleteQueries(int n, uint[] ids)
        {
            if (gl._DeleteQueries != null) gl._DeleteQueries(n, ids); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteQueries</para>
        /// </summary>
        [GLEntry("DeleteQueries", Category = "1.5", Alias = "DeleteQueriesARB ")]
        public static GLDelegate.DeleteQueries_uint _DeleteQueries_uint = null;
        /// <summary>
        /// <para>delete named query objects</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteQueries_uint.</para>
        /// <para>Fullname: DeleteQueries</para>
        /// <para>Aliases: DeleteQueriesARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_occlusion_query</para>
        /// </summary>
        /// <param name="n">Specifies the number of query objects to be deleted.</param>
        /// <param name="ids">Specifies an array of query objects to be deleted.</param>
        public static void DeleteQueries(int n, ref uint ids)
        {
            if (gl._DeleteQueries_uint != null) gl._DeleteQueries_uint(n, ref ids); else { }
        }
        /// <summary>
        /// <para>Fullname: EndQuery</para>
        /// </summary>
        [GLEntry("EndQuery", Category = "1.5", Alias = "EndQueryARB ")]
        public static GLDelegate.EndQuery _EndQuery = null;
        public static GLDelegate.EndQuery EndQueryARB = EndQuery;
        /// <summary>
        /// <para>This extension defines a mechanism whereby an application can query the number of pixels (or, more precisely, samples) drawn by a primitive or group of primitives. The primary purpose of such a query (hereafter referred to as an "occlusion query") is to determine the visibility of an object. Typically, the application will render the major occluders in the scene, then perform an occlusion query for the bounding box of each detail object in the scene.  Only if said bounding box is visible, i.e., if at least one sample is drawn, should the corresponding object be drawn. The earlier HP_occlusion_test extension defined a similar mechanism, but it had two major shortcomings. - It returned the result as a simple GL_TRUE/GL_FALSE result, when in fact it is often useful to know exactly how many samples were drawn. - It provided only a simple "stop-and-wait" model for using multiple queries.  The application begins an occlusion test and ends it; then, at some later point, it asks for the result...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EndQuery.</para>
        /// <para>Fullname: EndQuery</para>
        /// <para>Aliases: EndQueryARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_occlusion_query</para>
        /// </summary>
        public static void EndQuery(int target)
        {
            if (gl._EndQuery != null) gl._EndQuery(target); else { }
        }
        /// <summary>
        /// <para>Fullname: GenBuffers</para>
        /// </summary>
        [GLEntry("GenBuffers", Category = "1.5", Alias = "GenBuffersARB ")]
        public static GLDelegate.GenBuffers_uint _GenBuffers_uint = null;
        /// <summary>
        /// <para>generate buffer object names</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenBuffers_uint.</para>
        /// <para>Fullname: GenBuffers</para>
        /// <para>Aliases: GenBuffersARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_vertex_buffer_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of buffer object names to be generated.</param>
        /// <param name="buffers">Specifies an array in which the generated buffer object names are stored.</param>
        public static void GenBuffers(int n, out uint buffers)
        {
            if (gl._GenBuffers_uint != null) gl._GenBuffers_uint(n, out buffers); else { buffers = new uint(); }
        }
        /// <summary>
        /// <para>generate buffer object name</para>
        /// </summary>
        public static uint GenBuffer()
        {
            uint[] result = new uint[1];
            if (_GenBuffers != null) _GenBuffers(1, result);
            return result[0];
        }
        /// <summary>
        /// <para>Fullname: GenBuffers</para>
        /// </summary>
        [GLEntry("GenBuffers", Category = "1.5", Alias = "GenBuffersARB ")]
        public static GLDelegate.GenBuffers _GenBuffers = null;
        public static GLDelegate.GenBuffers GenBuffersARB = GenBuffers;
        /// <summary>
        /// <para>generate buffer object names</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenBuffers.</para>
        /// <para>Fullname: GenBuffers</para>
        /// <para>Aliases: GenBuffersARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_vertex_buffer_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of buffer object names to be generated.</param>
        /// <param name="buffers">Specifies an array in which the generated buffer object names are stored.</param>
        public static void GenBuffers(int n, uint[] buffers)
        {
            if (gl._GenBuffers != null) gl._GenBuffers(n, buffers); else { }
        }
        /// <summary>
        /// <para>Fullname: GenQueries</para>
        /// </summary>
        [GLEntry("GenQueries", Category = "1.5", Alias = "GenQueriesARB ")]
        public static GLDelegate.GenQueries_uint _GenQueries_uint = null;
        /// <summary>
        /// <para>generate query object names</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenQueries_uint.</para>
        /// <para>Fullname: GenQueries</para>
        /// <para>Aliases: GenQueriesARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_occlusion_query</para>
        /// </summary>
        /// <param name="n">Specifies the number of query object names to be generated.</param>
        /// <param name="ids">Specifies an array in which the generated query object names are stored.</param>
        public static void GenQueries(int n, out uint ids)
        {
            if (gl._GenQueries_uint != null) gl._GenQueries_uint(n, out ids); else { ids = new uint(); }
        }
        /// <summary>
        /// <para>Fullname: GenQueries</para>
        /// </summary>
        [GLEntry("GenQueries", Category = "1.5", Alias = "GenQueriesARB ")]
        public static GLDelegate.GenQueries _GenQueries = null;
        public static GLDelegate.GenQueries GenQueriesARB = GenQueries;
        /// <summary>
        /// <para>generate query object names</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenQueries.</para>
        /// <para>Fullname: GenQueries</para>
        /// <para>Aliases: GenQueriesARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_occlusion_query</para>
        /// </summary>
        /// <param name="n">Specifies the number of query object names to be generated.</param>
        /// <param name="ids">Specifies an array in which the generated query object names are stored.</param>
        public static void GenQueries(int n, uint[] ids)
        {
            if (gl._GenQueries != null) gl._GenQueries(n, ids); else { }
        }
        /// <summary>
        /// <para>Fullname: GetBufferParameteriv</para>
        /// </summary>
        [GLEntry("GetBufferParameteriv", Category = "1.5", Alias = "GetBufferParameterivARB ")]
        public static GLDelegate.GetBufferParameteriv _GetBufferParameteriv = null;
        public static GLDelegate.GetBufferParameteriv GetBufferParameterivARB = GetBufferParameteriv;
        /// <summary>
        /// <para>return parameters of a buffer object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetBufferParameteriv.</para>
        /// <para>Fullname: GetBufferParameteriv</para>
        /// <para>Aliases: GetBufferParameterivARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_vertex_buffer_object</para>
        /// </summary>
        /// <param name="target">Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.</param>
        /// <param name="value">Specifies the symbolic name of a buffer object parameter. Accepted values are GL_BUFFER_ACCESS, GL_BUFFER_MAPPED, GL_BUFFER_SIZE, or GL_BUFFER_USAGE.</param>
        /// <param name="data">Returns the requested parameter.</param>
        public static void GetBufferParameteriv(int target, int pname, int[] param)
        {
            if (gl._GetBufferParameteriv != null) gl._GetBufferParameteriv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetBufferPointerv</para>
        /// </summary>
        [GLEntry("GetBufferPointerv", Category = "1.5", Alias = "GetBufferPointervARB ")]
        public static GLDelegate.GetBufferPointerv _GetBufferPointerv = null;
        public static GLDelegate.GetBufferPointerv GetBufferPointervARB = GetBufferPointerv;
        /// <summary>
        /// <para>return the pointer to a mapped buffer object's data store</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetBufferPointerv.</para>
        /// <para>Fullname: GetBufferPointerv</para>
        /// <para>Aliases: GetBufferPointervARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_vertex_buffer_object</para>
        /// </summary>
        /// <param name="target">Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.</param>
        /// <param name="pname">Specifies the pointer to be returned. The symbolic constant must be GL_BUFFER_MAP_POINTER.</param>
        /// <param name="params">Returns the pointer value specified by pname.</param>
        public static void GetBufferPointerv(int target, int pname, IntPtr[] param)
        {
            if (gl._GetBufferPointerv != null) gl._GetBufferPointerv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetBufferSubData</para>
        /// </summary>
        [GLEntry("GetBufferSubData", Category = "1.5", Alias = "GetBufferSubDataARB ")]
        public static GLDelegate.GetBufferSubData _GetBufferSubData = null;
        public static GLDelegate.GetBufferSubData GetBufferSubDataARB = GetBufferSubData;
        /// <summary>
        /// <para>returns a subset of a buffer object's data store</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetBufferSubData.</para>
        /// <para>Fullname: GetBufferSubData</para>
        /// <para>Aliases: GetBufferSubDataARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_vertex_buffer_object</para>
        /// </summary>
        /// <param name="target">Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.</param>
        /// <param name="offset">Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes.</param>
        /// <param name="size">Specifies the size in bytes of the data store region being returned.</param>
        /// <param name="data">Specifies a pointer to the location where buffer object data is returned.</param>
        public static void GetBufferSubData(int target, int offset, int size, IntPtr data)
        {
            if (gl._GetBufferSubData != null) gl._GetBufferSubData(target, offset, size, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetQueryiv</para>
        /// </summary>
        [GLEntry("GetQueryiv", Category = "1.5", Alias = "GetQueryivARB ")]
        public static GLDelegate.GetQueryiv _GetQueryiv = null;
        public static GLDelegate.GetQueryiv GetQueryivARB = GetQueryiv;
        /// <summary>
        /// <para>return parameters of a query object target</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetQueryiv.</para>
        /// <para>Fullname: GetQueryiv</para>
        /// <para>Aliases: GetQueryivARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_occlusion_query</para>
        /// </summary>
        /// <param name="target">Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVEGL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP.</param>
        /// <param name="pname">Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetQueryiv(int target, int pname, int[] param)
        {
            if (gl._GetQueryiv != null) gl._GetQueryiv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetQueryObjectiv</para>
        /// </summary>
        [GLEntry("GetQueryObjectiv", Category = "1.5", Alias = "GetQueryObjectivARB ")]
        public static GLDelegate.GetQueryObjectiv _GetQueryObjectiv = null;
        public static GLDelegate.GetQueryObjectiv GetQueryObjectivARB = GetQueryObjectiv;
        /// <summary>
        /// <para>return parameters of a query object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetQueryObjectiv.</para>
        /// <para>Fullname: GetQueryObjectiv</para>
        /// <para>Aliases: GetQueryObjectivARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_occlusion_query</para>
        /// </summary>
        /// <param name="id">Specifies the name of a query object.</param>
        /// <param name="pname">Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetQueryObjectiv(uint id, int pname, int[] param)
        {
            if (gl._GetQueryObjectiv != null) gl._GetQueryObjectiv(id, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetQueryObjectuiv</para>
        /// </summary>
        [GLEntry("GetQueryObjectuiv", Category = "1.5", Alias = "GetQueryObjectuivARB ")]
        public static GLDelegate.GetQueryObjectuiv _GetQueryObjectuiv = null;
        public static GLDelegate.GetQueryObjectuiv GetQueryObjectuivARB = GetQueryObjectuiv;
        /// <summary>
        /// <para>return parameters of a query object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetQueryObjectuiv.</para>
        /// <para>Fullname: GetQueryObjectuiv</para>
        /// <para>Aliases: GetQueryObjectuivARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_occlusion_query</para>
        /// </summary>
        /// <param name="id">Specifies the name of a query object.</param>
        /// <param name="pname">Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetQueryObjectuiv(uint id, int pname, uint[] param)
        {
            if (gl._GetQueryObjectuiv != null) gl._GetQueryObjectuiv(id, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: IsBuffer</para>
        /// </summary>
        [GLEntry("IsBuffer", Category = "1.5", Alias = "IsBufferARB ")]
        public static GLDelegate.IsBuffer _IsBuffer = null;
        public static GLDelegate.IsBuffer IsBufferARB = IsBuffer;
        /// <summary>
        /// <para>determine if a name corresponds to a buffer object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsBuffer.</para>
        /// <para>Fullname: IsBuffer</para>
        /// <para>Aliases: IsBufferARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_vertex_buffer_object</para>
        /// </summary>
        /// <param name="buffer">Specifies a value that may be the name of a buffer object.</param>
        public static bool IsBuffer(uint buffer)
        {
            if (gl._IsBuffer != null) return gl._IsBuffer(buffer);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: IsQuery</para>
        /// </summary>
        [GLEntry("IsQuery", Category = "1.5", Alias = "IsQueryARB ")]
        public static GLDelegate.IsQuery _IsQuery = null;
        public static GLDelegate.IsQuery IsQueryARB = IsQuery;
        /// <summary>
        /// <para>determine if a name corresponds to a query object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsQuery.</para>
        /// <para>Fullname: IsQuery</para>
        /// <para>Aliases: IsQueryARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_occlusion_query</para>
        /// </summary>
        /// <param name="id">Specifies a value that may be the name of a query object.</param>
        public static bool IsQuery(uint id)
        {
            if (gl._IsQuery != null) return gl._IsQuery(id);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: MapBuffer</para>
        /// </summary>
        [GLEntry("MapBuffer", Category = "1.5", Alias = "MapBufferARB ")]
        public static GLDelegate.MapBuffer _MapBuffer = null;
        public static GLDelegate.MapBuffer MapBufferARB = MapBuffer;
        /// <summary>
        /// <para>map a buffer object's data store</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MapBuffer.</para>
        /// <para>Fullname: MapBuffer</para>
        /// <para>Aliases: MapBufferARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_vertex_buffer_object</para>
        /// </summary>
        /// <param name="target">Specifies the target buffer object being mapped. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER or GL_UNIFORM_BUFFER.</param>
        /// <param name="access">Specifies the access policy, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE.</param>
        public static IntPtr MapBuffer(int target, int access)
        {
            if (gl._MapBuffer != null) return gl._MapBuffer(target, access);
            else { return (IntPtr)0; }
        }
        /// <summary>
        /// <para>Fullname: UnmapBuffer</para>
        /// </summary>
        [GLEntry("UnmapBuffer", Category = "1.5", Alias = "UnmapBufferARB ")]
        public static GLDelegate.UnmapBuffer _UnmapBuffer = null;
        public static GLDelegate.UnmapBuffer UnmapBufferARB = UnmapBuffer;
        /// <summary>
        /// <para>This extension defines an interface that allows various types of data (especially vertex array data) to be cached in high-performance graphics memory on the server, thereby increasing the rate of data transfers. Chunks of data are encapsulated within "buffer objects", which conceptually are nothing more than arrays of bytes, just like any chunk of memory.  An API is provided whereby applications can read from or write to buffers, either via the GL itself (glBufferData, glBufferSubData, glGetBufferSubData) or via a pointer to the memory. The latter technique is known as "mapping" a buffer.  When an application maps a buffer, it is given a pointer to the memory.  When the application finishes reading from or writing to the memory, it is required to "unmap" the buffer before it is once again permitted to use that buffer as a GL data source or sink.  Mapping often allows applications to eliminate an extra data copy otherwise required to access the buffer, thereby enhancing performance.  In...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UnmapBuffer.</para>
        /// <para>Fullname: UnmapBuffer</para>
        /// <para>Aliases: UnmapBufferARB, </para>
        /// <para>Extensions: VERSION_1_5 ARB_vertex_buffer_object</para>
        /// </summary>
        public static bool UnmapBuffer(int target)
        {
            if (gl._UnmapBuffer != null) return gl._UnmapBuffer(target);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: AttachShader</para>
        /// </summary>
        [GLEntry("AttachShader", Category = "2.0")]
        public static GLDelegate.AttachShader _AttachShader = null;
        /// <summary>
        /// <para>Attaches a shader object to a program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _AttachShader.</para>
        /// <para>Fullname: AttachShader</para>
        /// <para>Extensions: VERSION_2_0</para>
        /// </summary>
        /// <param name="program">Specifies the program object to which a shader object will be attached.</param>
        /// <param name="shader">Specifies the shader object that is to be attached.</param>
        public static void AttachShader(uint program, uint shader)
        {
            if (gl._AttachShader != null) gl._AttachShader(program, shader); else { }
        }
        /// <summary>
        /// <para>Fullname: BindAttribLocation</para>
        /// </summary>
        [GLEntry("BindAttribLocation", Category = "2.0", Alias = "BindAttribLocationARB ")]
        public static GLDelegate.BindAttribLocation _BindAttribLocation = null;
        public static GLDelegate.BindAttribLocation BindAttribLocationARB = BindAttribLocation;
        /// <summary>
        /// <para>Associates a generic vertex attribute index with a named attribute variable</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindAttribLocation.</para>
        /// <para>Fullname: BindAttribLocation</para>
        /// <para>Aliases: BindAttribLocationARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_shader</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program object in which the association is to be made.</param>
        /// <param name="index">Specifies the index of the generic vertex attribute to be bound.</param>
        /// <param name="name">Specifies a null terminated string containing the name of the vertex shader attribute variable to which index is to be bound.</param>
        public static void BindAttribLocation(uint program, uint index, StringBuilder name)
        {
            if (gl._BindAttribLocation != null) gl._BindAttribLocation(program, index, name); else { }
        }
        /// <summary>
        /// <para>Fullname: BlendEquationSeparate</para>
        /// </summary>
        [GLEntry("BlendEquationSeparate", Category = "2.0", Alias = "BlendEquationSeparateEXT ")]
        public static GLDelegate.BlendEquationSeparate _BlendEquationSeparate = null;
        public static GLDelegate.BlendEquationSeparate BlendEquationSeparateEXT = BlendEquationSeparate;
        /// <summary>
        /// <para>set the RGB blend equation and the alpha blend equation separately</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BlendEquationSeparate.</para>
        /// <para>Fullname: BlendEquationSeparate</para>
        /// <para>Aliases: BlendEquationSeparateEXT, </para>
        /// <para>Extensions: VERSION_2_0 EXT_blend_equation_separate</para>
        /// </summary>
        /// <param name="buf">for glBlendEquationSeparatei, specifies the index of the draw buffer for which to set the blend equations.</param>
        /// <param name="modeRGB">specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.</param>
        /// <param name="modeAlpha">specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.</param>
        public static void BlendEquationSeparate(int modeRGB, int modeAlpha)
        {
            if (gl._BlendEquationSeparate != null) gl._BlendEquationSeparate(modeRGB, modeAlpha); else { }
        }
        /// <summary>
        /// <para>Fullname: CompileShader</para>
        /// </summary>
        [GLEntry("CompileShader", Category = "2.0", Alias = "CompileShaderARB ")]
        public static GLDelegate.CompileShader _CompileShader = null;
        public static GLDelegate.CompileShader CompileShaderARB = CompileShader;
        /// <summary>
        /// <para>Compiles a shader object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompileShader.</para>
        /// <para>Fullname: CompileShader</para>
        /// <para>Aliases: CompileShaderARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="shader">Specifies the shader object to be compiled.</param>
        public static void CompileShader(uint shader)
        {
            if (gl._CompileShader != null) gl._CompileShader(shader); else { }
        }
        /// <summary>
        /// <para>Fullname: CreateProgram</para>
        /// </summary>
        [GLEntry("CreateProgram", Category = "2.0")]
        public static GLDelegate.CreateProgram _CreateProgram = null;
        /// <summary>
        /// <para>Creates a program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CreateProgram.</para>
        /// <para>Fullname: CreateProgram</para>
        /// <para>Extensions: VERSION_2_0</para>
        /// </summary>
        public static uint CreateProgram()
        {
            if (gl._CreateProgram != null) return gl._CreateProgram();
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: CreateShader</para>
        /// </summary>
        [GLEntry("CreateShader", Category = "2.0")]
        public static GLDelegate.CreateShader _CreateShader = null;
        /// <summary>
        /// <para>Creates a shader object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CreateShader.</para>
        /// <para>Fullname: CreateShader</para>
        /// <para>Extensions: VERSION_2_0</para>
        /// </summary>
        /// <param name="shaderType">Specifies the type of shader to be created. Must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER, or GL_FRAGMENT_SHADER.</param>
        public static uint CreateShader(int type)
        {
            if (gl._CreateShader != null) return gl._CreateShader(type);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: DeleteProgram</para>
        /// </summary>
        [GLEntry("DeleteProgram", Category = "2.0")]
        public static GLDelegate.DeleteProgram _DeleteProgram = null;
        /// <summary>
        /// <para>Deletes a program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteProgram.</para>
        /// <para>Fullname: DeleteProgram</para>
        /// <para>Extensions: VERSION_2_0</para>
        /// </summary>
        /// <param name="program">Specifies the program object to be deleted.</param>
        public static void DeleteProgram(uint program)
        {
            if (gl._DeleteProgram != null) gl._DeleteProgram(program); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteShader</para>
        /// </summary>
        [GLEntry("DeleteShader", Category = "2.0")]
        public static GLDelegate.DeleteShader _DeleteShader = null;
        /// <summary>
        /// <para>Deletes a shader object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteShader.</para>
        /// <para>Fullname: DeleteShader</para>
        /// <para>Extensions: VERSION_2_0</para>
        /// </summary>
        /// <param name="shader">Specifies the shader object to be deleted.</param>
        public static void DeleteShader(uint shader)
        {
            if (gl._DeleteShader != null) gl._DeleteShader(shader); else { }
        }
        /// <summary>
        /// <para>Fullname: DetachShader</para>
        /// </summary>
        [GLEntry("DetachShader", Category = "2.0")]
        public static GLDelegate.DetachShader _DetachShader = null;
        /// <summary>
        /// <para>Detaches a shader object from a program object to which it is attached</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DetachShader.</para>
        /// <para>Fullname: DetachShader</para>
        /// <para>Extensions: VERSION_2_0</para>
        /// </summary>
        /// <param name="program">Specifies the program object from which to detach the shader object.</param>
        /// <param name="shader">Specifies the shader object to be detached.</param>
        public static void DetachShader(uint program, uint shader)
        {
            if (gl._DetachShader != null) gl._DetachShader(program, shader); else { }
        }
        /// <summary>
        /// <para>Fullname: DisableVertexAttribArray</para>
        /// </summary>
        [GLEntry("DisableVertexAttribArray", Category = "2.0", Alias = "DisableVertexAttribArrayARB ")]
        public static GLDelegate.DisableVertexAttribArray _DisableVertexAttribArray = null;
        public static GLDelegate.DisableVertexAttribArray DisableVertexAttribArrayARB = DisableVertexAttribArray;
        /// <summary>
        /// <para>Enable or disable a generic vertex attribute array</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DisableVertexAttribArray.</para>
        /// <para>Fullname: DisableVertexAttribArray</para>
        /// <para>Aliases: DisableVertexAttribArrayARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        public static void DisableVertexAttribArray(uint index)
        {
            if (gl._DisableVertexAttribArray != null) gl._DisableVertexAttribArray(index); else { }
        }
        /// <summary>
        /// <para>Fullname: DrawBuffers</para>
        /// </summary>
        [GLEntry("DrawBuffers", Category = "2.0", Alias = "DrawBuffersARB DrawBuffersATI ")]
        public static GLDelegate.DrawBuffers_int _DrawBuffers_int = null;
        /// <summary>
        /// <para>Specifies a list of color buffers to be drawn into</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawBuffers_int.</para>
        /// <para>Fullname: DrawBuffers</para>
        /// <para>Aliases: DrawBuffersARB, DrawBuffersATI, </para>
        /// <para>Extensions: VERSION_2_0 ARB_draw_buffers ATI_draw_buffers</para>
        /// </summary>
        /// <param name="n">Specifies the number of buffers in bufs.</param>
        /// <param name="bufs">Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</param>
        public static void DrawBuffers(int n, ref int bufs)
        {
            if (gl._DrawBuffers_int != null) gl._DrawBuffers_int(n, ref bufs); else { }
        }
        /// <summary>
        /// <para>Fullname: DrawBuffers</para>
        /// </summary>
        [GLEntry("DrawBuffers", Category = "2.0", Alias = "DrawBuffersARB DrawBuffersATI ")]
        public static GLDelegate.DrawBuffers _DrawBuffers = null;
        public static GLDelegate.DrawBuffers DrawBuffersARB = DrawBuffers;
        public static GLDelegate.DrawBuffers DrawBuffersATI = DrawBuffers;
        /// <summary>
        /// <para>Specifies a list of color buffers to be drawn into</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawBuffers.</para>
        /// <para>Fullname: DrawBuffers</para>
        /// <para>Aliases: DrawBuffersARB, DrawBuffersATI, </para>
        /// <para>Extensions: VERSION_2_0 ARB_draw_buffers ATI_draw_buffers</para>
        /// </summary>
        /// <param name="n">Specifies the number of buffers in bufs.</param>
        /// <param name="bufs">Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.</param>
        public static void DrawBuffers(int n, int[] bufs)
        {
            if (gl._DrawBuffers != null) gl._DrawBuffers(n, bufs); else { }
        }
        /// <summary>
        /// <para>Fullname: EnableVertexAttribArray</para>
        /// </summary>
        [GLEntry("EnableVertexAttribArray", Category = "2.0", Alias = "EnableVertexAttribArrayARB ")]
        public static GLDelegate.EnableVertexAttribArray _EnableVertexAttribArray = null;
        public static GLDelegate.EnableVertexAttribArray EnableVertexAttribArrayARB = EnableVertexAttribArray;
        /// <summary>
        /// <para>Enable or disable a generic vertex attribute array</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EnableVertexAttribArray.</para>
        /// <para>Fullname: EnableVertexAttribArray</para>
        /// <para>Aliases: EnableVertexAttribArrayARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be enabled or disabled.</param>
        public static void EnableVertexAttribArray(uint index)
        {
            if (gl._EnableVertexAttribArray != null) gl._EnableVertexAttribArray(index); else { }
        }
        /// <summary>
        /// <para>Fullname: GetActiveAttrib</para>
        /// </summary>
        [GLEntry("GetActiveAttrib", Category = "2.0", Alias = "GetActiveAttribARB ")]
        public static GLDelegate.GetActiveAttrib_int_int_int _GetActiveAttrib_int_int_int = null;
        /// <summary>
        /// <para>Returns information about an active attribute variable for the specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetActiveAttrib_int_int_int.</para>
        /// <para>Fullname: GetActiveAttrib</para>
        /// <para>Aliases: GetActiveAttribARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_shader</para>
        /// </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="index">Specifies the index of the attribute variable to be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.</param>
        /// <param name="length">Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.</param>
        /// <param name="size">Returns the size of the attribute variable.</param>
        /// <param name="type">Returns the data type of the attribute variable.</param>
        /// <param name="name">Returns a null terminated string containing the name of the attribute variable.</param>
        public static void GetActiveAttrib(uint program, uint index, int bufSize, out int length, out int size, out int type, StringBuilder name)
        {
            if (gl._GetActiveAttrib_int_int_int != null) gl._GetActiveAttrib_int_int_int(program, index, bufSize, out length, out size, out type, name); else { length = new int(); size = new int(); type = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetActiveAttrib</para>
        /// </summary>
        [GLEntry("GetActiveAttrib", Category = "2.0", Alias = "GetActiveAttribARB ")]
        public static GLDelegate.GetActiveAttrib _GetActiveAttrib = null;
        public static GLDelegate.GetActiveAttrib GetActiveAttribARB = GetActiveAttrib;
        /// <summary>
        /// <para>Returns information about an active attribute variable for the specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetActiveAttrib.</para>
        /// <para>Fullname: GetActiveAttrib</para>
        /// <para>Aliases: GetActiveAttribARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_shader</para>
        /// </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="index">Specifies the index of the attribute variable to be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.</param>
        /// <param name="length">Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.</param>
        /// <param name="size">Returns the size of the attribute variable.</param>
        /// <param name="type">Returns the data type of the attribute variable.</param>
        /// <param name="name">Returns a null terminated string containing the name of the attribute variable.</param>
        public static void GetActiveAttrib(uint program, uint index, int bufSize, int[] length, int[] size, int[] type, StringBuilder name)
        {
            if (gl._GetActiveAttrib != null) gl._GetActiveAttrib(program, index, bufSize, length, size, type, name); else { }
        }
        /// <summary>
        /// <para>Fullname: GetActiveUniform</para>
        /// </summary>
        [GLEntry("GetActiveUniform", Category = "2.0", Alias = "GetActiveUniformARB ")]
        public static GLDelegate.GetActiveUniform _GetActiveUniform = null;
        public static GLDelegate.GetActiveUniform GetActiveUniformARB = GetActiveUniform;
        /// <summary>
        /// <para>Returns information about an active uniform variable for the specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetActiveUniform.</para>
        /// <para>Fullname: GetActiveUniform</para>
        /// <para>Aliases: GetActiveUniformARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="index">Specifies the index of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.</param>
        /// <param name="length">Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.</param>
        /// <param name="size">Returns the size of the uniform variable.</param>
        /// <param name="type">Returns the data type of the uniform variable.</param>
        /// <param name="name">Returns a null terminated string containing the name of the uniform variable.</param>
        public static void GetActiveUniform(uint program, uint index, int bufSize, int[] length, int[] size, int[] type, StringBuilder name)
        {
            if (gl._GetActiveUniform != null) gl._GetActiveUniform(program, index, bufSize, length, size, type, name); else { }
        }
        /// <summary>
        /// <para>Fullname: GetActiveUniform</para>
        /// </summary>
        [GLEntry("GetActiveUniform", Category = "2.0", Alias = "GetActiveUniformARB ")]
        public static GLDelegate.GetActiveUniform_int_int_int _GetActiveUniform_int_int_int = null;
        /// <summary>
        /// <para>Returns information about an active uniform variable for the specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetActiveUniform_int_int_int.</para>
        /// <para>Fullname: GetActiveUniform</para>
        /// <para>Aliases: GetActiveUniformARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="index">Specifies the index of the uniform variable to be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.</param>
        /// <param name="length">Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.</param>
        /// <param name="size">Returns the size of the uniform variable.</param>
        /// <param name="type">Returns the data type of the uniform variable.</param>
        /// <param name="name">Returns a null terminated string containing the name of the uniform variable.</param>
        public static void GetActiveUniform(uint program, uint index, int bufSize, out int length, out int size, out int type, StringBuilder name)
        {
            if (gl._GetActiveUniform_int_int_int != null) gl._GetActiveUniform_int_int_int(program, index, bufSize, out length, out size, out type, name); else { length = new int(); size = new int(); type = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetAttachedShaders</para>
        /// </summary>
        [GLEntry("GetAttachedShaders", Category = "2.0")]
        public static GLDelegate.GetAttachedShaders_int _GetAttachedShaders_int = null;
        /// <summary>
        /// <para>Returns the handles of the shader objects attached to a program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetAttachedShaders_int.</para>
        /// <para>Fullname: GetAttachedShaders</para>
        /// <para>Extensions: VERSION_2_0</para>
        /// </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="maxCount">Specifies the size of the array for storing the returned object names.</param>
        /// <param name="count">Returns the number of names actually returned in objects.</param>
        /// <param name="shaders">Specifies an array that is used to return the names of attached shader objects.</param>
        public static void GetAttachedShaders(uint program, int maxCount, out int count, uint[] obj)
        {
            if (gl._GetAttachedShaders_int != null) gl._GetAttachedShaders_int(program, maxCount, out count, obj); else { count = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetAttachedShaders</para>
        /// </summary>
        [GLEntry("GetAttachedShaders", Category = "2.0")]
        public static GLDelegate.GetAttachedShaders _GetAttachedShaders = null;
        /// <summary>
        /// <para>Returns the handles of the shader objects attached to a program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetAttachedShaders.</para>
        /// <para>Fullname: GetAttachedShaders</para>
        /// <para>Extensions: VERSION_2_0</para>
        /// </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="maxCount">Specifies the size of the array for storing the returned object names.</param>
        /// <param name="count">Returns the number of names actually returned in objects.</param>
        /// <param name="shaders">Specifies an array that is used to return the names of attached shader objects.</param>
        public static void GetAttachedShaders(uint program, int maxCount, int[] count, uint[] obj)
        {
            if (gl._GetAttachedShaders != null) gl._GetAttachedShaders(program, maxCount, count, obj); else { }
        }
        /// <summary>
        /// <para>Fullname: GetAttribLocation</para>
        /// </summary>
        [GLEntry("GetAttribLocation", Category = "2.0", Alias = "GetAttribLocationARB ")]
        public static GLDelegate.GetAttribLocation _GetAttribLocation = null;
        public static GLDelegate.GetAttribLocation GetAttribLocationARB = GetAttribLocation;
        /// <summary>
        /// <para>Returns the location of an attribute variable</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetAttribLocation.</para>
        /// <para>Fullname: GetAttribLocation</para>
        /// <para>Aliases: GetAttribLocationARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_shader</para>
        /// </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="name">Points to a null terminated string containing the name of the attribute variable whose location is to be queried.</param>
        public static int GetAttribLocation(uint program, StringBuilder name)
        {
            if (gl._GetAttribLocation != null) return gl._GetAttribLocation(program, name);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Returns the location of an attribute variable</para>
        /// </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="name">String containing the name of the attribute variable whose location is to be queried.</param>
        public static int GetAttribLocation(uint program, string name)
        {
            if (gl._GetAttribLocation != null) return gl._GetAttribLocation(program, new StringBuilder(name));
            else return (int)0;
        }
        /// <summary>
        /// <para>Fullname: GetProgramInfoLog</para>
        /// </summary>
        [GLEntry("GetProgramInfoLog", Category = "2.0")]
        public static GLDelegate.GetProgramInfoLog _GetProgramInfoLog = null;
        /// <summary>
        /// <para>Returns the information log for a program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramInfoLog.</para>
        /// <para>Fullname: GetProgramInfoLog</para>
        /// <para>Extensions: VERSION_2_0</para>
        /// </summary>
        /// <param name="program">Specifies the program object whose information log is to be queried.</param>
        /// <param name="maxLength">Specifies the size of the character buffer for storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in infoLog (excluding the null terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used to return the information log.</param>
        public static void GetProgramInfoLog(uint program, int bufSize, int[] length, StringBuilder infoLog)
        {
            if (gl._GetProgramInfoLog != null) gl._GetProgramInfoLog(program, bufSize, length, infoLog); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramInfoLog</para>
        /// </summary>
        [GLEntry("GetProgramInfoLog", Category = "2.0")]
        public static GLDelegate.GetProgramInfoLog_int _GetProgramInfoLog_int = null;
        /// <summary>
        /// <para>Returns the information log for a program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramInfoLog_int.</para>
        /// <para>Fullname: GetProgramInfoLog</para>
        /// <para>Extensions: VERSION_2_0</para>
        /// </summary>
        /// <param name="program">Specifies the program object whose information log is to be queried.</param>
        /// <param name="maxLength">Specifies the size of the character buffer for storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in infoLog (excluding the null terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used to return the information log.</param>
        public static void GetProgramInfoLog(uint program, int bufSize, out int length, StringBuilder infoLog)
        {
            if (gl._GetProgramInfoLog_int != null) gl._GetProgramInfoLog_int(program, bufSize, out length, infoLog); else { length = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetProgramiv</para>
        /// </summary>
        [GLEntry("GetProgramiv", Category = "2.0", Alias = "GetProgramivNV ")]
        public static GLDelegate.GetProgramiv _GetProgramiv = null;
        public static GLDelegate.GetProgramiv GetProgramivNV = GetProgramiv;
        /// <summary>
        /// <para>Returns a parameter from a program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramiv.</para>
        /// <para>Fullname: GetProgramiv</para>
        /// <para>Aliases: GetProgramivNV, </para>
        /// <para>Extensions: VERSION_2_0 NV_vertex_program</para>
        /// </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="pname">Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZEGL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and GL_GEOMETRY_OUTPUT_TYPE.</param>
        /// <param name="params">Returns the requested object parameter.</param>
        public static void GetProgramiv(uint program, int pname, int[] param)
        {
            if (gl._GetProgramiv != null) gl._GetProgramiv(program, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetShaderInfoLog</para>
        /// </summary>
        [GLEntry("GetShaderInfoLog", Category = "2.0")]
        public static GLDelegate.GetShaderInfoLog _GetShaderInfoLog = null;
        /// <summary>
        /// <para>Returns the information log for a shader object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetShaderInfoLog.</para>
        /// <para>Fullname: GetShaderInfoLog</para>
        /// <para>Extensions: VERSION_2_0</para>
        /// </summary>
        /// <param name="shader">Specifies the shader object whose information log is to be queried.</param>
        /// <param name="maxLength">Specifies the size of the character buffer for storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in infoLog (excluding the null terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used to return the information log.</param>
        public static void GetShaderInfoLog(uint shader, int bufSize, int[] length, StringBuilder infoLog)
        {
            if (gl._GetShaderInfoLog != null) gl._GetShaderInfoLog(shader, bufSize, length, infoLog); else { }
        }
        /// <summary>
        /// <para>Fullname: GetShaderInfoLog</para>
        /// </summary>
        [GLEntry("GetShaderInfoLog", Category = "2.0")]
        public static GLDelegate.GetShaderInfoLog_int _GetShaderInfoLog_int = null;
        /// <summary>
        /// <para>Returns the information log for a shader object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetShaderInfoLog_int.</para>
        /// <para>Fullname: GetShaderInfoLog</para>
        /// <para>Extensions: VERSION_2_0</para>
        /// </summary>
        /// <param name="shader">Specifies the shader object whose information log is to be queried.</param>
        /// <param name="maxLength">Specifies the size of the character buffer for storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in infoLog (excluding the null terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used to return the information log.</param>
        public static void GetShaderInfoLog(uint shader, int bufSize, out int length, StringBuilder infoLog)
        {
            if (gl._GetShaderInfoLog_int != null) gl._GetShaderInfoLog_int(shader, bufSize, out length, infoLog); else { length = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetShaderiv</para>
        /// </summary>
        [GLEntry("GetShaderiv", Category = "2.0")]
        public static GLDelegate.GetShaderiv _GetShaderiv = null;
        /// <summary>
        /// <para>Returns a parameter from a shader object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetShaderiv.</para>
        /// <para>Fullname: GetShaderiv</para>
        /// <para>Extensions: VERSION_2_0</para>
        /// </summary>
        /// <param name="shader">Specifies the shader object to be queried.</param>
        /// <param name="pname">Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS, GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.</param>
        /// <param name="params">Returns the requested object parameter.</param>
        public static void GetShaderiv(uint shader, int pname, int[] param)
        {
            if (gl._GetShaderiv != null) gl._GetShaderiv(shader, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetShaderSource</para>
        /// </summary>
        [GLEntry("GetShaderSource", Category = "2.0", Alias = "GetShaderSourceARB ")]
        public static GLDelegate.GetShaderSource _GetShaderSource = null;
        public static GLDelegate.GetShaderSource GetShaderSourceARB = GetShaderSource;
        /// <summary>
        /// <para>Returns the source code string from a shader object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetShaderSource.</para>
        /// <para>Fullname: GetShaderSource</para>
        /// <para>Aliases: GetShaderSourceARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="shader">Specifies the shader object to be queried.</param>
        /// <param name="bufSize">Specifies the size of the character buffer for storing the returned source code string.</param>
        /// <param name="length">Returns the length of the string returned in source (excluding the null terminator).</param>
        /// <param name="source">Specifies an array of characters that is used to return the source code string.</param>
        public static void GetShaderSource(uint shader, int bufSize, int[] length, StringBuilder source)
        {
            if (gl._GetShaderSource != null) gl._GetShaderSource(shader, bufSize, length, source); else { }
        }
        /// <summary>
        /// <para>Fullname: GetShaderSource</para>
        /// </summary>
        [GLEntry("GetShaderSource", Category = "2.0", Alias = "GetShaderSourceARB ")]
        public static GLDelegate.GetShaderSource_int _GetShaderSource_int = null;
        /// <summary>
        /// <para>Returns the source code string from a shader object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetShaderSource_int.</para>
        /// <para>Fullname: GetShaderSource</para>
        /// <para>Aliases: GetShaderSourceARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="shader">Specifies the shader object to be queried.</param>
        /// <param name="bufSize">Specifies the size of the character buffer for storing the returned source code string.</param>
        /// <param name="length">Returns the length of the string returned in source (excluding the null terminator).</param>
        /// <param name="source">Specifies an array of characters that is used to return the source code string.</param>
        public static void GetShaderSource(uint shader, int bufSize, out int length, StringBuilder source)
        {
            if (gl._GetShaderSource_int != null) gl._GetShaderSource_int(shader, bufSize, out length, source); else { length = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetUniformfv</para>
        /// </summary>
        [GLEntry("GetUniformfv", Category = "2.0", Alias = "GetUniformfvARB ")]
        public static GLDelegate.GetUniformfv _GetUniformfv = null;
        public static GLDelegate.GetUniformfv GetUniformfvARB = GetUniformfv;
        /// <summary>
        /// <para>Returns the value of a uniform variable</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetUniformfv.</para>
        /// <para>Fullname: GetUniformfv</para>
        /// <para>Aliases: GetUniformfvARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="params">Returns the value of the specified uniform variable.</param>
        public static void GetUniformfv(uint program, int location, float[] param)
        {
            if (gl._GetUniformfv != null) gl._GetUniformfv(program, location, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetUniformiv</para>
        /// </summary>
        [GLEntry("GetUniformiv", Category = "2.0", Alias = "GetUniformivARB ")]
        public static GLDelegate.GetUniformiv _GetUniformiv = null;
        public static GLDelegate.GetUniformiv GetUniformivARB = GetUniformiv;
        /// <summary>
        /// <para>Returns the value of a uniform variable</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetUniformiv.</para>
        /// <para>Fullname: GetUniformiv</para>
        /// <para>Aliases: GetUniformivARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="params">Returns the value of the specified uniform variable.</param>
        public static void GetUniformiv(uint program, int location, int[] param)
        {
            if (gl._GetUniformiv != null) gl._GetUniformiv(program, location, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetUniformLocation</para>
        /// </summary>
        [GLEntry("GetUniformLocation", Category = "2.0", Alias = "GetUniformLocationARB ")]
        public static GLDelegate.GetUniformLocation _GetUniformLocation = null;
        public static GLDelegate.GetUniformLocation GetUniformLocationARB = GetUniformLocation;
        /// <summary>
        /// <para>Returns the location of a uniform variable</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetUniformLocation.</para>
        /// <para>Fullname: GetUniformLocation</para>
        /// <para>Aliases: GetUniformLocationARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="name">Points to a null terminated string containing the name of the uniform variable whose location is to be queried.</param>
        public static int GetUniformLocation(uint program, StringBuilder name)
        {
            if (gl._GetUniformLocation != null) return gl._GetUniformLocation(program, name);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Returns the location of a uniform variable</para>
        /// </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="name">String containing the name of the uniform variable whose location is to be queried.</param>
        public static int GetUniformLocation(uint program, string name)
        {
            if (gl._GetUniformLocation != null) return gl._GetUniformLocation(program, new StringBuilder(name));
            else return (int)0;
        }
        /// <summary>
        /// <para>Fullname: GetVertexAttribdv</para>
        /// </summary>
        [GLEntry("GetVertexAttribdv", Category = "2.0", Alias = "GetVertexAttribdvARB GetVertexAttribdvNV ")]
        public static GLDelegate.GetVertexAttribdv _GetVertexAttribdv = null;
        public static GLDelegate.GetVertexAttribdv GetVertexAttribdvARB = GetVertexAttribdv;
        public static GLDelegate.GetVertexAttribdv GetVertexAttribdvNV = GetVertexAttribdv;
        /// <summary>
        /// <para>Return a generic vertex attribute parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVertexAttribdv.</para>
        /// <para>Fullname: GetVertexAttribdv</para>
        /// <para>Aliases: GetVertexAttribdvARB, GetVertexAttribdvNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetVertexAttribdv(uint index, int pname, double[] param)
        {
            if (gl._GetVertexAttribdv != null) gl._GetVertexAttribdv(index, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVertexAttribfv</para>
        /// </summary>
        [GLEntry("GetVertexAttribfv", Category = "2.0", Alias = "GetVertexAttribfvARB GetVertexAttribfvNV ")]
        public static GLDelegate.GetVertexAttribfv _GetVertexAttribfv = null;
        public static GLDelegate.GetVertexAttribfv GetVertexAttribfvARB = GetVertexAttribfv;
        public static GLDelegate.GetVertexAttribfv GetVertexAttribfvNV = GetVertexAttribfv;
        /// <summary>
        /// <para>Return a generic vertex attribute parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVertexAttribfv.</para>
        /// <para>Fullname: GetVertexAttribfv</para>
        /// <para>Aliases: GetVertexAttribfvARB, GetVertexAttribfvNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetVertexAttribfv(uint index, int pname, float[] param)
        {
            if (gl._GetVertexAttribfv != null) gl._GetVertexAttribfv(index, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVertexAttribiv</para>
        /// </summary>
        [GLEntry("GetVertexAttribiv", Category = "2.0", Alias = "GetVertexAttribivARB GetVertexAttribivNV ")]
        public static GLDelegate.GetVertexAttribiv _GetVertexAttribiv = null;
        public static GLDelegate.GetVertexAttribiv GetVertexAttribivARB = GetVertexAttribiv;
        public static GLDelegate.GetVertexAttribiv GetVertexAttribivNV = GetVertexAttribiv;
        /// <summary>
        /// <para>Return a generic vertex attribute parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVertexAttribiv.</para>
        /// <para>Fullname: GetVertexAttribiv</para>
        /// <para>Aliases: GetVertexAttribivARB, GetVertexAttribivNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetVertexAttribiv(uint index, int pname, int[] param)
        {
            if (gl._GetVertexAttribiv != null) gl._GetVertexAttribiv(index, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVertexAttribPointerv</para>
        /// </summary>
        [GLEntry("GetVertexAttribPointerv", Category = "2.0", Alias = "GetVertexAttribPointervARB GetVertexAttribPointervNV ")]
        public static GLDelegate.GetVertexAttribPointerv _GetVertexAttribPointerv = null;
        public static GLDelegate.GetVertexAttribPointerv GetVertexAttribPointervARB = GetVertexAttribPointerv;
        public static GLDelegate.GetVertexAttribPointerv GetVertexAttribPointervNV = GetVertexAttribPointerv;
        /// <summary>
        /// <para>return the address of the specified generic vertex attribute pointer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVertexAttribPointerv.</para>
        /// <para>Fullname: GetVertexAttribPointerv</para>
        /// <para>Aliases: GetVertexAttribPointervARB, GetVertexAttribPointervNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be returned.</param>
        /// <param name="pname">Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be GL_VERTEX_ATTRIB_ARRAY_POINTER.</param>
        /// <param name="pointer">Returns the pointer value.</param>
        public static void GetVertexAttribPointerv(uint index, int pname, IntPtr[] pointer)
        {
            if (gl._GetVertexAttribPointerv != null) gl._GetVertexAttribPointerv(index, pname, pointer); else { }
        }
        /// <summary>
        /// <para>Fullname: IsProgram</para>
        /// </summary>
        [GLEntry("IsProgram", Category = "2.0", Alias = "IsProgramARB IsProgramNV ")]
        public static GLDelegate.IsProgram _IsProgram = null;
        public static GLDelegate.IsProgram IsProgramARB = IsProgram;
        public static GLDelegate.IsProgram IsProgramNV = IsProgram;
        /// <summary>
        /// <para>Determines if a name corresponds to a program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsProgram.</para>
        /// <para>Fullname: IsProgram</para>
        /// <para>Aliases: IsProgramARB, IsProgramNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// </summary>
        /// <param name="program">Specifies a potential program object.</param>
        public static bool IsProgram(uint program)
        {
            if (gl._IsProgram != null) return gl._IsProgram(program);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: IsShader</para>
        /// </summary>
        [GLEntry("IsShader", Category = "2.0")]
        public static GLDelegate.IsShader _IsShader = null;
        /// <summary>
        /// <para>Determines if a name corresponds to a shader object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsShader.</para>
        /// <para>Fullname: IsShader</para>
        /// <para>Extensions: VERSION_2_0</para>
        /// </summary>
        /// <param name="shader">Specifies a potential shader object.</param>
        public static bool IsShader(uint shader)
        {
            if (gl._IsShader != null) return gl._IsShader(shader);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: LinkProgram</para>
        /// </summary>
        [GLEntry("LinkProgram", Category = "2.0", Alias = "LinkProgramARB ")]
        public static GLDelegate.LinkProgram _LinkProgram = null;
        public static GLDelegate.LinkProgram LinkProgramARB = LinkProgram;
        /// <summary>
        /// <para>Links a program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _LinkProgram.</para>
        /// <para>Fullname: LinkProgram</para>
        /// <para>Aliases: LinkProgramARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program object to be linked.</param>
        public static void LinkProgram(uint program)
        {
            if (gl._LinkProgram != null) gl._LinkProgram(program); else { }
        }
        /// <summary>
        /// <para>Fullname: ShaderSource</para>
        /// </summary>
        [GLEntry("ShaderSource", Category = "2.0", Alias = "ShaderSourceARB ")]
        public static GLDelegate.ShaderSource_int _ShaderSource_int = null;
        /// <summary>
        /// <para>Replaces the source code in a shader object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ShaderSource_int.</para>
        /// <para>Fullname: ShaderSource</para>
        /// <para>Aliases: ShaderSourceARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="shader">Specifies the handle of the shader object whose source code is to be replaced.</param>
        /// <param name="count">Specifies the number of elements in the string and length arrays.</param>
        /// <param name="string">Specifies an array of pointers to strings containing the source code to be loaded into the shader.</param>
        /// <param name="length">Specifies an array of string lengths.</param>
        public static void ShaderSource(uint shader, int count, string[] str, ref int length)
        {
            if (gl._ShaderSource_int != null) gl._ShaderSource_int(shader, count, str, ref length); else { }
        }
        /// <summary>
        /// <para>Replaces the source code in a shader object</para>
        /// </summary>
        /// <param name="shader">Specifies the handle of the shader object whose source code is to be replaced.</param>
        /// <param name="string">Specifies the string containing the source code to be loaded into the shader.</param>
        public static void ShaderSource(uint shader, string source)
        {
            string[] src = new string[] { source };
            int[] len = new int[1] { source.Length };
            if (gl._ShaderSource != null) gl._ShaderSource(shader, 1, src, len);
        }
        /// <summary>
        /// <para>Fullname: ShaderSource</para>
        /// </summary>
        [GLEntry("ShaderSource", Category = "2.0", Alias = "ShaderSourceARB ")]
        public static GLDelegate.ShaderSource _ShaderSource = null;
        public static GLDelegate.ShaderSource ShaderSourceARB = ShaderSource;
        /// <summary>
        /// <para>Replaces the source code in a shader object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ShaderSource.</para>
        /// <para>Fullname: ShaderSource</para>
        /// <para>Aliases: ShaderSourceARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="shader">Specifies the handle of the shader object whose source code is to be replaced.</param>
        /// <param name="count">Specifies the number of elements in the string and length arrays.</param>
        /// <param name="string">Specifies an array of pointers to strings containing the source code to be loaded into the shader.</param>
        /// <param name="length">Specifies an array of string lengths.</param>
        public static void ShaderSource(uint shader, int count, string[] str, int[] length)
        {
            if (gl._ShaderSource != null) gl._ShaderSource(shader, count, str, length); else { }
        }
        /// <summary>
        /// <para>Fullname: StencilFuncSeparate</para>
        /// </summary>
        [GLEntry("StencilFuncSeparate", Category = "2.0", Alias = "StencilFuncSeparateATI ")]
        public static GLDelegate.StencilFuncSeparate _StencilFuncSeparate = null;
        public static GLDelegate.StencilFuncSeparate StencilFuncSeparateATI = StencilFuncSeparate;
        /// <summary>
        /// <para>set front and/or back function and reference value for stencil testing</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _StencilFuncSeparate.</para>
        /// <para>Fullname: StencilFuncSeparate</para>
        /// <para>Aliases: StencilFuncSeparateATI, </para>
        /// <para>Extensions: VERSION_2_0 ATI_separate_stencil</para>
        /// </summary>
        /// <param name="face">Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.</param>
        /// <param name="func">Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.</param>
        /// <param name="ref">Specifies the reference value for the stencil test. ref is clamped to the range 02n-1, where n is the number of bitplanes in the stencil buffer. The initial value is 0.</param>
        /// <param name="mask">Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.</param>
        public static void StencilFuncSeparate(int face, int func, int reference, uint mask)
        {
            if (gl._StencilFuncSeparate != null) gl._StencilFuncSeparate(face, func, reference, mask); else { }
        }
        /// <summary>
        /// <para>Fullname: StencilMaskSeparate</para>
        /// </summary>
        [GLEntry("StencilMaskSeparate", Category = "2.0")]
        public static GLDelegate.StencilMaskSeparate _StencilMaskSeparate = null;
        /// <summary>
        /// <para>control the front and/or back writing of individual bits in the stencil planes</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _StencilMaskSeparate.</para>
        /// <para>Fullname: StencilMaskSeparate</para>
        /// <para>Extensions: VERSION_2_0</para>
        /// </summary>
        /// <param name="face">Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.</param>
        /// <param name="mask">Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.</param>
        public static void StencilMaskSeparate(int face, uint mask)
        {
            if (gl._StencilMaskSeparate != null) gl._StencilMaskSeparate(face, mask); else { }
        }
        /// <summary>
        /// <para>Fullname: StencilOpSeparate</para>
        /// </summary>
        [GLEntry("StencilOpSeparate", Category = "2.0", Alias = "StencilOpSeparateATI ")]
        public static GLDelegate.StencilOpSeparate _StencilOpSeparate = null;
        public static GLDelegate.StencilOpSeparate StencilOpSeparateATI = StencilOpSeparate;
        /// <summary>
        /// <para>set front and/or back stencil test actions</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _StencilOpSeparate.</para>
        /// <para>Fullname: StencilOpSeparate</para>
        /// <para>Aliases: StencilOpSeparateATI, </para>
        /// <para>Extensions: VERSION_2_0 ATI_separate_stencil</para>
        /// </summary>
        /// <param name="face">Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.</param>
        /// <param name="sfail">Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP.</param>
        /// <param name="dpfail">Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP.</param>
        /// <param name="dppass">Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP.</param>
        public static void StencilOpSeparate(int face, int sfail, int dpfail, int dppass)
        {
            if (gl._StencilOpSeparate != null) gl._StencilOpSeparate(face, sfail, dpfail, dppass); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform1dv</para>
        /// </summary>
        [GLEntry("Uniform1dv", Category = "2.0")]
        public static GLDelegate.Uniform1dv_double _Uniform1dv_double = null;
        /// <summary>
        /// <para>This extension allows GLSL shaders to use double-precision floating-point data types, including vectors and matrices of doubles.  Doubles may be used as inputs, outputs, and uniforms. The shading language supports various arithmetic and comparison operators on double-precision scalar, vector, and matrix types, and provides a set of built-in functions including: * square roots and inverse square roots; * fused floating-point multiply-add operations; * splitting a floating-point number into a significand and exponent (frexp), or building a floating-point number from a significand and exponent (ldexp); * absolute value, sign tests, various functions to round to an integer value, modulus, minimum, maximum, clamping, blending two values, step functions, and testing for infinity and NaN values; * packing and unpacking doubles into a pair of 32-bit unsigned integers; * matrix component-wise multiplication, and computation of outer products, transposes, determinants, and inverses; and * vector...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform1dv_double.</para>
        /// <para>Fullname: Uniform1dv</para>
        /// <para>Extensions: VERSION_2_0</para>
        /// </summary>
        public static void Uniform1dv(int location, int count, ref double value)
        {
            if (gl._Uniform1dv_double != null) gl._Uniform1dv_double(location, count, ref value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform1f</para>
        /// </summary>
        [GLEntry("Uniform1f", Category = "2.0", Alias = "Uniform1fARB ")]
        public static GLDelegate.Uniform1f _Uniform1f = null;
        public static GLDelegate.Uniform1f Uniform1fARB = Uniform1f;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform1f.</para>
        /// <para>Fullname: Uniform1f</para>
        /// <para>Aliases: Uniform1fARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform1f(int location, float v0)
        {
            if (gl._Uniform1f != null) gl._Uniform1f(location, v0); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform1fv</para>
        /// </summary>
        [GLEntry("Uniform1fv", Category = "2.0")]
        public static GLDelegate.Uniform1fv_float _Uniform1fv_float = null;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform1fv_float.</para>
        /// <para>Fullname: Uniform1fv</para>
        /// <para>Extensions: VERSION_2_0</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform1fv(int location, int count, ref float value)
        {
            if (gl._Uniform1fv_float != null) gl._Uniform1fv_float(location, count, ref value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform1fv</para>
        /// </summary>
        [GLEntry("Uniform1fv", Category = "2.0", Alias = "Uniform1fvARB ")]
        public static GLDelegate.Uniform1fv _Uniform1fv = null;
        public static GLDelegate.Uniform1fv Uniform1fvARB = Uniform1fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform1fv.</para>
        /// <para>Fullname: Uniform1fv</para>
        /// <para>Aliases: Uniform1fvARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform1fv(int location, int count, float[] value)
        {
            if (gl._Uniform1fv != null) gl._Uniform1fv(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform1i</para>
        /// </summary>
        [GLEntry("Uniform1i", Category = "2.0", Alias = "Uniform1iARB ")]
        public static GLDelegate.Uniform1i _Uniform1i = null;
        public static GLDelegate.Uniform1i Uniform1iARB = Uniform1i;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform1i.</para>
        /// <para>Fullname: Uniform1i</para>
        /// <para>Aliases: Uniform1iARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform1i(int location, int v0)
        {
            if (gl._Uniform1i != null) gl._Uniform1i(location, v0); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform1iv</para>
        /// </summary>
        [GLEntry("Uniform1iv", Category = "2.0", Alias = "Uniform1ivARB ")]
        public static GLDelegate.Uniform1iv _Uniform1iv = null;
        public static GLDelegate.Uniform1iv Uniform1ivARB = Uniform1iv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform1iv.</para>
        /// <para>Fullname: Uniform1iv</para>
        /// <para>Aliases: Uniform1ivARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform1iv(int location, int count, int[] value)
        {
            if (gl._Uniform1iv != null) gl._Uniform1iv(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform2f</para>
        /// </summary>
        [GLEntry("Uniform2f", Category = "2.0", Alias = "Uniform2fARB ")]
        public static GLDelegate.Uniform2f _Uniform2f = null;
        public static GLDelegate.Uniform2f Uniform2fARB = Uniform2f;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform2f.</para>
        /// <para>Fullname: Uniform2f</para>
        /// <para>Aliases: Uniform2fARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform2f(int location, float v0, float v1)
        {
            if (gl._Uniform2f != null) gl._Uniform2f(location, v0, v1); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform2fv</para>
        /// </summary>
        [GLEntry("Uniform2fv", Category = "2.0", Alias = "Uniform2fvARB ")]
        public static GLDelegate.Uniform2fv _Uniform2fv = null;
        public static GLDelegate.Uniform2fv Uniform2fvARB = Uniform2fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform2fv.</para>
        /// <para>Fullname: Uniform2fv</para>
        /// <para>Aliases: Uniform2fvARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform2fv(int location, int count, float[] value)
        {
            if (gl._Uniform2fv != null) gl._Uniform2fv(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform2i</para>
        /// </summary>
        [GLEntry("Uniform2i", Category = "2.0", Alias = "Uniform2iARB ")]
        public static GLDelegate.Uniform2i _Uniform2i = null;
        public static GLDelegate.Uniform2i Uniform2iARB = Uniform2i;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform2i.</para>
        /// <para>Fullname: Uniform2i</para>
        /// <para>Aliases: Uniform2iARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform2i(int location, int v0, int v1)
        {
            if (gl._Uniform2i != null) gl._Uniform2i(location, v0, v1); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform2iv</para>
        /// </summary>
        [GLEntry("Uniform2iv", Category = "2.0", Alias = "Uniform2ivARB ")]
        public static GLDelegate.Uniform2iv _Uniform2iv = null;
        public static GLDelegate.Uniform2iv Uniform2ivARB = Uniform2iv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform2iv.</para>
        /// <para>Fullname: Uniform2iv</para>
        /// <para>Aliases: Uniform2ivARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform2iv(int location, int count, int[] value)
        {
            if (gl._Uniform2iv != null) gl._Uniform2iv(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform3f</para>
        /// </summary>
        [GLEntry("Uniform3f", Category = "2.0", Alias = "Uniform3fARB ")]
        public static GLDelegate.Uniform3f _Uniform3f = null;
        public static GLDelegate.Uniform3f Uniform3fARB = Uniform3f;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform3f.</para>
        /// <para>Fullname: Uniform3f</para>
        /// <para>Aliases: Uniform3fARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform3f(int location, float v0, float v1, float v2)
        {
            if (gl._Uniform3f != null) gl._Uniform3f(location, v0, v1, v2); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform3fv</para>
        /// </summary>
        [GLEntry("Uniform3fv", Category = "2.0", Alias = "Uniform3fvARB ")]
        public static GLDelegate.Uniform3fv _Uniform3fv = null;
        public static GLDelegate.Uniform3fv Uniform3fvARB = Uniform3fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform3fv.</para>
        /// <para>Fullname: Uniform3fv</para>
        /// <para>Aliases: Uniform3fvARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform3fv(int location, int count, float[] value)
        {
            if (gl._Uniform3fv != null) gl._Uniform3fv(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform3i</para>
        /// </summary>
        [GLEntry("Uniform3i", Category = "2.0", Alias = "Uniform3iARB ")]
        public static GLDelegate.Uniform3i _Uniform3i = null;
        public static GLDelegate.Uniform3i Uniform3iARB = Uniform3i;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform3i.</para>
        /// <para>Fullname: Uniform3i</para>
        /// <para>Aliases: Uniform3iARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform3i(int location, int v0, int v1, int v2)
        {
            if (gl._Uniform3i != null) gl._Uniform3i(location, v0, v1, v2); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform3iv</para>
        /// </summary>
        [GLEntry("Uniform3iv", Category = "2.0", Alias = "Uniform3ivARB ")]
        public static GLDelegate.Uniform3iv _Uniform3iv = null;
        public static GLDelegate.Uniform3iv Uniform3ivARB = Uniform3iv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform3iv.</para>
        /// <para>Fullname: Uniform3iv</para>
        /// <para>Aliases: Uniform3ivARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform3iv(int location, int count, int[] value)
        {
            if (gl._Uniform3iv != null) gl._Uniform3iv(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform4f</para>
        /// </summary>
        [GLEntry("Uniform4f", Category = "2.0", Alias = "Uniform4fARB ")]
        public static GLDelegate.Uniform4f _Uniform4f = null;
        public static GLDelegate.Uniform4f Uniform4fARB = Uniform4f;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform4f.</para>
        /// <para>Fullname: Uniform4f</para>
        /// <para>Aliases: Uniform4fARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform4f(int location, float v0, float v1, float v2, float v3)
        {
            if (gl._Uniform4f != null) gl._Uniform4f(location, v0, v1, v2, v3); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform4fv</para>
        /// </summary>
        [GLEntry("Uniform4fv", Category = "2.0", Alias = "Uniform4fvARB ")]
        public static GLDelegate.Uniform4fv _Uniform4fv = null;
        public static GLDelegate.Uniform4fv Uniform4fvARB = Uniform4fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform4fv.</para>
        /// <para>Fullname: Uniform4fv</para>
        /// <para>Aliases: Uniform4fvARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform4fv(int location, int count, float[] value)
        {
            if (gl._Uniform4fv != null) gl._Uniform4fv(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform4i</para>
        /// </summary>
        [GLEntry("Uniform4i", Category = "2.0", Alias = "Uniform4iARB ")]
        public static GLDelegate.Uniform4i _Uniform4i = null;
        public static GLDelegate.Uniform4i Uniform4iARB = Uniform4i;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform4i.</para>
        /// <para>Fullname: Uniform4i</para>
        /// <para>Aliases: Uniform4iARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform4i(int location, int v0, int v1, int v2, int v3)
        {
            if (gl._Uniform4i != null) gl._Uniform4i(location, v0, v1, v2, v3); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform4iv</para>
        /// </summary>
        [GLEntry("Uniform4iv", Category = "2.0", Alias = "Uniform4ivARB ")]
        public static GLDelegate.Uniform4iv _Uniform4iv = null;
        public static GLDelegate.Uniform4iv Uniform4ivARB = Uniform4iv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform4iv.</para>
        /// <para>Fullname: Uniform4iv</para>
        /// <para>Aliases: Uniform4ivARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform4iv(int location, int count, int[] value)
        {
            if (gl._Uniform4iv != null) gl._Uniform4iv(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformMatrix2fv</para>
        /// </summary>
        [GLEntry("UniformMatrix2fv", Category = "2.0", Alias = "UniformMatrix2fvARB ")]
        public static GLDelegate.UniformMatrix2fv _UniformMatrix2fv = null;
        public static GLDelegate.UniformMatrix2fv UniformMatrix2fvARB = UniformMatrix2fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformMatrix2fv.</para>
        /// <para>Fullname: UniformMatrix2fv</para>
        /// <para>Aliases: UniformMatrix2fvARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void UniformMatrix2fv(int location, int count, bool transpose, float[] value)
        {
            if (gl._UniformMatrix2fv != null) gl._UniformMatrix2fv(location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformMatrix3fv</para>
        /// </summary>
        [GLEntry("UniformMatrix3fv", Category = "2.0", Alias = "UniformMatrix3fvARB ")]
        public static GLDelegate.UniformMatrix3fv _UniformMatrix3fv = null;
        public static GLDelegate.UniformMatrix3fv UniformMatrix3fvARB = UniformMatrix3fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformMatrix3fv.</para>
        /// <para>Fullname: UniformMatrix3fv</para>
        /// <para>Aliases: UniformMatrix3fvARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void UniformMatrix3fv(int location, int count, bool transpose, float[] value)
        {
            if (gl._UniformMatrix3fv != null) gl._UniformMatrix3fv(location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformMatrix4fv</para>
        /// </summary>
        [GLEntry("UniformMatrix4fv", Category = "2.0", Alias = "UniformMatrix4fvARB ")]
        public static GLDelegate.UniformMatrix4fv _UniformMatrix4fv = null;
        public static GLDelegate.UniformMatrix4fv UniformMatrix4fvARB = UniformMatrix4fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformMatrix4fv.</para>
        /// <para>Fullname: UniformMatrix4fv</para>
        /// <para>Aliases: UniformMatrix4fvARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void UniformMatrix4fv(int location, int count, bool transpose, float[] value)
        {
            if (gl._UniformMatrix4fv != null) gl._UniformMatrix4fv(location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UseProgram</para>
        /// </summary>
        [GLEntry("UseProgram", Category = "2.0")]
        public static GLDelegate.UseProgram _UseProgram = null;
        /// <summary>
        /// <para>Installs a program object as part of current rendering state</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UseProgram.</para>
        /// <para>Fullname: UseProgram</para>
        /// <para>Extensions: VERSION_2_0</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program object whose executables are to be used as part of current rendering state.</param>
        public static void UseProgram(uint program)
        {
            if (gl._UseProgram != null) gl._UseProgram(program); else { }
        }
        /// <summary>
        /// <para>Fullname: ValidateProgram</para>
        /// </summary>
        [GLEntry("ValidateProgram", Category = "2.0", Alias = "ValidateProgramARB ")]
        public static GLDelegate.ValidateProgram _ValidateProgram = null;
        public static GLDelegate.ValidateProgram ValidateProgramARB = ValidateProgram;
        /// <summary>
        /// <para>Validates a program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ValidateProgram.</para>
        /// <para>Fullname: ValidateProgram</para>
        /// <para>Aliases: ValidateProgramARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_shader_objects</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program object to be validated.</param>
        public static void ValidateProgram(uint program)
        {
            if (gl._ValidateProgram != null) gl._ValidateProgram(program); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib1d</para>
        /// </summary>
        [GLEntry("VertexAttrib1d", Category = "2.0", Alias = "VertexAttrib1dARB VertexAttrib1dNV ")]
        public static GLDelegate.VertexAttrib1d _VertexAttrib1d = null;
        public static GLDelegate.VertexAttrib1d VertexAttrib1dARB = VertexAttrib1d;
        public static GLDelegate.VertexAttrib1d VertexAttrib1dNV = VertexAttrib1d;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib1d.</para>
        /// <para>Fullname: VertexAttrib1d</para>
        /// <para>Aliases: VertexAttrib1dARB, VertexAttrib1dNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib1d(uint index, double x)
        {
            if (gl._VertexAttrib1d != null) gl._VertexAttrib1d(index, x); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib1dv</para>
        /// </summary>
        [GLEntry("VertexAttrib1dv", Category = "2.0", Alias = "VertexAttrib1dvARB VertexAttrib1dvNV ")]
        public static GLDelegate.VertexAttrib1dv_double _VertexAttrib1dv_double = null;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib1dv_double.</para>
        /// <para>Fullname: VertexAttrib1dv</para>
        /// <para>Aliases: VertexAttrib1dvARB, VertexAttrib1dvNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib1dv(uint index, ref double v)
        {
            if (gl._VertexAttrib1dv_double != null) gl._VertexAttrib1dv_double(index, ref v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib1dv</para>
        /// </summary>
        [GLEntry("VertexAttrib1dv", Category = "2.0", Alias = "VertexAttrib1dvARB VertexAttrib1dvNV ")]
        public static GLDelegate.VertexAttrib1dv _VertexAttrib1dv = null;
        public static GLDelegate.VertexAttrib1dv VertexAttrib1dvARB = VertexAttrib1dv;
        public static GLDelegate.VertexAttrib1dv VertexAttrib1dvNV = VertexAttrib1dv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib1dv.</para>
        /// <para>Fullname: VertexAttrib1dv</para>
        /// <para>Aliases: VertexAttrib1dvARB, VertexAttrib1dvNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib1dv(uint index, double[] v)
        {
            if (gl._VertexAttrib1dv != null) gl._VertexAttrib1dv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib1f</para>
        /// </summary>
        [GLEntry("VertexAttrib1f", Category = "2.0", Alias = "VertexAttrib1fARB VertexAttrib1fNV ")]
        public static GLDelegate.VertexAttrib1f _VertexAttrib1f = null;
        public static GLDelegate.VertexAttrib1f VertexAttrib1fARB = VertexAttrib1f;
        public static GLDelegate.VertexAttrib1f VertexAttrib1fNV = VertexAttrib1f;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib1f.</para>
        /// <para>Fullname: VertexAttrib1f</para>
        /// <para>Aliases: VertexAttrib1fARB, VertexAttrib1fNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib1f(uint index, float x)
        {
            if (gl._VertexAttrib1f != null) gl._VertexAttrib1f(index, x); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib1fv</para>
        /// </summary>
        [GLEntry("VertexAttrib1fv", Category = "2.0", Alias = "VertexAttrib1fvARB VertexAttrib1fvNV ")]
        public static GLDelegate.VertexAttrib1fv _VertexAttrib1fv = null;
        public static GLDelegate.VertexAttrib1fv VertexAttrib1fvARB = VertexAttrib1fv;
        public static GLDelegate.VertexAttrib1fv VertexAttrib1fvNV = VertexAttrib1fv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib1fv.</para>
        /// <para>Fullname: VertexAttrib1fv</para>
        /// <para>Aliases: VertexAttrib1fvARB, VertexAttrib1fvNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib1fv(uint index, float[] v)
        {
            if (gl._VertexAttrib1fv != null) gl._VertexAttrib1fv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib1fv</para>
        /// </summary>
        [GLEntry("VertexAttrib1fv", Category = "2.0", Alias = "VertexAttrib1fvARB VertexAttrib1fvNV ")]
        public static GLDelegate.VertexAttrib1fv_float _VertexAttrib1fv_float = null;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib1fv_float.</para>
        /// <para>Fullname: VertexAttrib1fv</para>
        /// <para>Aliases: VertexAttrib1fvARB, VertexAttrib1fvNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib1fv(uint index, ref float v)
        {
            if (gl._VertexAttrib1fv_float != null) gl._VertexAttrib1fv_float(index, ref v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib1s</para>
        /// </summary>
        [GLEntry("VertexAttrib1s", Category = "2.0", Alias = "VertexAttrib1sARB VertexAttrib1sNV ")]
        public static GLDelegate.VertexAttrib1s _VertexAttrib1s = null;
        public static GLDelegate.VertexAttrib1s VertexAttrib1sARB = VertexAttrib1s;
        public static GLDelegate.VertexAttrib1s VertexAttrib1sNV = VertexAttrib1s;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib1s.</para>
        /// <para>Fullname: VertexAttrib1s</para>
        /// <para>Aliases: VertexAttrib1sARB, VertexAttrib1sNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib1s(uint index, short x)
        {
            if (gl._VertexAttrib1s != null) gl._VertexAttrib1s(index, x); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib1sv</para>
        /// </summary>
        [GLEntry("VertexAttrib1sv", Category = "2.0", Alias = "VertexAttrib1svARB VertexAttrib1svNV ")]
        public static GLDelegate.VertexAttrib1sv _VertexAttrib1sv = null;
        public static GLDelegate.VertexAttrib1sv VertexAttrib1svARB = VertexAttrib1sv;
        public static GLDelegate.VertexAttrib1sv VertexAttrib1svNV = VertexAttrib1sv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib1sv.</para>
        /// <para>Fullname: VertexAttrib1sv</para>
        /// <para>Aliases: VertexAttrib1svARB, VertexAttrib1svNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib1sv(uint index, short[] v)
        {
            if (gl._VertexAttrib1sv != null) gl._VertexAttrib1sv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib2d</para>
        /// </summary>
        [GLEntry("VertexAttrib2d", Category = "2.0", Alias = "VertexAttrib2dARB VertexAttrib2dNV ")]
        public static GLDelegate.VertexAttrib2d _VertexAttrib2d = null;
        public static GLDelegate.VertexAttrib2d VertexAttrib2dARB = VertexAttrib2d;
        public static GLDelegate.VertexAttrib2d VertexAttrib2dNV = VertexAttrib2d;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib2d.</para>
        /// <para>Fullname: VertexAttrib2d</para>
        /// <para>Aliases: VertexAttrib2dARB, VertexAttrib2dNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib2d(uint index, double x, double y)
        {
            if (gl._VertexAttrib2d != null) gl._VertexAttrib2d(index, x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib2dv</para>
        /// </summary>
        [GLEntry("VertexAttrib2dv", Category = "2.0", Alias = "VertexAttrib2dvARB VertexAttrib2dvNV ")]
        public static GLDelegate.VertexAttrib2dv _VertexAttrib2dv = null;
        public static GLDelegate.VertexAttrib2dv VertexAttrib2dvARB = VertexAttrib2dv;
        public static GLDelegate.VertexAttrib2dv VertexAttrib2dvNV = VertexAttrib2dv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib2dv.</para>
        /// <para>Fullname: VertexAttrib2dv</para>
        /// <para>Aliases: VertexAttrib2dvARB, VertexAttrib2dvNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib2dv(uint index, double[] v)
        {
            if (gl._VertexAttrib2dv != null) gl._VertexAttrib2dv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib2f</para>
        /// </summary>
        [GLEntry("VertexAttrib2f", Category = "2.0", Alias = "VertexAttrib2fARB VertexAttrib2fNV ")]
        public static GLDelegate.VertexAttrib2f _VertexAttrib2f = null;
        public static GLDelegate.VertexAttrib2f VertexAttrib2fARB = VertexAttrib2f;
        public static GLDelegate.VertexAttrib2f VertexAttrib2fNV = VertexAttrib2f;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib2f.</para>
        /// <para>Fullname: VertexAttrib2f</para>
        /// <para>Aliases: VertexAttrib2fARB, VertexAttrib2fNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib2f(uint index, float x, float y)
        {
            if (gl._VertexAttrib2f != null) gl._VertexAttrib2f(index, x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib2fv</para>
        /// </summary>
        [GLEntry("VertexAttrib2fv", Category = "2.0", Alias = "VertexAttrib2fvARB VertexAttrib2fvNV ")]
        public static GLDelegate.VertexAttrib2fv _VertexAttrib2fv = null;
        public static GLDelegate.VertexAttrib2fv VertexAttrib2fvARB = VertexAttrib2fv;
        public static GLDelegate.VertexAttrib2fv VertexAttrib2fvNV = VertexAttrib2fv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib2fv.</para>
        /// <para>Fullname: VertexAttrib2fv</para>
        /// <para>Aliases: VertexAttrib2fvARB, VertexAttrib2fvNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib2fv(uint index, float[] v)
        {
            if (gl._VertexAttrib2fv != null) gl._VertexAttrib2fv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib2s</para>
        /// </summary>
        [GLEntry("VertexAttrib2s", Category = "2.0", Alias = "VertexAttrib2sARB VertexAttrib2sNV ")]
        public static GLDelegate.VertexAttrib2s _VertexAttrib2s = null;
        public static GLDelegate.VertexAttrib2s VertexAttrib2sARB = VertexAttrib2s;
        public static GLDelegate.VertexAttrib2s VertexAttrib2sNV = VertexAttrib2s;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib2s.</para>
        /// <para>Fullname: VertexAttrib2s</para>
        /// <para>Aliases: VertexAttrib2sARB, VertexAttrib2sNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib2s(uint index, short x, short y)
        {
            if (gl._VertexAttrib2s != null) gl._VertexAttrib2s(index, x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib2sv</para>
        /// </summary>
        [GLEntry("VertexAttrib2sv", Category = "2.0", Alias = "VertexAttrib2svARB VertexAttrib2svNV ")]
        public static GLDelegate.VertexAttrib2sv _VertexAttrib2sv = null;
        public static GLDelegate.VertexAttrib2sv VertexAttrib2svARB = VertexAttrib2sv;
        public static GLDelegate.VertexAttrib2sv VertexAttrib2svNV = VertexAttrib2sv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib2sv.</para>
        /// <para>Fullname: VertexAttrib2sv</para>
        /// <para>Aliases: VertexAttrib2svARB, VertexAttrib2svNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib2sv(uint index, short[] v)
        {
            if (gl._VertexAttrib2sv != null) gl._VertexAttrib2sv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib3d</para>
        /// </summary>
        [GLEntry("VertexAttrib3d", Category = "2.0", Alias = "VertexAttrib3dARB VertexAttrib3dNV ")]
        public static GLDelegate.VertexAttrib3d _VertexAttrib3d = null;
        public static GLDelegate.VertexAttrib3d VertexAttrib3dARB = VertexAttrib3d;
        public static GLDelegate.VertexAttrib3d VertexAttrib3dNV = VertexAttrib3d;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib3d.</para>
        /// <para>Fullname: VertexAttrib3d</para>
        /// <para>Aliases: VertexAttrib3dARB, VertexAttrib3dNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib3d(uint index, double x, double y, double z)
        {
            if (gl._VertexAttrib3d != null) gl._VertexAttrib3d(index, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib3dv</para>
        /// </summary>
        [GLEntry("VertexAttrib3dv", Category = "2.0", Alias = "VertexAttrib3dvARB VertexAttrib3dvNV ")]
        public static GLDelegate.VertexAttrib3dv _VertexAttrib3dv = null;
        public static GLDelegate.VertexAttrib3dv VertexAttrib3dvARB = VertexAttrib3dv;
        public static GLDelegate.VertexAttrib3dv VertexAttrib3dvNV = VertexAttrib3dv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib3dv.</para>
        /// <para>Fullname: VertexAttrib3dv</para>
        /// <para>Aliases: VertexAttrib3dvARB, VertexAttrib3dvNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib3dv(uint index, double[] v)
        {
            if (gl._VertexAttrib3dv != null) gl._VertexAttrib3dv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib3f</para>
        /// </summary>
        [GLEntry("VertexAttrib3f", Category = "2.0", Alias = "VertexAttrib3fARB VertexAttrib3fNV ")]
        public static GLDelegate.VertexAttrib3f _VertexAttrib3f = null;
        public static GLDelegate.VertexAttrib3f VertexAttrib3fARB = VertexAttrib3f;
        public static GLDelegate.VertexAttrib3f VertexAttrib3fNV = VertexAttrib3f;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib3f.</para>
        /// <para>Fullname: VertexAttrib3f</para>
        /// <para>Aliases: VertexAttrib3fARB, VertexAttrib3fNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib3f(uint index, float x, float y, float z)
        {
            if (gl._VertexAttrib3f != null) gl._VertexAttrib3f(index, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib3fv</para>
        /// </summary>
        [GLEntry("VertexAttrib3fv", Category = "2.0", Alias = "VertexAttrib3fvARB VertexAttrib3fvNV ")]
        public static GLDelegate.VertexAttrib3fv _VertexAttrib3fv = null;
        public static GLDelegate.VertexAttrib3fv VertexAttrib3fvARB = VertexAttrib3fv;
        public static GLDelegate.VertexAttrib3fv VertexAttrib3fvNV = VertexAttrib3fv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib3fv.</para>
        /// <para>Fullname: VertexAttrib3fv</para>
        /// <para>Aliases: VertexAttrib3fvARB, VertexAttrib3fvNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib3fv(uint index, float[] v)
        {
            if (gl._VertexAttrib3fv != null) gl._VertexAttrib3fv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib3s</para>
        /// </summary>
        [GLEntry("VertexAttrib3s", Category = "2.0", Alias = "VertexAttrib3sARB VertexAttrib3sNV ")]
        public static GLDelegate.VertexAttrib3s _VertexAttrib3s = null;
        public static GLDelegate.VertexAttrib3s VertexAttrib3sARB = VertexAttrib3s;
        public static GLDelegate.VertexAttrib3s VertexAttrib3sNV = VertexAttrib3s;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib3s.</para>
        /// <para>Fullname: VertexAttrib3s</para>
        /// <para>Aliases: VertexAttrib3sARB, VertexAttrib3sNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib3s(uint index, short x, short y, short z)
        {
            if (gl._VertexAttrib3s != null) gl._VertexAttrib3s(index, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib3sv</para>
        /// </summary>
        [GLEntry("VertexAttrib3sv", Category = "2.0", Alias = "VertexAttrib3svARB VertexAttrib3svNV ")]
        public static GLDelegate.VertexAttrib3sv _VertexAttrib3sv = null;
        public static GLDelegate.VertexAttrib3sv VertexAttrib3svARB = VertexAttrib3sv;
        public static GLDelegate.VertexAttrib3sv VertexAttrib3svNV = VertexAttrib3sv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib3sv.</para>
        /// <para>Fullname: VertexAttrib3sv</para>
        /// <para>Aliases: VertexAttrib3svARB, VertexAttrib3svNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib3sv(uint index, short[] v)
        {
            if (gl._VertexAttrib3sv != null) gl._VertexAttrib3sv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4bv</para>
        /// </summary>
        [GLEntry("VertexAttrib4bv", Category = "2.0", Alias = "VertexAttrib4bvARB ")]
        public static GLDelegate.VertexAttrib4bv _VertexAttrib4bv = null;
        public static GLDelegate.VertexAttrib4bv VertexAttrib4bvARB = VertexAttrib4bv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4bv.</para>
        /// <para>Fullname: VertexAttrib4bv</para>
        /// <para>Aliases: VertexAttrib4bvARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib4bv(uint index, byte[] v)
        {
            if (gl._VertexAttrib4bv != null) gl._VertexAttrib4bv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4d</para>
        /// </summary>
        [GLEntry("VertexAttrib4d", Category = "2.0", Alias = "VertexAttrib4dARB VertexAttrib4dNV ")]
        public static GLDelegate.VertexAttrib4d _VertexAttrib4d = null;
        public static GLDelegate.VertexAttrib4d VertexAttrib4dARB = VertexAttrib4d;
        public static GLDelegate.VertexAttrib4d VertexAttrib4dNV = VertexAttrib4d;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4d.</para>
        /// <para>Fullname: VertexAttrib4d</para>
        /// <para>Aliases: VertexAttrib4dARB, VertexAttrib4dNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib4d(uint index, double x, double y, double z, double w)
        {
            if (gl._VertexAttrib4d != null) gl._VertexAttrib4d(index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4dv</para>
        /// </summary>
        [GLEntry("VertexAttrib4dv", Category = "2.0", Alias = "VertexAttrib4dvARB VertexAttrib4dvNV ")]
        public static GLDelegate.VertexAttrib4dv _VertexAttrib4dv = null;
        public static GLDelegate.VertexAttrib4dv VertexAttrib4dvARB = VertexAttrib4dv;
        public static GLDelegate.VertexAttrib4dv VertexAttrib4dvNV = VertexAttrib4dv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4dv.</para>
        /// <para>Fullname: VertexAttrib4dv</para>
        /// <para>Aliases: VertexAttrib4dvARB, VertexAttrib4dvNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib4dv(uint index, double[] v)
        {
            if (gl._VertexAttrib4dv != null) gl._VertexAttrib4dv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4f</para>
        /// </summary>
        [GLEntry("VertexAttrib4f", Category = "2.0", Alias = "VertexAttrib4fARB VertexAttrib4fNV ")]
        public static GLDelegate.VertexAttrib4f _VertexAttrib4f = null;
        public static GLDelegate.VertexAttrib4f VertexAttrib4fARB = VertexAttrib4f;
        public static GLDelegate.VertexAttrib4f VertexAttrib4fNV = VertexAttrib4f;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4f.</para>
        /// <para>Fullname: VertexAttrib4f</para>
        /// <para>Aliases: VertexAttrib4fARB, VertexAttrib4fNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib4f(uint index, float x, float y, float z, float w)
        {
            if (gl._VertexAttrib4f != null) gl._VertexAttrib4f(index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4fv</para>
        /// </summary>
        [GLEntry("VertexAttrib4fv", Category = "2.0", Alias = "VertexAttrib4fvARB VertexAttrib4fvNV ")]
        public static GLDelegate.VertexAttrib4fv _VertexAttrib4fv = null;
        public static GLDelegate.VertexAttrib4fv VertexAttrib4fvARB = VertexAttrib4fv;
        public static GLDelegate.VertexAttrib4fv VertexAttrib4fvNV = VertexAttrib4fv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4fv.</para>
        /// <para>Fullname: VertexAttrib4fv</para>
        /// <para>Aliases: VertexAttrib4fvARB, VertexAttrib4fvNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib4fv(uint index, float[] v)
        {
            if (gl._VertexAttrib4fv != null) gl._VertexAttrib4fv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4iv</para>
        /// </summary>
        [GLEntry("VertexAttrib4iv", Category = "2.0", Alias = "VertexAttrib4ivARB ")]
        public static GLDelegate.VertexAttrib4iv _VertexAttrib4iv = null;
        public static GLDelegate.VertexAttrib4iv VertexAttrib4ivARB = VertexAttrib4iv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4iv.</para>
        /// <para>Fullname: VertexAttrib4iv</para>
        /// <para>Aliases: VertexAttrib4ivARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib4iv(uint index, int[] v)
        {
            if (gl._VertexAttrib4iv != null) gl._VertexAttrib4iv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4Nbv</para>
        /// </summary>
        [GLEntry("VertexAttrib4Nbv", Category = "2.0", Alias = "VertexAttrib4NbvARB ")]
        public static GLDelegate.VertexAttrib4Nbv _VertexAttrib4Nbv = null;
        public static GLDelegate.VertexAttrib4Nbv VertexAttrib4NbvARB = VertexAttrib4Nbv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4Nbv.</para>
        /// <para>Fullname: VertexAttrib4Nbv</para>
        /// <para>Aliases: VertexAttrib4NbvARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib4Nbv(uint index, byte[] v)
        {
            if (gl._VertexAttrib4Nbv != null) gl._VertexAttrib4Nbv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4Niv</para>
        /// </summary>
        [GLEntry("VertexAttrib4Niv", Category = "2.0", Alias = "VertexAttrib4NivARB ")]
        public static GLDelegate.VertexAttrib4Niv _VertexAttrib4Niv = null;
        public static GLDelegate.VertexAttrib4Niv VertexAttrib4NivARB = VertexAttrib4Niv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4Niv.</para>
        /// <para>Fullname: VertexAttrib4Niv</para>
        /// <para>Aliases: VertexAttrib4NivARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib4Niv(uint index, int[] v)
        {
            if (gl._VertexAttrib4Niv != null) gl._VertexAttrib4Niv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4Nsv</para>
        /// </summary>
        [GLEntry("VertexAttrib4Nsv", Category = "2.0", Alias = "VertexAttrib4NsvARB ")]
        public static GLDelegate.VertexAttrib4Nsv _VertexAttrib4Nsv = null;
        public static GLDelegate.VertexAttrib4Nsv VertexAttrib4NsvARB = VertexAttrib4Nsv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4Nsv.</para>
        /// <para>Fullname: VertexAttrib4Nsv</para>
        /// <para>Aliases: VertexAttrib4NsvARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib4Nsv(uint index, short[] v)
        {
            if (gl._VertexAttrib4Nsv != null) gl._VertexAttrib4Nsv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4Nub</para>
        /// </summary>
        [GLEntry("VertexAttrib4Nub", Category = "2.0", Alias = "VertexAttrib4NubARB ")]
        public static GLDelegate.VertexAttrib4Nub _VertexAttrib4Nub = null;
        public static GLDelegate.VertexAttrib4Nub VertexAttrib4NubARB = VertexAttrib4Nub;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4Nub.</para>
        /// <para>Fullname: VertexAttrib4Nub</para>
        /// <para>Aliases: VertexAttrib4NubARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib4Nub(uint index, byte x, byte y, byte z, byte w)
        {
            if (gl._VertexAttrib4Nub != null) gl._VertexAttrib4Nub(index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4Nubv</para>
        /// </summary>
        [GLEntry("VertexAttrib4Nubv", Category = "2.0", Alias = "VertexAttrib4NubvARB ")]
        public static GLDelegate.VertexAttrib4Nubv _VertexAttrib4Nubv = null;
        public static GLDelegate.VertexAttrib4Nubv VertexAttrib4NubvARB = VertexAttrib4Nubv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4Nubv.</para>
        /// <para>Fullname: VertexAttrib4Nubv</para>
        /// <para>Aliases: VertexAttrib4NubvARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib4Nubv(uint index, byte[] v)
        {
            if (gl._VertexAttrib4Nubv != null) gl._VertexAttrib4Nubv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4Nuiv</para>
        /// </summary>
        [GLEntry("VertexAttrib4Nuiv", Category = "2.0", Alias = "VertexAttrib4NuivARB ")]
        public static GLDelegate.VertexAttrib4Nuiv _VertexAttrib4Nuiv = null;
        public static GLDelegate.VertexAttrib4Nuiv VertexAttrib4NuivARB = VertexAttrib4Nuiv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4Nuiv.</para>
        /// <para>Fullname: VertexAttrib4Nuiv</para>
        /// <para>Aliases: VertexAttrib4NuivARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib4Nuiv(uint index, uint[] v)
        {
            if (gl._VertexAttrib4Nuiv != null) gl._VertexAttrib4Nuiv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4Nusv</para>
        /// </summary>
        [GLEntry("VertexAttrib4Nusv", Category = "2.0", Alias = "VertexAttrib4NusvARB ")]
        public static GLDelegate.VertexAttrib4Nusv _VertexAttrib4Nusv = null;
        public static GLDelegate.VertexAttrib4Nusv VertexAttrib4NusvARB = VertexAttrib4Nusv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4Nusv.</para>
        /// <para>Fullname: VertexAttrib4Nusv</para>
        /// <para>Aliases: VertexAttrib4NusvARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib4Nusv(uint index, ushort[] v)
        {
            if (gl._VertexAttrib4Nusv != null) gl._VertexAttrib4Nusv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4s</para>
        /// </summary>
        [GLEntry("VertexAttrib4s", Category = "2.0", Alias = "VertexAttrib4sARB VertexAttrib4sNV ")]
        public static GLDelegate.VertexAttrib4s _VertexAttrib4s = null;
        public static GLDelegate.VertexAttrib4s VertexAttrib4sARB = VertexAttrib4s;
        public static GLDelegate.VertexAttrib4s VertexAttrib4sNV = VertexAttrib4s;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4s.</para>
        /// <para>Fullname: VertexAttrib4s</para>
        /// <para>Aliases: VertexAttrib4sARB, VertexAttrib4sNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib4s(uint index, short x, short y, short z, short w)
        {
            if (gl._VertexAttrib4s != null) gl._VertexAttrib4s(index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4sv</para>
        /// </summary>
        [GLEntry("VertexAttrib4sv", Category = "2.0", Alias = "VertexAttrib4svARB VertexAttrib4svNV ")]
        public static GLDelegate.VertexAttrib4sv _VertexAttrib4sv = null;
        public static GLDelegate.VertexAttrib4sv VertexAttrib4svARB = VertexAttrib4sv;
        public static GLDelegate.VertexAttrib4sv VertexAttrib4svNV = VertexAttrib4sv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4sv.</para>
        /// <para>Fullname: VertexAttrib4sv</para>
        /// <para>Aliases: VertexAttrib4svARB, VertexAttrib4svNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib4sv(uint index, short[] v)
        {
            if (gl._VertexAttrib4sv != null) gl._VertexAttrib4sv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4ubv</para>
        /// </summary>
        [GLEntry("VertexAttrib4ubv", Category = "2.0", Alias = "VertexAttrib4ubvARB VertexAttrib4ubvNV ")]
        public static GLDelegate.VertexAttrib4ubv _VertexAttrib4ubv = null;
        public static GLDelegate.VertexAttrib4ubv VertexAttrib4ubvARB = VertexAttrib4ubv;
        public static GLDelegate.VertexAttrib4ubv VertexAttrib4ubvNV = VertexAttrib4ubv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4ubv.</para>
        /// <para>Fullname: VertexAttrib4ubv</para>
        /// <para>Aliases: VertexAttrib4ubvARB, VertexAttrib4ubvNV, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program NV_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib4ubv(uint index, byte[] v)
        {
            if (gl._VertexAttrib4ubv != null) gl._VertexAttrib4ubv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4uiv</para>
        /// </summary>
        [GLEntry("VertexAttrib4uiv", Category = "2.0", Alias = "VertexAttrib4uivARB ")]
        public static GLDelegate.VertexAttrib4uiv _VertexAttrib4uiv = null;
        public static GLDelegate.VertexAttrib4uiv VertexAttrib4uivARB = VertexAttrib4uiv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4uiv.</para>
        /// <para>Fullname: VertexAttrib4uiv</para>
        /// <para>Aliases: VertexAttrib4uivARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib4uiv(uint index, uint[] v)
        {
            if (gl._VertexAttrib4uiv != null) gl._VertexAttrib4uiv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4usv</para>
        /// </summary>
        [GLEntry("VertexAttrib4usv", Category = "2.0", Alias = "VertexAttrib4usvARB ")]
        public static GLDelegate.VertexAttrib4usv _VertexAttrib4usv = null;
        public static GLDelegate.VertexAttrib4usv VertexAttrib4usvARB = VertexAttrib4usv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4usv.</para>
        /// <para>Fullname: VertexAttrib4usv</para>
        /// <para>Aliases: VertexAttrib4usvARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttrib4usv(uint index, ushort[] v)
        {
            if (gl._VertexAttrib4usv != null) gl._VertexAttrib4usv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribPointer</para>
        /// </summary>
        [GLEntry("VertexAttribPointer", Category = "2.0", Alias = "VertexAttribPointerARB ")]
        public static GLDelegate.VertexAttribPointer _VertexAttribPointer = null;
        public static GLDelegate.VertexAttribPointer VertexAttribPointerARB = VertexAttribPointer;
        /// <summary>
        /// <para>define an array of generic vertex attribute data</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribPointer.</para>
        /// <para>Fullname: VertexAttribPointer</para>
        /// <para>Aliases: VertexAttribPointerARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
        /// <param name="normalized">For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.</param>
        /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        public static void VertexAttribPointer(uint index, int size, int type, bool normalized, int stride, IntPtr pointer)
        {
            if (gl._VertexAttribPointer != null) gl._VertexAttribPointer(index, size, type, normalized, stride, pointer); else { }
        }
        /// <summary>
        /// <para>define an array of generic vertex attribute data</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribPointer.</para>
        /// <para>Fullname: VertexAttribPointer</para>
        /// <para>Aliases: VertexAttribPointerARB, </para>
        /// <para>Extensions: VERSION_2_0 ARB_vertex_program</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</param>
        /// <param name="normalized">For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.</param>
        /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        public static void VertexAttribPointer(uint index, int size, int type, bool normalized, int stride, Array pointer)
        {
            GCHandle h = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try { if (gl._VertexAttribPointer != null) gl._VertexAttribPointer(index, size, type, normalized, stride, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: UniformMatrix2x3fv</para>
        /// </summary>
        [GLEntry("UniformMatrix2x3fv", Category = "2.1")]
        public static GLDelegate.UniformMatrix2x3fv _UniformMatrix2x3fv = null;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformMatrix2x3fv.</para>
        /// <para>Fullname: UniformMatrix2x3fv</para>
        /// <para>Extensions: VERSION_2_1</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void UniformMatrix2x3fv(int location, int count, bool transpose, float[] value)
        {
            if (gl._UniformMatrix2x3fv != null) gl._UniformMatrix2x3fv(location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformMatrix2x4fv</para>
        /// </summary>
        [GLEntry("UniformMatrix2x4fv", Category = "2.1")]
        public static GLDelegate.UniformMatrix2x4fv _UniformMatrix2x4fv = null;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformMatrix2x4fv.</para>
        /// <para>Fullname: UniformMatrix2x4fv</para>
        /// <para>Extensions: VERSION_2_1</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void UniformMatrix2x4fv(int location, int count, bool transpose, float[] value)
        {
            if (gl._UniformMatrix2x4fv != null) gl._UniformMatrix2x4fv(location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformMatrix3x2fv</para>
        /// </summary>
        [GLEntry("UniformMatrix3x2fv", Category = "2.1")]
        public static GLDelegate.UniformMatrix3x2fv _UniformMatrix3x2fv = null;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformMatrix3x2fv.</para>
        /// <para>Fullname: UniformMatrix3x2fv</para>
        /// <para>Extensions: VERSION_2_1</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void UniformMatrix3x2fv(int location, int count, bool transpose, float[] value)
        {
            if (gl._UniformMatrix3x2fv != null) gl._UniformMatrix3x2fv(location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformMatrix3x4fv</para>
        /// </summary>
        [GLEntry("UniformMatrix3x4fv", Category = "2.1")]
        public static GLDelegate.UniformMatrix3x4fv _UniformMatrix3x4fv = null;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformMatrix3x4fv.</para>
        /// <para>Fullname: UniformMatrix3x4fv</para>
        /// <para>Extensions: VERSION_2_1</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void UniformMatrix3x4fv(int location, int count, bool transpose, float[] value)
        {
            if (gl._UniformMatrix3x4fv != null) gl._UniformMatrix3x4fv(location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformMatrix4x2fv</para>
        /// </summary>
        [GLEntry("UniformMatrix4x2fv", Category = "2.1")]
        public static GLDelegate.UniformMatrix4x2fv _UniformMatrix4x2fv = null;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformMatrix4x2fv.</para>
        /// <para>Fullname: UniformMatrix4x2fv</para>
        /// <para>Extensions: VERSION_2_1</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void UniformMatrix4x2fv(int location, int count, bool transpose, float[] value)
        {
            if (gl._UniformMatrix4x2fv != null) gl._UniformMatrix4x2fv(location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformMatrix4x3fv</para>
        /// </summary>
        [GLEntry("UniformMatrix4x3fv", Category = "2.1")]
        public static GLDelegate.UniformMatrix4x3fv _UniformMatrix4x3fv = null;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformMatrix4x3fv.</para>
        /// <para>Fullname: UniformMatrix4x3fv</para>
        /// <para>Extensions: VERSION_2_1</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void UniformMatrix4x3fv(int location, int count, bool transpose, float[] value)
        {
            if (gl._UniformMatrix4x3fv != null) gl._UniformMatrix4x3fv(location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: BeginConditionalRender</para>
        /// </summary>
        [GLEntry("BeginConditionalRender", Category = "3.0", Alias = "BeginConditionalRenderNV ")]
        public static GLDelegate.BeginConditionalRender _BeginConditionalRender = null;
        public static GLDelegate.BeginConditionalRender BeginConditionalRenderNV = BeginConditionalRender;
        /// <summary>
        /// <para>start conditional rendering</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BeginConditionalRender.</para>
        /// <para>Fullname: BeginConditionalRender</para>
        /// <para>Aliases: BeginConditionalRenderNV, </para>
        /// <para>Extensions: VERSION_3_0 NV_conditional_render</para>
        /// </summary>
        /// <param name="id">Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded.</param>
        /// <param name="mode">Specifies how glBeginConditionalRender interprets the results of the occlusion query.</param>
        public static void BeginConditionalRender(uint id, int mode)
        {
            if (gl._BeginConditionalRender != null) gl._BeginConditionalRender(id, mode); else { }
        }
        /// <summary>
        /// <para>Fullname: BeginTransformFeedback</para>
        /// </summary>
        [GLEntry("BeginTransformFeedback", Category = "3.0", Alias = "BeginTransformFeedbackEXT BeginTransformFeedbackNV ")]
        public static GLDelegate.BeginTransformFeedback _BeginTransformFeedback = null;
        public static GLDelegate.BeginTransformFeedback BeginTransformFeedbackEXT = BeginTransformFeedback;
        public static GLDelegate.BeginTransformFeedback BeginTransformFeedbackNV = BeginTransformFeedback;
        /// <summary>
        /// <para>start transform feedback operation</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BeginTransformFeedback.</para>
        /// <para>Fullname: BeginTransformFeedback</para>
        /// <para>Aliases: BeginTransformFeedbackEXT, BeginTransformFeedbackNV, </para>
        /// <para>Extensions: VERSION_3_0 EXT_transform_feedback NV_transform_feedback</para>
        /// </summary>
        /// <param name="primitiveMode">Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback.</param>
        public static void BeginTransformFeedback(int primitiveMode)
        {
            if (gl._BeginTransformFeedback != null) gl._BeginTransformFeedback(primitiveMode); else { }
        }
        /// <summary>
        /// <para>Fullname: BindBufferBase</para>
        /// </summary>
        [GLEntry("BindBufferBase", Category = "3.0", Alias = "BindBufferBaseEXT BindBufferBaseNV ")]
        public static GLDelegate.BindBufferBase _BindBufferBase = null;
        public static GLDelegate.BindBufferBase BindBufferBaseEXT = BindBufferBase;
        public static GLDelegate.BindBufferBase BindBufferBaseNV = BindBufferBase;
        /// <summary>
        /// <para>bind a buffer object to an indexed buffer target</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindBufferBase.</para>
        /// <para>Fullname: BindBufferBase</para>
        /// <para>Aliases: BindBufferBaseEXT, BindBufferBaseNV, </para>
        /// <para>Extensions: VERSION_3_0 EXT_transform_feedback NV_transform_feedback</para>
        /// </summary>
        /// <param name="target">Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.</param>
        /// <param name="index">Specify the index of the binding point within the array specified by target.</param>
        /// <param name="buffer">The name of a buffer object to bind to the specified binding point.</param>
        public static void BindBufferBase(int target, uint index, uint buffer)
        {
            if (gl._BindBufferBase != null) gl._BindBufferBase(target, index, buffer); else { }
        }
        /// <summary>
        /// <para>Fullname: BindBufferRange</para>
        /// </summary>
        [GLEntry("BindBufferRange", Category = "3.0", Alias = "BindBufferRangeEXT BindBufferRangeNV ")]
        public static GLDelegate.BindBufferRange _BindBufferRange = null;
        public static GLDelegate.BindBufferRange BindBufferRangeEXT = BindBufferRange;
        public static GLDelegate.BindBufferRange BindBufferRangeNV = BindBufferRange;
        /// <summary>
        /// <para>bind a range within a buffer object to an indexed buffer target</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindBufferRange.</para>
        /// <para>Fullname: BindBufferRange</para>
        /// <para>Aliases: BindBufferRangeEXT, BindBufferRangeNV, </para>
        /// <para>Extensions: VERSION_3_0 EXT_transform_feedback NV_transform_feedback</para>
        /// </summary>
        /// <param name="target">Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER.</param>
        /// <param name="index">Specify the index of the binding point within the array specified by target.</param>
        /// <param name="buffer">The name of a buffer object to bind to the specified binding point.</param>
        /// <param name="offset">The starting offset in basic machine units into the buffer object buffer.</param>
        /// <param name="size">The amount of data in machine units that can be read from the buffet object while used as an indexed target.</param>
        public static void BindBufferRange(int target, uint index, uint buffer, int offset, int size)
        {
            if (gl._BindBufferRange != null) gl._BindBufferRange(target, index, buffer, offset, size); else { }
        }
        /// <summary>
        /// <para>Fullname: BindFragDataLocation</para>
        /// </summary>
        [GLEntry("BindFragDataLocation", Category = "3.0", Alias = "BindFragDataLocationEXT ")]
        public static GLDelegate.BindFragDataLocation _BindFragDataLocation = null;
        public static GLDelegate.BindFragDataLocation BindFragDataLocationEXT = BindFragDataLocation;
        /// <summary>
        /// <para>bind a user-defined varying out variable to a fragment shader color number</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindFragDataLocation.</para>
        /// <para>Fullname: BindFragDataLocation</para>
        /// <para>Aliases: BindFragDataLocationEXT, </para>
        /// <para>Extensions: VERSION_3_0 EXT_gpu_shader4</para>
        /// </summary>
        /// <param name="program">The name of the program containing varying out variable whose binding to modify</param>
        /// <param name="colorNumber">The color number to bind the user-defined varying out variable to</param>
        /// <param name="name">The name of the user-defined varying out variable whose binding to modify</param>
        public static void BindFragDataLocation(uint program, uint color, StringBuilder name)
        {
            if (gl._BindFragDataLocation != null) gl._BindFragDataLocation(program, color, name); else { }
        }
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new hardware. In particular, this extension provides the following functionality: * New texture lookup functions are provided that allow shaders to access individual texels using integer coordinates referring to the texel location and level of detail. No filtering is performed. These functions allow applications to use textures as one-, two-, and three-dimensional arrays. * New texture lookup functions are provided that allow shaders to query the dimensions of a specific level-of-detail image of a texture object. * New texture lookup functions variants are provided that allow shaders to pass a constant integer vector used to offset the texel locations used during the lookup to assist in custom texture filtering operations. * New texture lookup functions are provided that allow shaders to access one- and two-dimensional array textures. The second, or third, coordinate...</para>
        /// <para>Fullname: BindFragDataLocation</para>
        /// <para>Aliases: BindFragDataLocationEXT, </para>
        /// <para>Extensions: VERSION_3_0 EXT_gpu_shader4</para>
        /// </summary>
        public static void BindFragDataLocation(uint program, uint color, string name)
        {
            if (gl._BindFragDataLocation != null) gl._BindFragDataLocation(program, color, new StringBuilder(name));
        }
        /// <summary>
        /// <para>Fullname: ClampColor</para>
        /// </summary>
        [GLEntry("ClampColor", Category = "3.0", Alias = "ClampColorARB ")]
        public static GLDelegate.ClampColor _ClampColor = null;
        public static GLDelegate.ClampColor ClampColorARB = ClampColor;
        /// <summary>
        /// <para>specify whether data read via glReadPixels should be clamped</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClampColor.</para>
        /// <para>Fullname: ClampColor</para>
        /// <para>Aliases: ClampColorARB, </para>
        /// <para>Extensions: VERSION_3_0 ARB_color_buffer_float</para>
        /// </summary>
        /// <param name="target">Target for color clamping. target must be GL_CLAMP_READ_COLOR.</param>
        /// <param name="clamp">Specifies whether to apply color clamping. clamp must be GL_TRUE or GL_FALSE.</param>
        public static void ClampColor(int target, int clamp)
        {
            if (gl._ClampColor != null) gl._ClampColor(target, clamp); else { }
        }
        /// <summary>
        /// <para>Fullname: ClearBufferfi</para>
        /// </summary>
        [GLEntry("ClearBufferfi", Category = "3.0")]
        public static GLDelegate.ClearBufferfi _ClearBufferfi = null;
        /// <summary>
        /// <para>clear individual buffers of the currently bound draw framebuffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClearBufferfi.</para>
        /// <para>Fullname: ClearBufferfi</para>
        /// <para>Extensions: VERSION_3_0</para>
        /// </summary>
        /// <param name="buffer">Specify the buffer to clear.</param>
        /// <param name="drawBuffer">Specify a particular draw buffer to clear.</param>
        /// <param name="value">For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.</param>
        /// <param name="depth">The value to clear a depth render buffer to.</param>
        /// <param name="stencil">The value to clear a stencil render buffer to.</param>
        public static void ClearBufferfi(int buffer, int drawbuffer, float depth, int stencil)
        {
            if (gl._ClearBufferfi != null) gl._ClearBufferfi(buffer, drawbuffer, depth, stencil); else { }
        }
        /// <summary>
        /// <para>Fullname: ClearBufferfv</para>
        /// </summary>
        [GLEntry("ClearBufferfv", Category = "3.0")]
        public static GLDelegate.ClearBufferfv _ClearBufferfv = null;
        /// <summary>
        /// <para>clear individual buffers of the currently bound draw framebuffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClearBufferfv.</para>
        /// <para>Fullname: ClearBufferfv</para>
        /// <para>Extensions: VERSION_3_0</para>
        /// </summary>
        /// <param name="buffer">Specify the buffer to clear.</param>
        /// <param name="drawBuffer">Specify a particular draw buffer to clear.</param>
        /// <param name="value">For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.</param>
        /// <param name="depth">The value to clear a depth render buffer to.</param>
        /// <param name="stencil">The value to clear a stencil render buffer to.</param>
        public static void ClearBufferfv(int buffer, int drawbuffer, float[] value)
        {
            if (gl._ClearBufferfv != null) gl._ClearBufferfv(buffer, drawbuffer, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ClearBufferiv</para>
        /// </summary>
        [GLEntry("ClearBufferiv", Category = "3.0")]
        public static GLDelegate.ClearBufferiv _ClearBufferiv = null;
        /// <summary>
        /// <para>clear individual buffers of the currently bound draw framebuffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClearBufferiv.</para>
        /// <para>Fullname: ClearBufferiv</para>
        /// <para>Extensions: VERSION_3_0</para>
        /// </summary>
        /// <param name="buffer">Specify the buffer to clear.</param>
        /// <param name="drawBuffer">Specify a particular draw buffer to clear.</param>
        /// <param name="value">For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.</param>
        /// <param name="depth">The value to clear a depth render buffer to.</param>
        /// <param name="stencil">The value to clear a stencil render buffer to.</param>
        public static void ClearBufferiv(int buffer, int drawbuffer, int[] value)
        {
            if (gl._ClearBufferiv != null) gl._ClearBufferiv(buffer, drawbuffer, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ClearBufferuiv</para>
        /// </summary>
        [GLEntry("ClearBufferuiv", Category = "3.0")]
        public static GLDelegate.ClearBufferuiv _ClearBufferuiv = null;
        /// <summary>
        /// <para>clear individual buffers of the currently bound draw framebuffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClearBufferuiv.</para>
        /// <para>Fullname: ClearBufferuiv</para>
        /// <para>Extensions: VERSION_3_0</para>
        /// </summary>
        /// <param name="buffer">Specify the buffer to clear.</param>
        /// <param name="drawBuffer">Specify a particular draw buffer to clear.</param>
        /// <param name="value">For color buffers, a pointer to a four-element vector specifying R, G, B and A values to clear the buffer to. For depth buffers, a pointer to a single depth value to clear the buffer to. For stencil buffers, a pointer to a single stencil value to clear the buffer to.</param>
        /// <param name="depth">The value to clear a depth render buffer to.</param>
        /// <param name="stencil">The value to clear a stencil render buffer to.</param>
        public static void ClearBufferuiv(int buffer, int drawbuffer, uint[] value)
        {
            if (gl._ClearBufferuiv != null) gl._ClearBufferuiv(buffer, drawbuffer, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ColorMaski</para>
        /// </summary>
        [GLEntry("ColorMaski", Category = "3.0")]
        public static GLDelegate.ColorMaski _ColorMaski = null;
        /// <summary>
        /// <para>enable and disable writing of frame buffer color components</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorMaski.</para>
        /// <para>Fullname: ColorMaski</para>
        /// <para>Extensions: VERSION_3_0</para>
        /// </summary>
        /// <param name="buf">For glColorMaski, specifies the index of the draw buffer whose color mask to set.</param>
        /// <param name="red">Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written.</param>
        /// <param name="green">Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written.</param>
        /// <param name="blue">Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written.</param>
        /// <param name="alpha">Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written.</param>
        public static void ColorMaski(uint index, bool r, bool g, bool b, bool a)
        {
            if (gl._ColorMaski != null) gl._ColorMaski(index, r, g, b, a); else { }
        }
        /// <summary>
        /// <para>Fullname: Disablei</para>
        /// </summary>
        [GLEntry("Disablei", Category = "3.0")]
        public static GLDelegate.Disablei _Disablei = null;
        /// <summary>
        /// <para>enable or disable server-side GL capabilities</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Disablei.</para>
        /// <para>Fullname: Disablei</para>
        /// <para>Extensions: VERSION_3_0</para>
        /// </summary>
        /// <param name="cap">Specifies a symbolic constant indicating a GL capability.</param>
        public static void Disablei(int target, uint index)
        {
            if (gl._Disablei != null) gl._Disablei(target, index); else { }
        }
        /// <summary>
        /// <para>Fullname: Enablei</para>
        /// </summary>
        [GLEntry("Enablei", Category = "3.0")]
        public static GLDelegate.Enablei _Enablei = null;
        /// <summary>
        /// <para>enable or disable server-side GL capabilities</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Enablei.</para>
        /// <para>Fullname: Enablei</para>
        /// <para>Extensions: VERSION_3_0</para>
        /// </summary>
        /// <param name="cap">Specifies a symbolic constant indicating a GL capability.</param>
        public static void Enablei(int target, uint index)
        {
            if (gl._Enablei != null) gl._Enablei(target, index); else { }
        }
        /// <summary>
        /// <para>Fullname: EndConditionalRender</para>
        /// </summary>
        [GLEntry("EndConditionalRender", Category = "3.0", Alias = "EndConditionalRenderNV ")]
        public static GLDelegate.EndConditionalRender _EndConditionalRender = null;
        public static GLDelegate.EndConditionalRender EndConditionalRenderNV = EndConditionalRender;
        /// <summary>
        /// <para>start conditional rendering</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EndConditionalRender.</para>
        /// <para>Fullname: EndConditionalRender</para>
        /// <para>Aliases: EndConditionalRenderNV, </para>
        /// <para>Extensions: VERSION_3_0 NV_conditional_render</para>
        /// </summary>
        /// <param name="id">Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded.</param>
        /// <param name="mode">Specifies how glBeginConditionalRender interprets the results of the occlusion query.</param>
        public static void EndConditionalRender()
        {
            if (gl._EndConditionalRender != null) gl._EndConditionalRender(); else { }
        }
        /// <summary>
        /// <para>Fullname: EndTransformFeedback</para>
        /// </summary>
        [GLEntry("EndTransformFeedback", Category = "3.0", Alias = "EndTransformFeedbackEXT EndTransformFeedbackNV ")]
        public static GLDelegate.EndTransformFeedback _EndTransformFeedback = null;
        public static GLDelegate.EndTransformFeedback EndTransformFeedbackEXT = EndTransformFeedback;
        public static GLDelegate.EndTransformFeedback EndTransformFeedbackNV = EndTransformFeedback;
        /// <summary>
        /// <para>This extension provides a new mode to the GL, called transform feedback, which records selected vertex attributes for each primitive processed by the GL.  The selected attributes are written into buffer objects, and can be written with each attribute in a separate buffer object or with all attributes interleaved into a single buffer object.  If a geometry shader is active, the primitives recorded are those emitted by the geometry shader.  Otherwise, transform feedback captures primitives whose vertices are transformed by a vertex shader.  In either case, the primitives captured are those generated prior to clipping.  Transform feedback mode captures the values of specified varying variables emitted from GLSL vertex or geometry shaders. The vertex data recorded in transform feedback mode is stored into buffer objects as an array of vertex attributes.  The regular representation and the use of buffer objects allows the recorded data to be processed directly by the GL without requiring CP...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EndTransformFeedback.</para>
        /// <para>Fullname: EndTransformFeedback</para>
        /// <para>Aliases: EndTransformFeedbackEXT, EndTransformFeedbackNV, </para>
        /// <para>Extensions: VERSION_3_0 EXT_transform_feedback NV_transform_feedback</para>
        /// </summary>
        public static void EndTransformFeedback()
        {
            if (gl._EndTransformFeedback != null) gl._EndTransformFeedback(); else { }
        }
        /// <summary>
        /// <para>Fullname: GetBooleani_v</para>
        /// </summary>
        [GLEntry("GetBooleani_v", Category = "3.0")]
        public static GLDelegate.GetBooleani_v _GetBooleani_v = null;
        /// <summary>
        /// <para>return the value or values of a selected parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetBooleani_v.</para>
        /// <para>Fullname: GetBooleani_v</para>
        /// <para>Extensions: VERSION_3_0</para>
        /// </summary>
        /// <param name="pname">Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.</param>
        /// <param name="params">Returns the value or values of the specified parameter.</param>
        public static void GetBooleani_v(int target, uint index, bool[] data)
        {
            if (gl._GetBooleani_v != null) gl._GetBooleani_v(target, index, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetFragDataLocation</para>
        /// </summary>
        [GLEntry("GetFragDataLocation", Category = "3.0", Alias = "GetFragDataLocationEXT ")]
        public static GLDelegate.GetFragDataLocation _GetFragDataLocation = null;
        public static GLDelegate.GetFragDataLocation GetFragDataLocationEXT = GetFragDataLocation;
        /// <summary>
        /// <para>query the bindings of color numbers to user-defined varying out variables</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetFragDataLocation.</para>
        /// <para>Fullname: GetFragDataLocation</para>
        /// <para>Aliases: GetFragDataLocationEXT, </para>
        /// <para>Extensions: VERSION_3_0 EXT_gpu_shader4</para>
        /// </summary>
        /// <param name="program">The name of the program containing varying out variable whose binding to query</param>
        /// <param name="name">The name of the user-defined varying out variable whose binding to query</param>
        public static int GetFragDataLocation(uint program, StringBuilder name)
        {
            if (gl._GetFragDataLocation != null) return gl._GetFragDataLocation(program, name);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: GetIntegeri_v</para>
        /// </summary>
        [GLEntry("GetIntegeri_v", Category = "3.0")]
        public static GLDelegate.GetIntegeri_v _GetIntegeri_v = null;
        /// <summary>
        /// <para>return the value or values of a selected parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetIntegeri_v.</para>
        /// <para>Fullname: GetIntegeri_v</para>
        /// <para>Extensions: VERSION_3_0</para>
        /// </summary>
        /// <param name="pname">Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.</param>
        /// <param name="params">Returns the value or values of the specified parameter.</param>
        public static void GetIntegeri_v(int target, uint index, int[] data)
        {
            if (gl._GetIntegeri_v != null) gl._GetIntegeri_v(target, index, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetStringi</para>
        /// </summary>
        [GLEntry("GetStringi", Category = "3.0")]
        public static GLDelegate.GetStringi _GetStringi = null;
        /// <summary>
        /// <para>return a string describing the current GL connection</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetStringi.</para>
        /// <para>Fullname: GetStringi</para>
        /// <para>Extensions: VERSION_3_0</para>
        /// </summary>
        /// <param name="name">Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token.</param>
        /// <param name="index">For glGetStringi, specifies the index of the string to return.</param>
        public static IntPtr GetStringi(int name, uint index)
        {
            if (gl._GetStringi != null) return gl._GetStringi(name, index);
            else { return (IntPtr)0; }
        }
        /// <summary>
        /// Wrapped glGetString function. Returns marshaled string instead of IntPtr
        /// </summary>
        public static string GetStringiNet(int name, uint index)
        {
            if (gl._GetStringi != null)
            {
                IntPtr i = GetStringi(name, index);
                return Marshal.PtrToStringAnsi(i);
            }
            return null;
        }
        /// <summary>
        /// <para>Fullname: GetTexParameterIiv</para>
        /// </summary>
        [GLEntry("GetTexParameterIiv", Category = "3.0", Alias = "GetTexParameterIivEXT ")]
        public static GLDelegate.GetTexParameterIiv _GetTexParameterIiv = null;
        public static GLDelegate.GetTexParameterIiv GetTexParameterIivEXT = GetTexParameterIiv;
        /// <summary>
        /// <para>return texture parameter values</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTexParameterIiv.</para>
        /// <para>Fullname: GetTexParameterIiv</para>
        /// <para>Aliases: GetTexParameterIivEXT, </para>
        /// <para>Extensions: VERSION_3_0 EXT_texture_integer</para>
        /// </summary>
        /// <param name="target">Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="params">Returns the texture parameters.</param>
        public static void GetTexParameterIiv(int target, int pname, int[] param)
        {
            if (gl._GetTexParameterIiv != null) gl._GetTexParameterIiv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTexParameterIuiv</para>
        /// </summary>
        [GLEntry("GetTexParameterIuiv", Category = "3.0", Alias = "GetTexParameterIuivEXT ")]
        public static GLDelegate.GetTexParameterIuiv _GetTexParameterIuiv = null;
        public static GLDelegate.GetTexParameterIuiv GetTexParameterIuivEXT = GetTexParameterIuiv;
        /// <summary>
        /// <para>return texture parameter values</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTexParameterIuiv.</para>
        /// <para>Fullname: GetTexParameterIuiv</para>
        /// <para>Aliases: GetTexParameterIuivEXT, </para>
        /// <para>Extensions: VERSION_3_0 EXT_texture_integer</para>
        /// </summary>
        /// <param name="target">Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, and GL_TEXTURE_CUBE_MAP_ARRAY are accepted.</param>
        /// <param name="pname">Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT, GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS, GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are accepted.</param>
        /// <param name="params">Returns the texture parameters.</param>
        public static void GetTexParameterIuiv(int target, int pname, uint[] param)
        {
            if (gl._GetTexParameterIuiv != null) gl._GetTexParameterIuiv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTransformFeedbackVarying</para>
        /// </summary>
        [GLEntry("GetTransformFeedbackVarying", Category = "3.0", Alias = "GetTransformFeedbackVaryingEXT ")]
        public static GLDelegate.GetTransformFeedbackVarying _GetTransformFeedbackVarying = null;
        public static GLDelegate.GetTransformFeedbackVarying GetTransformFeedbackVaryingEXT = GetTransformFeedbackVarying;
        /// <summary>
        /// <para>retrieve information about varying variables selected for transform feedback</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTransformFeedbackVarying.</para>
        /// <para>Fullname: GetTransformFeedbackVarying</para>
        /// <para>Aliases: GetTransformFeedbackVaryingEXT, </para>
        /// <para>Extensions: VERSION_3_0 EXT_transform_feedback</para>
        /// </summary>
        /// <param name="program">The name of the target program object.</param>
        /// <param name="index">The index of the varying variable whose information to retrieve.</param>
        /// <param name="bufSize">The maximum number of characters, including the null terminator, that may be written into name.</param>
        /// <param name="length">The address of a variable which will receive the number of characters written into name, excluding the null-terminator. If length is NULL no length is returned.</param>
        /// <param name="size">The address of a variable that will receive the size of the varying.</param>
        /// <param name="type">The address of a variable that will recieve the type of the varying.</param>
        /// <param name="name">The address of a buffer into which will be written the name of the varying.</param>
        public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int[] length, int[] size, int[] type, StringBuilder name)
        {
            if (gl._GetTransformFeedbackVarying != null) gl._GetTransformFeedbackVarying(program, index, bufSize, length, size, type, name); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTransformFeedbackVarying</para>
        /// </summary>
        [GLEntry("GetTransformFeedbackVarying", Category = "3.0", Alias = "GetTransformFeedbackVaryingEXT ")]
        public static GLDelegate.GetTransformFeedbackVarying_int_int_int _GetTransformFeedbackVarying_int_int_int = null;
        /// <summary>
        /// <para>retrieve information about varying variables selected for transform feedback</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTransformFeedbackVarying_int_int_int.</para>
        /// <para>Fullname: GetTransformFeedbackVarying</para>
        /// <para>Aliases: GetTransformFeedbackVaryingEXT, </para>
        /// <para>Extensions: VERSION_3_0 EXT_transform_feedback</para>
        /// </summary>
        /// <param name="program">The name of the target program object.</param>
        /// <param name="index">The index of the varying variable whose information to retrieve.</param>
        /// <param name="bufSize">The maximum number of characters, including the null terminator, that may be written into name.</param>
        /// <param name="length">The address of a variable which will receive the number of characters written into name, excluding the null-terminator. If length is NULL no length is returned.</param>
        /// <param name="size">The address of a variable that will receive the size of the varying.</param>
        /// <param name="type">The address of a variable that will recieve the type of the varying.</param>
        /// <param name="name">The address of a buffer into which will be written the name of the varying.</param>
        public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, out int length, out int size, out int type, StringBuilder name)
        {
            if (gl._GetTransformFeedbackVarying_int_int_int != null) gl._GetTransformFeedbackVarying_int_int_int(program, index, bufSize, out length, out size, out type, name); else { length = new int(); size = new int(); type = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetUniformuiv</para>
        /// </summary>
        [GLEntry("GetUniformuiv", Category = "3.0", Alias = "GetUniformuivEXT ")]
        public static GLDelegate.GetUniformuiv _GetUniformuiv = null;
        public static GLDelegate.GetUniformuiv GetUniformuivEXT = GetUniformuiv;
        /// <summary>
        /// <para>Returns the value of a uniform variable</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetUniformuiv.</para>
        /// <para>Fullname: GetUniformuiv</para>
        /// <para>Aliases: GetUniformuivEXT, </para>
        /// <para>Extensions: VERSION_3_0 EXT_gpu_shader4</para>
        /// </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="params">Returns the value of the specified uniform variable.</param>
        public static void GetUniformuiv(uint program, int location, uint[] param)
        {
            if (gl._GetUniformuiv != null) gl._GetUniformuiv(program, location, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVertexAttribIiv</para>
        /// </summary>
        [GLEntry("GetVertexAttribIiv", Category = "3.0", Alias = "GetVertexAttribIivEXT ")]
        public static GLDelegate.GetVertexAttribIiv_int _GetVertexAttribIiv_int = null;
        /// <summary>
        /// <para>Return a generic vertex attribute parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVertexAttribIiv_int.</para>
        /// <para>Fullname: GetVertexAttribIiv</para>
        /// <para>Aliases: GetVertexAttribIivEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetVertexAttribIiv(uint index, int pname, out int param)
        {
            if (gl._GetVertexAttribIiv_int != null) gl._GetVertexAttribIiv_int(index, pname, out param); else { param = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetVertexAttribIiv</para>
        /// </summary>
        [GLEntry("GetVertexAttribIiv", Category = "3.0", Alias = "GetVertexAttribIivEXT ")]
        public static GLDelegate.GetVertexAttribIiv _GetVertexAttribIiv = null;
        public static GLDelegate.GetVertexAttribIiv GetVertexAttribIivEXT = GetVertexAttribIiv;
        /// <summary>
        /// <para>Return a generic vertex attribute parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVertexAttribIiv.</para>
        /// <para>Fullname: GetVertexAttribIiv</para>
        /// <para>Aliases: GetVertexAttribIivEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetVertexAttribIiv(uint index, int pname, int[] param)
        {
            if (gl._GetVertexAttribIiv != null) gl._GetVertexAttribIiv(index, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVertexAttribIuiv</para>
        /// </summary>
        [GLEntry("GetVertexAttribIuiv", Category = "3.0", Alias = "GetVertexAttribIuivEXT ")]
        public static GLDelegate.GetVertexAttribIuiv_uint _GetVertexAttribIuiv_uint = null;
        /// <summary>
        /// <para>Return a generic vertex attribute parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVertexAttribIuiv_uint.</para>
        /// <para>Fullname: GetVertexAttribIuiv</para>
        /// <para>Aliases: GetVertexAttribIuivEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetVertexAttribIuiv(uint index, int pname, out uint param)
        {
            if (gl._GetVertexAttribIuiv_uint != null) gl._GetVertexAttribIuiv_uint(index, pname, out param); else { param = new uint(); }
        }
        /// <summary>
        /// <para>Fullname: GetVertexAttribIuiv</para>
        /// </summary>
        [GLEntry("GetVertexAttribIuiv", Category = "3.0", Alias = "GetVertexAttribIuivEXT ")]
        public static GLDelegate.GetVertexAttribIuiv _GetVertexAttribIuiv = null;
        public static GLDelegate.GetVertexAttribIuiv GetVertexAttribIuivEXT = GetVertexAttribIuiv;
        /// <summary>
        /// <para>Return a generic vertex attribute parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVertexAttribIuiv.</para>
        /// <para>Fullname: GetVertexAttribIuiv</para>
        /// <para>Aliases: GetVertexAttribIuivEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetVertexAttribIuiv(uint index, int pname, uint[] param)
        {
            if (gl._GetVertexAttribIuiv != null) gl._GetVertexAttribIuiv(index, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: IsEnabledi</para>
        /// </summary>
        [GLEntry("IsEnabledi", Category = "3.0")]
        public static GLDelegate.IsEnabledi _IsEnabledi = null;
        /// <summary>
        /// <para>test whether a capability is enabled</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsEnabledi.</para>
        /// <para>Fullname: IsEnabledi</para>
        /// <para>Extensions: VERSION_3_0</para>
        /// </summary>
        /// <param name="cap">Specifies a symbolic constant indicating a GL capability.</param>
        /// <param name="index">Specifies the index of the capability.</param>
        public static bool IsEnabledi(int target, uint index)
        {
            if (gl._IsEnabledi != null) return gl._IsEnabledi(target, index);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: TexParameterIiv</para>
        /// </summary>
        [GLEntry("TexParameterIiv", Category = "3.0", Alias = "TexParameterIivEXT ")]
        public static GLDelegate.TexParameterIiv _TexParameterIiv = null;
        public static GLDelegate.TexParameterIiv TexParameterIivEXT = TexParameterIiv;
        /// <summary>
        /// <para>set texture parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexParameterIiv.</para>
        /// <para>Fullname: TexParameterIiv</para>
        /// <para>Aliases: TexParameterIivEXT, </para>
        /// <para>Extensions: VERSION_3_0 EXT_texture_integer</para>
        /// </summary>
        /// <param name="target">Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">Specifies the value of pname.</param>
        public static void TexParameterIiv(int target, int pname, int[] param)
        {
            if (gl._TexParameterIiv != null) gl._TexParameterIiv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TexParameterIuiv</para>
        /// </summary>
        [GLEntry("TexParameterIuiv", Category = "3.0", Alias = "TexParameterIuivEXT ")]
        public static GLDelegate.TexParameterIuiv _TexParameterIuiv = null;
        public static GLDelegate.TexParameterIuiv TexParameterIuivEXT = TexParameterIuiv;
        /// <summary>
        /// <para>set texture parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexParameterIuiv.</para>
        /// <para>Fullname: TexParameterIuiv</para>
        /// <para>Aliases: TexParameterIuivEXT, </para>
        /// <para>Extensions: VERSION_3_0 EXT_texture_integer</para>
        /// </summary>
        /// <param name="target">Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_CUBE_MAP.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R, GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.</param>
        /// <param name="param">Specifies the value of pname.</param>
        public static void TexParameterIuiv(int target, int pname, uint[] param)
        {
            if (gl._TexParameterIuiv != null) gl._TexParameterIuiv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TransformFeedbackVaryings</para>
        /// </summary>
        [GLEntry("TransformFeedbackVaryings", Category = "3.0", Alias = "TransformFeedbackVaryingsEXT ")]
        public static GLDelegate.TransformFeedbackVaryings _TransformFeedbackVaryings = null;
        public static GLDelegate.TransformFeedbackVaryings TransformFeedbackVaryingsEXT = TransformFeedbackVaryings;
        /// <summary>
        /// <para>specify values to record in transform feedback buffers</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TransformFeedbackVaryings.</para>
        /// <para>Fullname: TransformFeedbackVaryings</para>
        /// <para>Aliases: TransformFeedbackVaryingsEXT, </para>
        /// <para>Extensions: VERSION_3_0 EXT_transform_feedback</para>
        /// </summary>
        /// <param name="program">The name of the target program object.</param>
        /// <param name="count">The number of varying variables used for transform feedback.</param>
        /// <param name="varyings">An array of count zero-terminated strings specifying the names of the varying variables to use for transform feedback.</param>
        /// <param name="bufferMode">Identifies the mode used to capture the varying variables when transform feedback is active. bufferMode must be GL_INTERLEAVED_ATTRIBS or GL_SEPARATE_ATTRIBS.</param>
        public static void TransformFeedbackVaryings(uint program, int count, string[] varyings, int bufferMode)
        {
            if (gl._TransformFeedbackVaryings != null) gl._TransformFeedbackVaryings(program, count, varyings, bufferMode); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform1ui</para>
        /// </summary>
        [GLEntry("Uniform1ui", Category = "3.0", Alias = "Uniform1uiEXT ")]
        public static GLDelegate.Uniform1ui _Uniform1ui = null;
        public static GLDelegate.Uniform1ui Uniform1uiEXT = Uniform1ui;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform1ui.</para>
        /// <para>Fullname: Uniform1ui</para>
        /// <para>Aliases: Uniform1uiEXT, </para>
        /// <para>Extensions: VERSION_3_0 EXT_gpu_shader4</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform1ui(int location, uint v0)
        {
            if (gl._Uniform1ui != null) gl._Uniform1ui(location, v0); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform1uiv</para>
        /// </summary>
        [GLEntry("Uniform1uiv", Category = "3.0", Alias = "Uniform1uivEXT ")]
        public static GLDelegate.Uniform1uiv _Uniform1uiv = null;
        public static GLDelegate.Uniform1uiv Uniform1uivEXT = Uniform1uiv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform1uiv.</para>
        /// <para>Fullname: Uniform1uiv</para>
        /// <para>Aliases: Uniform1uivEXT, </para>
        /// <para>Extensions: VERSION_3_0 EXT_gpu_shader4</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform1uiv(int location, int count, uint[] value)
        {
            if (gl._Uniform1uiv != null) gl._Uniform1uiv(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform2ui</para>
        /// </summary>
        [GLEntry("Uniform2ui", Category = "3.0", Alias = "Uniform2uiEXT ")]
        public static GLDelegate.Uniform2ui _Uniform2ui = null;
        public static GLDelegate.Uniform2ui Uniform2uiEXT = Uniform2ui;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform2ui.</para>
        /// <para>Fullname: Uniform2ui</para>
        /// <para>Aliases: Uniform2uiEXT, </para>
        /// <para>Extensions: VERSION_3_0 EXT_gpu_shader4</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform2ui(int location, uint v0, uint v1)
        {
            if (gl._Uniform2ui != null) gl._Uniform2ui(location, v0, v1); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform2uiv</para>
        /// </summary>
        [GLEntry("Uniform2uiv", Category = "3.0", Alias = "Uniform2uivEXT ")]
        public static GLDelegate.Uniform2uiv _Uniform2uiv = null;
        public static GLDelegate.Uniform2uiv Uniform2uivEXT = Uniform2uiv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform2uiv.</para>
        /// <para>Fullname: Uniform2uiv</para>
        /// <para>Aliases: Uniform2uivEXT, </para>
        /// <para>Extensions: VERSION_3_0 EXT_gpu_shader4</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform2uiv(int location, int count, uint[] value)
        {
            if (gl._Uniform2uiv != null) gl._Uniform2uiv(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform3ui</para>
        /// </summary>
        [GLEntry("Uniform3ui", Category = "3.0", Alias = "Uniform3uiEXT ")]
        public static GLDelegate.Uniform3ui _Uniform3ui = null;
        public static GLDelegate.Uniform3ui Uniform3uiEXT = Uniform3ui;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform3ui.</para>
        /// <para>Fullname: Uniform3ui</para>
        /// <para>Aliases: Uniform3uiEXT, </para>
        /// <para>Extensions: VERSION_3_0 EXT_gpu_shader4</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform3ui(int location, uint v0, uint v1, uint v2)
        {
            if (gl._Uniform3ui != null) gl._Uniform3ui(location, v0, v1, v2); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform3uiv</para>
        /// </summary>
        [GLEntry("Uniform3uiv", Category = "3.0", Alias = "Uniform3uivEXT ")]
        public static GLDelegate.Uniform3uiv _Uniform3uiv = null;
        public static GLDelegate.Uniform3uiv Uniform3uivEXT = Uniform3uiv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform3uiv.</para>
        /// <para>Fullname: Uniform3uiv</para>
        /// <para>Aliases: Uniform3uivEXT, </para>
        /// <para>Extensions: VERSION_3_0 EXT_gpu_shader4</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform3uiv(int location, int count, uint[] value)
        {
            if (gl._Uniform3uiv != null) gl._Uniform3uiv(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform4ui</para>
        /// </summary>
        [GLEntry("Uniform4ui", Category = "3.0", Alias = "Uniform4uiEXT ")]
        public static GLDelegate.Uniform4ui _Uniform4ui = null;
        public static GLDelegate.Uniform4ui Uniform4uiEXT = Uniform4ui;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform4ui.</para>
        /// <para>Fullname: Uniform4ui</para>
        /// <para>Aliases: Uniform4uiEXT, </para>
        /// <para>Extensions: VERSION_3_0 EXT_gpu_shader4</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform4ui(int location, uint v0, uint v1, uint v2, uint v3)
        {
            if (gl._Uniform4ui != null) gl._Uniform4ui(location, v0, v1, v2, v3); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform4uiv</para>
        /// </summary>
        [GLEntry("Uniform4uiv", Category = "3.0", Alias = "Uniform4uivEXT ")]
        public static GLDelegate.Uniform4uiv _Uniform4uiv = null;
        public static GLDelegate.Uniform4uiv Uniform4uivEXT = Uniform4uiv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for the current program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform4uiv.</para>
        /// <para>Fullname: Uniform4uiv</para>
        /// <para>Aliases: Uniform4uivEXT, </para>
        /// <para>Extensions: VERSION_3_0 EXT_gpu_shader4</para>
        /// </summary>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void Uniform4uiv(int location, int count, uint[] value)
        {
            if (gl._Uniform4uiv != null) gl._Uniform4uiv(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI1i</para>
        /// </summary>
        [GLEntry("VertexAttribI1i", Category = "3.0", Alias = "VertexAttribI1iEXT ")]
        public static GLDelegate.VertexAttribI1i _VertexAttribI1i = null;
        public static GLDelegate.VertexAttribI1i VertexAttribI1iEXT = VertexAttribI1i;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI1i.</para>
        /// <para>Fullname: VertexAttribI1i</para>
        /// <para>Aliases: VertexAttribI1iEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI1i(uint index, int x)
        {
            if (gl._VertexAttribI1i != null) gl._VertexAttribI1i(index, x); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI1iv</para>
        /// </summary>
        [GLEntry("VertexAttribI1iv", Category = "3.0", Alias = "VertexAttribI1ivEXT ")]
        public static GLDelegate.VertexAttribI1iv _VertexAttribI1iv = null;
        public static GLDelegate.VertexAttribI1iv VertexAttribI1ivEXT = VertexAttribI1iv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI1iv.</para>
        /// <para>Fullname: VertexAttribI1iv</para>
        /// <para>Aliases: VertexAttribI1ivEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI1iv(uint index, int[] v)
        {
            if (gl._VertexAttribI1iv != null) gl._VertexAttribI1iv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI1iv</para>
        /// </summary>
        [GLEntry("VertexAttribI1iv", Category = "3.0", Alias = "VertexAttribI1ivEXT ")]
        public static GLDelegate.VertexAttribI1iv_int _VertexAttribI1iv_int = null;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI1iv_int.</para>
        /// <para>Fullname: VertexAttribI1iv</para>
        /// <para>Aliases: VertexAttribI1ivEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI1iv(uint index, ref int v)
        {
            if (gl._VertexAttribI1iv_int != null) gl._VertexAttribI1iv_int(index, ref v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI1ui</para>
        /// </summary>
        [GLEntry("VertexAttribI1ui", Category = "3.0", Alias = "VertexAttribI1uiEXT ")]
        public static GLDelegate.VertexAttribI1ui _VertexAttribI1ui = null;
        public static GLDelegate.VertexAttribI1ui VertexAttribI1uiEXT = VertexAttribI1ui;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI1ui.</para>
        /// <para>Fullname: VertexAttribI1ui</para>
        /// <para>Aliases: VertexAttribI1uiEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI1ui(uint index, uint x)
        {
            if (gl._VertexAttribI1ui != null) gl._VertexAttribI1ui(index, x); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI1uiv</para>
        /// </summary>
        [GLEntry("VertexAttribI1uiv", Category = "3.0", Alias = "VertexAttribI1uivEXT ")]
        public static GLDelegate.VertexAttribI1uiv_uint _VertexAttribI1uiv_uint = null;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI1uiv_uint.</para>
        /// <para>Fullname: VertexAttribI1uiv</para>
        /// <para>Aliases: VertexAttribI1uivEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI1uiv(uint index, ref uint v)
        {
            if (gl._VertexAttribI1uiv_uint != null) gl._VertexAttribI1uiv_uint(index, ref v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI1uiv</para>
        /// </summary>
        [GLEntry("VertexAttribI1uiv", Category = "3.0", Alias = "VertexAttribI1uivEXT ")]
        public static GLDelegate.VertexAttribI1uiv _VertexAttribI1uiv = null;
        public static GLDelegate.VertexAttribI1uiv VertexAttribI1uivEXT = VertexAttribI1uiv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI1uiv.</para>
        /// <para>Fullname: VertexAttribI1uiv</para>
        /// <para>Aliases: VertexAttribI1uivEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI1uiv(uint index, uint[] v)
        {
            if (gl._VertexAttribI1uiv != null) gl._VertexAttribI1uiv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI2i</para>
        /// </summary>
        [GLEntry("VertexAttribI2i", Category = "3.0", Alias = "VertexAttribI2iEXT ")]
        public static GLDelegate.VertexAttribI2i _VertexAttribI2i = null;
        public static GLDelegate.VertexAttribI2i VertexAttribI2iEXT = VertexAttribI2i;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI2i.</para>
        /// <para>Fullname: VertexAttribI2i</para>
        /// <para>Aliases: VertexAttribI2iEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI2i(uint index, int x, int y)
        {
            if (gl._VertexAttribI2i != null) gl._VertexAttribI2i(index, x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI2iv</para>
        /// </summary>
        [GLEntry("VertexAttribI2iv", Category = "3.0", Alias = "VertexAttribI2ivEXT ")]
        public static GLDelegate.VertexAttribI2iv _VertexAttribI2iv = null;
        public static GLDelegate.VertexAttribI2iv VertexAttribI2ivEXT = VertexAttribI2iv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI2iv.</para>
        /// <para>Fullname: VertexAttribI2iv</para>
        /// <para>Aliases: VertexAttribI2ivEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI2iv(uint index, int[] v)
        {
            if (gl._VertexAttribI2iv != null) gl._VertexAttribI2iv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI2ui</para>
        /// </summary>
        [GLEntry("VertexAttribI2ui", Category = "3.0", Alias = "VertexAttribI2uiEXT ")]
        public static GLDelegate.VertexAttribI2ui _VertexAttribI2ui = null;
        public static GLDelegate.VertexAttribI2ui VertexAttribI2uiEXT = VertexAttribI2ui;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI2ui.</para>
        /// <para>Fullname: VertexAttribI2ui</para>
        /// <para>Aliases: VertexAttribI2uiEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI2ui(uint index, uint x, uint y)
        {
            if (gl._VertexAttribI2ui != null) gl._VertexAttribI2ui(index, x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI2uiv</para>
        /// </summary>
        [GLEntry("VertexAttribI2uiv", Category = "3.0", Alias = "VertexAttribI2uivEXT ")]
        public static GLDelegate.VertexAttribI2uiv _VertexAttribI2uiv = null;
        public static GLDelegate.VertexAttribI2uiv VertexAttribI2uivEXT = VertexAttribI2uiv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI2uiv.</para>
        /// <para>Fullname: VertexAttribI2uiv</para>
        /// <para>Aliases: VertexAttribI2uivEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI2uiv(uint index, uint[] v)
        {
            if (gl._VertexAttribI2uiv != null) gl._VertexAttribI2uiv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI3i</para>
        /// </summary>
        [GLEntry("VertexAttribI3i", Category = "3.0", Alias = "VertexAttribI3iEXT ")]
        public static GLDelegate.VertexAttribI3i _VertexAttribI3i = null;
        public static GLDelegate.VertexAttribI3i VertexAttribI3iEXT = VertexAttribI3i;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI3i.</para>
        /// <para>Fullname: VertexAttribI3i</para>
        /// <para>Aliases: VertexAttribI3iEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI3i(uint index, int x, int y, int z)
        {
            if (gl._VertexAttribI3i != null) gl._VertexAttribI3i(index, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI3iv</para>
        /// </summary>
        [GLEntry("VertexAttribI3iv", Category = "3.0", Alias = "VertexAttribI3ivEXT ")]
        public static GLDelegate.VertexAttribI3iv _VertexAttribI3iv = null;
        public static GLDelegate.VertexAttribI3iv VertexAttribI3ivEXT = VertexAttribI3iv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI3iv.</para>
        /// <para>Fullname: VertexAttribI3iv</para>
        /// <para>Aliases: VertexAttribI3ivEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI3iv(uint index, int[] v)
        {
            if (gl._VertexAttribI3iv != null) gl._VertexAttribI3iv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI3ui</para>
        /// </summary>
        [GLEntry("VertexAttribI3ui", Category = "3.0", Alias = "VertexAttribI3uiEXT ")]
        public static GLDelegate.VertexAttribI3ui _VertexAttribI3ui = null;
        public static GLDelegate.VertexAttribI3ui VertexAttribI3uiEXT = VertexAttribI3ui;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI3ui.</para>
        /// <para>Fullname: VertexAttribI3ui</para>
        /// <para>Aliases: VertexAttribI3uiEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI3ui(uint index, uint x, uint y, uint z)
        {
            if (gl._VertexAttribI3ui != null) gl._VertexAttribI3ui(index, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI3uiv</para>
        /// </summary>
        [GLEntry("VertexAttribI3uiv", Category = "3.0", Alias = "VertexAttribI3uivEXT ")]
        public static GLDelegate.VertexAttribI3uiv _VertexAttribI3uiv = null;
        public static GLDelegate.VertexAttribI3uiv VertexAttribI3uivEXT = VertexAttribI3uiv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI3uiv.</para>
        /// <para>Fullname: VertexAttribI3uiv</para>
        /// <para>Aliases: VertexAttribI3uivEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI3uiv(uint index, uint[] v)
        {
            if (gl._VertexAttribI3uiv != null) gl._VertexAttribI3uiv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI4bv</para>
        /// </summary>
        [GLEntry("VertexAttribI4bv", Category = "3.0", Alias = "VertexAttribI4bvEXT ")]
        public static GLDelegate.VertexAttribI4bv _VertexAttribI4bv = null;
        public static GLDelegate.VertexAttribI4bv VertexAttribI4bvEXT = VertexAttribI4bv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI4bv.</para>
        /// <para>Fullname: VertexAttribI4bv</para>
        /// <para>Aliases: VertexAttribI4bvEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI4bv(uint index, byte[] v)
        {
            if (gl._VertexAttribI4bv != null) gl._VertexAttribI4bv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI4i</para>
        /// </summary>
        [GLEntry("VertexAttribI4i", Category = "3.0", Alias = "VertexAttribI4iEXT ")]
        public static GLDelegate.VertexAttribI4i _VertexAttribI4i = null;
        public static GLDelegate.VertexAttribI4i VertexAttribI4iEXT = VertexAttribI4i;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI4i.</para>
        /// <para>Fullname: VertexAttribI4i</para>
        /// <para>Aliases: VertexAttribI4iEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI4i(uint index, int x, int y, int z, int w)
        {
            if (gl._VertexAttribI4i != null) gl._VertexAttribI4i(index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI4iv</para>
        /// </summary>
        [GLEntry("VertexAttribI4iv", Category = "3.0", Alias = "VertexAttribI4ivEXT ")]
        public static GLDelegate.VertexAttribI4iv _VertexAttribI4iv = null;
        public static GLDelegate.VertexAttribI4iv VertexAttribI4ivEXT = VertexAttribI4iv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI4iv.</para>
        /// <para>Fullname: VertexAttribI4iv</para>
        /// <para>Aliases: VertexAttribI4ivEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI4iv(uint index, int[] v)
        {
            if (gl._VertexAttribI4iv != null) gl._VertexAttribI4iv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI4sv</para>
        /// </summary>
        [GLEntry("VertexAttribI4sv", Category = "3.0", Alias = "VertexAttribI4svEXT ")]
        public static GLDelegate.VertexAttribI4sv _VertexAttribI4sv = null;
        public static GLDelegate.VertexAttribI4sv VertexAttribI4svEXT = VertexAttribI4sv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI4sv.</para>
        /// <para>Fullname: VertexAttribI4sv</para>
        /// <para>Aliases: VertexAttribI4svEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI4sv(uint index, short[] v)
        {
            if (gl._VertexAttribI4sv != null) gl._VertexAttribI4sv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI4ubv</para>
        /// </summary>
        [GLEntry("VertexAttribI4ubv", Category = "3.0", Alias = "VertexAttribI4ubvEXT ")]
        public static GLDelegate.VertexAttribI4ubv _VertexAttribI4ubv = null;
        public static GLDelegate.VertexAttribI4ubv VertexAttribI4ubvEXT = VertexAttribI4ubv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI4ubv.</para>
        /// <para>Fullname: VertexAttribI4ubv</para>
        /// <para>Aliases: VertexAttribI4ubvEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI4ubv(uint index, byte[] v)
        {
            if (gl._VertexAttribI4ubv != null) gl._VertexAttribI4ubv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI4ui</para>
        /// </summary>
        [GLEntry("VertexAttribI4ui", Category = "3.0", Alias = "VertexAttribI4uiEXT ")]
        public static GLDelegate.VertexAttribI4ui _VertexAttribI4ui = null;
        public static GLDelegate.VertexAttribI4ui VertexAttribI4uiEXT = VertexAttribI4ui;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI4ui.</para>
        /// <para>Fullname: VertexAttribI4ui</para>
        /// <para>Aliases: VertexAttribI4uiEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI4ui(uint index, uint x, uint y, uint z, uint w)
        {
            if (gl._VertexAttribI4ui != null) gl._VertexAttribI4ui(index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI4uiv</para>
        /// </summary>
        [GLEntry("VertexAttribI4uiv", Category = "3.0", Alias = "VertexAttribI4uivEXT ")]
        public static GLDelegate.VertexAttribI4uiv _VertexAttribI4uiv = null;
        public static GLDelegate.VertexAttribI4uiv VertexAttribI4uivEXT = VertexAttribI4uiv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI4uiv.</para>
        /// <para>Fullname: VertexAttribI4uiv</para>
        /// <para>Aliases: VertexAttribI4uivEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI4uiv(uint index, uint[] v)
        {
            if (gl._VertexAttribI4uiv != null) gl._VertexAttribI4uiv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribI4usv</para>
        /// </summary>
        [GLEntry("VertexAttribI4usv", Category = "3.0", Alias = "VertexAttribI4usvEXT ")]
        public static GLDelegate.VertexAttribI4usv _VertexAttribI4usv = null;
        public static GLDelegate.VertexAttribI4usv VertexAttribI4usvEXT = VertexAttribI4usv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribI4usv.</para>
        /// <para>Fullname: VertexAttribI4usv</para>
        /// <para>Aliases: VertexAttribI4usvEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// <para>Deprecated: 3.1</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribI4usv(uint index, ushort[] v)
        {
            if (gl._VertexAttribI4usv != null) gl._VertexAttribI4usv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribIPointer</para>
        /// </summary>
        [GLEntry("VertexAttribIPointer", Category = "3.0", Alias = "VertexAttribIPointerEXT ")]
        public static GLDelegate.VertexAttribIPointer _VertexAttribIPointer = null;
        public static GLDelegate.VertexAttribIPointer VertexAttribIPointerEXT = VertexAttribIPointer;
        /// <summary>
        /// <para>define an array of generic vertex attribute data</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribIPointer.</para>
        /// <para>Fullname: VertexAttribIPointer</para>
        /// <para>Aliases: VertexAttribIPointerEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by both functions. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_INT_2_10_10_10_REV, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted by glVertexAttribPointer. The initial value is GL_FLOAT.</param>
        /// <param name="normalized">For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.</param>
        /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        public static void VertexAttribIPointer(uint index, int size, int type, int stride, IntPtr pointer)
        {
            if (gl._VertexAttribIPointer != null) gl._VertexAttribIPointer(index, size, type, stride, pointer); else { }
        }
        /// <summary>
        /// <para>define an array of generic vertex attribute data</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribIPointer.</para>
        /// <para>Fullname: VertexAttribIPointer</para>
        /// <para>Aliases: VertexAttribIPointerEXT, </para>
        /// <para>Extensions: VERSION_3_0 NV_vertex_program4</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by both functions. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_INT_2_10_10_10_REV, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted by glVertexAttribPointer. The initial value is GL_FLOAT.</param>
        /// <param name="normalized">For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.</param>
        /// <param name="stride">Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        public static void VertexAttribIPointer(uint index, int size, int type, int stride, Array pointer)
        {
            GCHandle h = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try { if (gl._VertexAttribIPointer != null) gl._VertexAttribIPointer(index, size, type, stride, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: DrawArraysInstanced</para>
        /// </summary>
        [GLEntry("DrawArraysInstanced", Category = "3.1", Alias = "DrawArraysInstancedARB DrawArraysInstancedEXT ")]
        public static GLDelegate.DrawArraysInstanced _DrawArraysInstanced = null;
        public static GLDelegate.DrawArraysInstanced DrawArraysInstancedARB = DrawArraysInstanced;
        public static GLDelegate.DrawArraysInstanced DrawArraysInstancedEXT = DrawArraysInstanced;
        /// <summary>
        /// <para>draw multiple instances of a range of elements</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawArraysInstanced.</para>
        /// <para>Fullname: DrawArraysInstanced</para>
        /// <para>Aliases: DrawArraysInstancedARB, DrawArraysInstancedEXT, </para>
        /// <para>Extensions: VERSION_3_1 ARB_draw_instanced EXT_draw_instanced</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLESGL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="first">Specifies the starting index in the enabled arrays.</param>
        /// <param name="count">Specifies the number of indices to be rendered.</param>
        /// <param name="primcount">Specifies the number of instances of the specified range of indices to be rendered.</param>
        public static void DrawArraysInstanced(int mode, int first, int count, int instancecount)
        {
            if (gl._DrawArraysInstanced != null) gl._DrawArraysInstanced(mode, first, count, instancecount); else { }
        }
        /// <summary>
        /// <para>Fullname: DrawElementsInstanced</para>
        /// </summary>
        [GLEntry("DrawElementsInstanced", Category = "3.1", Alias = "DrawElementsInstancedARB DrawElementsInstancedEXT ")]
        public static GLDelegate.DrawElementsInstanced _DrawElementsInstanced = null;
        public static GLDelegate.DrawElementsInstanced DrawElementsInstancedARB = DrawElementsInstanced;
        public static GLDelegate.DrawElementsInstanced DrawElementsInstancedEXT = DrawElementsInstanced;
        /// <summary>
        /// <para>draw multiple instances of a set of elements</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawElementsInstanced.</para>
        /// <para>Fullname: DrawElementsInstanced</para>
        /// <para>Aliases: DrawElementsInstancedARB, DrawElementsInstancedEXT, </para>
        /// <para>Extensions: VERSION_3_1 ARB_draw_instanced EXT_draw_instanced</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="primcount">Specifies the number of instances of the specified range of indices to be rendered.</param>
        public static void DrawElementsInstanced(int mode, int count, int type, IntPtr indices, int instancecount)
        {
            if (gl._DrawElementsInstanced != null) gl._DrawElementsInstanced(mode, count, type, indices, instancecount); else { }
        }
        /// <summary>
        /// <para>draw multiple instances of a set of elements</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawElementsInstanced.</para>
        /// <para>Fullname: DrawElementsInstanced</para>
        /// <para>Aliases: DrawElementsInstancedARB, DrawElementsInstancedEXT, </para>
        /// <para>Extensions: VERSION_3_1 ARB_draw_instanced EXT_draw_instanced</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="primcount">Specifies the number of instances of the specified range of indices to be rendered.</param>
        public static void DrawElementsInstanced(int mode, int count, int type, Array indices, int instancecount)
        {
            GCHandle h = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try { if (gl._DrawElementsInstanced != null) gl._DrawElementsInstanced(mode, count, type, h.AddrOfPinnedObject(), instancecount); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: PrimitiveRestartIndex</para>
        /// </summary>
        [GLEntry("PrimitiveRestartIndex", Category = "3.1", Alias = "PrimitiveRestartIndexNV ")]
        public static GLDelegate.PrimitiveRestartIndex _PrimitiveRestartIndex = null;
        public static GLDelegate.PrimitiveRestartIndex PrimitiveRestartIndexNV = PrimitiveRestartIndex;
        /// <summary>
        /// <para>specify the primitive restart index</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PrimitiveRestartIndex.</para>
        /// <para>Fullname: PrimitiveRestartIndex</para>
        /// <para>Aliases: PrimitiveRestartIndexNV, </para>
        /// <para>Extensions: VERSION_3_1 NV_primitive_restart</para>
        /// </summary>
        /// <param name="index">Specifies the value to be interpreted as the primitive restart index.</param>
        public static void PrimitiveRestartIndex(uint index)
        {
            if (gl._PrimitiveRestartIndex != null) gl._PrimitiveRestartIndex(index); else { }
        }
        /// <summary>
        /// <para>Fullname: TexBuffer</para>
        /// </summary>
        [GLEntry("TexBuffer", Category = "3.1", Alias = "TexBufferARB TexBufferEXT ")]
        public static GLDelegate.TexBuffer _TexBuffer = null;
        public static GLDelegate.TexBuffer TexBufferARB = TexBuffer;
        public static GLDelegate.TexBuffer TexBufferEXT = TexBuffer;
        /// <summary>
        /// <para>attach the storage for a buffer object to the active buffer texture</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexBuffer.</para>
        /// <para>Fullname: TexBuffer</para>
        /// <para>Aliases: TexBufferARB, TexBufferEXT, </para>
        /// <para>Extensions: VERSION_3_1 ARB_texture_buffer_object EXT_texture_buffer_object</para>
        /// </summary>
        /// <param name="target">Specifies the target of the operation and must be GL_TEXTURE_BUFFER.</param>
        /// <param name="internalFormat">Specifies the internal format of the data in the store belonging to buffer.</param>
        /// <param name="buffer">Specifies the name of the buffer object whose storage to attach to the active buffer texture.</param>
        public static void TexBuffer(int target, int internalformat, uint buffer)
        {
            if (gl._TexBuffer != null) gl._TexBuffer(target, internalformat, buffer); else { }
        }
        /// <summary>
        /// <para>Fullname: FramebufferTexture</para>
        /// </summary>
        [GLEntry("FramebufferTexture", Category = "3.2", Alias = "FramebufferTextureARB FramebufferTextureEXT ")]
        public static GLDelegate.FramebufferTexture _FramebufferTexture = null;
        public static GLDelegate.FramebufferTexture FramebufferTextureARB = FramebufferTexture;
        public static GLDelegate.FramebufferTexture FramebufferTextureEXT = FramebufferTexture;
        /// <summary>
        /// <para>attach a level of a texture object as a logical buffer to the currently bound framebuffer object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FramebufferTexture.</para>
        /// <para>Fullname: FramebufferTexture</para>
        /// <para>Aliases: FramebufferTextureARB, FramebufferTextureEXT, </para>
        /// <para>Extensions: VERSION_3_2 ARB_geometry_shader4 NV_geometry_program4</para>
        /// </summary>
        /// <param name="target">Specifies the framebuffer target. target must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.</param>
        /// <param name="attachment">Specifies the attachment point of the framebuffer. attachment must be GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT or GL_DEPTH_STENCIL_ATTACHMMENT.</param>
        /// <param name="textarget">For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached.</param>
        /// <param name="texture">Specifies the texture object to attach to the framebuffer attachment point named by attachment.</param>
        /// <param name="level">Specifies the mipmap level of texture to attach.</param>
        public static void FramebufferTexture(int target, int attachment, uint texture, int level)
        {
            if (gl._FramebufferTexture != null) gl._FramebufferTexture(target, attachment, texture, level); else { }
        }
        /// <summary>
        /// <para>Fullname: GetBufferParameteri64v</para>
        /// </summary>
        [GLEntry("GetBufferParameteri64v", Category = "3.2")]
        public static GLDelegate.GetBufferParameteri64v _GetBufferParameteri64v = null;
        /// <summary>
        /// <para>return parameters of a buffer object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetBufferParameteri64v.</para>
        /// <para>Fullname: GetBufferParameteri64v</para>
        /// <para>Extensions: VERSION_3_2</para>
        /// </summary>
        /// <param name="target">Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.</param>
        /// <param name="value">Specifies the symbolic name of a buffer object parameter. Accepted values are GL_BUFFER_ACCESS, GL_BUFFER_MAPPED, GL_BUFFER_SIZE, or GL_BUFFER_USAGE.</param>
        /// <param name="data">Returns the requested parameter.</param>
        public static void GetBufferParameteri64v(int target, int pname, long[] param)
        {
            if (gl._GetBufferParameteri64v != null) gl._GetBufferParameteri64v(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetInteger64i_v</para>
        /// </summary>
        [GLEntry("GetInteger64i_v", Category = "3.2")]
        public static GLDelegate.GetInteger64i_v _GetInteger64i_v = null;
        /// <summary>
        /// <para>return the value or values of a selected parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetInteger64i_v.</para>
        /// <para>Fullname: GetInteger64i_v</para>
        /// <para>Extensions: VERSION_3_2</para>
        /// </summary>
        /// <param name="pname">Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.</param>
        /// <param name="params">Returns the value or values of the specified parameter.</param>
        public static void GetInteger64i_v(int target, uint index, long[] data)
        {
            if (gl._GetInteger64i_v != null) gl._GetInteger64i_v(target, index, data); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribDivisor</para>
        /// </summary>
        [GLEntry("VertexAttribDivisor", Category = "3.3", Alias = "VertexAttribDivisorARB ")]
        public static GLDelegate.VertexAttribDivisor _VertexAttribDivisor = null;
        public static GLDelegate.VertexAttribDivisor VertexAttribDivisorARB = VertexAttribDivisor;
        /// <summary>
        /// <para>modify the rate at which generic vertex attributes advance during instanced rendering</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribDivisor.</para>
        /// <para>Fullname: VertexAttribDivisor</para>
        /// <para>Aliases: VertexAttribDivisorARB, </para>
        /// <para>Extensions: VERSION_3_3 ARB_instanced_arrays</para>
        /// </summary>
        /// <param name="index">Specify the index of the generic vertex attribute.</param>
        /// <param name="divisor">Specify the number of instances that will pass between updates of the generic attribute at slot index.</param>
        public static void VertexAttribDivisor(uint index, uint divisor)
        {
            if (gl._VertexAttribDivisor != null) gl._VertexAttribDivisor(index, divisor); else { }
        }
        /// <summary>
        /// <para>Fullname: BlendEquationi</para>
        /// </summary>
        [GLEntry("BlendEquationi", Category = "4.0", Alias = "BlendEquationiARB ")]
        public static GLDelegate.BlendEquationi _BlendEquationi = null;
        public static GLDelegate.BlendEquationi BlendEquationiARB = BlendEquationi;
        /// <summary>
        /// <para>specify the equation used for both the RGB blend equation and the Alpha blend equation</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BlendEquationi.</para>
        /// <para>Fullname: BlendEquationi</para>
        /// <para>Aliases: BlendEquationiARB, </para>
        /// <para>Extensions: VERSION_4_0 ARB_draw_buffers_blend</para>
        /// </summary>
        /// <param name="buf">for glBlendEquationi, specifies the index of the draw buffer for which to set the blend equation.</param>
        /// <param name="mode">specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.</param>
        public static void BlendEquationi(uint buf, int mode)
        {
            if (gl._BlendEquationi != null) gl._BlendEquationi(buf, mode); else { }
        }
        /// <summary>
        /// <para>Fullname: BlendEquationSeparatei</para>
        /// </summary>
        [GLEntry("BlendEquationSeparatei", Category = "4.0", Alias = "BlendEquationSeparateiARB ")]
        public static GLDelegate.BlendEquationSeparatei _BlendEquationSeparatei = null;
        public static GLDelegate.BlendEquationSeparatei BlendEquationSeparateiARB = BlendEquationSeparatei;
        /// <summary>
        /// <para>set the RGB blend equation and the alpha blend equation separately</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BlendEquationSeparatei.</para>
        /// <para>Fullname: BlendEquationSeparatei</para>
        /// <para>Aliases: BlendEquationSeparateiARB, </para>
        /// <para>Extensions: VERSION_4_0 ARB_draw_buffers_blend</para>
        /// </summary>
        /// <param name="buf">for glBlendEquationSeparatei, specifies the index of the draw buffer for which to set the blend equations.</param>
        /// <param name="modeRGB">specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.</param>
        /// <param name="modeAlpha">specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.</param>
        public static void BlendEquationSeparatei(uint buf, int modeRGB, int modeAlpha)
        {
            if (gl._BlendEquationSeparatei != null) gl._BlendEquationSeparatei(buf, modeRGB, modeAlpha); else { }
        }
        /// <summary>
        /// <para>Fullname: BlendFunci</para>
        /// </summary>
        [GLEntry("BlendFunci", Category = "4.0", Alias = "BlendFunciARB ")]
        public static GLDelegate.BlendFunci _BlendFunci = null;
        public static GLDelegate.BlendFunci BlendFunciARB = BlendFunci;
        /// <summary>
        /// <para>specify pixel arithmetic</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BlendFunci.</para>
        /// <para>Fullname: BlendFunci</para>
        /// <para>Aliases: BlendFunciARB, </para>
        /// <para>Extensions: VERSION_4_0 ARB_draw_buffers_blend</para>
        /// </summary>
        /// <param name="buf">For glBlendFunci, specifies the index of the draw buffer for which to set the blend function.</param>
        /// <param name="sfactor">Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is GL_ONE.</param>
        /// <param name="dfactor">Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.</param>
        public static void BlendFunci(uint buf, int src, int dst)
        {
            if (gl._BlendFunci != null) gl._BlendFunci(buf, src, dst); else { }
        }
        /// <summary>
        /// <para>Fullname: BlendFuncSeparatei</para>
        /// </summary>
        [GLEntry("BlendFuncSeparatei", Category = "4.0", Alias = "BlendFuncSeparateiARB ")]
        public static GLDelegate.BlendFuncSeparatei _BlendFuncSeparatei = null;
        public static GLDelegate.BlendFuncSeparatei BlendFuncSeparateiARB = BlendFuncSeparatei;
        /// <summary>
        /// <para>specify pixel arithmetic for RGB and alpha components separately</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BlendFuncSeparatei.</para>
        /// <para>Fullname: BlendFuncSeparatei</para>
        /// <para>Aliases: BlendFuncSeparateiARB, </para>
        /// <para>Extensions: VERSION_4_0 ARB_draw_buffers_blend</para>
        /// </summary>
        /// <param name="buf">For glBlendFuncSeparatei, specifies the index of the draw buffer for which to set the blend functions.</param>
        /// <param name="srcRGB">Specifies how the red, green, and blue blending factors are computed. The initial value is GL_ONE.</param>
        /// <param name="dstRGB">Specifies how the red, green, and blue destination blending factors are computed. The initial value is GL_ZERO.</param>
        /// <param name="srcAlpha">Specified how the alpha source blending factor is computed. The initial value is GL_ONE.</param>
        /// <param name="dstAlpha">Specified how the alpha destination blending factor is computed. The initial value is GL_ZERO.</param>
        public static void BlendFuncSeparatei(uint buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha)
        {
            if (gl._BlendFuncSeparatei != null) gl._BlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha); else { }
        }
        /// <summary>
        /// <para>Fullname: MinSampleShading</para>
        /// </summary>
        [GLEntry("MinSampleShading", Category = "4.0", Alias = "MinSampleShadingARB ")]
        public static GLDelegate.MinSampleShading _MinSampleShading = null;
        public static GLDelegate.MinSampleShading MinSampleShadingARB = MinSampleShading;
        /// <summary>
        /// <para>specifies minimum rate at which sample shaing takes place</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MinSampleShading.</para>
        /// <para>Fullname: MinSampleShading</para>
        /// <para>Aliases: MinSampleShadingARB, </para>
        /// <para>Extensions: VERSION_4_0 ARB_sample_shading</para>
        /// </summary>
        /// <param name="value">Specifies the rate at which samples are shaded within each covered pixel.</param>
        public static void MinSampleShading(float value)
        {
            if (gl._MinSampleShading != null) gl._MinSampleShading(value); else { }
        }
        /// <summary>
        /// <para>Fullname: ActiveShaderProgram</para>
        /// </summary>
        [GLEntry("ActiveShaderProgram", Category = "ARB")]
        public static GLDelegate.ActiveShaderProgram _ActiveShaderProgram = null;
        /// <summary>
        /// <para>set the active program object for a program pipeline object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ActiveShaderProgram.</para>
        /// <para>Fullname: ActiveShaderProgram</para>
        /// <para>Extensions: ARB_separate_shader_objects</para>
        /// </summary>
        /// <param name="pipeline">Specifies the program pipeline object to set the active program object for.</param>
        /// <param name="program">Specifies the program object to set as the active program pipeline object pipeline.</param>
        public static void ActiveShaderProgram(uint pipeline, uint program)
        {
            if (gl._ActiveShaderProgram != null) gl._ActiveShaderProgram(pipeline, program); else { }
        }
        /// <summary>
        /// <para>Fullname: AttachObjectARB</para>
        /// </summary>
        [GLEntry("AttachObjectARB", Category = "ARB")]
        public static GLDelegate.AttachObject _AttachObject = null;
        /// <summary>
        /// <para>This extension adds API calls that are necessary to manage shader objects and program objects as defined in the OpenGL 2.0 white papers by 3Dlabs. The generation of an executable that runs on one of OpenGL's programmable units is modeled to that of developing a typical C/C++ application. There are one or more source files, each of which are stored by OpenGL in a shader object. Each shader object (source file) needs to be compiled and attached to a program object. Once all shader objects are compiled successfully, the program object needs to be linked to produce an executable. This executable is part of the program object, and can now be loaded onto the programmable units to make it part of the current OpenGL state. Both the compile and link stages generate a text string that can be queried to get more information. This information could be, but is not limited to, compile errors, link errors, optimization hints, etc. Values for uniform variables, declared in a shader, can be set by the ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _AttachObject.</para>
        /// <para>Fullname: AttachObjectARB</para>
        /// <para>Extensions: ARB_shader_objects</para>
        /// </summary>
        public static void AttachObject(uint containerObj, uint obj)
        {
            if (gl._AttachObject != null) gl._AttachObject(containerObj, obj); else { }
        }
        /// <summary>
        /// <para>Fullname: BeginQueryIndexed</para>
        /// </summary>
        [GLEntry("BeginQueryIndexed", Category = "ARB")]
        public static GLDelegate.BeginQueryIndexed _BeginQueryIndexed = null;
        /// <summary>
        /// <para>delimit the boundaries of a query object on an indexed target</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BeginQueryIndexed.</para>
        /// <para>Fullname: BeginQueryIndexed</para>
        /// <para>Extensions: ARB_transform_feedback3</para>
        /// </summary>
        /// <param name="target">Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED.</param>
        /// <param name="index">Specifies the index of the query target upon which to begin the query.</param>
        /// <param name="id">Specifies the name of a query object.</param>
        public static void BeginQueryIndexed(int target, uint index, uint id)
        {
            if (gl._BeginQueryIndexed != null) gl._BeginQueryIndexed(target, index, id); else { }
        }
        /// <summary>
        /// <para>Fullname: BindFragDataLocationIndexed</para>
        /// </summary>
        [GLEntry("BindFragDataLocationIndexed", Category = "ARB")]
        public static GLDelegate.BindFragDataLocationIndexed _BindFragDataLocationIndexed = null;
        /// <summary>
        /// <para>bind a user-defined varying out variable to a fragment shader color number and index</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindFragDataLocationIndexed.</para>
        /// <para>Fullname: BindFragDataLocationIndexed</para>
        /// <para>Extensions: ARB_blend_func_extended</para>
        /// </summary>
        /// <param name="program">The name of the program containing varying out variable whose binding to modify</param>
        /// <param name="colorNumber">The color number to bind the user-defined varying out variable to</param>
        /// <param name="index">The index of the color input to bind the user-defined varying out variable to</param>
        /// <param name="name">The name of the user-defined varying out variable whose binding to modify</param>
        public static void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, StringBuilder name)
        {
            if (gl._BindFragDataLocationIndexed != null) gl._BindFragDataLocationIndexed(program, colorNumber, index, name); else { }
        }
        /// <summary>
        /// <para>Fullname: BindFramebuffer</para>
        /// </summary>
        [GLEntry("BindFramebuffer", Category = "ARB", Alias = "BindFramebufferEXT ")]
        public static GLDelegate.BindFramebuffer _BindFramebuffer = null;
        public static GLDelegate.BindFramebuffer BindFramebufferEXT = BindFramebuffer;
        /// <summary>
        /// <para>bind a framebuffer to a framebuffer target</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindFramebuffer.</para>
        /// <para>Fullname: BindFramebuffer</para>
        /// <para>Aliases: BindFramebufferEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="target">Specifies the framebuffer target of the binding operation.</param>
        /// <param name="framebuffer">Specifies the name of the framebuffer object to bind.</param>
        public static void BindFramebuffer(int target, uint framebuffer)
        {
            if (gl._BindFramebuffer != null) gl._BindFramebuffer(target, framebuffer); else { }
        }
        /// <summary>
        /// <para>Fullname: BindImageTexture</para>
        /// </summary>
        [GLEntry("BindImageTexture", Category = "ARB", Alias = "BindImageTextureEXT ")]
        public static GLDelegate.BindImageTexture _BindImageTexture = null;
        public static GLDelegate.BindImageTexture BindImageTextureEXT = BindImageTexture;
        /// <summary>
        /// <para>bind a level of a texture to an image unit</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindImageTexture.</para>
        /// <para>Fullname: BindImageTexture</para>
        /// <para>Aliases: BindImageTextureEXT, </para>
        /// <para>Extensions: ARB_shader_image_load_store EXT_shader_image_load_store</para>
        /// </summary>
        /// <param name="unit">Specifies the index of the image unit to which to bind the texture</param>
        /// <param name="texture">Specifies the name of the texture to bind to the image unit.</param>
        /// <param name="level">Specifies the level of the texture that is to be bound.</param>
        /// <param name="layered">Specifies whether a layered texture binding is to be established.</param>
        /// <param name="layer">If layered is GL_FALSE, specifies the layer of texture to be bound to the image unit. Ignored otherwise.</param>
        /// <param name="access">Specifies a token indicating the type of access that will be performed on the image.</param>
        /// <param name="format">Specifies the format that the elements of the image will be treated as for the purposes of formatted stores.</param>
        public static void BindImageTexture(uint unit, uint texture, int level, bool layered, int layer, int access, int format)
        {
            if (gl._BindImageTexture != null) gl._BindImageTexture(unit, texture, level, layered, layer, access, format); else { }
        }
        /// <summary>
        /// <para>Fullname: BindProgramARB</para>
        /// </summary>
        [GLEntry("BindProgramARB", Category = "ARB", Alias = "BindProgramNV ")]
        public static GLDelegate.BindProgram _BindProgram = null;
        public static GLDelegate.BindProgram BindProgramNV = BindProgram;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindProgram.</para>
        /// <para>Fullname: BindProgramARB</para>
        /// <para>Aliases: BindProgramNV, </para>
        /// <para>Extensions: ARB_vertex_program NV_vertex_program</para>
        /// </summary>
        public static void BindProgram(int target, uint program)
        {
            if (gl._BindProgram != null) gl._BindProgram(target, program); else { }
        }
        /// <summary>
        /// <para>Fullname: BindProgramPipeline</para>
        /// </summary>
        [GLEntry("BindProgramPipeline", Category = "ARB")]
        public static GLDelegate.BindProgramPipeline _BindProgramPipeline = null;
        /// <summary>
        /// <para>bind a program pipeline to the current context</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindProgramPipeline.</para>
        /// <para>Fullname: BindProgramPipeline</para>
        /// <para>Extensions: ARB_separate_shader_objects</para>
        /// </summary>
        /// <param name="pipeline">Specifies the name of the pipeline object to bind to the context.</param>
        public static void BindProgramPipeline(uint pipeline)
        {
            if (gl._BindProgramPipeline != null) gl._BindProgramPipeline(pipeline); else { }
        }
        /// <summary>
        /// <para>Fullname: BindRenderbuffer</para>
        /// </summary>
        [GLEntry("BindRenderbuffer", Category = "ARB", Alias = "BindRenderbufferEXT ")]
        public static GLDelegate.BindRenderbuffer _BindRenderbuffer = null;
        public static GLDelegate.BindRenderbuffer BindRenderbufferEXT = BindRenderbuffer;
        /// <summary>
        /// <para>bind a renderbuffer to a renderbuffer target</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindRenderbuffer.</para>
        /// <para>Fullname: BindRenderbuffer</para>
        /// <para>Aliases: BindRenderbufferEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="target">Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER.</param>
        /// <param name="renderbuffer">Specifies the name of the renderbuffer object to bind.</param>
        public static void BindRenderbuffer(int target, uint renderbuffer)
        {
            if (gl._BindRenderbuffer != null) gl._BindRenderbuffer(target, renderbuffer); else { }
        }
        /// <summary>
        /// <para>Fullname: BindSampler</para>
        /// </summary>
        [GLEntry("BindSampler", Category = "ARB")]
        public static GLDelegate.BindSampler _BindSampler = null;
        /// <summary>
        /// <para>bind a named sampler to a texturing target</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindSampler.</para>
        /// <para>Fullname: BindSampler</para>
        /// <para>Extensions: ARB_sampler_objects</para>
        /// </summary>
        /// <param name="unit">Specifies the index of the texture unit to which the sampler is bound.</param>
        /// <param name="sampler">Specifies the name of a sampler.</param>
        public static void BindSampler(uint unit, uint sampler)
        {
            if (gl._BindSampler != null) gl._BindSampler(unit, sampler); else { }
        }
        /// <summary>
        /// <para>Fullname: BindTransformFeedback</para>
        /// </summary>
        [GLEntry("BindTransformFeedback", Category = "ARB", Alias = "BindTransformFeedbackNV ")]
        public static GLDelegate.BindTransformFeedback _BindTransformFeedback = null;
        public static GLDelegate.BindTransformFeedback BindTransformFeedbackNV = BindTransformFeedback;
        /// <summary>
        /// <para>bind a transform feedback object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindTransformFeedback.</para>
        /// <para>Fullname: BindTransformFeedback</para>
        /// <para>Aliases: BindTransformFeedbackNV, </para>
        /// <para>Extensions: ARB_transform_feedback2 NV_transform_feedback2</para>
        /// </summary>
        /// <param name="target">Specifies the target to which to bind the transform feedback object id. target must be GL_TRANSFORM_FEEDBACK.</param>
        /// <param name="id">Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks.</param>
        public static void BindTransformFeedback(int target, uint id)
        {
            if (gl._BindTransformFeedback != null) gl._BindTransformFeedback(target, id); else { }
        }
        /// <summary>
        /// <para>Fullname: BindVertexArray</para>
        /// </summary>
        [GLEntry("BindVertexArray", Category = "ARB", Alias = "BindVertexArrayAPPLE ")]
        public static GLDelegate.BindVertexArray _BindVertexArray = null;
        public static GLDelegate.BindVertexArray BindVertexArrayAPPLE = BindVertexArray;
        /// <summary>
        /// <para>bind a vertex array object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindVertexArray.</para>
        /// <para>Fullname: BindVertexArray</para>
        /// <para>Aliases: BindVertexArrayAPPLE, </para>
        /// <para>Extensions: ARB_vertex_array_object APPLE_vertex_array_object</para>
        /// </summary>
        /// <param name="array">Specifies the name of the vertex array to bind.</param>
        public static void BindVertexArray(uint array)
        {
            if (gl._BindVertexArray != null) gl._BindVertexArray(array); else { }
        }
        /// <summary>
        /// <para>Fullname: BindVertexBuffer</para>
        /// </summary>
        [GLEntry("BindVertexBuffer", Category = "ARB")]
        public static GLDelegate.BindVertexBuffer _BindVertexBuffer = null;
        /// <summary>
        /// <para>bind a buffer to a vertex buffer bind point</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindVertexBuffer.</para>
        /// <para>Fullname: BindVertexBuffer</para>
        /// <para>Extensions: ARB_vertex_attrib_binding</para>
        /// </summary>
        /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind the buffer.</param>
        /// <param name="buffer">The name of an existing buffer to bind to the vertex buffer binding point.</param>
        /// <param name="offset">The offset of the first element of the buffer.</param>
        /// <param name="stride">The distance between elements within the buffer.</param>
        public static void BindVertexBuffer(uint bindingindex, uint buffer, int offset, int stride)
        {
            if (gl._BindVertexBuffer != null) gl._BindVertexBuffer(bindingindex, buffer, offset, stride); else { }
        }
        /// <summary>
        /// <para>Fullname: BlitFramebuffer</para>
        /// </summary>
        [GLEntry("BlitFramebuffer", Category = "ARB", Alias = "BlitFramebufferEXT ")]
        public static GLDelegate.BlitFramebuffer _BlitFramebuffer = null;
        public static GLDelegate.BlitFramebuffer BlitFramebufferEXT = BlitFramebuffer;
        /// <summary>
        /// <para>copy a block of pixels from the read framebuffer to the draw framebuffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BlitFramebuffer.</para>
        /// <para>Fullname: BlitFramebuffer</para>
        /// <para>Aliases: BlitFramebufferEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_blit</para>
        /// </summary>
        /// <param name="srcX0">Specify the bounds of the source rectangle within the read buffer of the read framebuffer.</param>
        /// <param name="srcY0">Specify the bounds of the source rectangle within the read buffer of the read framebuffer.</param>
        /// <param name="srcX1">Specify the bounds of the source rectangle within the read buffer of the read framebuffer.</param>
        /// <param name="srcY1">Specify the bounds of the source rectangle within the read buffer of the read framebuffer.</param>
        /// <param name="dstX0">Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.</param>
        /// <param name="dstY0">Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.</param>
        /// <param name="dstX1">Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.</param>
        /// <param name="dstY1">Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.</param>
        /// <param name="mask">The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT.</param>
        /// <param name="filter">Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR.</param>
        public static void BlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter)
        {
            if (gl._BlitFramebuffer != null) gl._BlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter); else { }
        }
        /// <summary>
        /// <para>Fullname: CheckFramebufferStatus</para>
        /// </summary>
        [GLEntry("CheckFramebufferStatus", Category = "ARB", Alias = "CheckFramebufferStatusEXT ")]
        public static GLDelegate.CheckFramebufferStatus _CheckFramebufferStatus = null;
        public static GLDelegate.CheckFramebufferStatus CheckFramebufferStatusEXT = CheckFramebufferStatus;
        /// <summary>
        /// <para>check the completeness status of a framebuffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CheckFramebufferStatus.</para>
        /// <para>Fullname: CheckFramebufferStatus</para>
        /// <para>Aliases: CheckFramebufferStatusEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="target">Specify the target of the framebuffer completeness check.</param>
        public static int CheckFramebufferStatus(int target)
        {
            if (gl._CheckFramebufferStatus != null) return gl._CheckFramebufferStatus(target);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: ClearBufferData</para>
        /// </summary>
        [GLEntry("ClearBufferData", Category = "ARB")]
        public static GLDelegate.ClearBufferData _ClearBufferData = null;
        /// <summary>
        /// <para>fill a buffer object's data store with a fixed value</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClearBufferData.</para>
        /// <para>Fullname: ClearBufferData</para>
        /// <para>Extensions: ARB_clear_buffer_object</para>
        /// </summary>
        /// <param name="target">Specify the target of the operation. target must be one of the global buffer binding targets.</param>
        /// <param name="internalformat">The internal format with which the data will be stored in the buffer object.</param>
        /// <param name="size">The size, in basic machine units of the range of the data store to fill.</param>
        /// <param name="format">The format of the data in memory addressed by data.</param>
        /// <param name="type">The type of the data in memory addressed by data.</param>
        /// <param name="data">The address of a memory location storing the data to be replicated into the buffer's data store.</param>
        public static void ClearBufferData(int target, int internalformat, int format, int type, IntPtr data)
        {
            if (gl._ClearBufferData != null) gl._ClearBufferData(target, internalformat, format, type, data); else { }
        }
        /// <summary>
        /// <para>Fullname: ClearBufferSubData</para>
        /// </summary>
        [GLEntry("ClearBufferSubData", Category = "ARB")]
        public static GLDelegate.ClearBufferSubData _ClearBufferSubData = null;
        /// <summary>
        /// <para>fill all or part of buffer object's data store with a fixed value</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClearBufferSubData.</para>
        /// <para>Fullname: ClearBufferSubData</para>
        /// <para>Extensions: ARB_clear_buffer_object</para>
        /// </summary>
        /// <param name="target">Specify the target of the operation. target must be one of the global buffer binding targets.</param>
        /// <param name="internalformat">The internal format with which the data will be stored in the buffer object.</param>
        /// <param name="offset">The offset, in basic machine units into the buffer object's data store at which to start filling.</param>
        /// <param name="size">The size, in basic machine units of the range of the data store to fill.</param>
        /// <param name="format">The format of the data in memory addressed by data.</param>
        /// <param name="type">The type of the data in memory addressed by data.</param>
        /// <param name="data">The address of a memory location storing the data to be replicated into the buffer's data store.</param>
        public static void ClearBufferSubData(int target, int internalformat, int offset, int size, int format, int type, IntPtr data)
        {
            if (gl._ClearBufferSubData != null) gl._ClearBufferSubData(target, internalformat, offset, size, format, type, data); else { }
        }
        /// <summary>
        /// <para>Fullname: ClearDepthf</para>
        /// </summary>
        [GLEntry("ClearDepthf", Category = "ARB")]
        public static GLDelegate.ClearDepthf _ClearDepthf = null;
        /// <summary>
        /// <para>specify the clear value for the depth buffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClearDepthf.</para>
        /// <para>Fullname: ClearDepthf</para>
        /// <para>Extensions: ARB_ES2_compatibility</para>
        /// </summary>
        /// <param name="depth">Specifies the depth value used when the depth buffer is cleared. The initial value is 1.</param>
        public static void ClearDepthf(float d)
        {
            if (gl._ClearDepthf != null) gl._ClearDepthf(d); else { }
        }
        /// <summary>
        /// <para>Fullname: ClearNamedBufferDataEXT</para>
        /// </summary>
        [GLEntry("ClearNamedBufferDataEXT", Category = "ARB")]
        public static GLDelegate.ClearNamedBufferData _ClearNamedBufferData = null;
        /// <summary>
        /// <para>Buffer objects are fundamental to the operation of OpenGL. Buffers are used as a source of data for vertices and indices, read through buffer textures in shaders, used to transfer texture and image data into and out of textures and framebuffers, and may be written to by operations such as transform feedback. OpenGL contains mechanisms to copy sections of buffers from one to another, but it has no mechanism to initialize the content of a buffer to a known value. In effect, it has memcpy, but not memset. This extension adds such a mechanism and has several use cases. Examples include clearing a pixel unpack buffer before transferring data to a texture or resetting buffer data to a known value before sparse updates through shader image stores or transform feedback. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClearNamedBufferData.</para>
        /// <para>Fullname: ClearNamedBufferDataEXT</para>
        /// <para>Extensions: ARB_clear_buffer_object</para>
        /// </summary>
        public static void ClearNamedBufferData(uint buffer, int internalformat, int format, int type, IntPtr data)
        {
            if (gl._ClearNamedBufferData != null) gl._ClearNamedBufferData(buffer, internalformat, format, type, data); else { }
        }
        /// <summary>
        /// <para>Fullname: ClearNamedBufferSubDataEXT</para>
        /// </summary>
        [GLEntry("ClearNamedBufferSubDataEXT", Category = "ARB")]
        public static GLDelegate.ClearNamedBufferSubData _ClearNamedBufferSubData = null;
        /// <summary>
        /// <para>Buffer objects are fundamental to the operation of OpenGL. Buffers are used as a source of data for vertices and indices, read through buffer textures in shaders, used to transfer texture and image data into and out of textures and framebuffers, and may be written to by operations such as transform feedback. OpenGL contains mechanisms to copy sections of buffers from one to another, but it has no mechanism to initialize the content of a buffer to a known value. In effect, it has memcpy, but not memset. This extension adds such a mechanism and has several use cases. Examples include clearing a pixel unpack buffer before transferring data to a texture or resetting buffer data to a known value before sparse updates through shader image stores or transform feedback. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClearNamedBufferSubData.</para>
        /// <para>Fullname: ClearNamedBufferSubDataEXT</para>
        /// <para>Extensions: ARB_clear_buffer_object</para>
        /// </summary>
        public static void ClearNamedBufferSubData(uint buffer, int internalformat, int format, int type, int offset, int size, IntPtr data)
        {
            if (gl._ClearNamedBufferSubData != null) gl._ClearNamedBufferSubData(buffer, internalformat, format, type, offset, size, data); else { }
        }
        /// <summary>
        /// <para>Fullname: ClientWaitSync</para>
        /// </summary>
        [GLEntry("ClientWaitSync", Category = "ARB")]
        public static GLDelegate.ClientWaitSync _ClientWaitSync = null;
        /// <summary>
        /// <para>block and wait for a sync object to become signaled</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClientWaitSync.</para>
        /// <para>Fullname: ClientWaitSync</para>
        /// <para>Extensions: ARB_sync</para>
        /// </summary>
        /// <param name="sync">The sync object whose status to wait on.</param>
        /// <param name="flags">A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT.</param>
        public static int ClientWaitSync(IntPtr sync, int flags, ulong timeout)
        {
            if (gl._ClientWaitSync != null) return gl._ClientWaitSync(sync, flags, timeout);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: ColorP3ui</para>
        /// </summary>
        [GLEntry("ColorP3ui", Category = "ARB")]
        public static GLDelegate.ColorP3ui _ColorP3ui = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorP3ui.</para>
        /// <para>Fullname: ColorP3ui</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void ColorP3ui(int type, uint color)
        {
            if (gl._ColorP3ui != null) gl._ColorP3ui(type, color); else { }
        }
        /// <summary>
        /// <para>Fullname: ColorP3uiv</para>
        /// </summary>
        [GLEntry("ColorP3uiv", Category = "ARB")]
        public static GLDelegate.ColorP3uiv_uint _ColorP3uiv_uint = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorP3uiv_uint.</para>
        /// <para>Fullname: ColorP3uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void ColorP3uiv(int type, ref uint color)
        {
            if (gl._ColorP3uiv_uint != null) gl._ColorP3uiv_uint(type, ref color); else { }
        }
        /// <summary>
        /// <para>Fullname: ColorP3uiv</para>
        /// </summary>
        [GLEntry("ColorP3uiv", Category = "ARB")]
        public static GLDelegate.ColorP3uiv _ColorP3uiv = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorP3uiv.</para>
        /// <para>Fullname: ColorP3uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void ColorP3uiv(int type, uint[] color)
        {
            if (gl._ColorP3uiv != null) gl._ColorP3uiv(type, color); else { }
        }
        /// <summary>
        /// <para>Fullname: ColorP4ui</para>
        /// </summary>
        [GLEntry("ColorP4ui", Category = "ARB")]
        public static GLDelegate.ColorP4ui _ColorP4ui = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorP4ui.</para>
        /// <para>Fullname: ColorP4ui</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void ColorP4ui(int type, uint color)
        {
            if (gl._ColorP4ui != null) gl._ColorP4ui(type, color); else { }
        }
        /// <summary>
        /// <para>Fullname: ColorP4uiv</para>
        /// </summary>
        [GLEntry("ColorP4uiv", Category = "ARB")]
        public static GLDelegate.ColorP4uiv _ColorP4uiv = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorP4uiv.</para>
        /// <para>Fullname: ColorP4uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void ColorP4uiv(int type, uint[] color)
        {
            if (gl._ColorP4uiv != null) gl._ColorP4uiv(type, color); else { }
        }
        /// <summary>
        /// <para>Fullname: ColorP4uiv</para>
        /// </summary>
        [GLEntry("ColorP4uiv", Category = "ARB")]
        public static GLDelegate.ColorP4uiv_uint _ColorP4uiv_uint = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorP4uiv_uint.</para>
        /// <para>Fullname: ColorP4uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void ColorP4uiv(int type, ref uint color)
        {
            if (gl._ColorP4uiv_uint != null) gl._ColorP4uiv_uint(type, ref color); else { }
        }
        /// <summary>
        /// <para>Fullname: CompileShaderIncludeARB</para>
        /// </summary>
        [GLEntry("CompileShaderIncludeARB", Category = "ARB")]
        public static GLDelegate.CompileShaderInclude _CompileShaderInclude = null;
        /// <summary>
        /// <para>This extension introduces a #include GLSL directive to allow reusing the same shader text in multiple shaders and defines the semantics and syntax of the names allowed in #include directives. It also defines API mechanisms to define the named string backing a #include. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompileShaderInclude.</para>
        /// <para>Fullname: CompileShaderIncludeARB</para>
        /// <para>Extensions: ARB_shading_language_include</para>
        /// </summary>
        public static void CompileShaderInclude(uint shader, int count, string[] path, int[] length)
        {
            if (gl._CompileShaderInclude != null) gl._CompileShaderInclude(shader, count, path, length); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyBufferSubData</para>
        /// </summary>
        [GLEntry("CopyBufferSubData", Category = "ARB")]
        public static GLDelegate.CopyBufferSubData _CopyBufferSubData = null;
        /// <summary>
        /// <para>copy part of the data store of a buffer object to the data store of another buffer object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyBufferSubData.</para>
        /// <para>Fullname: CopyBufferSubData</para>
        /// <para>Extensions: ARB_copy_buffer</para>
        /// </summary>
        /// <param name="readtarget">Specifies the target from whose data store data should be read.</param>
        /// <param name="writetarget">Specifies the target to whose data store data should be written.</param>
        /// <param name="readoffset">Specifies the offset, in basic machine units, within the data store of readtarget from which data should be read.</param>
        /// <param name="writeoffset">Specifies the offset, in basic machine units, within the data store of writetarget to which data should be written.</param>
        /// <param name="size">Specifies the size, in basic machine units, of the data to be copied from readtarget to writetarget.</param>
        public static void CopyBufferSubData(int readTarget, int writeTarget, int readOffset, int writeOffset, int size)
        {
            if (gl._CopyBufferSubData != null) gl._CopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyImageSubData</para>
        /// </summary>
        [GLEntry("CopyImageSubData", Category = "ARB", Alias = "CopyImageSubDataNV ")]
        public static GLDelegate.CopyImageSubData _CopyImageSubData = null;
        public static GLDelegate.CopyImageSubData CopyImageSubDataNV = CopyImageSubData;
        /// <summary>
        /// <para>perform a raw data copy between two images</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyImageSubData.</para>
        /// <para>Fullname: CopyImageSubData</para>
        /// <para>Aliases: CopyImageSubDataNV, </para>
        /// <para>Extensions: ARB_copy_image NV_copy_image</para>
        /// </summary>
        /// <param name="srcName">The name of a texture or renderbuffer object from which to copy.</param>
        /// <param name="srcTarget">The target representing the namespace of the source name srcName.</param>
        /// <param name="srcLevel">The mipmap level to read from the source.</param>
        /// <param name="srcX">The X coordinate of the left edge of the souce region to copy.</param>
        /// <param name="srcY">The Y coordinate of the top edge of the souce region to copy.</param>
        /// <param name="srcZ">The Z coordinate of the near edge of the souce region to copy.</param>
        /// <param name="dstName">The name of a texture or renderbuffer object to which to copy.</param>
        /// <param name="dstTarget">The target representing the namespace of the destination name dstName.</param>
        /// <param name="dstX">The X coordinate of the left edge of the destination region.</param>
        /// <param name="dstY">The Y coordinate of the top edge of the destination region.</param>
        /// <param name="dstZ">The Z coordinate of the near edge of the destination region.</param>
        /// <param name="srcWidth">The width of the region to be copied.</param>
        /// <param name="srcHeight">The height of the region to be copied.</param>
        /// <param name="srcDepth">The depth of the region to be copied.</param>
        public static void CopyImageSubData(uint srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth)
        {
            if (gl._CopyImageSubData != null) gl._CopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth); else { }
        }
        /// <summary>
        /// <para>Fullname: CreateProgramObjectARB</para>
        /// </summary>
        [GLEntry("CreateProgramObjectARB", Category = "ARB")]
        public static GLDelegate.CreateProgramObject _CreateProgramObject = null;
        /// <summary>
        /// <para>This extension adds API calls that are necessary to manage shader objects and program objects as defined in the OpenGL 2.0 white papers by 3Dlabs. The generation of an executable that runs on one of OpenGL's programmable units is modeled to that of developing a typical C/C++ application. There are one or more source files, each of which are stored by OpenGL in a shader object. Each shader object (source file) needs to be compiled and attached to a program object. Once all shader objects are compiled successfully, the program object needs to be linked to produce an executable. This executable is part of the program object, and can now be loaded onto the programmable units to make it part of the current OpenGL state. Both the compile and link stages generate a text string that can be queried to get more information. This information could be, but is not limited to, compile errors, link errors, optimization hints, etc. Values for uniform variables, declared in a shader, can be set by the ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CreateProgramObject.</para>
        /// <para>Fullname: CreateProgramObjectARB</para>
        /// <para>Extensions: ARB_shader_objects</para>
        /// </summary>
        public static uint CreateProgramObject()
        {
            if (gl._CreateProgramObject != null) return gl._CreateProgramObject();
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: CreateShaderObjectARB</para>
        /// </summary>
        [GLEntry("CreateShaderObjectARB", Category = "ARB")]
        public static GLDelegate.CreateShaderObject _CreateShaderObject = null;
        /// <summary>
        /// <para>This extension adds API calls that are necessary to manage shader objects and program objects as defined in the OpenGL 2.0 white papers by 3Dlabs. The generation of an executable that runs on one of OpenGL's programmable units is modeled to that of developing a typical C/C++ application. There are one or more source files, each of which are stored by OpenGL in a shader object. Each shader object (source file) needs to be compiled and attached to a program object. Once all shader objects are compiled successfully, the program object needs to be linked to produce an executable. This executable is part of the program object, and can now be loaded onto the programmable units to make it part of the current OpenGL state. Both the compile and link stages generate a text string that can be queried to get more information. This information could be, but is not limited to, compile errors, link errors, optimization hints, etc. Values for uniform variables, declared in a shader, can be set by the ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CreateShaderObject.</para>
        /// <para>Fullname: CreateShaderObjectARB</para>
        /// <para>Extensions: ARB_shader_objects</para>
        /// </summary>
        public static uint CreateShaderObject(int shaderType)
        {
            if (gl._CreateShaderObject != null) return gl._CreateShaderObject(shaderType);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: CreateShaderProgramv</para>
        /// </summary>
        [GLEntry("CreateShaderProgramv", Category = "ARB")]
        public static GLDelegate.CreateShaderProgramv _CreateShaderProgramv = null;
        /// <summary>
        /// <para>create a stand-alone program from an array of null-terminated source code strings</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CreateShaderProgramv.</para>
        /// <para>Fullname: CreateShaderProgramv</para>
        /// <para>Extensions: ARB_separate_shader_objects</para>
        /// </summary>
        /// <param name="type">Specifies the type of shader to create.</param>
        /// <param name="count">Specifies the number of source code strings in the array strings.</param>
        /// <param name="strings">Specifies the address of an array of pointers to source code strings from which to create the program object.</param>
        public static uint CreateShaderProgramv(int type, int count, string[] strings)
        {
            if (gl._CreateShaderProgramv != null) return gl._CreateShaderProgramv(type, count, strings);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: CreateSyncFromCLeventARB</para>
        /// </summary>
        [GLEntry("CreateSyncFromCLeventARB", Category = "ARB")]
        public static GLDelegate.CreateSyncFromCLevent _CreateSyncFromCLevent = null;
        /// <summary>
        /// <para>This extension allows creating OpenGL sync objects linked to OpenCL event objects, potentially improving efficiency of sharing images and buffers between the two APIs. The companion cl_khr_gl_event OpenCL extension provides the complementary functionality of creating an OpenCL event object from an OpenGL fence sync object. That extension is located in the OpenCL API Registry. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CreateSyncFromCLevent.</para>
        /// <para>Fullname: CreateSyncFromCLeventARB</para>
        /// <para>Extensions: ARB_cl_event</para>
        /// </summary>
        public static IntPtr CreateSyncFromCLevent(IntPtr context, IntPtr clevents, int flags)
        {
            if (gl._CreateSyncFromCLevent != null) return gl._CreateSyncFromCLevent(context, clevents, flags);
            else { return (IntPtr)0; }
        }
        /// <summary>
        /// <para>Fullname: CurrentPaletteMatrixARB</para>
        /// </summary>
        [GLEntry("CurrentPaletteMatrixARB", Category = "ARB")]
        public static GLDelegate.CurrentPaletteMatrix _CurrentPaletteMatrix = null;
        /// <summary>
        /// <para>This extension extends the abilities of ARB_vertex_blend to include a palette of modelview matrices.  The n vertex units use a palette of m modelview matrices.  (Where n and m are constrained to implementation defined maxima.)  Each vertex has a set of n indices into the palette, and a corresponding set of n weights. Matrix indices can be changed for each vertex (between Begin and End).  When this extension is utilized, the enabled units transform each vertex by the modelview matrices specified by the vertices' respective indices.  These results are subsequently scaled by the weights of the respective units and then summed to create the eyespace vertex.  A similar procedure is followed for normals.  Normals, however, are transformed by the inverse transpose of the modelview matrix.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CurrentPaletteMatrix.</para>
        /// <para>Fullname: CurrentPaletteMatrixARB</para>
        /// <para>Extensions: ARB_matrix_palette</para>
        /// </summary>
        public static void CurrentPaletteMatrix(int index)
        {
            if (gl._CurrentPaletteMatrix != null) gl._CurrentPaletteMatrix(index); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteFramebuffers</para>
        /// </summary>
        [GLEntry("DeleteFramebuffers", Category = "ARB", Alias = "DeleteFramebuffersEXT ")]
        public static GLDelegate.DeleteFramebuffers_uint _DeleteFramebuffers_uint = null;
        /// <summary>
        /// <para>delete framebuffer objects</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteFramebuffers_uint.</para>
        /// <para>Fullname: DeleteFramebuffers</para>
        /// <para>Aliases: DeleteFramebuffersEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of framebuffer objects to be deleted.</param>
        /// <param name="framebuffers">A pointer to an array containing n framebuffer objects to be deleted.</param>
        public static void DeleteFramebuffers(int n, ref uint framebuffers)
        {
            if (gl._DeleteFramebuffers_uint != null) gl._DeleteFramebuffers_uint(n, ref framebuffers); else { }
        }
        /// <summary>
        /// <para>ARB_framebuffer_object is an extension intended to address the following goals:  - Reflect FBO-related functionality found in the OpenGL 3.0 specification.  - Integrate multiple disjoint extensions into a single ARB extension. These extensions are: EXT_framebuffer_object EXT_framebuffer_blit EXT_framebuffer_multisample EXT_packed_depth_stencil  - Where appropriate, relax some of the constraints expressed by previous FBO-related extensions. In particular the requirement of matching attachment dimensions and component sizes has been relaxed, to allow implementations the freedom to support more flexible usages where possible. ARB_framebuffer_object defines an interface for drawing to rendering destinations other than the buffers provided to the GL by the window-system. In this extension, these newly defined rendering destinations are known collectively as "framebuffer-attachable images".  This extension provides a mechanism for attaching framebuffer-attachable images to the GL framebuffer...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteFramebuffers.</para>
        /// <para>Fullname: DeleteFramebuffers</para>
        /// <para>Aliases: DeleteFramebuffersEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="framebuffer">Specifies a framebuffer to be deleted.</param>
        public static void DeleteFramebuffer(uint framebuffer)
        {
            if (gl._DeleteFramebuffers != null) gl._DeleteFramebuffers(1, new uint[] { framebuffer });
        }
        /// <summary>
        /// <para>Fullname: DeleteFramebuffers</para>
        /// </summary>
        [GLEntry("DeleteFramebuffers", Category = "ARB", Alias = "DeleteFramebuffersEXT ")]
        public static GLDelegate.DeleteFramebuffers _DeleteFramebuffers = null;
        public static GLDelegate.DeleteFramebuffers DeleteFramebuffersEXT = DeleteFramebuffers;
        /// <summary>
        /// <para>delete framebuffer objects</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteFramebuffers.</para>
        /// <para>Fullname: DeleteFramebuffers</para>
        /// <para>Aliases: DeleteFramebuffersEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of framebuffer objects to be deleted.</param>
        /// <param name="framebuffers">A pointer to an array containing n framebuffer objects to be deleted.</param>
        public static void DeleteFramebuffers(int n, uint[] framebuffers)
        {
            if (gl._DeleteFramebuffers != null) gl._DeleteFramebuffers(n, framebuffers); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteNamedStringARB</para>
        /// </summary>
        [GLEntry("DeleteNamedStringARB", Category = "ARB")]
        public static GLDelegate.DeleteNamedString _DeleteNamedString = null;
        /// <summary>
        /// <para>This extension introduces a #include GLSL directive to allow reusing the same shader text in multiple shaders and defines the semantics and syntax of the names allowed in #include directives. It also defines API mechanisms to define the named string backing a #include. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteNamedString.</para>
        /// <para>Fullname: DeleteNamedStringARB</para>
        /// <para>Extensions: ARB_shading_language_include</para>
        /// </summary>
        public static void DeleteNamedString(int namelen, StringBuilder name)
        {
            if (gl._DeleteNamedString != null) gl._DeleteNamedString(namelen, name); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteObjectARB</para>
        /// </summary>
        [GLEntry("DeleteObjectARB", Category = "ARB")]
        public static GLDelegate.DeleteObject _DeleteObject = null;
        /// <summary>
        /// <para>This extension adds API calls that are necessary to manage shader objects and program objects as defined in the OpenGL 2.0 white papers by 3Dlabs. The generation of an executable that runs on one of OpenGL's programmable units is modeled to that of developing a typical C/C++ application. There are one or more source files, each of which are stored by OpenGL in a shader object. Each shader object (source file) needs to be compiled and attached to a program object. Once all shader objects are compiled successfully, the program object needs to be linked to produce an executable. This executable is part of the program object, and can now be loaded onto the programmable units to make it part of the current OpenGL state. Both the compile and link stages generate a text string that can be queried to get more information. This information could be, but is not limited to, compile errors, link errors, optimization hints, etc. Values for uniform variables, declared in a shader, can be set by the ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteObject.</para>
        /// <para>Fullname: DeleteObjectARB</para>
        /// <para>Extensions: ARB_shader_objects</para>
        /// </summary>
        public static void DeleteObject(uint obj)
        {
            if (gl._DeleteObject != null) gl._DeleteObject(obj); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteProgramPipelines</para>
        /// </summary>
        [GLEntry("DeleteProgramPipelines", Category = "ARB")]
        public static GLDelegate.DeleteProgramPipelines _DeleteProgramPipelines = null;
        /// <summary>
        /// <para>delete program pipeline objects</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteProgramPipelines.</para>
        /// <para>Fullname: DeleteProgramPipelines</para>
        /// <para>Extensions: ARB_separate_shader_objects</para>
        /// </summary>
        /// <param name="n">Specifies the number of program pipeline objects to delete.</param>
        /// <param name="pipelines">Specifies an array of names of program pipeline objects to delete.</param>
        public static void DeleteProgramPipelines(int n, uint[] pipelines)
        {
            if (gl._DeleteProgramPipelines != null) gl._DeleteProgramPipelines(n, pipelines); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteProgramPipelines</para>
        /// </summary>
        [GLEntry("DeleteProgramPipelines", Category = "ARB")]
        public static GLDelegate.DeleteProgramPipelines_uint _DeleteProgramPipelines_uint = null;
        /// <summary>
        /// <para>delete program pipeline objects</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteProgramPipelines_uint.</para>
        /// <para>Fullname: DeleteProgramPipelines</para>
        /// <para>Extensions: ARB_separate_shader_objects</para>
        /// </summary>
        /// <param name="n">Specifies the number of program pipeline objects to delete.</param>
        /// <param name="pipelines">Specifies an array of names of program pipeline objects to delete.</param>
        public static void DeleteProgramPipelines(int n, ref uint pipelines)
        {
            if (gl._DeleteProgramPipelines_uint != null) gl._DeleteProgramPipelines_uint(n, ref pipelines); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteProgramsARB</para>
        /// </summary>
        [GLEntry("DeleteProgramsARB", Category = "ARB", Alias = "DeleteProgramsNV ")]
        public static GLDelegate.DeletePrograms _DeletePrograms = null;
        public static GLDelegate.DeletePrograms DeleteProgramsNV = DeletePrograms;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeletePrograms.</para>
        /// <para>Fullname: DeleteProgramsARB</para>
        /// <para>Aliases: DeleteProgramsNV, </para>
        /// <para>Extensions: ARB_vertex_program NV_vertex_program</para>
        /// </summary>
        public static void DeletePrograms(int n, uint[] programs)
        {
            if (gl._DeletePrograms != null) gl._DeletePrograms(n, programs); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteProgramsARB</para>
        /// </summary>
        [GLEntry("DeleteProgramsARB", Category = "ARB", Alias = "DeleteProgramsNV ")]
        public static GLDelegate.DeletePrograms_uint _DeletePrograms_uint = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeletePrograms_uint.</para>
        /// <para>Fullname: DeleteProgramsARB</para>
        /// <para>Aliases: DeleteProgramsNV, </para>
        /// <para>Extensions: ARB_vertex_program NV_vertex_program</para>
        /// </summary>
        public static void DeletePrograms(int n, ref uint programs)
        {
            if (gl._DeletePrograms_uint != null) gl._DeletePrograms_uint(n, ref programs); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteRenderbuffers</para>
        /// </summary>
        [GLEntry("DeleteRenderbuffers", Category = "ARB", Alias = "DeleteRenderbuffersEXT ")]
        public static GLDelegate.DeleteRenderbuffers _DeleteRenderbuffers = null;
        public static GLDelegate.DeleteRenderbuffers DeleteRenderbuffersEXT = DeleteRenderbuffers;
        /// <summary>
        /// <para>delete renderbuffer objects</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteRenderbuffers.</para>
        /// <para>Fullname: DeleteRenderbuffers</para>
        /// <para>Aliases: DeleteRenderbuffersEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of renderbuffer objects to be deleted.</param>
        /// <param name="renderbuffers">A pointer to an array containing n renderbuffer objects to be deleted.</param>
        public static void DeleteRenderbuffers(int n, uint[] renderbuffers)
        {
            if (gl._DeleteRenderbuffers != null) gl._DeleteRenderbuffers(n, renderbuffers); else { }
        }
        public static void DeleteRenderbuffer(uint framebuffer)
        {
            if (gl._DeleteRenderbuffers != null) gl._DeleteRenderbuffers(1, new uint[] { framebuffer });
        }
        /// <summary>
        /// <para>Fullname: DeleteRenderbuffers</para>
        /// </summary>
        [GLEntry("DeleteRenderbuffers", Category = "ARB", Alias = "DeleteRenderbuffersEXT ")]
        public static GLDelegate.DeleteRenderbuffers_uint _DeleteRenderbuffers_uint = null;
        /// <summary>
        /// <para>delete renderbuffer objects</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteRenderbuffers_uint.</para>
        /// <para>Fullname: DeleteRenderbuffers</para>
        /// <para>Aliases: DeleteRenderbuffersEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of renderbuffer objects to be deleted.</param>
        /// <param name="renderbuffers">A pointer to an array containing n renderbuffer objects to be deleted.</param>
        public static void DeleteRenderbuffers(int n, ref uint renderbuffers)
        {
            if (gl._DeleteRenderbuffers_uint != null) gl._DeleteRenderbuffers_uint(n, ref renderbuffers); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteSamplers</para>
        /// </summary>
        [GLEntry("DeleteSamplers", Category = "ARB")]
        public static GLDelegate.DeleteSamplers _DeleteSamplers = null;
        /// <summary>
        /// <para>delete named sampler objects</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteSamplers.</para>
        /// <para>Fullname: DeleteSamplers</para>
        /// <para>Extensions: ARB_sampler_objects</para>
        /// </summary>
        /// <param name="n">Specifies the number of sampler objects to be deleted.</param>
        /// <param name="samplers">Specifies an array of sampler objects to be deleted.</param>
        public static void DeleteSamplers(int count, uint[] samplers)
        {
            if (gl._DeleteSamplers != null) gl._DeleteSamplers(count, samplers); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteSync</para>
        /// </summary>
        [GLEntry("DeleteSync", Category = "ARB")]
        public static GLDelegate.DeleteSync _DeleteSync = null;
        /// <summary>
        /// <para>delete a sync object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteSync.</para>
        /// <para>Fullname: DeleteSync</para>
        /// <para>Extensions: ARB_sync</para>
        /// </summary>
        /// <param name="sync">The sync object to be deleted.</param>
        public static void DeleteSync(IntPtr sync)
        {
            if (gl._DeleteSync != null) gl._DeleteSync(sync); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteTransformFeedbacks</para>
        /// </summary>
        [GLEntry("DeleteTransformFeedbacks", Category = "ARB", Alias = "DeleteTransformFeedbacksNV ")]
        public static GLDelegate.DeleteTransformFeedbacks_uint _DeleteTransformFeedbacks_uint = null;
        /// <summary>
        /// <para>delete transform feedback objects</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteTransformFeedbacks_uint.</para>
        /// <para>Fullname: DeleteTransformFeedbacks</para>
        /// <para>Aliases: DeleteTransformFeedbacksNV, </para>
        /// <para>Extensions: ARB_transform_feedback2 NV_transform_feedback2</para>
        /// </summary>
        /// <param name="n">Specifies the number of transform feedback objects to delete.</param>
        /// <param name="ids">Specifies an array of names of transform feedback objects to delete.</param>
        public static void DeleteTransformFeedbacks(int n, ref uint ids)
        {
            if (gl._DeleteTransformFeedbacks_uint != null) gl._DeleteTransformFeedbacks_uint(n, ref ids); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteTransformFeedbacks</para>
        /// </summary>
        [GLEntry("DeleteTransformFeedbacks", Category = "ARB", Alias = "DeleteTransformFeedbacksNV ")]
        public static GLDelegate.DeleteTransformFeedbacks _DeleteTransformFeedbacks = null;
        public static GLDelegate.DeleteTransformFeedbacks DeleteTransformFeedbacksNV = DeleteTransformFeedbacks;
        /// <summary>
        /// <para>delete transform feedback objects</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteTransformFeedbacks.</para>
        /// <para>Fullname: DeleteTransformFeedbacks</para>
        /// <para>Aliases: DeleteTransformFeedbacksNV, </para>
        /// <para>Extensions: ARB_transform_feedback2 NV_transform_feedback2</para>
        /// </summary>
        /// <param name="n">Specifies the number of transform feedback objects to delete.</param>
        /// <param name="ids">Specifies an array of names of transform feedback objects to delete.</param>
        public static void DeleteTransformFeedbacks(int n, uint[] ids)
        {
            if (gl._DeleteTransformFeedbacks != null) gl._DeleteTransformFeedbacks(n, ids); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteVertexArrays</para>
        /// </summary>
        [GLEntry("DeleteVertexArrays", Category = "ARB", Alias = "DeleteVertexArraysAPPLE ")]
        public static GLDelegate.DeleteVertexArrays_uint _DeleteVertexArrays_uint = null;
        /// <summary>
        /// <para>delete vertex array objects</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteVertexArrays_uint.</para>
        /// <para>Fullname: DeleteVertexArrays</para>
        /// <para>Aliases: DeleteVertexArraysAPPLE, </para>
        /// <para>Extensions: ARB_vertex_array_object APPLE_vertex_array_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of vertex array objects to be deleted.</param>
        /// <param name="arrays">Specifies the address of an array containing the n names of the objects to be deleted.</param>
        public static void DeleteVertexArrays(int n, ref uint arrays)
        {
            if (gl._DeleteVertexArrays_uint != null) gl._DeleteVertexArrays_uint(n, ref arrays); else { }
        }
        /// <summary>
        /// <para>This extension introduces named vertex array objects which encapsulate vertex array state on the client side.  These objects allow applications to rapidly switch between large sets of array state.  In addition, layered libraries can return to the default array state by simply creating and binding a new vertex array object. This extension differs from GL_APPLE_vertex_array_object in that client memory cannot be accessed through a non-zero vertex array object.  It also differs in that vertex array objects are explicitly not sharable between contexts. </para>
        /// </summary>
        public static void DeleteVertexArray(uint array)
        {
            if (gl._DeleteVertexArrays != null) gl._DeleteVertexArrays(1, new uint[] { array });
        }
        /// <summary>
        /// <para>Fullname: DeleteVertexArrays</para>
        /// </summary>
        [GLEntry("DeleteVertexArrays", Category = "ARB", Alias = "DeleteVertexArraysAPPLE ")]
        public static GLDelegate.DeleteVertexArrays _DeleteVertexArrays = null;
        public static GLDelegate.DeleteVertexArrays DeleteVertexArraysAPPLE = DeleteVertexArrays;
        /// <summary>
        /// <para>delete vertex array objects</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteVertexArrays.</para>
        /// <para>Fullname: DeleteVertexArrays</para>
        /// <para>Aliases: DeleteVertexArraysAPPLE, </para>
        /// <para>Extensions: ARB_vertex_array_object APPLE_vertex_array_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of vertex array objects to be deleted.</param>
        /// <param name="arrays">Specifies the address of an array containing the n names of the objects to be deleted.</param>
        public static void DeleteVertexArrays(int n, uint[] arrays)
        {
            if (gl._DeleteVertexArrays != null) gl._DeleteVertexArrays(n, arrays); else { }
        }
        /// <summary>
        /// <para>Fullname: DepthRangeArrayv</para>
        /// </summary>
        [GLEntry("DepthRangeArrayv", Category = "ARB")]
        public static GLDelegate.DepthRangeArrayv _DepthRangeArrayv = null;
        /// <summary>
        /// <para>specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DepthRangeArrayv.</para>
        /// <para>Fullname: DepthRangeArrayv</para>
        /// <para>Extensions: ARB_viewport_array</para>
        /// </summary>
        /// <param name="first">Specifies the index of the first viewport whose depth range to update.</param>
        /// <param name="count">Specifies the number of viewports whose depth range to update.</param>
        /// <param name="v">Specifies the address of an array containing the near and far values for the depth range of each modified viewport.</param>
        public static void DepthRangeArrayv(uint first, int count, double[] v)
        {
            if (gl._DepthRangeArrayv != null) gl._DepthRangeArrayv(first, count, v); else { }
        }
        /// <summary>
        /// <para>Fullname: DepthRangef</para>
        /// </summary>
        [GLEntry("DepthRangef", Category = "ARB")]
        public static GLDelegate.DepthRangef _DepthRangef = null;
        /// <summary>
        /// <para>specify mapping of depth values from normalized device coordinates to window coordinates</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DepthRangef.</para>
        /// <para>Fullname: DepthRangef</para>
        /// <para>Extensions: ARB_ES2_compatibility</para>
        /// </summary>
        /// <param name="nearVal">Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.</param>
        /// <param name="farVal">Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.</param>
        public static void DepthRangef(float n, float f)
        {
            if (gl._DepthRangef != null) gl._DepthRangef(n, f); else { }
        }
        /// <summary>
        /// <para>Fullname: DepthRangeIndexed</para>
        /// </summary>
        [GLEntry("DepthRangeIndexed", Category = "ARB")]
        public static GLDelegate.DepthRangeIndexed _DepthRangeIndexed = null;
        /// <summary>
        /// <para>specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DepthRangeIndexed.</para>
        /// <para>Fullname: DepthRangeIndexed</para>
        /// <para>Extensions: ARB_viewport_array</para>
        /// </summary>
        /// <param name="index">Specifies the index of the viewport whose depth range to update.</param>
        /// <param name="nearVal">Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.</param>
        /// <param name="farVal">Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.</param>
        public static void DepthRangeIndexed(uint index, double n, double f)
        {
            if (gl._DepthRangeIndexed != null) gl._DepthRangeIndexed(index, n, f); else { }
        }
        /// <summary>
        /// <para>Fullname: DetachObjectARB</para>
        /// </summary>
        [GLEntry("DetachObjectARB", Category = "ARB")]
        public static GLDelegate.DetachObject _DetachObject = null;
        /// <summary>
        /// <para>This extension adds API calls that are necessary to manage shader objects and program objects as defined in the OpenGL 2.0 white papers by 3Dlabs. The generation of an executable that runs on one of OpenGL's programmable units is modeled to that of developing a typical C/C++ application. There are one or more source files, each of which are stored by OpenGL in a shader object. Each shader object (source file) needs to be compiled and attached to a program object. Once all shader objects are compiled successfully, the program object needs to be linked to produce an executable. This executable is part of the program object, and can now be loaded onto the programmable units to make it part of the current OpenGL state. Both the compile and link stages generate a text string that can be queried to get more information. This information could be, but is not limited to, compile errors, link errors, optimization hints, etc. Values for uniform variables, declared in a shader, can be set by the ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DetachObject.</para>
        /// <para>Fullname: DetachObjectARB</para>
        /// <para>Extensions: ARB_shader_objects</para>
        /// </summary>
        public static void DetachObject(uint containerObj, uint attachedObj)
        {
            if (gl._DetachObject != null) gl._DetachObject(containerObj, attachedObj); else { }
        }
        /// <summary>
        /// <para>Fullname: DispatchCompute</para>
        /// </summary>
        [GLEntry("DispatchCompute", Category = "ARB")]
        public static GLDelegate.DispatchCompute _DispatchCompute = null;
        /// <summary>
        /// <para>launch one or more compute work groups</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DispatchCompute.</para>
        /// <para>Fullname: DispatchCompute</para>
        /// <para>Extensions: ARB_compute_shader</para>
        /// </summary>
        /// <param name="num_groups_x">The number of work groups to be launched in the X dimension.</param>
        /// <param name="num_groups_y">The number of work groups to be launched in the Y dimension.</param>
        /// <param name="num_groups_z">The number of work groups to be launched in the Z dimension.</param>
        public static void DispatchCompute(uint num_groups_x, uint num_groups_y, uint num_groups_z)
        {
            if (gl._DispatchCompute != null) gl._DispatchCompute(num_groups_x, num_groups_y, num_groups_z); else { }
        }
        /// <summary>
        /// <para>Fullname: DispatchComputeIndirect</para>
        /// </summary>
        [GLEntry("DispatchComputeIndirect", Category = "ARB")]
        public static GLDelegate.DispatchComputeIndirect _DispatchComputeIndirect = null;
        /// <summary>
        /// <para>launch one or more compute work groups using parameters stored in a buffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DispatchComputeIndirect.</para>
        /// <para>Fullname: DispatchComputeIndirect</para>
        /// <para>Extensions: ARB_compute_shader</para>
        /// </summary>
        /// <param name="indirect">The offset into the buffer object currently bound to the GL_DISPATCH_INDIRECT_BUFFER buffer target at which the dispatch parameters are stored.</param>
        public static void DispatchComputeIndirect(int indirect)
        {
            if (gl._DispatchComputeIndirect != null) gl._DispatchComputeIndirect(indirect); else { }
        }
        /// <summary>
        /// <para>Fullname: DrawArraysIndirect</para>
        /// </summary>
        [GLEntry("DrawArraysIndirect", Category = "ARB")]
        public static GLDelegate.DrawArraysIndirect _DrawArraysIndirect = null;
        /// <summary>
        /// <para>render primitives from array data, taking parameters from memory</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawArraysIndirect.</para>
        /// <para>Fullname: DrawArraysIndirect</para>
        /// <para>Extensions: ARB_draw_indirect</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.</param>
        /// <param name="indirect">Specifies the address of a structure containing the draw parameters.</param>
        public static void DrawArraysIndirect(int mode, IntPtr indirect)
        {
            if (gl._DrawArraysIndirect != null) gl._DrawArraysIndirect(mode, indirect); else { }
        }
        /// <summary>
        /// <para>render primitives from array data, taking parameters from memory</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawArraysIndirect.</para>
        /// <para>Fullname: DrawArraysIndirect</para>
        /// <para>Extensions: ARB_draw_indirect</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.</param>
        /// <param name="indirect">Specifies the address of a structure containing the draw parameters.</param>
        public static void DrawArraysIndirect(int mode, Array indirect)
        {
            GCHandle h = GCHandle.Alloc(indirect, GCHandleType.Pinned);
            try { if (gl._DrawArraysIndirect != null) gl._DrawArraysIndirect(mode, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: DrawArraysInstancedBaseInstance</para>
        /// </summary>
        [GLEntry("DrawArraysInstancedBaseInstance", Category = "ARB")]
        public static GLDelegate.DrawArraysInstancedBaseInstance _DrawArraysInstancedBaseInstance = null;
        /// <summary>
        /// <para>draw multiple instances of a range of elements with offset applied to instanced attributes</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawArraysInstancedBaseInstance.</para>
        /// <para>Fullname: DrawArraysInstancedBaseInstance</para>
        /// <para>Extensions: ARB_base_instance</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLESGL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="first">Specifies the starting index in the enabled arrays.</param>
        /// <param name="count">Specifies the number of indices to be rendered.</param>
        /// <param name="primcount">Specifies the number of instances of the specified range of indices to be rendered.</param>
        /// <param name="baseinstance">Specifies the base instance for use in fetching instanced vertex attributes.</param>
        public static void DrawArraysInstancedBaseInstance(int mode, int first, int count, int instancecount, uint baseinstance)
        {
            if (gl._DrawArraysInstancedBaseInstance != null) gl._DrawArraysInstancedBaseInstance(mode, first, count, instancecount, baseinstance); else { }
        }
        /// <summary>
        /// <para>Fullname: DrawElementsBaseVertex</para>
        /// </summary>
        [GLEntry("DrawElementsBaseVertex", Category = "ARB")]
        public static GLDelegate.DrawElementsBaseVertex _DrawElementsBaseVertex = null;
        /// <summary>
        /// <para>render primitives from array data with a per-element offset</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawElementsBaseVertex.</para>
        /// <para>Fullname: DrawElementsBaseVertex</para>
        /// <para>Extensions: ARB_draw_elements_base_vertex</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="basevertex">Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.</param>
        public static void DrawElementsBaseVertex(int mode, int count, int type, IntPtr indices, int basevertex)
        {
            if (gl._DrawElementsBaseVertex != null) gl._DrawElementsBaseVertex(mode, count, type, indices, basevertex); else { }
        }
        /// <summary>
        /// <para>render primitives from array data with a per-element offset</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawElementsBaseVertex.</para>
        /// <para>Fullname: DrawElementsBaseVertex</para>
        /// <para>Extensions: ARB_draw_elements_base_vertex</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="basevertex">Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.</param>
        public static void DrawElementsBaseVertex(int mode, int count, int type, Array indices, int basevertex)
        {
            GCHandle h = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try { if (gl._DrawElementsBaseVertex != null) gl._DrawElementsBaseVertex(mode, count, type, h.AddrOfPinnedObject(), basevertex); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: DrawElementsIndirect</para>
        /// </summary>
        [GLEntry("DrawElementsIndirect", Category = "ARB")]
        public static GLDelegate.DrawElementsIndirect _DrawElementsIndirect = null;
        /// <summary>
        /// <para>render indexed primitives from array data, taking parameters from memory</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawElementsIndirect.</para>
        /// <para>Fullname: DrawElementsIndirect</para>
        /// <para>Extensions: ARB_draw_indirect</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.</param>
        /// <param name="type">Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding.</param>
        /// <param name="indirect">Specifies the address of a structure containing the draw parameters.</param>
        public static void DrawElementsIndirect(int mode, int type, IntPtr indirect)
        {
            if (gl._DrawElementsIndirect != null) gl._DrawElementsIndirect(mode, type, indirect); else { }
        }
        /// <summary>
        /// <para>render indexed primitives from array data, taking parameters from memory</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawElementsIndirect.</para>
        /// <para>Fullname: DrawElementsIndirect</para>
        /// <para>Extensions: ARB_draw_indirect</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.</param>
        /// <param name="type">Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding.</param>
        /// <param name="indirect">Specifies the address of a structure containing the draw parameters.</param>
        public static void DrawElementsIndirect(int mode, int type, Array indirect)
        {
            GCHandle h = GCHandle.Alloc(indirect, GCHandleType.Pinned);
            try { if (gl._DrawElementsIndirect != null) gl._DrawElementsIndirect(mode, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: DrawElementsInstancedBaseInstance</para>
        /// </summary>
        [GLEntry("DrawElementsInstancedBaseInstance", Category = "ARB")]
        public static GLDelegate.DrawElementsInstancedBaseInstance _DrawElementsInstancedBaseInstance = null;
        /// <summary>
        /// <para>draw multiple instances of a set of elements with offset applied to instanced attributes</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawElementsInstancedBaseInstance.</para>
        /// <para>Fullname: DrawElementsInstancedBaseInstance</para>
        /// <para>Extensions: ARB_base_instance</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="primcount">Specifies the number of instances of the specified range of indices to be rendered.</param>
        /// <param name="baseinstance">Specifies the base instance for use in fetching instanced vertex attributes.</param>
        public static void DrawElementsInstancedBaseInstance(int mode, int count, int type, IntPtr indices, int instancecount, uint baseinstance)
        {
            if (gl._DrawElementsInstancedBaseInstance != null) gl._DrawElementsInstancedBaseInstance(mode, count, type, indices, instancecount, baseinstance); else { }
        }
        /// <summary>
        /// <para>draw multiple instances of a set of elements with offset applied to instanced attributes</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawElementsInstancedBaseInstance.</para>
        /// <para>Fullname: DrawElementsInstancedBaseInstance</para>
        /// <para>Extensions: ARB_base_instance</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="primcount">Specifies the number of instances of the specified range of indices to be rendered.</param>
        /// <param name="baseinstance">Specifies the base instance for use in fetching instanced vertex attributes.</param>
        public static void DrawElementsInstancedBaseInstance(int mode, int count, int type, Array indices, int instancecount, uint baseinstance)
        {
            GCHandle h = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try { if (gl._DrawElementsInstancedBaseInstance != null) gl._DrawElementsInstancedBaseInstance(mode, count, type, h.AddrOfPinnedObject(), instancecount, baseinstance); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: DrawElementsInstancedBaseVertex</para>
        /// </summary>
        [GLEntry("DrawElementsInstancedBaseVertex", Category = "ARB")]
        public static GLDelegate.DrawElementsInstancedBaseVertex _DrawElementsInstancedBaseVertex = null;
        /// <summary>
        /// <para>render multiple instances of a set of primitives from array data with a per-element offset</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawElementsInstancedBaseVertex.</para>
        /// <para>Fullname: DrawElementsInstancedBaseVertex</para>
        /// <para>Extensions: ARB_draw_elements_base_vertex</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="primcount">Specifies the number of instances of the indexed geometry that should be drawn.</param>
        /// <param name="basevertex">Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.</param>
        public static void DrawElementsInstancedBaseVertex(int mode, int count, int type, IntPtr indices, int instancecount, int basevertex)
        {
            if (gl._DrawElementsInstancedBaseVertex != null) gl._DrawElementsInstancedBaseVertex(mode, count, type, indices, instancecount, basevertex); else { }
        }
        /// <summary>
        /// <para>render multiple instances of a set of primitives from array data with a per-element offset</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawElementsInstancedBaseVertex.</para>
        /// <para>Fullname: DrawElementsInstancedBaseVertex</para>
        /// <para>Extensions: ARB_draw_elements_base_vertex</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="primcount">Specifies the number of instances of the indexed geometry that should be drawn.</param>
        /// <param name="basevertex">Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.</param>
        public static void DrawElementsInstancedBaseVertex(int mode, int count, int type, Array indices, int instancecount, int basevertex)
        {
            GCHandle h = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try { if (gl._DrawElementsInstancedBaseVertex != null) gl._DrawElementsInstancedBaseVertex(mode, count, type, h.AddrOfPinnedObject(), instancecount, basevertex); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: DrawElementsInstancedBaseVertexBaseInstance</para>
        /// </summary>
        [GLEntry("DrawElementsInstancedBaseVertexBaseInstance", Category = "ARB")]
        public static GLDelegate.DrawElementsInstancedBaseVertexBaseInstance _DrawElementsInstancedBaseVertexBaseInstance = null;
        /// <summary>
        /// <para>render multiple instances of a set of primitives from array data with a per-element offset</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawElementsInstancedBaseVertexBaseInstance.</para>
        /// <para>Fullname: DrawElementsInstancedBaseVertexBaseInstance</para>
        /// <para>Extensions: ARB_base_instance</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="primcount">Specifies the number of instances of the indexed geometry that should be drawn.</param>
        /// <param name="basevertex">Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.</param>
        /// <param name="baseinstance">Specifies the base instance for use in fetching instanced vertex attributes.</param>
        public static void DrawElementsInstancedBaseVertexBaseInstance(int mode, int count, int type, IntPtr indices, int instancecount, int basevertex, uint baseinstance)
        {
            if (gl._DrawElementsInstancedBaseVertexBaseInstance != null) gl._DrawElementsInstancedBaseVertexBaseInstance(mode, count, type, indices, instancecount, basevertex, baseinstance); else { }
        }
        /// <summary>
        /// <para>render multiple instances of a set of primitives from array data with a per-element offset</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawElementsInstancedBaseVertexBaseInstance.</para>
        /// <para>Fullname: DrawElementsInstancedBaseVertexBaseInstance</para>
        /// <para>Extensions: ARB_base_instance</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="primcount">Specifies the number of instances of the indexed geometry that should be drawn.</param>
        /// <param name="basevertex">Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.</param>
        /// <param name="baseinstance">Specifies the base instance for use in fetching instanced vertex attributes.</param>
        public static void DrawElementsInstancedBaseVertexBaseInstance(int mode, int count, int type, Array indices, int instancecount, int basevertex, uint baseinstance)
        {
            GCHandle h = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try { if (gl._DrawElementsInstancedBaseVertexBaseInstance != null) gl._DrawElementsInstancedBaseVertexBaseInstance(mode, count, type, h.AddrOfPinnedObject(), instancecount, basevertex, baseinstance); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: DrawRangeElementsBaseVertex</para>
        /// </summary>
        [GLEntry("DrawRangeElementsBaseVertex", Category = "ARB")]
        public static GLDelegate.DrawRangeElementsBaseVertex _DrawRangeElementsBaseVertex = null;
        /// <summary>
        /// <para>render primitives from array data with a per-element offset</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawRangeElementsBaseVertex.</para>
        /// <para>Fullname: DrawRangeElementsBaseVertex</para>
        /// <para>Extensions: ARB_draw_elements_base_vertex</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="start">Specifies the minimum array index contained in indices.</param>
        /// <param name="end">Specifies the maximum array index contained in indices.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="basevertex">Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.</param>
        public static void DrawRangeElementsBaseVertex(int mode, uint start, uint end, int count, int type, IntPtr indices, int basevertex)
        {
            if (gl._DrawRangeElementsBaseVertex != null) gl._DrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basevertex); else { }
        }
        /// <summary>
        /// <para>render primitives from array data with a per-element offset</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawRangeElementsBaseVertex.</para>
        /// <para>Fullname: DrawRangeElementsBaseVertex</para>
        /// <para>Extensions: ARB_draw_elements_base_vertex</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="start">Specifies the minimum array index contained in indices.</param>
        /// <param name="end">Specifies the maximum array index contained in indices.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="basevertex">Specifies a constant that should be added to each element of indices when chosing elements from the enabled vertex arrays.</param>
        public static void DrawRangeElementsBaseVertex(int mode, uint start, uint end, int count, int type, Array indices, int basevertex)
        {
            GCHandle h = GCHandle.Alloc(indices, GCHandleType.Pinned);
            try { if (gl._DrawRangeElementsBaseVertex != null) gl._DrawRangeElementsBaseVertex(mode, start, end, count, type, h.AddrOfPinnedObject(), basevertex); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: DrawTransformFeedback</para>
        /// </summary>
        [GLEntry("DrawTransformFeedback", Category = "ARB", Alias = "DrawTransformFeedbackNV ")]
        public static GLDelegate.DrawTransformFeedback _DrawTransformFeedback = null;
        public static GLDelegate.DrawTransformFeedback DrawTransformFeedbackNV = DrawTransformFeedback;
        /// <summary>
        /// <para>render primitives using a count derived from a transform feedback object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawTransformFeedback.</para>
        /// <para>Fullname: DrawTransformFeedback</para>
        /// <para>Aliases: DrawTransformFeedbackNV, </para>
        /// <para>Extensions: ARB_transform_feedback2 NV_transform_feedback2</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.</param>
        /// <param name="id">Specifies the name of a transform feedback object from which to retrieve a primitive count.</param>
        public static void DrawTransformFeedback(int mode, uint id)
        {
            if (gl._DrawTransformFeedback != null) gl._DrawTransformFeedback(mode, id); else { }
        }
        /// <summary>
        /// <para>Fullname: DrawTransformFeedbackInstanced</para>
        /// </summary>
        [GLEntry("DrawTransformFeedbackInstanced", Category = "ARB")]
        public static GLDelegate.DrawTransformFeedbackInstanced _DrawTransformFeedbackInstanced = null;
        /// <summary>
        /// <para>render multiple instances of primitives using a count derived from a transform feedback object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawTransformFeedbackInstanced.</para>
        /// <para>Fullname: DrawTransformFeedbackInstanced</para>
        /// <para>Extensions: ARB_transform_feedback_instanced</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.</param>
        /// <param name="id">Specifies the name of a transform feedback object from which to retrieve a primitive count.</param>
        /// <param name="primcount">Specifies the number of instances of the geometry to render.</param>
        public static void DrawTransformFeedbackInstanced(int mode, uint id, int instancecount)
        {
            if (gl._DrawTransformFeedbackInstanced != null) gl._DrawTransformFeedbackInstanced(mode, id, instancecount); else { }
        }
        /// <summary>
        /// <para>Fullname: DrawTransformFeedbackStream</para>
        /// </summary>
        [GLEntry("DrawTransformFeedbackStream", Category = "ARB")]
        public static GLDelegate.DrawTransformFeedbackStream _DrawTransformFeedbackStream = null;
        /// <summary>
        /// <para>render primitives using a count derived from a specifed stream of a transform feedback object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawTransformFeedbackStream.</para>
        /// <para>Fullname: DrawTransformFeedbackStream</para>
        /// <para>Extensions: ARB_transform_feedback3</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.</param>
        /// <param name="id">Specifies the name of a transform feedback object from which to retrieve a primitive count.</param>
        /// <param name="stream">Specifies the index of the transform feedback stream from which to retrieve a primitive count.</param>
        public static void DrawTransformFeedbackStream(int mode, uint id, uint stream)
        {
            if (gl._DrawTransformFeedbackStream != null) gl._DrawTransformFeedbackStream(mode, id, stream); else { }
        }
        /// <summary>
        /// <para>Fullname: DrawTransformFeedbackStreamInstanced</para>
        /// </summary>
        [GLEntry("DrawTransformFeedbackStreamInstanced", Category = "ARB")]
        public static GLDelegate.DrawTransformFeedbackStreamInstanced _DrawTransformFeedbackStreamInstanced = null;
        /// <summary>
        /// <para>render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawTransformFeedbackStreamInstanced.</para>
        /// <para>Fullname: DrawTransformFeedbackStreamInstanced</para>
        /// <para>Extensions: ARB_transform_feedback_instanced</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.</param>
        /// <param name="id">Specifies the name of a transform feedback object from which to retrieve a primitive count.</param>
        /// <param name="stream">Specifies the index of the transform feedback stream from which to retrieve a primitive count.</param>
        /// <param name="primcount">Specifies the number of instances of the geometry to render.</param>
        public static void DrawTransformFeedbackStreamInstanced(int mode, uint id, uint stream, int instancecount)
        {
            if (gl._DrawTransformFeedbackStreamInstanced != null) gl._DrawTransformFeedbackStreamInstanced(mode, id, stream, instancecount); else { }
        }
        /// <summary>
        /// <para>Fullname: EndQueryIndexed</para>
        /// </summary>
        [GLEntry("EndQueryIndexed", Category = "ARB")]
        public static GLDelegate.EndQueryIndexed _EndQueryIndexed = null;
        /// <summary>
        /// <para>delimit the boundaries of a query object on an indexed target</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EndQueryIndexed.</para>
        /// <para>Fullname: EndQueryIndexed</para>
        /// <para>Extensions: ARB_transform_feedback3</para>
        /// </summary>
        /// <param name="target">Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED.</param>
        /// <param name="index">Specifies the index of the query target upon which to begin the query.</param>
        /// <param name="id">Specifies the name of a query object.</param>
        public static void EndQueryIndexed(int target, uint index)
        {
            if (gl._EndQueryIndexed != null) gl._EndQueryIndexed(target, index); else { }
        }
        /// <summary>
        /// <para>Fullname: FenceSync</para>
        /// </summary>
        [GLEntry("FenceSync", Category = "ARB")]
        public static GLDelegate.FenceSync _FenceSync = null;
        /// <summary>
        /// <para>create a new sync object and insert it into the GL command stream</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FenceSync.</para>
        /// <para>Fullname: FenceSync</para>
        /// <para>Extensions: ARB_sync</para>
        /// </summary>
        /// <param name="condition">Specifies the condition that must be met to set the sync object's state to signaled. condition must be GL_SYNC_GPU_COMMANDS_COMPLETE.</param>
        /// <param name="flags">Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero.[1]</param>
        public static IntPtr FenceSync(int condition, int flags)
        {
            if (gl._FenceSync != null) return gl._FenceSync(condition, flags);
            else { return (IntPtr)0; }
        }
        /// <summary>
        /// <para>Fullname: FlushMappedBufferRange</para>
        /// </summary>
        [GLEntry("FlushMappedBufferRange", Category = "ARB", Alias = "FlushMappedBufferRangeAPPLE ")]
        public static GLDelegate.FlushMappedBufferRange _FlushMappedBufferRange = null;
        public static GLDelegate.FlushMappedBufferRange FlushMappedBufferRangeAPPLE = FlushMappedBufferRange;
        /// <summary>
        /// <para>indicate modifications to a range of a mapped buffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FlushMappedBufferRange.</para>
        /// <para>Fullname: FlushMappedBufferRange</para>
        /// <para>Aliases: FlushMappedBufferRangeAPPLE, </para>
        /// <para>Extensions: ARB_map_buffer_range APPLE_flush_buffer_range</para>
        /// </summary>
        /// <param name="target">Specifies the target of the flush operation. target must be GL_ARRAY_BUFFER, GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_TEXTURE_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.</param>
        /// <param name="offset">Specifies the start of the buffer subrange, in basic machine units.</param>
        /// <param name="length">Specifies the length of the buffer subrange, in basic machine units.</param>
        public static void FlushMappedBufferRange(int target, int offset, int length)
        {
            if (gl._FlushMappedBufferRange != null) gl._FlushMappedBufferRange(target, offset, length); else { }
        }
        /// <summary>
        /// <para>Fullname: FramebufferParameteri</para>
        /// </summary>
        [GLEntry("FramebufferParameteri", Category = "ARB")]
        public static GLDelegate.FramebufferParameteri _FramebufferParameteri = null;
        /// <summary>
        /// <para>set a named parameter of a framebuffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FramebufferParameteri.</para>
        /// <para>Fullname: FramebufferParameteri</para>
        /// <para>Extensions: ARB_framebuffer_no_attachments</para>
        /// </summary>
        /// <param name="target">The target of the operation, which must be GL_READ_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER or GL_FRAMEBUFFER.</param>
        /// <param name="pname">A token indicating the parameter to be modified.</param>
        /// <param name="param">The new value for the parameter named pname.</param>
        public static void FramebufferParameteri(int target, int pname, int param)
        {
            if (gl._FramebufferParameteri != null) gl._FramebufferParameteri(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: FramebufferRenderbuffer</para>
        /// </summary>
        [GLEntry("FramebufferRenderbuffer", Category = "ARB", Alias = "FramebufferRenderbufferEXT ")]
        public static GLDelegate.FramebufferRenderbuffer _FramebufferRenderbuffer = null;
        public static GLDelegate.FramebufferRenderbuffer FramebufferRenderbufferEXT = FramebufferRenderbuffer;
        /// <summary>
        /// <para>attach a renderbuffer as a logical buffer to the currently bound framebuffer object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FramebufferRenderbuffer.</para>
        /// <para>Fullname: FramebufferRenderbuffer</para>
        /// <para>Aliases: FramebufferRenderbufferEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="target">Specifies the framebuffer target. target must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.</param>
        /// <param name="attachment">Specifies the attachment point of the framebuffer.</param>
        /// <param name="renderbuffertarget">Specifies the renderbuffer target and must be GL_RENDERBUFFER.</param>
        /// <param name="renderbuffer">Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach.</param>
        public static void FramebufferRenderbuffer(int target, int attachment, int renderbuffertarget, uint renderbuffer)
        {
            if (gl._FramebufferRenderbuffer != null) gl._FramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer); else { }
        }
        /// <summary>
        /// <para>Fullname: FramebufferTexture1D</para>
        /// </summary>
        [GLEntry("FramebufferTexture1D", Category = "ARB", Alias = "FramebufferTexture1DEXT ")]
        public static GLDelegate.FramebufferTexture1D _FramebufferTexture1D = null;
        public static GLDelegate.FramebufferTexture1D FramebufferTexture1DEXT = FramebufferTexture1D;
        /// <summary>
        /// <para>attach a level of a texture object as a logical buffer to the currently bound framebuffer object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FramebufferTexture1D.</para>
        /// <para>Fullname: FramebufferTexture1D</para>
        /// <para>Aliases: FramebufferTexture1DEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="target">Specifies the framebuffer target. target must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.</param>
        /// <param name="attachment">Specifies the attachment point of the framebuffer. attachment must be GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT or GL_DEPTH_STENCIL_ATTACHMMENT.</param>
        /// <param name="textarget">For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached.</param>
        /// <param name="texture">Specifies the texture object to attach to the framebuffer attachment point named by attachment.</param>
        /// <param name="level">Specifies the mipmap level of texture to attach.</param>
        public static void FramebufferTexture1D(int target, int attachment, int textarget, uint texture, int level)
        {
            if (gl._FramebufferTexture1D != null) gl._FramebufferTexture1D(target, attachment, textarget, texture, level); else { }
        }
        /// <summary>
        /// <para>Fullname: FramebufferTexture2D</para>
        /// </summary>
        [GLEntry("FramebufferTexture2D", Category = "ARB", Alias = "FramebufferTexture2DEXT ")]
        public static GLDelegate.FramebufferTexture2D _FramebufferTexture2D = null;
        public static GLDelegate.FramebufferTexture2D FramebufferTexture2DEXT = FramebufferTexture2D;
        /// <summary>
        /// <para>attach a level of a texture object as a logical buffer to the currently bound framebuffer object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FramebufferTexture2D.</para>
        /// <para>Fullname: FramebufferTexture2D</para>
        /// <para>Aliases: FramebufferTexture2DEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="target">Specifies the framebuffer target. target must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.</param>
        /// <param name="attachment">Specifies the attachment point of the framebuffer. attachment must be GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT or GL_DEPTH_STENCIL_ATTACHMMENT.</param>
        /// <param name="textarget">For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached.</param>
        /// <param name="texture">Specifies the texture object to attach to the framebuffer attachment point named by attachment.</param>
        /// <param name="level">Specifies the mipmap level of texture to attach.</param>
        public static void FramebufferTexture2D(int target, int attachment, int textarget, uint texture, int level)
        {
            if (gl._FramebufferTexture2D != null) gl._FramebufferTexture2D(target, attachment, textarget, texture, level); else { }
        }
        /// <summary>
        /// <para>Fullname: FramebufferTexture3D</para>
        /// </summary>
        [GLEntry("FramebufferTexture3D", Category = "ARB", Alias = "FramebufferTexture3DEXT ")]
        public static GLDelegate.FramebufferTexture3D _FramebufferTexture3D = null;
        public static GLDelegate.FramebufferTexture3D FramebufferTexture3DEXT = FramebufferTexture3D;
        /// <summary>
        /// <para>attach a level of a texture object as a logical buffer to the currently bound framebuffer object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FramebufferTexture3D.</para>
        /// <para>Fullname: FramebufferTexture3D</para>
        /// <para>Aliases: FramebufferTexture3DEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="target">Specifies the framebuffer target. target must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.</param>
        /// <param name="attachment">Specifies the attachment point of the framebuffer. attachment must be GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT or GL_DEPTH_STENCIL_ATTACHMMENT.</param>
        /// <param name="textarget">For glFramebufferTexture1D, glFramebufferTexture2D and glFramebufferTexture3D, specifies what type of texture is expected in the texture parameter, or for cube map textures, which face is to be attached.</param>
        /// <param name="texture">Specifies the texture object to attach to the framebuffer attachment point named by attachment.</param>
        /// <param name="level">Specifies the mipmap level of texture to attach.</param>
        public static void FramebufferTexture3D(int target, int attachment, int textarget, uint texture, int level, int zoffset)
        {
            if (gl._FramebufferTexture3D != null) gl._FramebufferTexture3D(target, attachment, textarget, texture, level, zoffset); else { }
        }
        /// <summary>
        /// <para>Fullname: FramebufferTextureFaceARB</para>
        /// </summary>
        [GLEntry("FramebufferTextureFaceARB", Category = "ARB", Alias = "FramebufferTextureFaceEXT ")]
        public static GLDelegate.FramebufferTextureFace _FramebufferTextureFace = null;
        public static GLDelegate.FramebufferTextureFace FramebufferTextureFaceEXT = FramebufferTextureFace;
        /// <summary>
        /// <para>ARB_geometry_shader4 defines a new shader type available to be run on the GPU, called a geometry shader. Geometry shaders are run after vertices are transformed, but prior to color clamping, flat shading and clipping. A geometry shader begins with a single primitive (point, line, triangle). It can read the attributes of any of the vertices in the primitive and use them to generate new primitives. A geometry shader has a fixed output primitive type (point, line strip, or triangle strip) and emits vertices to define a new primitive. A geometry shader can emit multiple disconnected primitives. The primitives emitted by the geometry shader are clipped and then processed like an equivalent OpenGL primitive specified by the application. Furthermore, ARB_geometry_shader4 provides four additional primitive types: lines with adjacency, line strips with adjacency, separate triangles with adjacency, and triangle strips with adjacency.  Some of the vertices specified in these new primitive types a...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FramebufferTextureFace.</para>
        /// <para>Fullname: FramebufferTextureFaceARB</para>
        /// <para>Aliases: FramebufferTextureFaceEXT, </para>
        /// <para>Extensions: ARB_geometry_shader4 NV_geometry_program4</para>
        /// </summary>
        public static void FramebufferTextureFace(int target, int attachment, uint texture, int level, int face)
        {
            if (gl._FramebufferTextureFace != null) gl._FramebufferTextureFace(target, attachment, texture, level, face); else { }
        }
        /// <summary>
        /// <para>Fullname: FramebufferTextureLayer</para>
        /// </summary>
        [GLEntry("FramebufferTextureLayer", Category = "ARB", Alias = "FramebufferTextureLayerARB FramebufferTextureLayerEXT ")]
        public static GLDelegate.FramebufferTextureLayer _FramebufferTextureLayer = null;
        public static GLDelegate.FramebufferTextureLayer FramebufferTextureLayerARB = FramebufferTextureLayer;
        public static GLDelegate.FramebufferTextureLayer FramebufferTextureLayerEXT = FramebufferTextureLayer;
        /// <summary>
        /// <para>attach a single layer of a texture to a framebuffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FramebufferTextureLayer.</para>
        /// <para>Fullname: FramebufferTextureLayer</para>
        /// <para>Aliases: FramebufferTextureLayerARB, FramebufferTextureLayerEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object ARB_geometry_shader4 NV_geometry_program4</para>
        /// </summary>
        /// <param name="target">Specifies the framebuffer target. target must be GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER, or GL_FRAMEBUFFER. GL_FRAMEBUFFER is equivalent to GL_DRAW_FRAMEBUFFER.</param>
        /// <param name="attachment">Specifies the attachment point of the framebuffer. attachment must be GL_COLOR_ATTACHMENTi, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT or GL_DEPTH_STENCIL_ATTACHMMENT.</param>
        /// <param name="texture">Specifies the texture object to attach to the framebuffer attachment point named by attachment.</param>
        /// <param name="level">Specifies the mipmap level of texture to attach.</param>
        /// <param name="layer">Specifies the layer of texture to attach.</param>
        public static void FramebufferTextureLayer(int target, int attachment, uint texture, int level, int layer)
        {
            if (gl._FramebufferTextureLayer != null) gl._FramebufferTextureLayer(target, attachment, texture, level, layer); else { }
        }
        /// <summary>
        /// <para>Fullname: GenerateMipmap</para>
        /// </summary>
        [GLEntry("GenerateMipmap", Category = "ARB", Alias = "GenerateMipmapEXT ")]
        public static GLDelegate.GenerateMipmap _GenerateMipmap = null;
        public static GLDelegate.GenerateMipmap GenerateMipmapEXT = GenerateMipmap;
        /// <summary>
        /// <para>generate mipmaps for a specified texture target</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenerateMipmap.</para>
        /// <para>Fullname: GenerateMipmap</para>
        /// <para>Aliases: GenerateMipmapEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="target">Specifies the target to which the texture whose mimaps to generate is bound. target must be GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY or GL_TEXTURE_CUBE_MAP.</param>
        public static void GenerateMipmap(int target)
        {
            if (gl._GenerateMipmap != null) gl._GenerateMipmap(target); else { }
        }
        /// <summary>
        /// <para>Fullname: GenFramebuffers</para>
        /// </summary>
        [GLEntry("GenFramebuffers", Category = "ARB", Alias = "GenFramebuffersEXT ")]
        public static GLDelegate.GenFramebuffers_uint _GenFramebuffers_uint = null;
        /// <summary>
        /// <para>generate framebuffer object names</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenFramebuffers_uint.</para>
        /// <para>Fullname: GenFramebuffers</para>
        /// <para>Aliases: GenFramebuffersEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of framebuffer object names to generate.</param>
        /// <param name="ids">Specifies an array in which the generated framebuffer object names are stored.</param>
        public static void GenFramebuffers(int n, out uint framebuffers)
        {
            if (gl._GenFramebuffers_uint != null) gl._GenFramebuffers_uint(n, out framebuffers); else { framebuffers = new uint(); }
        }
        /// <summary>
        /// <para>generate frame buffer object name</para>
        /// </summary>
        public static uint GenFramebuffer()
        {
            uint[] result = new uint[1];
            if (_GenFramebuffers != null) _GenFramebuffers(1, result);
            return result[0];
        }
        /// <summary>
        /// <para>Fullname: GenFramebuffers</para>
        /// </summary>
        [GLEntry("GenFramebuffers", Category = "ARB", Alias = "GenFramebuffersEXT ")]
        public static GLDelegate.GenFramebuffers _GenFramebuffers = null;
        public static GLDelegate.GenFramebuffers GenFramebuffersEXT = GenFramebuffers;
        /// <summary>
        /// <para>generate framebuffer object names</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenFramebuffers.</para>
        /// <para>Fullname: GenFramebuffers</para>
        /// <para>Aliases: GenFramebuffersEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of framebuffer object names to generate.</param>
        /// <param name="ids">Specifies an array in which the generated framebuffer object names are stored.</param>
        public static void GenFramebuffers(int n, uint[] framebuffers)
        {
            if (gl._GenFramebuffers != null) gl._GenFramebuffers(n, framebuffers); else { }
        }
        /// <summary>
        /// <para>Fullname: GenProgramPipelines</para>
        /// </summary>
        [GLEntry("GenProgramPipelines", Category = "ARB")]
        public static GLDelegate.GenProgramPipelines_uint _GenProgramPipelines_uint = null;
        /// <summary>
        /// <para>reserve program pipeline object names</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenProgramPipelines_uint.</para>
        /// <para>Fullname: GenProgramPipelines</para>
        /// <para>Extensions: ARB_separate_shader_objects</para>
        /// </summary>
        /// <param name="n">Specifies the number of program pipeline object names to reserve.</param>
        /// <param name="pipelines">Specifies an array of into which the reserved names will be written.</param>
        public static void GenProgramPipelines(int n, out uint pipelines)
        {
            if (gl._GenProgramPipelines_uint != null) gl._GenProgramPipelines_uint(n, out pipelines); else { pipelines = new uint(); }
        }
        /// <summary>
        /// <para>Fullname: GenProgramPipelines</para>
        /// </summary>
        [GLEntry("GenProgramPipelines", Category = "ARB")]
        public static GLDelegate.GenProgramPipelines _GenProgramPipelines = null;
        /// <summary>
        /// <para>reserve program pipeline object names</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenProgramPipelines.</para>
        /// <para>Fullname: GenProgramPipelines</para>
        /// <para>Extensions: ARB_separate_shader_objects</para>
        /// </summary>
        /// <param name="n">Specifies the number of program pipeline object names to reserve.</param>
        /// <param name="pipelines">Specifies an array of into which the reserved names will be written.</param>
        public static void GenProgramPipelines(int n, uint[] pipelines)
        {
            if (gl._GenProgramPipelines != null) gl._GenProgramPipelines(n, pipelines); else { }
        }
        /// <summary>
        /// <para>Fullname: GenProgramsARB</para>
        /// </summary>
        [GLEntry("GenProgramsARB", Category = "ARB", Alias = "GenProgramsNV ")]
        public static GLDelegate.GenPrograms _GenPrograms = null;
        public static GLDelegate.GenPrograms GenProgramsNV = GenPrograms;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenPrograms.</para>
        /// <para>Fullname: GenProgramsARB</para>
        /// <para>Aliases: GenProgramsNV, </para>
        /// <para>Extensions: ARB_vertex_program NV_vertex_program</para>
        /// </summary>
        public static void GenPrograms(int n, uint[] programs)
        {
            if (gl._GenPrograms != null) gl._GenPrograms(n, programs); else { }
        }
        /// <summary>
        /// <para>Fullname: GenProgramsARB</para>
        /// </summary>
        [GLEntry("GenProgramsARB", Category = "ARB", Alias = "GenProgramsNV ")]
        public static GLDelegate.GenPrograms_uint _GenPrograms_uint = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenPrograms_uint.</para>
        /// <para>Fullname: GenProgramsARB</para>
        /// <para>Aliases: GenProgramsNV, </para>
        /// <para>Extensions: ARB_vertex_program NV_vertex_program</para>
        /// </summary>
        public static void GenPrograms(int n, out uint programs)
        {
            if (gl._GenPrograms_uint != null) gl._GenPrograms_uint(n, out programs); else { programs = new uint(); }
        }
        /// <summary>
        /// <para>Fullname: GenRenderbuffers</para>
        /// </summary>
        [GLEntry("GenRenderbuffers", Category = "ARB", Alias = "GenRenderbuffersEXT ")]
        public static GLDelegate.GenRenderbuffers_uint _GenRenderbuffers_uint = null;
        /// <summary>
        /// <para>generate renderbuffer object names</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenRenderbuffers_uint.</para>
        /// <para>Fullname: GenRenderbuffers</para>
        /// <para>Aliases: GenRenderbuffersEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of renderbuffer object names to generate.</param>
        /// <param name="renderbuffers">Specifies an array in which the generated renderbuffer object names are stored.</param>
        public static void GenRenderbuffers(int n, out uint renderbuffers)
        {
            if (gl._GenRenderbuffers_uint != null) gl._GenRenderbuffers_uint(n, out renderbuffers); else { renderbuffers = new uint(); }
        }
        /// <summary>
        /// <para>generate render buffer object name</para>
        /// </summary>
        public static uint GenRenderBuffer()
        {
            uint[] result = new uint[1];
            if (_GenRenderbuffers != null) _GenRenderbuffers(1, result);
            return result[0];
        }
        /// <summary>
        /// <para>Fullname: GenRenderbuffers</para>
        /// </summary>
        [GLEntry("GenRenderbuffers", Category = "ARB", Alias = "GenRenderbuffersEXT ")]
        public static GLDelegate.GenRenderbuffers _GenRenderbuffers = null;
        public static GLDelegate.GenRenderbuffers GenRenderbuffersEXT = GenRenderbuffers;
        /// <summary>
        /// <para>generate renderbuffer object names</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenRenderbuffers.</para>
        /// <para>Fullname: GenRenderbuffers</para>
        /// <para>Aliases: GenRenderbuffersEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of renderbuffer object names to generate.</param>
        /// <param name="renderbuffers">Specifies an array in which the generated renderbuffer object names are stored.</param>
        public static void GenRenderbuffers(int n, uint[] renderbuffers)
        {
            if (gl._GenRenderbuffers != null) gl._GenRenderbuffers(n, renderbuffers); else { }
        }
        /// <summary>
        /// <para>Fullname: GenSamplers</para>
        /// </summary>
        [GLEntry("GenSamplers", Category = "ARB")]
        public static GLDelegate.GenSamplers _GenSamplers = null;
        /// <summary>
        /// <para>generate sampler object names</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenSamplers.</para>
        /// <para>Fullname: GenSamplers</para>
        /// <para>Extensions: ARB_sampler_objects</para>
        /// </summary>
        /// <param name="n">Specifies the number of sampler object names to generate.</param>
        /// <param name="samplers">Specifies an array in which the generated sampler object names are stored.</param>
        public static void GenSamplers(int count, uint[] samplers)
        {
            if (gl._GenSamplers != null) gl._GenSamplers(count, samplers); else { }
        }
        /// <summary>
        /// <para>Fullname: GenTransformFeedbacks</para>
        /// </summary>
        [GLEntry("GenTransformFeedbacks", Category = "ARB", Alias = "GenTransformFeedbacksNV ")]
        public static GLDelegate.GenTransformFeedbacks _GenTransformFeedbacks = null;
        public static GLDelegate.GenTransformFeedbacks GenTransformFeedbacksNV = GenTransformFeedbacks;
        /// <summary>
        /// <para>reserve transform feedback object names</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenTransformFeedbacks.</para>
        /// <para>Fullname: GenTransformFeedbacks</para>
        /// <para>Aliases: GenTransformFeedbacksNV, </para>
        /// <para>Extensions: ARB_transform_feedback2 NV_transform_feedback2</para>
        /// </summary>
        /// <param name="n">Specifies the number of transform feedback object names to reserve.</param>
        /// <param name="ids">Specifies an array of into which the reserved names will be written.</param>
        public static void GenTransformFeedbacks(int n, uint[] ids)
        {
            if (gl._GenTransformFeedbacks != null) gl._GenTransformFeedbacks(n, ids); else { }
        }
        /// <summary>
        /// <para>Fullname: GenTransformFeedbacks</para>
        /// </summary>
        [GLEntry("GenTransformFeedbacks", Category = "ARB", Alias = "GenTransformFeedbacksNV ")]
        public static GLDelegate.GenTransformFeedbacks_uint _GenTransformFeedbacks_uint = null;
        /// <summary>
        /// <para>reserve transform feedback object names</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenTransformFeedbacks_uint.</para>
        /// <para>Fullname: GenTransformFeedbacks</para>
        /// <para>Aliases: GenTransformFeedbacksNV, </para>
        /// <para>Extensions: ARB_transform_feedback2 NV_transform_feedback2</para>
        /// </summary>
        /// <param name="n">Specifies the number of transform feedback object names to reserve.</param>
        /// <param name="ids">Specifies an array of into which the reserved names will be written.</param>
        public static void GenTransformFeedbacks(int n, out uint ids)
        {
            if (gl._GenTransformFeedbacks_uint != null) gl._GenTransformFeedbacks_uint(n, out ids); else { ids = new uint(); }
        }
        /// <summary>
        /// <para>Fullname: GenVertexArrays</para>
        /// </summary>
        [GLEntry("GenVertexArrays", Category = "ARB", Alias = "GenVertexArraysAPPLE ")]
        public static GLDelegate.GenVertexArrays _GenVertexArrays = null;
        public static GLDelegate.GenVertexArrays GenVertexArraysAPPLE = GenVertexArrays;
        /// <summary>
        /// <para>generate vertex array object names</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenVertexArrays.</para>
        /// <para>Fullname: GenVertexArrays</para>
        /// <para>Aliases: GenVertexArraysAPPLE, </para>
        /// <para>Extensions: ARB_vertex_array_object APPLE_vertex_array_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of vertex array object names to generate.</param>
        /// <param name="arrays">Specifies an array in which the generated vertex array object names are stored.</param>
        public static void GenVertexArrays(int n, uint[] arrays)
        {
            if (gl._GenVertexArrays != null) gl._GenVertexArrays(n, arrays); else { }
        }
        /// <summary>
        /// <para>generate buffer object name</para>
        /// </summary>
        public static uint GenVertexArray()
        {
            uint[] result = new uint[1];
            if (_GenVertexArrays != null) _GenVertexArrays(1, result);
            return result[0];
        }
        /// <summary>
        /// <para>Fullname: GenVertexArrays</para>
        /// </summary>
        [GLEntry("GenVertexArrays", Category = "ARB", Alias = "GenVertexArraysAPPLE ")]
        public static GLDelegate.GenVertexArrays_uint _GenVertexArrays_uint = null;
        /// <summary>
        /// <para>generate vertex array object names</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenVertexArrays_uint.</para>
        /// <para>Fullname: GenVertexArrays</para>
        /// <para>Aliases: GenVertexArraysAPPLE, </para>
        /// <para>Extensions: ARB_vertex_array_object APPLE_vertex_array_object</para>
        /// </summary>
        /// <param name="n">Specifies the number of vertex array object names to generate.</param>
        /// <param name="arrays">Specifies an array in which the generated vertex array object names are stored.</param>
        public static void GenVertexArrays(int n, out uint arrays)
        {
            if (gl._GenVertexArrays_uint != null) gl._GenVertexArrays_uint(n, out arrays); else { arrays = new uint(); }
        }
        /// <summary>
        /// <para>Fullname: GetActiveAtomicCounterBufferiv</para>
        /// </summary>
        [GLEntry("GetActiveAtomicCounterBufferiv", Category = "ARB")]
        public static GLDelegate.GetActiveAtomicCounterBufferiv _GetActiveAtomicCounterBufferiv = null;
        /// <summary>
        /// <para>retrieve information about the set of active atomic counter buffers for a program</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetActiveAtomicCounterBufferiv.</para>
        /// <para>Fullname: GetActiveAtomicCounterBufferiv</para>
        /// <para>Extensions: ARB_shader_atomic_counters</para>
        /// </summary>
        /// <param name="program">The name of a program object from which to retrieve information.</param>
        /// <param name="bufferIndex">Specifies index of an active atomic counter buffer.</param>
        /// <param name="pname">Specifies which parameter of the atomic counter buffer to retrieve.</param>
        /// <param name="params">Specifies the address of a variable into which to write the retrieved information.</param>
        public static void GetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, int pname, int[] param)
        {
            if (gl._GetActiveAtomicCounterBufferiv != null) gl._GetActiveAtomicCounterBufferiv(program, bufferIndex, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetActiveSubroutineName</para>
        /// </summary>
        [GLEntry("GetActiveSubroutineName", Category = "ARB")]
        public static GLDelegate.GetActiveSubroutineName _GetActiveSubroutineName = null;
        /// <summary>
        /// <para>query the name of an active shader subroutine</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetActiveSubroutineName.</para>
        /// <para>Fullname: GetActiveSubroutineName</para>
        /// <para>Extensions: ARB_shader_subroutine</para>
        /// </summary>
        /// <param name="program">Specifies the name of the program containing the subroutine.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query the subroutine name.</param>
        /// <param name="index">Specifies the index of the shader subroutine uniform.</param>
        /// <param name="bufsize">Specifies the size of the buffer whose address is given in name.</param>
        /// <param name="length">Specifies the address of a variable which is to receive the length of the shader subroutine uniform name.</param>
        /// <param name="name">Specifies the address of an array into which the name of the shader subroutine uniform will be written.</param>
        public static void GetActiveSubroutineName(uint program, int shadertype, uint index, int bufsize, int[] length, StringBuilder name)
        {
            if (gl._GetActiveSubroutineName != null) gl._GetActiveSubroutineName(program, shadertype, index, bufsize, length, name); else { }
        }
        /// <summary>
        /// <para>Fullname: GetActiveSubroutineName</para>
        /// </summary>
        [GLEntry("GetActiveSubroutineName", Category = "ARB")]
        public static GLDelegate.GetActiveSubroutineName_int _GetActiveSubroutineName_int = null;
        /// <summary>
        /// <para>query the name of an active shader subroutine</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetActiveSubroutineName_int.</para>
        /// <para>Fullname: GetActiveSubroutineName</para>
        /// <para>Extensions: ARB_shader_subroutine</para>
        /// </summary>
        /// <param name="program">Specifies the name of the program containing the subroutine.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query the subroutine name.</param>
        /// <param name="index">Specifies the index of the shader subroutine uniform.</param>
        /// <param name="bufsize">Specifies the size of the buffer whose address is given in name.</param>
        /// <param name="length">Specifies the address of a variable which is to receive the length of the shader subroutine uniform name.</param>
        /// <param name="name">Specifies the address of an array into which the name of the shader subroutine uniform will be written.</param>
        public static void GetActiveSubroutineName(uint program, int shadertype, uint index, int bufsize, out int length, StringBuilder name)
        {
            if (gl._GetActiveSubroutineName_int != null) gl._GetActiveSubroutineName_int(program, shadertype, index, bufsize, out length, name); else { length = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetActiveSubroutineUniformiv</para>
        /// </summary>
        [GLEntry("GetActiveSubroutineUniformiv", Category = "ARB")]
        public static GLDelegate.GetActiveSubroutineUniformiv _GetActiveSubroutineUniformiv = null;
        /// <summary>
        /// <para>query a property of an active shader subroutine uniform</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetActiveSubroutineUniformiv.</para>
        /// <para>Fullname: GetActiveSubroutineUniformiv</para>
        /// <para>Extensions: ARB_shader_subroutine</para>
        /// </summary>
        /// <param name="program">Specifies the name of the program containing the subroutine.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER.</param>
        /// <param name="index">Specifies the index of the shader subroutine uniform.</param>
        /// <param name="pname">Specifies the parameter of the shader subroutine uniform to query. pname must be GL_NUM_COMPATIBLE_SUBROUTINES, GL_COMPATIBLE_SUBROUTINES, GL_UNIFORM_SIZE or GL_UNIFORM_NAME_LENGTH.</param>
        /// <param name="values">Specifies the address of a into which the queried value or values will be placed.</param>
        public static void GetActiveSubroutineUniformiv(uint program, int shadertype, uint index, int pname, int[] values)
        {
            if (gl._GetActiveSubroutineUniformiv != null) gl._GetActiveSubroutineUniformiv(program, shadertype, index, pname, values); else { }
        }
        /// <summary>
        /// <para>Fullname: GetActiveSubroutineUniformName</para>
        /// </summary>
        [GLEntry("GetActiveSubroutineUniformName", Category = "ARB")]
        public static GLDelegate.GetActiveSubroutineUniformName _GetActiveSubroutineUniformName = null;
        /// <summary>
        /// <para>query the name of an active shader subroutine uniform</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetActiveSubroutineUniformName.</para>
        /// <para>Fullname: GetActiveSubroutineUniformName</para>
        /// <para>Extensions: ARB_shader_subroutine</para>
        /// </summary>
        /// <param name="program">Specifies the name of the program containing the subroutine.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER.</param>
        /// <param name="index">Specifies the index of the shader subroutine uniform.</param>
        /// <param name="bufsize">Specifies the size of the buffer whose address is given in name.</param>
        /// <param name="length">Specifies the address of a variable into which is written the number of characters copied into name.</param>
        /// <param name="name">Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform.</param>
        public static void GetActiveSubroutineUniformName(uint program, int shadertype, uint index, int bufsize, int[] length, StringBuilder name)
        {
            if (gl._GetActiveSubroutineUniformName != null) gl._GetActiveSubroutineUniformName(program, shadertype, index, bufsize, length, name); else { }
        }
        /// <summary>
        /// <para>Fullname: GetActiveSubroutineUniformName</para>
        /// </summary>
        [GLEntry("GetActiveSubroutineUniformName", Category = "ARB")]
        public static GLDelegate.GetActiveSubroutineUniformName_int _GetActiveSubroutineUniformName_int = null;
        /// <summary>
        /// <para>query the name of an active shader subroutine uniform</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetActiveSubroutineUniformName_int.</para>
        /// <para>Fullname: GetActiveSubroutineUniformName</para>
        /// <para>Extensions: ARB_shader_subroutine</para>
        /// </summary>
        /// <param name="program">Specifies the name of the program containing the subroutine.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER.</param>
        /// <param name="index">Specifies the index of the shader subroutine uniform.</param>
        /// <param name="bufsize">Specifies the size of the buffer whose address is given in name.</param>
        /// <param name="length">Specifies the address of a variable into which is written the number of characters copied into name.</param>
        /// <param name="name">Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform.</param>
        public static void GetActiveSubroutineUniformName(uint program, int shadertype, uint index, int bufsize, out int length, StringBuilder name)
        {
            if (gl._GetActiveSubroutineUniformName_int != null) gl._GetActiveSubroutineUniformName_int(program, shadertype, index, bufsize, out length, name); else { length = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetActiveUniformBlockiv</para>
        /// </summary>
        [GLEntry("GetActiveUniformBlockiv", Category = "ARB")]
        public static GLDelegate.GetActiveUniformBlockiv _GetActiveUniformBlockiv = null;
        /// <summary>
        /// <para>query information about an active uniform block</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetActiveUniformBlockiv.</para>
        /// <para>Fullname: GetActiveUniformBlockiv</para>
        /// <para>Extensions: ARB_uniform_buffer_object</para>
        /// </summary>
        /// <param name="program">Specifies the name of a program containing the uniform block.</param>
        /// <param name="uniformBlockIndex">Specifies the index of the uniform block within program.</param>
        /// <param name="pname">Specifies the name of the parameter to query.</param>
        /// <param name="params">Specifies the address of a variable to receive the result of the query.</param>
        public static void GetActiveUniformBlockiv(uint program, uint uniformBlockIndex, int pname, int[] param)
        {
            if (gl._GetActiveUniformBlockiv != null) gl._GetActiveUniformBlockiv(program, uniformBlockIndex, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetActiveUniformBlockName</para>
        /// </summary>
        [GLEntry("GetActiveUniformBlockName", Category = "ARB")]
        public static GLDelegate.GetActiveUniformBlockName_int _GetActiveUniformBlockName_int = null;
        /// <summary>
        /// <para>retrieve the name of an active uniform block</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetActiveUniformBlockName_int.</para>
        /// <para>Fullname: GetActiveUniformBlockName</para>
        /// <para>Extensions: ARB_uniform_buffer_object</para>
        /// </summary>
        /// <param name="program">Specifies the name of a program containing the uniform block.</param>
        /// <param name="uniformBlockIndex">Specifies the index of the uniform block within program.</param>
        /// <param name="bufSize">Specifies the size of the buffer addressed by uniformBlockName.</param>
        /// <param name="length">Specifies the address of a variable to receive the number of characters that were written to uniformBlockName.</param>
        /// <param name="uniformBlockName">Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex.</param>
        public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, out int length, StringBuilder uniformBlockName)
        {
            if (gl._GetActiveUniformBlockName_int != null) gl._GetActiveUniformBlockName_int(program, uniformBlockIndex, bufSize, out length, uniformBlockName); else { length = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetActiveUniformBlockName</para>
        /// </summary>
        [GLEntry("GetActiveUniformBlockName", Category = "ARB")]
        public static GLDelegate.GetActiveUniformBlockName _GetActiveUniformBlockName = null;
        /// <summary>
        /// <para>retrieve the name of an active uniform block</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetActiveUniformBlockName.</para>
        /// <para>Fullname: GetActiveUniformBlockName</para>
        /// <para>Extensions: ARB_uniform_buffer_object</para>
        /// </summary>
        /// <param name="program">Specifies the name of a program containing the uniform block.</param>
        /// <param name="uniformBlockIndex">Specifies the index of the uniform block within program.</param>
        /// <param name="bufSize">Specifies the size of the buffer addressed by uniformBlockName.</param>
        /// <param name="length">Specifies the address of a variable to receive the number of characters that were written to uniformBlockName.</param>
        /// <param name="uniformBlockName">Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex.</param>
        public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int[] length, StringBuilder uniformBlockName)
        {
            if (gl._GetActiveUniformBlockName != null) gl._GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName); else { }
        }
        /// <summary>
        /// <para>Fullname: GetActiveUniformName</para>
        /// </summary>
        [GLEntry("GetActiveUniformName", Category = "ARB")]
        public static GLDelegate.GetActiveUniformName _GetActiveUniformName = null;
        /// <summary>
        /// <para>query the name of an active uniform</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetActiveUniformName.</para>
        /// <para>Fullname: GetActiveUniformName</para>
        /// <para>Extensions: ARB_uniform_buffer_object</para>
        /// </summary>
        /// <param name="program">Specifies the program containing the active uniform index uniformIndex.</param>
        /// <param name="uniformIndex">Specifies the index of the active uniform whose name to query.</param>
        /// <param name="bufSize">Specifies the size of the buffer, in units of GLchar, of the buffer whose address is specified in uniformName.</param>
        /// <param name="length">Specifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by uniformName.</param>
        /// <param name="uniformName">Specifies the address of a buffer into which the GL will place the name of the active uniform at uniformIndex within program.</param>
        public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int[] length, StringBuilder uniformName)
        {
            if (gl._GetActiveUniformName != null) gl._GetActiveUniformName(program, uniformIndex, bufSize, length, uniformName); else { }
        }
        /// <summary>
        /// <para>Fullname: GetActiveUniformName</para>
        /// </summary>
        [GLEntry("GetActiveUniformName", Category = "ARB")]
        public static GLDelegate.GetActiveUniformName_int _GetActiveUniformName_int = null;
        /// <summary>
        /// <para>query the name of an active uniform</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetActiveUniformName_int.</para>
        /// <para>Fullname: GetActiveUniformName</para>
        /// <para>Extensions: ARB_uniform_buffer_object</para>
        /// </summary>
        /// <param name="program">Specifies the program containing the active uniform index uniformIndex.</param>
        /// <param name="uniformIndex">Specifies the index of the active uniform whose name to query.</param>
        /// <param name="bufSize">Specifies the size of the buffer, in units of GLchar, of the buffer whose address is specified in uniformName.</param>
        /// <param name="length">Specifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by uniformName.</param>
        /// <param name="uniformName">Specifies the address of a buffer into which the GL will place the name of the active uniform at uniformIndex within program.</param>
        public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, out int length, StringBuilder uniformName)
        {
            if (gl._GetActiveUniformName_int != null) gl._GetActiveUniformName_int(program, uniformIndex, bufSize, out length, uniformName); else { length = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetActiveUniformsiv</para>
        /// </summary>
        [GLEntry("GetActiveUniformsiv", Category = "ARB")]
        public static GLDelegate.GetActiveUniformsiv _GetActiveUniformsiv = null;
        /// <summary>
        /// <para>Returns information about several active uniform variables for the specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetActiveUniformsiv.</para>
        /// <para>Fullname: GetActiveUniformsiv</para>
        /// <para>Extensions: ARB_uniform_buffer_object</para>
        /// </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="uniformCount">Specifies both the number of elements in the array of indices uniformIndices and the number of parameters written to params upon successful return.</param>
        /// <param name="uniformIndices">Specifies the address of an array of uniformCount integers containing the indices of uniforms within program whose parameter pname pname.</param>
        /// <param name="pname">Specifies the property of the each uniform in uniformIndices that should be written into the corresponding element of params.</param>
        /// <param name="params">Specifies the address of an array of uniformCount integers which are to receive the value of pname for each uniform in uniformIndices.</param>
        public static void GetActiveUniformsiv(uint program, int uniformCount, uint[] uniformIndices, int pname, int[] param)
        {
            if (gl._GetActiveUniformsiv != null) gl._GetActiveUniformsiv(program, uniformCount, uniformIndices, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetAttachedObjectsARB</para>
        /// </summary>
        [GLEntry("GetAttachedObjectsARB", Category = "ARB")]
        public static GLDelegate.GetAttachedObjects _GetAttachedObjects = null;
        /// <summary>
        /// <para>This extension adds API calls that are necessary to manage shader objects and program objects as defined in the OpenGL 2.0 white papers by 3Dlabs. The generation of an executable that runs on one of OpenGL's programmable units is modeled to that of developing a typical C/C++ application. There are one or more source files, each of which are stored by OpenGL in a shader object. Each shader object (source file) needs to be compiled and attached to a program object. Once all shader objects are compiled successfully, the program object needs to be linked to produce an executable. This executable is part of the program object, and can now be loaded onto the programmable units to make it part of the current OpenGL state. Both the compile and link stages generate a text string that can be queried to get more information. This information could be, but is not limited to, compile errors, link errors, optimization hints, etc. Values for uniform variables, declared in a shader, can be set by the ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetAttachedObjects.</para>
        /// <para>Fullname: GetAttachedObjectsARB</para>
        /// <para>Extensions: ARB_shader_objects</para>
        /// </summary>
        public static void GetAttachedObjects(uint containerObj, int maxCount, int[] count, uint[] obj)
        {
            if (gl._GetAttachedObjects != null) gl._GetAttachedObjects(containerObj, maxCount, count, obj); else { }
        }
        /// <summary>
        /// <para>Fullname: GetAttachedObjectsARB</para>
        /// </summary>
        [GLEntry("GetAttachedObjectsARB", Category = "ARB")]
        public static GLDelegate.GetAttachedObjects_int _GetAttachedObjects_int = null;
        /// <summary>
        /// <para>This extension adds API calls that are necessary to manage shader objects and program objects as defined in the OpenGL 2.0 white papers by 3Dlabs. The generation of an executable that runs on one of OpenGL's programmable units is modeled to that of developing a typical C/C++ application. There are one or more source files, each of which are stored by OpenGL in a shader object. Each shader object (source file) needs to be compiled and attached to a program object. Once all shader objects are compiled successfully, the program object needs to be linked to produce an executable. This executable is part of the program object, and can now be loaded onto the programmable units to make it part of the current OpenGL state. Both the compile and link stages generate a text string that can be queried to get more information. This information could be, but is not limited to, compile errors, link errors, optimization hints, etc. Values for uniform variables, declared in a shader, can be set by the ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetAttachedObjects_int.</para>
        /// <para>Fullname: GetAttachedObjectsARB</para>
        /// <para>Extensions: ARB_shader_objects</para>
        /// </summary>
        public static void GetAttachedObjects(uint containerObj, int maxCount, out int count, uint[] obj)
        {
            if (gl._GetAttachedObjects_int != null) gl._GetAttachedObjects_int(containerObj, maxCount, out count, obj); else { count = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetDoublei_v</para>
        /// </summary>
        [GLEntry("GetDoublei_v", Category = "ARB")]
        public static GLDelegate.GetDoublei_v _GetDoublei_v = null;
        /// <summary>
        /// <para>return the value or values of a selected parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetDoublei_v.</para>
        /// <para>Fullname: GetDoublei_v</para>
        /// <para>Extensions: ARB_viewport_array</para>
        /// </summary>
        /// <param name="pname">Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.</param>
        /// <param name="params">Returns the value or values of the specified parameter.</param>
        public static void GetDoublei_v(int target, uint index, double[] data)
        {
            if (gl._GetDoublei_v != null) gl._GetDoublei_v(target, index, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetFloati_v</para>
        /// </summary>
        [GLEntry("GetFloati_v", Category = "ARB")]
        public static GLDelegate.GetFloati_v _GetFloati_v = null;
        /// <summary>
        /// <para>return the value or values of a selected parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetFloati_v.</para>
        /// <para>Fullname: GetFloati_v</para>
        /// <para>Extensions: ARB_viewport_array</para>
        /// </summary>
        /// <param name="pname">Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.</param>
        /// <param name="params">Returns the value or values of the specified parameter.</param>
        public static void GetFloati_v(int target, uint index, float[] data)
        {
            if (gl._GetFloati_v != null) gl._GetFloati_v(target, index, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetFragDataIndex</para>
        /// </summary>
        [GLEntry("GetFragDataIndex", Category = "ARB")]
        public static GLDelegate.GetFragDataIndex _GetFragDataIndex = null;
        /// <summary>
        /// <para>query the bindings of color indices to user-defined varying out variables</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetFragDataIndex.</para>
        /// <para>Fullname: GetFragDataIndex</para>
        /// <para>Extensions: ARB_blend_func_extended</para>
        /// </summary>
        /// <param name="program">The name of the program containing varying out variable whose binding to query</param>
        /// <param name="name">The name of the user-defined varying out variable whose index to query</param>
        public static int GetFragDataIndex(uint program, StringBuilder name)
        {
            if (gl._GetFragDataIndex != null) return gl._GetFragDataIndex(program, name);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: GetFramebufferAttachmentParameteriv</para>
        /// </summary>
        [GLEntry("GetFramebufferAttachmentParameteriv", Category = "ARB", Alias = "GetFramebufferAttachmentParameterivEXT ")]
        public static GLDelegate.GetFramebufferAttachmentParameteriv _GetFramebufferAttachmentParameteriv = null;
        public static GLDelegate.GetFramebufferAttachmentParameteriv GetFramebufferAttachmentParameterivEXT = GetFramebufferAttachmentParameteriv;
        /// <summary>
        /// <para>retrieve information about attachments of a bound framebuffer object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetFramebufferAttachmentParameteriv.</para>
        /// <para>Fullname: GetFramebufferAttachmentParameteriv</para>
        /// <para>Aliases: GetFramebufferAttachmentParameterivEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="target">Specifies the target of the query operation.</param>
        /// <param name="attachment">Specifies the attachment within target</param>
        /// <param name="pname">Specifies the parameter of attachment to query.</param>
        /// <param name="params">Specifies the address of a variable receive the value of pname for attachment.</param>
        public static void GetFramebufferAttachmentParameteriv(int target, int attachment, int pname, int[] param)
        {
            if (gl._GetFramebufferAttachmentParameteriv != null) gl._GetFramebufferAttachmentParameteriv(target, attachment, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetFramebufferParameteriv</para>
        /// </summary>
        [GLEntry("GetFramebufferParameteriv", Category = "ARB")]
        public static GLDelegate.GetFramebufferParameteriv _GetFramebufferParameteriv = null;
        /// <summary>
        /// <para>retrieve a named parameter from a framebuffer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetFramebufferParameteriv.</para>
        /// <para>Fullname: GetFramebufferParameteriv</para>
        /// <para>Extensions: ARB_framebuffer_no_attachments</para>
        /// </summary>
        /// <param name="target">The target of the operation, which must be GL_READ_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER or GL_FRAMEBUFFER.</param>
        /// <param name="pname">A token indicating the parameter to be retrieved.</param>
        /// <param name="params">The address of a variable to receive the value of the parameter named pname.</param>
        public static void GetFramebufferParameteriv(int target, int pname, int[] param)
        {
            if (gl._GetFramebufferParameteriv != null) gl._GetFramebufferParameteriv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetGraphicsResetStatusARB</para>
        /// </summary>
        [GLEntry("GetGraphicsResetStatusARB", Category = "ARB")]
        public static GLDelegate.GetGraphicsResetStatus _GetGraphicsResetStatus = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetGraphicsResetStatus.</para>
        /// <para>Fullname: GetGraphicsResetStatusARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static int GetGraphicsResetStatus()
        {
            if (gl._GetGraphicsResetStatus != null) return gl._GetGraphicsResetStatus();
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: GetHandleARB</para>
        /// </summary>
        [GLEntry("GetHandleARB", Category = "ARB")]
        public static GLDelegate.GetHandle _GetHandle = null;
        /// <summary>
        /// <para>This extension adds API calls that are necessary to manage shader objects and program objects as defined in the OpenGL 2.0 white papers by 3Dlabs. The generation of an executable that runs on one of OpenGL's programmable units is modeled to that of developing a typical C/C++ application. There are one or more source files, each of which are stored by OpenGL in a shader object. Each shader object (source file) needs to be compiled and attached to a program object. Once all shader objects are compiled successfully, the program object needs to be linked to produce an executable. This executable is part of the program object, and can now be loaded onto the programmable units to make it part of the current OpenGL state. Both the compile and link stages generate a text string that can be queried to get more information. This information could be, but is not limited to, compile errors, link errors, optimization hints, etc. Values for uniform variables, declared in a shader, can be set by the ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetHandle.</para>
        /// <para>Fullname: GetHandleARB</para>
        /// <para>Extensions: ARB_shader_objects</para>
        /// </summary>
        public static uint GetHandle(int pname)
        {
            if (gl._GetHandle != null) return gl._GetHandle(pname);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: GetInfoLogARB</para>
        /// </summary>
        [GLEntry("GetInfoLogARB", Category = "ARB")]
        public static GLDelegate.GetInfoLog _GetInfoLog = null;
        /// <summary>
        /// <para>This extension adds API calls that are necessary to manage shader objects and program objects as defined in the OpenGL 2.0 white papers by 3Dlabs. The generation of an executable that runs on one of OpenGL's programmable units is modeled to that of developing a typical C/C++ application. There are one or more source files, each of which are stored by OpenGL in a shader object. Each shader object (source file) needs to be compiled and attached to a program object. Once all shader objects are compiled successfully, the program object needs to be linked to produce an executable. This executable is part of the program object, and can now be loaded onto the programmable units to make it part of the current OpenGL state. Both the compile and link stages generate a text string that can be queried to get more information. This information could be, but is not limited to, compile errors, link errors, optimization hints, etc. Values for uniform variables, declared in a shader, can be set by the ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetInfoLog.</para>
        /// <para>Fullname: GetInfoLogARB</para>
        /// <para>Extensions: ARB_shader_objects</para>
        /// </summary>
        public static void GetInfoLog(uint obj, int maxLength, int[] length, StringBuilder infoLog)
        {
            if (gl._GetInfoLog != null) gl._GetInfoLog(obj, maxLength, length, infoLog); else { }
        }
        public static string GetInfoLog(uint obj)
        {
            StringBuilder info = new StringBuilder(1024);
            int[] length = new int[] { 1024 };
            if (_GetInfoLog != null) _GetInfoLog(obj, 1024, length, info);
            return info.ToString();
        }
        /// <summary>
        /// <para>Fullname: GetInfoLogARB</para>
        /// </summary>
        [GLEntry("GetInfoLogARB", Category = "ARB")]
        public static GLDelegate.GetInfoLog_int _GetInfoLog_int = null;
        /// <summary>
        /// <para>This extension adds API calls that are necessary to manage shader objects and program objects as defined in the OpenGL 2.0 white papers by 3Dlabs. The generation of an executable that runs on one of OpenGL's programmable units is modeled to that of developing a typical C/C++ application. There are one or more source files, each of which are stored by OpenGL in a shader object. Each shader object (source file) needs to be compiled and attached to a program object. Once all shader objects are compiled successfully, the program object needs to be linked to produce an executable. This executable is part of the program object, and can now be loaded onto the programmable units to make it part of the current OpenGL state. Both the compile and link stages generate a text string that can be queried to get more information. This information could be, but is not limited to, compile errors, link errors, optimization hints, etc. Values for uniform variables, declared in a shader, can be set by the ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetInfoLog_int.</para>
        /// <para>Fullname: GetInfoLogARB</para>
        /// <para>Extensions: ARB_shader_objects</para>
        /// </summary>
        public static void GetInfoLog(uint obj, int maxLength, out int length, StringBuilder infoLog)
        {
            if (gl._GetInfoLog_int != null) gl._GetInfoLog_int(obj, maxLength, out length, infoLog); else { length = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetInteger64v</para>
        /// </summary>
        [GLEntry("GetInteger64v", Category = "ARB")]
        public static GLDelegate.GetInteger64v _GetInteger64v = null;
        /// <summary>
        /// <para>return the value or values of a selected parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetInteger64v.</para>
        /// <para>Fullname: GetInteger64v</para>
        /// <para>Extensions: ARB_sync</para>
        /// </summary>
        /// <param name="pname">Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.</param>
        /// <param name="params">Returns the value or values of the specified parameter.</param>
        public static void GetInteger64v(int pname, long[] param)
        {
            if (gl._GetInteger64v != null) gl._GetInteger64v(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetInternalformati64v</para>
        /// </summary>
        [GLEntry("GetInternalformati64v", Category = "ARB")]
        public static GLDelegate.GetInternalformati64v _GetInternalformati64v = null;
        /// <summary>
        /// <para>This extension extends the GetInternalformativ query that was added in the ARB_internalformat_query extension to provide applications with more granular per-format capability information. This extension allows the remainder of the texture-style targets to be specified along with any possible internal format. We add queries for additional properties supported for an internal format in addition to the multisample-related information that was added in ARB_internalformat_query. The goals of this extension are to: a) provide a mechanism for implementations to declare support *above* the minimum required by the specification b) provide API to allow universally constant information to be queried c) provide a user-friendly way of finding out about version- or implementation-specific limitations. While much of this information can be determined for a single GL version by careful examination of the specification, support for many of these properties has been gradually introduced over a number of...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetInternalformati64v.</para>
        /// <para>Fullname: GetInternalformati64v</para>
        /// <para>Extensions: ARB_internalformat_query2</para>
        /// </summary>
        public static void GetInternalformati64v(int target, int internalformat, int pname, int bufSize, long[] param)
        {
            if (gl._GetInternalformati64v != null) gl._GetInternalformati64v(target, internalformat, pname, bufSize, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetInternalformativ</para>
        /// </summary>
        [GLEntry("GetInternalformativ", Category = "ARB")]
        public static GLDelegate.GetInternalformativ _GetInternalformativ = null;
        /// <summary>
        /// <para>OpenGL 4.1 has a number of queries to indicate the maximum number of samples available for different formats. These give a coarse-grained query mechanism e.g. an implementation can expose different sample counts for integer and floating-point formats, but not for different floating-point formats. There is also no convenient way for the user to determine the granularity of sample counts available, only the maximum. This extension adds a query mechanism that allows the user to determine which sample counts are available for a specific internal format. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetInternalformativ.</para>
        /// <para>Fullname: GetInternalformativ</para>
        /// <para>Extensions: ARB_internalformat_query</para>
        /// </summary>
        public static void GetInternalformativ(int target, int internalformat, int pname, int bufSize, int[] param)
        {
            if (gl._GetInternalformativ != null) gl._GetInternalformativ(target, internalformat, pname, bufSize, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMultisamplefv</para>
        /// </summary>
        [GLEntry("GetMultisamplefv", Category = "ARB", Alias = "GetMultisamplefvNV ")]
        public static GLDelegate.GetMultisamplefv _GetMultisamplefv = null;
        public static GLDelegate.GetMultisamplefv GetMultisamplefvNV = GetMultisamplefv;
        /// <summary>
        /// <para>retrieve the location of a sample</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMultisamplefv.</para>
        /// <para>Fullname: GetMultisamplefv</para>
        /// <para>Aliases: GetMultisamplefvNV, </para>
        /// <para>Extensions: ARB_texture_multisample NV_explicit_multisample</para>
        /// </summary>
        /// <param name="pname">Specifies the sample parameter name. pname must be GL_SAMPLE_POSITION.</param>
        /// <param name="index">Specifies the index of the sample whose position to query.</param>
        /// <param name="val">Specifies the address of an array to receive the position of the sample.</param>
        public static void GetMultisamplefv(int pname, uint index, float[] val)
        {
            if (gl._GetMultisamplefv != null) gl._GetMultisamplefv(pname, index, val); else { }
        }
        /// <summary>
        /// <para>Fullname: GetNamedFramebufferParameterivEXT</para>
        /// </summary>
        [GLEntry("GetNamedFramebufferParameterivEXT", Category = "ARB")]
        public static GLDelegate.GetNamedFramebufferParameteriv _GetNamedFramebufferParameteriv = null;
        /// <summary>
        /// <para>Framebuffer objects as introduced by ARB_framebuffer_object and OpenGL 3.0 provide a generalized mechanism for rendering to off-screen surfaces. Each framebuffer object may have depth, stencil and zero or more color attachments that can be written to by the GL.  The size of the framebuffer (width, height, layer count, sample count) is derived from the attachments of that framebuffer.  In unextended OpenGL 4.2, it is not legal to render into a framebuffer object that has no attachments.  Such a framebuffer would be considered incomplete with the FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT status. With OpenGL 4.2 and ARB_shader_image_load_store, fragment shaders are capable of doing random access writes to buffer and texture memory via image loads, stores, and atomics.  This ability enables algorithms using the conventional rasterizer to generate a collection of fragments, where each fragment shader invocation will write its outputs to buffer or texture memory using image stores or atomics...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetNamedFramebufferParameteriv.</para>
        /// <para>Fullname: GetNamedFramebufferParameterivEXT</para>
        /// <para>Extensions: ARB_framebuffer_no_attachments</para>
        /// </summary>
        public static void GetNamedFramebufferParameteriv(uint framebuffer, int pname, int[] param)
        {
            if (gl._GetNamedFramebufferParameteriv != null) gl._GetNamedFramebufferParameteriv(framebuffer, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetNamedStringARB</para>
        /// </summary>
        [GLEntry("GetNamedStringARB", Category = "ARB")]
        public static GLDelegate.GetNamedString_int _GetNamedString_int = null;
        /// <summary>
        /// <para>This extension introduces a #include GLSL directive to allow reusing the same shader text in multiple shaders and defines the semantics and syntax of the names allowed in #include directives. It also defines API mechanisms to define the named string backing a #include. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetNamedString_int.</para>
        /// <para>Fullname: GetNamedStringARB</para>
        /// <para>Extensions: ARB_shading_language_include</para>
        /// </summary>
        public static void GetNamedString(int namelen, StringBuilder name, int bufSize, out int stringlen, StringBuilder str)
        {
            if (gl._GetNamedString_int != null) gl._GetNamedString_int(namelen, name, bufSize, out stringlen, str); else { stringlen = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetNamedStringARB</para>
        /// </summary>
        [GLEntry("GetNamedStringARB", Category = "ARB")]
        public static GLDelegate.GetNamedString _GetNamedString = null;
        /// <summary>
        /// <para>This extension introduces a #include GLSL directive to allow reusing the same shader text in multiple shaders and defines the semantics and syntax of the names allowed in #include directives. It also defines API mechanisms to define the named string backing a #include. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetNamedString.</para>
        /// <para>Fullname: GetNamedStringARB</para>
        /// <para>Extensions: ARB_shading_language_include</para>
        /// </summary>
        public static void GetNamedString(int namelen, StringBuilder name, int bufSize, int[] stringlen, StringBuilder str)
        {
            if (gl._GetNamedString != null) gl._GetNamedString(namelen, name, bufSize, stringlen, str); else { }
        }
        /// <summary>
        /// <para>Fullname: GetNamedStringivARB</para>
        /// </summary>
        [GLEntry("GetNamedStringivARB", Category = "ARB")]
        public static GLDelegate.GetNamedStringiv _GetNamedStringiv = null;
        /// <summary>
        /// <para>This extension introduces a #include GLSL directive to allow reusing the same shader text in multiple shaders and defines the semantics and syntax of the names allowed in #include directives. It also defines API mechanisms to define the named string backing a #include. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetNamedStringiv.</para>
        /// <para>Fullname: GetNamedStringivARB</para>
        /// <para>Extensions: ARB_shading_language_include</para>
        /// </summary>
        public static void GetNamedStringiv(int namelen, StringBuilder name, int pname, int[] param)
        {
            if (gl._GetNamedStringiv != null) gl._GetNamedStringiv(namelen, name, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetnColorTableARB</para>
        /// </summary>
        [GLEntry("GetnColorTableARB", Category = "ARB")]
        public static GLDelegate.GetnColorTable _GetnColorTable = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetnColorTable.</para>
        /// <para>Fullname: GetnColorTableARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static void GetnColorTable(int target, int format, int type, int bufSize, IntPtr table)
        {
            if (gl._GetnColorTable != null) gl._GetnColorTable(target, format, type, bufSize, table); else { }
        }
        /// <summary>
        /// <para>Fullname: GetnCompressedTexImageARB</para>
        /// </summary>
        [GLEntry("GetnCompressedTexImageARB", Category = "ARB")]
        public static GLDelegate.GetnCompressedTexImage _GetnCompressedTexImage = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetnCompressedTexImage.</para>
        /// <para>Fullname: GetnCompressedTexImageARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static void GetnCompressedTexImage(int target, int lod, int bufSize, IntPtr img)
        {
            if (gl._GetnCompressedTexImage != null) gl._GetnCompressedTexImage(target, lod, bufSize, img); else { }
        }
        /// <summary>
        /// <para>Fullname: GetnConvolutionFilterARB</para>
        /// </summary>
        [GLEntry("GetnConvolutionFilterARB", Category = "ARB")]
        public static GLDelegate.GetnConvolutionFilter _GetnConvolutionFilter = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetnConvolutionFilter.</para>
        /// <para>Fullname: GetnConvolutionFilterARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static void GetnConvolutionFilter(int target, int format, int type, int bufSize, IntPtr image)
        {
            if (gl._GetnConvolutionFilter != null) gl._GetnConvolutionFilter(target, format, type, bufSize, image); else { }
        }
        /// <summary>
        /// <para>Fullname: GetnHistogramARB</para>
        /// </summary>
        [GLEntry("GetnHistogramARB", Category = "ARB")]
        public static GLDelegate.GetnHistogram _GetnHistogram = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetnHistogram.</para>
        /// <para>Fullname: GetnHistogramARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static void GetnHistogram(int target, bool reset, int format, int type, int bufSize, IntPtr values)
        {
            if (gl._GetnHistogram != null) gl._GetnHistogram(target, reset, format, type, bufSize, values); else { }
        }
        /// <summary>
        /// <para>Fullname: GetnMapdvARB</para>
        /// </summary>
        [GLEntry("GetnMapdvARB", Category = "ARB")]
        public static GLDelegate.GetnMapdv _GetnMapdv = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetnMapdv.</para>
        /// <para>Fullname: GetnMapdvARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static void GetnMapdv(int target, int query, int bufSize, double[] v)
        {
            if (gl._GetnMapdv != null) gl._GetnMapdv(target, query, bufSize, v); else { }
        }
        /// <summary>
        /// <para>Fullname: GetnMapfvARB</para>
        /// </summary>
        [GLEntry("GetnMapfvARB", Category = "ARB")]
        public static GLDelegate.GetnMapfv _GetnMapfv = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetnMapfv.</para>
        /// <para>Fullname: GetnMapfvARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static void GetnMapfv(int target, int query, int bufSize, float[] v)
        {
            if (gl._GetnMapfv != null) gl._GetnMapfv(target, query, bufSize, v); else { }
        }
        /// <summary>
        /// <para>Fullname: GetnMapivARB</para>
        /// </summary>
        [GLEntry("GetnMapivARB", Category = "ARB")]
        public static GLDelegate.GetnMapiv _GetnMapiv = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetnMapiv.</para>
        /// <para>Fullname: GetnMapivARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static void GetnMapiv(int target, int query, int bufSize, int[] v)
        {
            if (gl._GetnMapiv != null) gl._GetnMapiv(target, query, bufSize, v); else { }
        }
        /// <summary>
        /// <para>Fullname: GetnMinmaxARB</para>
        /// </summary>
        [GLEntry("GetnMinmaxARB", Category = "ARB")]
        public static GLDelegate.GetnMinmax _GetnMinmax = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetnMinmax.</para>
        /// <para>Fullname: GetnMinmaxARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static void GetnMinmax(int target, bool reset, int format, int type, int bufSize, IntPtr values)
        {
            if (gl._GetnMinmax != null) gl._GetnMinmax(target, reset, format, type, bufSize, values); else { }
        }
        /// <summary>
        /// <para>Fullname: GetnPixelMapfvARB</para>
        /// </summary>
        [GLEntry("GetnPixelMapfvARB", Category = "ARB")]
        public static GLDelegate.GetnPixelMapfv _GetnPixelMapfv = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetnPixelMapfv.</para>
        /// <para>Fullname: GetnPixelMapfvARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static void GetnPixelMapfv(int map, int bufSize, float[] values)
        {
            if (gl._GetnPixelMapfv != null) gl._GetnPixelMapfv(map, bufSize, values); else { }
        }
        /// <summary>
        /// <para>Fullname: GetnPixelMapuivARB</para>
        /// </summary>
        [GLEntry("GetnPixelMapuivARB", Category = "ARB")]
        public static GLDelegate.GetnPixelMapuiv _GetnPixelMapuiv = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetnPixelMapuiv.</para>
        /// <para>Fullname: GetnPixelMapuivARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static void GetnPixelMapuiv(int map, int bufSize, uint[] values)
        {
            if (gl._GetnPixelMapuiv != null) gl._GetnPixelMapuiv(map, bufSize, values); else { }
        }
        /// <summary>
        /// <para>Fullname: GetnPixelMapusvARB</para>
        /// </summary>
        [GLEntry("GetnPixelMapusvARB", Category = "ARB")]
        public static GLDelegate.GetnPixelMapusv _GetnPixelMapusv = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetnPixelMapusv.</para>
        /// <para>Fullname: GetnPixelMapusvARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static void GetnPixelMapusv(int map, int bufSize, ushort[] values)
        {
            if (gl._GetnPixelMapusv != null) gl._GetnPixelMapusv(map, bufSize, values); else { }
        }
        /// <summary>
        /// <para>Fullname: GetnPolygonStippleARB</para>
        /// </summary>
        [GLEntry("GetnPolygonStippleARB", Category = "ARB")]
        public static GLDelegate.GetnPolygonStipple _GetnPolygonStipple = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetnPolygonStipple.</para>
        /// <para>Fullname: GetnPolygonStippleARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static void GetnPolygonStipple(int bufSize, byte[] pattern)
        {
            if (gl._GetnPolygonStipple != null) gl._GetnPolygonStipple(bufSize, pattern); else { }
        }
        /// <summary>
        /// <para>Fullname: GetnSeparableFilterARB</para>
        /// </summary>
        [GLEntry("GetnSeparableFilterARB", Category = "ARB")]
        public static GLDelegate.GetnSeparableFilter _GetnSeparableFilter = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetnSeparableFilter.</para>
        /// <para>Fullname: GetnSeparableFilterARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static void GetnSeparableFilter(int target, int format, int type, int rowBufSize, IntPtr row, int columnBufSize, IntPtr column, IntPtr span)
        {
            if (gl._GetnSeparableFilter != null) gl._GetnSeparableFilter(target, format, type, rowBufSize, row, columnBufSize, column, span); else { }
        }
        /// <summary>
        /// <para>Fullname: GetnTexImageARB</para>
        /// </summary>
        [GLEntry("GetnTexImageARB", Category = "ARB")]
        public static GLDelegate.GetnTexImage _GetnTexImage = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetnTexImage.</para>
        /// <para>Fullname: GetnTexImageARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static void GetnTexImage(int target, int level, int format, int type, int bufSize, IntPtr img)
        {
            if (gl._GetnTexImage != null) gl._GetnTexImage(target, level, format, type, bufSize, img); else { }
        }
        /// <summary>
        /// <para>Fullname: GetnUniformdvARB</para>
        /// </summary>
        [GLEntry("GetnUniformdvARB", Category = "ARB")]
        public static GLDelegate.GetnUniformdv _GetnUniformdv = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetnUniformdv.</para>
        /// <para>Fullname: GetnUniformdvARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static void GetnUniformdv(uint program, int location, int bufSize, double[] param)
        {
            if (gl._GetnUniformdv != null) gl._GetnUniformdv(program, location, bufSize, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetnUniformfvARB</para>
        /// </summary>
        [GLEntry("GetnUniformfvARB", Category = "ARB")]
        public static GLDelegate.GetnUniformfv _GetnUniformfv = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetnUniformfv.</para>
        /// <para>Fullname: GetnUniformfvARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static void GetnUniformfv(uint program, int location, int bufSize, float[] param)
        {
            if (gl._GetnUniformfv != null) gl._GetnUniformfv(program, location, bufSize, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetnUniformivARB</para>
        /// </summary>
        [GLEntry("GetnUniformivARB", Category = "ARB")]
        public static GLDelegate.GetnUniformiv _GetnUniformiv = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetnUniformiv.</para>
        /// <para>Fullname: GetnUniformivARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static void GetnUniformiv(uint program, int location, int bufSize, int[] param)
        {
            if (gl._GetnUniformiv != null) gl._GetnUniformiv(program, location, bufSize, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetnUniformuivARB</para>
        /// </summary>
        [GLEntry("GetnUniformuivARB", Category = "ARB")]
        public static GLDelegate.GetnUniformuiv _GetnUniformuiv = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetnUniformuiv.</para>
        /// <para>Fullname: GetnUniformuivARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static void GetnUniformuiv(uint program, int location, int bufSize, uint[] param)
        {
            if (gl._GetnUniformuiv != null) gl._GetnUniformuiv(program, location, bufSize, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetObjectParameterfvARB</para>
        /// </summary>
        [GLEntry("GetObjectParameterfvARB", Category = "ARB")]
        public static GLDelegate.GetObjectParameterfv _GetObjectParameterfv = null;
        /// <summary>
        /// <para>This extension adds API calls that are necessary to manage shader objects and program objects as defined in the OpenGL 2.0 white papers by 3Dlabs. The generation of an executable that runs on one of OpenGL's programmable units is modeled to that of developing a typical C/C++ application. There are one or more source files, each of which are stored by OpenGL in a shader object. Each shader object (source file) needs to be compiled and attached to a program object. Once all shader objects are compiled successfully, the program object needs to be linked to produce an executable. This executable is part of the program object, and can now be loaded onto the programmable units to make it part of the current OpenGL state. Both the compile and link stages generate a text string that can be queried to get more information. This information could be, but is not limited to, compile errors, link errors, optimization hints, etc. Values for uniform variables, declared in a shader, can be set by the ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetObjectParameterfv.</para>
        /// <para>Fullname: GetObjectParameterfvARB</para>
        /// <para>Extensions: ARB_shader_objects</para>
        /// </summary>
        public static void GetObjectParameterfv(uint obj, int pname, float[] param)
        {
            if (gl._GetObjectParameterfv != null) gl._GetObjectParameterfv(obj, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetObjectParameterivARB</para>
        /// </summary>
        [GLEntry("GetObjectParameterivARB", Category = "ARB")]
        public static GLDelegate.GetObjectParameteriv _GetObjectParameteriv = null;
        /// <summary>
        /// <para>This extension adds API calls that are necessary to manage shader objects and program objects as defined in the OpenGL 2.0 white papers by 3Dlabs. The generation of an executable that runs on one of OpenGL's programmable units is modeled to that of developing a typical C/C++ application. There are one or more source files, each of which are stored by OpenGL in a shader object. Each shader object (source file) needs to be compiled and attached to a program object. Once all shader objects are compiled successfully, the program object needs to be linked to produce an executable. This executable is part of the program object, and can now be loaded onto the programmable units to make it part of the current OpenGL state. Both the compile and link stages generate a text string that can be queried to get more information. This information could be, but is not limited to, compile errors, link errors, optimization hints, etc. Values for uniform variables, declared in a shader, can be set by the ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetObjectParameteriv.</para>
        /// <para>Fullname: GetObjectParameterivARB</para>
        /// <para>Extensions: ARB_shader_objects</para>
        /// </summary>
        public static void GetObjectParameteriv(uint obj, int pname, int[] param)
        {
            if (gl._GetObjectParameteriv != null) gl._GetObjectParameteriv(obj, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramBinary</para>
        /// </summary>
        [GLEntry("GetProgramBinary", Category = "ARB")]
        public static GLDelegate.GetProgramBinary_int_int _GetProgramBinary_int_int = null;
        /// <summary>
        /// <para>return a binary representation of a program object's compiled and linked executable source</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramBinary_int_int.</para>
        /// <para>Fullname: GetProgramBinary</para>
        /// <para>Extensions: ARB_get_program_binary</para>
        /// </summary>
        /// <param name="program">Specifies the name of a program object whose binary representation to retrieve.</param>
        /// <param name="bufSize">Specifies the size of the buffer whose address is given by binary.</param>
        /// <param name="length">Specifies the address of a variable to receive the number of bytes written into binary.</param>
        /// <param name="binaryFormat">Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.</param>
        /// <param name="binary">Specifies the address an array into which the GL will return program's binary representation.</param>
        public static void GetProgramBinary(uint program, int bufSize, out int length, out int binaryFormat, IntPtr binary)
        {
            if (gl._GetProgramBinary_int_int != null) gl._GetProgramBinary_int_int(program, bufSize, out length, out binaryFormat, binary); else { length = new int(); binaryFormat = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetProgramBinary</para>
        /// </summary>
        [GLEntry("GetProgramBinary", Category = "ARB")]
        public static GLDelegate.GetProgramBinary _GetProgramBinary = null;
        /// <summary>
        /// <para>return a binary representation of a program object's compiled and linked executable source</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramBinary.</para>
        /// <para>Fullname: GetProgramBinary</para>
        /// <para>Extensions: ARB_get_program_binary</para>
        /// </summary>
        /// <param name="program">Specifies the name of a program object whose binary representation to retrieve.</param>
        /// <param name="bufSize">Specifies the size of the buffer whose address is given by binary.</param>
        /// <param name="length">Specifies the address of a variable to receive the number of bytes written into binary.</param>
        /// <param name="binaryFormat">Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.</param>
        /// <param name="binary">Specifies the address an array into which the GL will return program's binary representation.</param>
        public static void GetProgramBinary(uint program, int bufSize, int[] length, int[] binaryFormat, IntPtr binary)
        {
            if (gl._GetProgramBinary != null) gl._GetProgramBinary(program, bufSize, length, binaryFormat, binary); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramEnvParameterdvARB</para>
        /// </summary>
        [GLEntry("GetProgramEnvParameterdvARB", Category = "ARB")]
        public static GLDelegate.GetProgramEnvParameterdv _GetProgramEnvParameterdv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramEnvParameterdv.</para>
        /// <para>Fullname: GetProgramEnvParameterdvARB</para>
        /// <para>Extensions: ARB_vertex_program</para>
        /// </summary>
        public static void GetProgramEnvParameterdv(int target, uint index, double[] param)
        {
            if (gl._GetProgramEnvParameterdv != null) gl._GetProgramEnvParameterdv(target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramEnvParameterfvARB</para>
        /// </summary>
        [GLEntry("GetProgramEnvParameterfvARB", Category = "ARB")]
        public static GLDelegate.GetProgramEnvParameterfv _GetProgramEnvParameterfv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramEnvParameterfv.</para>
        /// <para>Fullname: GetProgramEnvParameterfvARB</para>
        /// <para>Extensions: ARB_vertex_program</para>
        /// </summary>
        public static void GetProgramEnvParameterfv(int target, uint index, float[] param)
        {
            if (gl._GetProgramEnvParameterfv != null) gl._GetProgramEnvParameterfv(target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramInterfaceiv</para>
        /// </summary>
        [GLEntry("GetProgramInterfaceiv", Category = "ARB")]
        public static GLDelegate.GetProgramInterfaceiv _GetProgramInterfaceiv = null;
        /// <summary>
        /// <para>query a property of an interface in a program</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramInterfaceiv.</para>
        /// <para>Fullname: GetProgramInterfaceiv</para>
        /// <para>Extensions: ARB_program_interface_query</para>
        /// </summary>
        /// <param name="program">The name of a program object whose interface to query.</param>
        /// <param name="programInterface">A token identifying the interface within program to query.</param>
        /// <param name="pname">The name of the parameter within programInterface to query.</param>
        /// <param name="params">The address of a variable to retrieve the value of pname for the program interface.</param>
        public static void GetProgramInterfaceiv(uint program, int programInterface, int pname, int[] param)
        {
            if (gl._GetProgramInterfaceiv != null) gl._GetProgramInterfaceiv(program, programInterface, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramivARB</para>
        /// </summary>
        [GLEntry("GetProgramivARB", Category = "ARB")]
        public static GLDelegate.GetProgramivARB_int _GetProgramivARB_int = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramivARB_int.</para>
        /// <para>Fullname: GetProgramivARB</para>
        /// <para>Extensions: ARB_vertex_program</para>
        /// </summary>
        public static void GetProgramivARB(int target, int pname, out int param)
        {
            if (gl._GetProgramivARB_int != null) gl._GetProgramivARB_int(target, pname, out param); else { param = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetProgramivARB</para>
        /// </summary>
        [GLEntry("GetProgramivARB", Category = "ARB")]
        public static GLDelegate.GetProgramivARB _GetProgramivARB = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramivARB.</para>
        /// <para>Fullname: GetProgramivARB</para>
        /// <para>Extensions: ARB_vertex_program</para>
        /// </summary>
        public static void GetProgramivARB(int target, int pname, int[] param)
        {
            if (gl._GetProgramivARB != null) gl._GetProgramivARB(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramLocalParameterdvARB</para>
        /// </summary>
        [GLEntry("GetProgramLocalParameterdvARB", Category = "ARB")]
        public static GLDelegate.GetProgramLocalParameterdv _GetProgramLocalParameterdv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramLocalParameterdv.</para>
        /// <para>Fullname: GetProgramLocalParameterdvARB</para>
        /// <para>Extensions: ARB_vertex_program</para>
        /// </summary>
        public static void GetProgramLocalParameterdv(int target, uint index, double[] param)
        {
            if (gl._GetProgramLocalParameterdv != null) gl._GetProgramLocalParameterdv(target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramLocalParameterfvARB</para>
        /// </summary>
        [GLEntry("GetProgramLocalParameterfvARB", Category = "ARB")]
        public static GLDelegate.GetProgramLocalParameterfv _GetProgramLocalParameterfv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramLocalParameterfv.</para>
        /// <para>Fullname: GetProgramLocalParameterfvARB</para>
        /// <para>Extensions: ARB_vertex_program</para>
        /// </summary>
        public static void GetProgramLocalParameterfv(int target, uint index, float[] param)
        {
            if (gl._GetProgramLocalParameterfv != null) gl._GetProgramLocalParameterfv(target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramPipelineInfoLog</para>
        /// </summary>
        [GLEntry("GetProgramPipelineInfoLog", Category = "ARB")]
        public static GLDelegate.GetProgramPipelineInfoLog _GetProgramPipelineInfoLog = null;
        /// <summary>
        /// <para>retrieve the info log string from a program pipeline object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramPipelineInfoLog.</para>
        /// <para>Fullname: GetProgramPipelineInfoLog</para>
        /// <para>Extensions: ARB_separate_shader_objects</para>
        /// </summary>
        /// <param name="pipeline">Specifies the name of a program pipeline object from which to retrieve the info log.</param>
        /// <param name="bufSize">Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.</param>
        /// <param name="length">Specifies the address of a variable into which will be written the number of characters written into infoLog.</param>
        /// <param name="infoLog">Specifies the address of an array of characters into which will be written the info log for pipeline.</param>
        public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, int[] length, StringBuilder infoLog)
        {
            if (gl._GetProgramPipelineInfoLog != null) gl._GetProgramPipelineInfoLog(pipeline, bufSize, length, infoLog); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramPipelineInfoLog</para>
        /// </summary>
        [GLEntry("GetProgramPipelineInfoLog", Category = "ARB")]
        public static GLDelegate.GetProgramPipelineInfoLog_int _GetProgramPipelineInfoLog_int = null;
        /// <summary>
        /// <para>retrieve the info log string from a program pipeline object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramPipelineInfoLog_int.</para>
        /// <para>Fullname: GetProgramPipelineInfoLog</para>
        /// <para>Extensions: ARB_separate_shader_objects</para>
        /// </summary>
        /// <param name="pipeline">Specifies the name of a program pipeline object from which to retrieve the info log.</param>
        /// <param name="bufSize">Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.</param>
        /// <param name="length">Specifies the address of a variable into which will be written the number of characters written into infoLog.</param>
        /// <param name="infoLog">Specifies the address of an array of characters into which will be written the info log for pipeline.</param>
        public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, out int length, StringBuilder infoLog)
        {
            if (gl._GetProgramPipelineInfoLog_int != null) gl._GetProgramPipelineInfoLog_int(pipeline, bufSize, out length, infoLog); else { length = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetProgramPipelineiv</para>
        /// </summary>
        [GLEntry("GetProgramPipelineiv", Category = "ARB")]
        public static GLDelegate.GetProgramPipelineiv _GetProgramPipelineiv = null;
        /// <summary>
        /// <para>retrieve properties of a program pipeline object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramPipelineiv.</para>
        /// <para>Fullname: GetProgramPipelineiv</para>
        /// <para>Extensions: ARB_separate_shader_objects</para>
        /// </summary>
        /// <param name="pipeline">Specifies the name of a program pipeline object whose parameter retrieve.</param>
        /// <param name="pname">Specifies the name of the parameter to retrieve.</param>
        /// <param name="params">Specifies the address of a variable into which will be written the value or values of pname for pipeline.</param>
        public static void GetProgramPipelineiv(uint pipeline, int pname, int[] param)
        {
            if (gl._GetProgramPipelineiv != null) gl._GetProgramPipelineiv(pipeline, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramResourceIndex</para>
        /// </summary>
        [GLEntry("GetProgramResourceIndex", Category = "ARB")]
        public static GLDelegate.GetProgramResourceIndex _GetProgramResourceIndex = null;
        /// <summary>
        /// <para>query the index of a named resource within a program</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramResourceIndex.</para>
        /// <para>Fullname: GetProgramResourceIndex</para>
        /// <para>Extensions: ARB_program_interface_query</para>
        /// </summary>
        /// <param name="program">The name of a program object whose resources to query.</param>
        /// <param name="programInterface">A token identifying the interface within program containing the resource named name.</param>
        /// <param name="name">The name of the resource to query the index of.</param>
        public static uint GetProgramResourceIndex(uint program, int programInterface, StringBuilder name)
        {
            if (gl._GetProgramResourceIndex != null) return gl._GetProgramResourceIndex(program, programInterface, name);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: GetProgramResourceiv</para>
        /// </summary>
        [GLEntry("GetProgramResourceiv", Category = "ARB")]
        public static GLDelegate.GetProgramResourceiv _GetProgramResourceiv = null;
        /// <summary>
        /// <para>retrieve values for multiple properties of a single active resource within a program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramResourceiv.</para>
        /// <para>Fullname: GetProgramResourceiv</para>
        /// <para>Extensions: ARB_program_interface_query</para>
        /// </summary>
        /// <param name="program">The name of a program object whose resources to query.</param>
        /// <param name="programInterface">A token identifying the interface within program containing the resource named name.</param>
        public static void GetProgramResourceiv(uint program, int programInterface, uint index, int propCount, int[] props, int bufSize, int[] length, int[] param)
        {
            if (gl._GetProgramResourceiv != null) gl._GetProgramResourceiv(program, programInterface, index, propCount, props, bufSize, length, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramResourceLocation</para>
        /// </summary>
        [GLEntry("GetProgramResourceLocation", Category = "ARB")]
        public static GLDelegate.GetProgramResourceLocation _GetProgramResourceLocation = null;
        /// <summary>
        /// <para>query the location of a named resource within a program</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramResourceLocation.</para>
        /// <para>Fullname: GetProgramResourceLocation</para>
        /// <para>Extensions: ARB_program_interface_query</para>
        /// </summary>
        /// <param name="program">The name of a program object whose resources to query.</param>
        /// <param name="programInterface">A token identifying the interface within program containing the resource named name.</param>
        /// <param name="name">The name of the resource to query the location of.</param>
        public static int GetProgramResourceLocation(uint program, int programInterface, StringBuilder name)
        {
            if (gl._GetProgramResourceLocation != null) return gl._GetProgramResourceLocation(program, programInterface, name);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: GetProgramResourceLocationIndex</para>
        /// </summary>
        [GLEntry("GetProgramResourceLocationIndex", Category = "ARB")]
        public static GLDelegate.GetProgramResourceLocationIndex _GetProgramResourceLocationIndex = null;
        /// <summary>
        /// <para>query the fragment color index of a named variable within a program</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramResourceLocationIndex.</para>
        /// <para>Fullname: GetProgramResourceLocationIndex</para>
        /// <para>Extensions: ARB_program_interface_query</para>
        /// </summary>
        /// <param name="program">The name of a program object whose resources to query.</param>
        /// <param name="programInterface">A token identifying the interface within program containing the resource named name.</param>
        /// <param name="name">The name of the resource to query the location of.</param>
        public static int GetProgramResourceLocationIndex(uint program, int programInterface, StringBuilder name)
        {
            if (gl._GetProgramResourceLocationIndex != null) return gl._GetProgramResourceLocationIndex(program, programInterface, name);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: GetProgramResourceName</para>
        /// </summary>
        [GLEntry("GetProgramResourceName", Category = "ARB")]
        public static GLDelegate.GetProgramResourceName _GetProgramResourceName = null;
        /// <summary>
        /// <para>query the name of an indexed resource within a program</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramResourceName.</para>
        /// <para>Fullname: GetProgramResourceName</para>
        /// <para>Extensions: ARB_program_interface_query</para>
        /// </summary>
        /// <param name="program">The name of a program object whose resources to query.</param>
        /// <param name="programInterface">A token identifying the interface within program containing the indexed resource.</param>
        /// <param name="index">The index of the resource within programInterface of program.</param>
        /// <param name="bufSize">The size of the character array whose address is given by name.</param>
        /// <param name="length">The address of a variable which will receive the length of the resource name.</param>
        /// <param name="name">The address of a character array into which will be written the name of the resource.</param>
        public static void GetProgramResourceName(uint program, int programInterface, uint index, int bufSize, int[] length, StringBuilder name)
        {
            if (gl._GetProgramResourceName != null) gl._GetProgramResourceName(program, programInterface, index, bufSize, length, name); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramStageiv</para>
        /// </summary>
        [GLEntry("GetProgramStageiv", Category = "ARB")]
        public static GLDelegate.GetProgramStageiv_int _GetProgramStageiv_int = null;
        /// <summary>
        /// <para>retrieve properties of a program object corresponding to a specified shader stage</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramStageiv_int.</para>
        /// <para>Fullname: GetProgramStageiv</para>
        /// <para>Extensions: ARB_shader_subroutine</para>
        /// </summary>
        /// <param name="program">Specifies the name of the program containing shader stage.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER.</param>
        /// <param name="pname">Specifies the parameter of the shader to query. pname must be GL_ACTIVE_SUBROUTINE_UNIFORMS, GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS, GL_ACTIVE_SUBROUTINES, GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, or GL_ACTIVE_SUBROUTINE_MAX_LENGTH.</param>
        /// <param name="values">Specifies the address of a variable into which the queried value or values will be placed.</param>
        public static void GetProgramStageiv(uint program, int shadertype, int pname, out int values)
        {
            if (gl._GetProgramStageiv_int != null) gl._GetProgramStageiv_int(program, shadertype, pname, out values); else { values = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetProgramStageiv</para>
        /// </summary>
        [GLEntry("GetProgramStageiv", Category = "ARB")]
        public static GLDelegate.GetProgramStageiv _GetProgramStageiv = null;
        /// <summary>
        /// <para>retrieve properties of a program object corresponding to a specified shader stage</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramStageiv.</para>
        /// <para>Fullname: GetProgramStageiv</para>
        /// <para>Extensions: ARB_shader_subroutine</para>
        /// </summary>
        /// <param name="program">Specifies the name of the program containing shader stage.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER.</param>
        /// <param name="pname">Specifies the parameter of the shader to query. pname must be GL_ACTIVE_SUBROUTINE_UNIFORMS, GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS, GL_ACTIVE_SUBROUTINES, GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, or GL_ACTIVE_SUBROUTINE_MAX_LENGTH.</param>
        /// <param name="values">Specifies the address of a variable into which the queried value or values will be placed.</param>
        public static void GetProgramStageiv(uint program, int shadertype, int pname, int[] values)
        {
            if (gl._GetProgramStageiv != null) gl._GetProgramStageiv(program, shadertype, pname, values); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramStringARB</para>
        /// </summary>
        [GLEntry("GetProgramStringARB", Category = "ARB")]
        public static GLDelegate.GetProgramString _GetProgramString = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramString.</para>
        /// <para>Fullname: GetProgramStringARB</para>
        /// <para>Extensions: ARB_vertex_program</para>
        /// </summary>
        public static void GetProgramString(int target, int pname, IntPtr str)
        {
            if (gl._GetProgramString != null) gl._GetProgramString(target, pname, str); else { }
        }
        /// <summary>
        /// <para>Fullname: GetQueryIndexediv</para>
        /// </summary>
        [GLEntry("GetQueryIndexediv", Category = "ARB")]
        public static GLDelegate.GetQueryIndexediv _GetQueryIndexediv = null;
        /// <summary>
        /// <para>return parameters of an indexed query object target</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetQueryIndexediv.</para>
        /// <para>Fullname: GetQueryIndexediv</para>
        /// <para>Extensions: ARB_transform_feedback3</para>
        /// </summary>
        /// <param name="target">Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVEGL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP.</param>
        /// <param name="index">Specifies the index of the query object target.</param>
        /// <param name="pname">Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetQueryIndexediv(int target, uint index, int pname, int[] param)
        {
            if (gl._GetQueryIndexediv != null) gl._GetQueryIndexediv(target, index, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetQueryObjecti64v</para>
        /// </summary>
        [GLEntry("GetQueryObjecti64v", Category = "ARB", Alias = "GetQueryObjecti64vEXT ")]
        public static GLDelegate.GetQueryObjecti64v _GetQueryObjecti64v = null;
        public static GLDelegate.GetQueryObjecti64v GetQueryObjecti64vEXT = GetQueryObjecti64v;
        /// <summary>
        /// <para>return parameters of a query object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetQueryObjecti64v.</para>
        /// <para>Fullname: GetQueryObjecti64v</para>
        /// <para>Aliases: GetQueryObjecti64vEXT, </para>
        /// <para>Extensions: ARB_timer_query EXT_timer_query</para>
        /// </summary>
        /// <param name="id">Specifies the name of a query object.</param>
        /// <param name="pname">Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetQueryObjecti64v(uint id, int pname, long[] param)
        {
            if (gl._GetQueryObjecti64v != null) gl._GetQueryObjecti64v(id, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetQueryObjectui64v</para>
        /// </summary>
        [GLEntry("GetQueryObjectui64v", Category = "ARB", Alias = "GetQueryObjectui64vEXT ")]
        public static GLDelegate.GetQueryObjectui64v _GetQueryObjectui64v = null;
        public static GLDelegate.GetQueryObjectui64v GetQueryObjectui64vEXT = GetQueryObjectui64v;
        /// <summary>
        /// <para>return parameters of a query object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetQueryObjectui64v.</para>
        /// <para>Fullname: GetQueryObjectui64v</para>
        /// <para>Aliases: GetQueryObjectui64vEXT, </para>
        /// <para>Extensions: ARB_timer_query EXT_timer_query</para>
        /// </summary>
        /// <param name="id">Specifies the name of a query object.</param>
        /// <param name="pname">Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetQueryObjectui64v(uint id, int pname, ulong[] param)
        {
            if (gl._GetQueryObjectui64v != null) gl._GetQueryObjectui64v(id, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetRenderbufferParameteriv</para>
        /// </summary>
        [GLEntry("GetRenderbufferParameteriv", Category = "ARB", Alias = "GetRenderbufferParameterivEXT ")]
        public static GLDelegate.GetRenderbufferParameteriv _GetRenderbufferParameteriv = null;
        public static GLDelegate.GetRenderbufferParameteriv GetRenderbufferParameterivEXT = GetRenderbufferParameteriv;
        /// <summary>
        /// <para>retrieve information about a bound renderbuffer object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetRenderbufferParameteriv.</para>
        /// <para>Fullname: GetRenderbufferParameteriv</para>
        /// <para>Aliases: GetRenderbufferParameterivEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="target">Specifies the target of the query operation. target must be GL_RENDERBUFFER.</param>
        /// <param name="pname">Specifies the parameter whose value to retrieve from the renderbuffer bound to target.</param>
        /// <param name="params">Specifies the address of an array to receive the value of the queried parameter.</param>
        public static void GetRenderbufferParameteriv(int target, int pname, int[] param)
        {
            if (gl._GetRenderbufferParameteriv != null) gl._GetRenderbufferParameteriv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetSamplerParameterfv</para>
        /// </summary>
        [GLEntry("GetSamplerParameterfv", Category = "ARB")]
        public static GLDelegate.GetSamplerParameterfv _GetSamplerParameterfv = null;
        /// <summary>
        /// <para>return sampler parameter values</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetSamplerParameterfv.</para>
        /// <para>Fullname: GetSamplerParameterfv</para>
        /// <para>Extensions: ARB_sampler_objects</para>
        /// </summary>
        /// <param name="sampler">Specifies name of the sampler object from which to retrieve parameters.</param>
        /// <param name="pname">Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.</param>
        /// <param name="params">Returns the sampler parameters.</param>
        public static void GetSamplerParameterfv(uint sampler, int pname, float[] param)
        {
            if (gl._GetSamplerParameterfv != null) gl._GetSamplerParameterfv(sampler, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetSamplerParameterIiv</para>
        /// </summary>
        [GLEntry("GetSamplerParameterIiv", Category = "ARB")]
        public static GLDelegate.GetSamplerParameterIiv _GetSamplerParameterIiv = null;
        /// <summary>
        /// <para>return sampler parameter values</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetSamplerParameterIiv.</para>
        /// <para>Fullname: GetSamplerParameterIiv</para>
        /// <para>Extensions: ARB_sampler_objects</para>
        /// </summary>
        /// <param name="sampler">Specifies name of the sampler object from which to retrieve parameters.</param>
        /// <param name="pname">Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.</param>
        /// <param name="params">Returns the sampler parameters.</param>
        public static void GetSamplerParameterIiv(uint sampler, int pname, int[] param)
        {
            if (gl._GetSamplerParameterIiv != null) gl._GetSamplerParameterIiv(sampler, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetSamplerParameterIuiv</para>
        /// </summary>
        [GLEntry("GetSamplerParameterIuiv", Category = "ARB")]
        public static GLDelegate.GetSamplerParameterIuiv _GetSamplerParameterIuiv = null;
        /// <summary>
        /// <para>return sampler parameter values</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetSamplerParameterIuiv.</para>
        /// <para>Fullname: GetSamplerParameterIuiv</para>
        /// <para>Extensions: ARB_sampler_objects</para>
        /// </summary>
        /// <param name="sampler">Specifies name of the sampler object from which to retrieve parameters.</param>
        /// <param name="pname">Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.</param>
        /// <param name="params">Returns the sampler parameters.</param>
        public static void GetSamplerParameterIuiv(uint sampler, int pname, uint[] param)
        {
            if (gl._GetSamplerParameterIuiv != null) gl._GetSamplerParameterIuiv(sampler, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetSamplerParameteriv</para>
        /// </summary>
        [GLEntry("GetSamplerParameteriv", Category = "ARB")]
        public static GLDelegate.GetSamplerParameteriv _GetSamplerParameteriv = null;
        /// <summary>
        /// <para>return sampler parameter values</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetSamplerParameteriv.</para>
        /// <para>Fullname: GetSamplerParameteriv</para>
        /// <para>Extensions: ARB_sampler_objects</para>
        /// </summary>
        /// <param name="sampler">Specifies name of the sampler object from which to retrieve parameters.</param>
        /// <param name="pname">Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are accepted.</param>
        /// <param name="params">Returns the sampler parameters.</param>
        public static void GetSamplerParameteriv(uint sampler, int pname, int[] param)
        {
            if (gl._GetSamplerParameteriv != null) gl._GetSamplerParameteriv(sampler, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetShaderPrecisionFormat</para>
        /// </summary>
        [GLEntry("GetShaderPrecisionFormat", Category = "ARB")]
        public static GLDelegate.GetShaderPrecisionFormat _GetShaderPrecisionFormat = null;
        /// <summary>
        /// <para>retrieve the range and precision for numeric formats supported by the shader compiler</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetShaderPrecisionFormat.</para>
        /// <para>Fullname: GetShaderPrecisionFormat</para>
        /// <para>Extensions: ARB_ES2_compatibility</para>
        /// </summary>
        /// <param name="shaderType">Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER.</param>
        /// <param name="precisionType">Specifies the numeric format whose precision and range to query.</param>
        /// <param name="range">Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned.</param>
        /// <param name="precision">Specifies the address of an integer into which the numeric precision of the implementation is written.</param>
        public static void GetShaderPrecisionFormat(int shadertype, int precisiontype, int[] range, int[] precision)
        {
            if (gl._GetShaderPrecisionFormat != null) gl._GetShaderPrecisionFormat(shadertype, precisiontype, range, precision); else { }
        }
        /// <summary>
        /// <para>Fullname: GetSubroutineIndex</para>
        /// </summary>
        [GLEntry("GetSubroutineIndex", Category = "ARB")]
        public static GLDelegate.GetSubroutineIndex _GetSubroutineIndex = null;
        /// <summary>
        /// <para>retrieve the index of a subroutine uniform of a given shader stage within a program</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetSubroutineIndex.</para>
        /// <para>Fullname: GetSubroutineIndex</para>
        /// <para>Extensions: ARB_shader_subroutine</para>
        /// </summary>
        /// <param name="program">Specifies the name of the program containing shader stage.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER.</param>
        /// <param name="name">Specifies the name of the subroutine uniform whose index to query.</param>
        public static uint GetSubroutineIndex(uint program, int shadertype, StringBuilder name)
        {
            if (gl._GetSubroutineIndex != null) return gl._GetSubroutineIndex(program, shadertype, name);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: GetSubroutineUniformLocation</para>
        /// </summary>
        [GLEntry("GetSubroutineUniformLocation", Category = "ARB")]
        public static GLDelegate.GetSubroutineUniformLocation _GetSubroutineUniformLocation = null;
        /// <summary>
        /// <para>retrieve the location of a subroutine uniform of a given shader stage within a program</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetSubroutineUniformLocation.</para>
        /// <para>Fullname: GetSubroutineUniformLocation</para>
        /// <para>Extensions: ARB_shader_subroutine</para>
        /// </summary>
        /// <param name="program">Specifies the name of the program containing shader stage.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER.</param>
        /// <param name="name">Specifies the name of the subroutine uniform whose index to query.</param>
        public static int GetSubroutineUniformLocation(uint program, int shadertype, StringBuilder name)
        {
            if (gl._GetSubroutineUniformLocation != null) return gl._GetSubroutineUniformLocation(program, shadertype, name);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: GetSynciv</para>
        /// </summary>
        [GLEntry("GetSynciv", Category = "ARB")]
        public static GLDelegate.GetSynciv_int _GetSynciv_int = null;
        /// <summary>
        /// <para>query the properties of a sync object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetSynciv_int.</para>
        /// <para>Fullname: GetSynciv</para>
        /// <para>Extensions: ARB_sync</para>
        /// </summary>
        /// <param name="sync">Specifies the sync object whose properties to query.</param>
        /// <param name="pname">Specifies the parameter whose value to retrieve from the sync object specified in sync.</param>
        /// <param name="bufSize">Specifies the size of the buffer whose address is given in values.</param>
        /// <param name="length">Specifies the address of an variable to receive the number of integers placed in values.</param>
        /// <param name="values">Specifies the address of an array to receive the values of the queried parameter.</param>
        public static void GetSynciv(IntPtr sync, int pname, int bufSize, out int length, int[] values)
        {
            if (gl._GetSynciv_int != null) gl._GetSynciv_int(sync, pname, bufSize, out length, values); else { length = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetSynciv</para>
        /// </summary>
        [GLEntry("GetSynciv", Category = "ARB")]
        public static GLDelegate.GetSynciv _GetSynciv = null;
        /// <summary>
        /// <para>query the properties of a sync object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetSynciv.</para>
        /// <para>Fullname: GetSynciv</para>
        /// <para>Extensions: ARB_sync</para>
        /// </summary>
        /// <param name="sync">Specifies the sync object whose properties to query.</param>
        /// <param name="pname">Specifies the parameter whose value to retrieve from the sync object specified in sync.</param>
        /// <param name="bufSize">Specifies the size of the buffer whose address is given in values.</param>
        /// <param name="length">Specifies the address of an variable to receive the number of integers placed in values.</param>
        /// <param name="values">Specifies the address of an array to receive the values of the queried parameter.</param>
        public static void GetSynciv(IntPtr sync, int pname, int bufSize, int[] length, int[] values)
        {
            if (gl._GetSynciv != null) gl._GetSynciv(sync, pname, bufSize, length, values); else { }
        }
        /// <summary>
        /// <para>Fullname: GetUniformBlockIndex</para>
        /// </summary>
        [GLEntry("GetUniformBlockIndex", Category = "ARB")]
        public static GLDelegate.GetUniformBlockIndex _GetUniformBlockIndex = null;
        /// <summary>
        /// <para>retrieve the index of a named uniform block</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetUniformBlockIndex.</para>
        /// <para>Fullname: GetUniformBlockIndex</para>
        /// <para>Extensions: ARB_uniform_buffer_object</para>
        /// </summary>
        /// <param name="program">Specifies the name of a program containing the uniform block.</param>
        /// <param name="uniformBlockName">Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve.</param>
        public static uint GetUniformBlockIndex(uint program, StringBuilder uniformBlockName)
        {
            if (gl._GetUniformBlockIndex != null) return gl._GetUniformBlockIndex(program, uniformBlockName);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: GetUniformdv</para>
        /// </summary>
        [GLEntry("GetUniformdv", Category = "ARB")]
        public static GLDelegate.GetUniformdv _GetUniformdv = null;
        /// <summary>
        /// <para>Returns the value of a uniform variable</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetUniformdv.</para>
        /// <para>Fullname: GetUniformdv</para>
        /// <para>Extensions: ARB_gpu_shader_fp64</para>
        /// </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="location">Specifies the location of the uniform variable to be queried.</param>
        /// <param name="params">Returns the value of the specified uniform variable.</param>
        public static void GetUniformdv(uint program, int location, double[] param)
        {
            if (gl._GetUniformdv != null) gl._GetUniformdv(program, location, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetUniformIndices</para>
        /// </summary>
        [GLEntry("GetUniformIndices", Category = "ARB")]
        public static GLDelegate.GetUniformIndices _GetUniformIndices = null;
        /// <summary>
        /// <para>retrieve the index of a named uniform block</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetUniformIndices.</para>
        /// <para>Fullname: GetUniformIndices</para>
        /// <para>Extensions: ARB_uniform_buffer_object</para>
        /// </summary>
        /// <param name="program">Specifies the name of a program containing uniforms whose indices to query.</param>
        /// <param name="uniformCount">Specifies the number of uniforms whose indices to query.</param>
        /// <param name="uniformNames">Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.</param>
        /// <param name="uniformIndices">Specifies the address of an array that will receive the indices of the uniforms.</param>
        public static void GetUniformIndices(uint program, int uniformCount, string[] uniformNames, uint[] uniformIndices)
        {
            if (gl._GetUniformIndices != null) gl._GetUniformIndices(program, uniformCount, uniformNames, uniformIndices); else { }
        }
        /// <summary>
        /// <para>Fullname: GetUniformSubroutineuiv</para>
        /// </summary>
        [GLEntry("GetUniformSubroutineuiv", Category = "ARB")]
        public static GLDelegate.GetUniformSubroutineuiv_uint _GetUniformSubroutineuiv_uint = null;
        /// <summary>
        /// <para>retrieve the value of a subroutine uniform of a given shader stage of the current program</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetUniformSubroutineuiv_uint.</para>
        /// <para>Fullname: GetUniformSubroutineuiv</para>
        /// <para>Extensions: ARB_shader_subroutine</para>
        /// </summary>
        /// <param name="shadertype">Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER.</param>
        /// <param name="location">Specifies the location of the subroutine uniform.</param>
        /// <param name="values">Specifies the address of a variable to receive the value or values of the subroutine uniform.</param>
        public static void GetUniformSubroutineuiv(int shadertype, int location, out uint param)
        {
            if (gl._GetUniformSubroutineuiv_uint != null) gl._GetUniformSubroutineuiv_uint(shadertype, location, out param); else { param = new uint(); }
        }
        /// <summary>
        /// <para>Fullname: GetUniformSubroutineuiv</para>
        /// </summary>
        [GLEntry("GetUniformSubroutineuiv", Category = "ARB")]
        public static GLDelegate.GetUniformSubroutineuiv _GetUniformSubroutineuiv = null;
        /// <summary>
        /// <para>retrieve the value of a subroutine uniform of a given shader stage of the current program</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetUniformSubroutineuiv.</para>
        /// <para>Fullname: GetUniformSubroutineuiv</para>
        /// <para>Extensions: ARB_shader_subroutine</para>
        /// </summary>
        /// <param name="shadertype">Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER.</param>
        /// <param name="location">Specifies the location of the subroutine uniform.</param>
        /// <param name="values">Specifies the address of a variable to receive the value or values of the subroutine uniform.</param>
        public static void GetUniformSubroutineuiv(int shadertype, int location, uint[] param)
        {
            if (gl._GetUniformSubroutineuiv != null) gl._GetUniformSubroutineuiv(shadertype, location, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVertexAttribLdv</para>
        /// </summary>
        [GLEntry("GetVertexAttribLdv", Category = "ARB", Alias = "GetVertexAttribLdvEXT ")]
        public static GLDelegate.GetVertexAttribLdv _GetVertexAttribLdv = null;
        public static GLDelegate.GetVertexAttribLdv GetVertexAttribLdvEXT = GetVertexAttribLdv;
        /// <summary>
        /// <para>Return a generic vertex attribute parameter</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVertexAttribLdv.</para>
        /// <para>Fullname: GetVertexAttribLdv</para>
        /// <para>Aliases: GetVertexAttribLdvEXT, </para>
        /// <para>Extensions: ARB_vertex_attrib_64bit EXT_vertex_attrib_64bit</para>
        /// </summary>
        /// <param name="index">Specifies the generic vertex attribute parameter to be queried.</param>
        /// <param name="pname">Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.</param>
        /// <param name="params">Returns the requested data.</param>
        public static void GetVertexAttribLdv(uint index, int pname, double[] param)
        {
            if (gl._GetVertexAttribLdv != null) gl._GetVertexAttribLdv(index, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: InvalidateBufferData</para>
        /// </summary>
        [GLEntry("InvalidateBufferData", Category = "ARB")]
        public static GLDelegate.InvalidateBufferData _InvalidateBufferData = null;
        /// <summary>
        /// <para>invalidate the content of a buffer object's data store</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _InvalidateBufferData.</para>
        /// <para>Fullname: InvalidateBufferData</para>
        /// <para>Extensions: ARB_invalidate_subdata</para>
        /// </summary>
        /// <param name="buffer">The name of a buffer object whose data store to invalidate.</param>
        public static void InvalidateBufferData(uint buffer)
        {
            if (gl._InvalidateBufferData != null) gl._InvalidateBufferData(buffer); else { }
        }
        /// <summary>
        /// <para>Fullname: InvalidateBufferSubData</para>
        /// </summary>
        [GLEntry("InvalidateBufferSubData", Category = "ARB")]
        public static GLDelegate.InvalidateBufferSubData _InvalidateBufferSubData = null;
        /// <summary>
        /// <para>invalidate a region of a buffer object's data store</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _InvalidateBufferSubData.</para>
        /// <para>Fullname: InvalidateBufferSubData</para>
        /// <para>Extensions: ARB_invalidate_subdata</para>
        /// </summary>
        /// <param name="buffer">The name of a buffer object, a subrange of whose data store to invalidate.</param>
        /// <param name="offset">The offset within the buffer's data store of the start of the range to be invalidated.</param>
        /// <param name="length">The length of the range within the buffer's data store to be invalidated.</param>
        public static void InvalidateBufferSubData(uint buffer, int offset, int length)
        {
            if (gl._InvalidateBufferSubData != null) gl._InvalidateBufferSubData(buffer, offset, length); else { }
        }
        /// <summary>
        /// <para>Fullname: InvalidateFramebuffer</para>
        /// </summary>
        [GLEntry("InvalidateFramebuffer", Category = "ARB")]
        public static GLDelegate.InvalidateFramebuffer _InvalidateFramebuffer = null;
        /// <summary>
        /// <para>invalidate the content some or all of a framebuffer object's attachments</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _InvalidateFramebuffer.</para>
        /// <para>Fullname: InvalidateFramebuffer</para>
        /// <para>Extensions: ARB_invalidate_subdata</para>
        /// </summary>
        /// <param name="target">The target to which the framebuffer is attached. target must be GL_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER, or GL_READ_FRAMEBUFFER.</param>
        /// <param name="numAttachments">The number of entries in the attachments array.</param>
        /// <param name="attachments">The address of an array identifying the attachments to be invalidated.</param>
        public static void InvalidateFramebuffer(int target, int numAttachments, int[] attachments)
        {
            if (gl._InvalidateFramebuffer != null) gl._InvalidateFramebuffer(target, numAttachments, attachments); else { }
        }
        /// <summary>
        /// <para>Fullname: InvalidateSubFramebuffer</para>
        /// </summary>
        [GLEntry("InvalidateSubFramebuffer", Category = "ARB")]
        public static GLDelegate.InvalidateSubFramebuffer _InvalidateSubFramebuffer = null;
        /// <summary>
        /// <para>invalidate the content of a region of some or all of a framebuffer object's attachments</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _InvalidateSubFramebuffer.</para>
        /// <para>Fullname: InvalidateSubFramebuffer</para>
        /// <para>Extensions: ARB_invalidate_subdata</para>
        /// </summary>
        /// <param name="target">The target to which the framebuffer is attached. target must be GL_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER, or GL_READ_FRAMEBUFFER.</param>
        /// <param name="numAttachments">The number of entries in the attachments array.</param>
        /// <param name="attachments">The address of an array identifying the attachments to be invalidated.</param>
        /// <param name="x">The X offset of the region to be invalidated.</param>
        /// <param name="y">The Y offset of the region to be invalidated.</param>
        /// <param name="width">The width of the region to be invalidated.</param>
        /// <param name="height">The height of the region to be invalidated.</param>
        public static void InvalidateSubFramebuffer(int target, int numAttachments, int[] attachments, int x, int y, int width, int height)
        {
            if (gl._InvalidateSubFramebuffer != null) gl._InvalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height); else { }
        }
        /// <summary>
        /// <para>Fullname: InvalidateTexImage</para>
        /// </summary>
        [GLEntry("InvalidateTexImage", Category = "ARB")]
        public static GLDelegate.InvalidateTexImage _InvalidateTexImage = null;
        /// <summary>
        /// <para>invalidate the entirety a texture image</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _InvalidateTexImage.</para>
        /// <para>Fullname: InvalidateTexImage</para>
        /// <para>Extensions: ARB_invalidate_subdata</para>
        /// </summary>
        /// <param name="texture">The name of a texture object to invalidate.</param>
        /// <param name="level">The level of detail of the texture object to invalidate.</param>
        public static void InvalidateTexImage(uint texture, int level)
        {
            if (gl._InvalidateTexImage != null) gl._InvalidateTexImage(texture, level); else { }
        }
        /// <summary>
        /// <para>Fullname: InvalidateTexSubImage</para>
        /// </summary>
        [GLEntry("InvalidateTexSubImage", Category = "ARB")]
        public static GLDelegate.InvalidateTexSubImage _InvalidateTexSubImage = null;
        /// <summary>
        /// <para>invalidate a region of a texture image</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _InvalidateTexSubImage.</para>
        /// <para>Fullname: InvalidateTexSubImage</para>
        /// <para>Extensions: ARB_invalidate_subdata</para>
        /// </summary>
        /// <param name="texture">The name of a texture object a subregion of which to invalidate.</param>
        /// <param name="level">The level of detail of the texture object within which the region resides.</param>
        /// <param name="xoffset">The X offset of the region to be invalidated.</param>
        /// <param name="yoffset">The Y offset of the region to be invalidated.</param>
        /// <param name="zoffset">The Z offset of the region to be invalidated.</param>
        /// <param name="width">The width of the region to be invalidated.</param>
        /// <param name="height">The height of the region to be invalidated.</param>
        /// <param name="depth">The depth of the region to be invalidated.</param>
        public static void InvalidateTexSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth)
        {
            if (gl._InvalidateTexSubImage != null) gl._InvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth); else { }
        }
        /// <summary>
        /// <para>Fullname: IsFramebuffer</para>
        /// </summary>
        [GLEntry("IsFramebuffer", Category = "ARB", Alias = "IsFramebufferEXT ")]
        public static GLDelegate.IsFramebuffer _IsFramebuffer = null;
        public static GLDelegate.IsFramebuffer IsFramebufferEXT = IsFramebuffer;
        /// <summary>
        /// <para>determine if a name corresponds to a framebuffer object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsFramebuffer.</para>
        /// <para>Fullname: IsFramebuffer</para>
        /// <para>Aliases: IsFramebufferEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="framebuffer">Specifies a value that may be the name of a framebuffer object.</param>
        public static bool IsFramebuffer(uint framebuffer)
        {
            if (gl._IsFramebuffer != null) return gl._IsFramebuffer(framebuffer);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: IsNamedStringARB</para>
        /// </summary>
        [GLEntry("IsNamedStringARB", Category = "ARB")]
        public static GLDelegate.IsNamedString _IsNamedString = null;
        /// <summary>
        /// <para>This extension introduces a #include GLSL directive to allow reusing the same shader text in multiple shaders and defines the semantics and syntax of the names allowed in #include directives. It also defines API mechanisms to define the named string backing a #include. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsNamedString.</para>
        /// <para>Fullname: IsNamedStringARB</para>
        /// <para>Extensions: ARB_shading_language_include</para>
        /// </summary>
        public static bool IsNamedString(int namelen, StringBuilder name)
        {
            if (gl._IsNamedString != null) return gl._IsNamedString(namelen, name);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: IsProgramPipeline</para>
        /// </summary>
        [GLEntry("IsProgramPipeline", Category = "ARB")]
        public static GLDelegate.IsProgramPipeline _IsProgramPipeline = null;
        /// <summary>
        /// <para>determine if a name corresponds to a program pipeline object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsProgramPipeline.</para>
        /// <para>Fullname: IsProgramPipeline</para>
        /// <para>Extensions: ARB_separate_shader_objects</para>
        /// </summary>
        /// <param name="pipeline">Specifies a value that may be the name of a program pipeline object.</param>
        public static bool IsProgramPipeline(uint pipeline)
        {
            if (gl._IsProgramPipeline != null) return gl._IsProgramPipeline(pipeline);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: IsRenderbuffer</para>
        /// </summary>
        [GLEntry("IsRenderbuffer", Category = "ARB", Alias = "IsRenderbufferEXT ")]
        public static GLDelegate.IsRenderbuffer _IsRenderbuffer = null;
        public static GLDelegate.IsRenderbuffer IsRenderbufferEXT = IsRenderbuffer;
        /// <summary>
        /// <para>determine if a name corresponds to a renderbuffer object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsRenderbuffer.</para>
        /// <para>Fullname: IsRenderbuffer</para>
        /// <para>Aliases: IsRenderbufferEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="renderbuffer">Specifies a value that may be the name of a renderbuffer object.</param>
        public static bool IsRenderbuffer(uint renderbuffer)
        {
            if (gl._IsRenderbuffer != null) return gl._IsRenderbuffer(renderbuffer);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: IsSampler</para>
        /// </summary>
        [GLEntry("IsSampler", Category = "ARB")]
        public static GLDelegate.IsSampler _IsSampler = null;
        /// <summary>
        /// <para>determine if a name corresponds to a sampler object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsSampler.</para>
        /// <para>Fullname: IsSampler</para>
        /// <para>Extensions: ARB_sampler_objects</para>
        /// </summary>
        /// <param name="id">Specifies a value that may be the name of a sampler object.</param>
        public static bool IsSampler(uint sampler)
        {
            if (gl._IsSampler != null) return gl._IsSampler(sampler);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: IsSync</para>
        /// </summary>
        [GLEntry("IsSync", Category = "ARB")]
        public static GLDelegate.IsSync _IsSync = null;
        /// <summary>
        /// <para>determine if a name corresponds to a sync object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsSync.</para>
        /// <para>Fullname: IsSync</para>
        /// <para>Extensions: ARB_sync</para>
        /// </summary>
        /// <param name="sync">Specifies a value that may be the name of a sync object.</param>
        public static bool IsSync(IntPtr sync)
        {
            if (gl._IsSync != null) return gl._IsSync(sync);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: IsTransformFeedback</para>
        /// </summary>
        [GLEntry("IsTransformFeedback", Category = "ARB", Alias = "IsTransformFeedbackNV ")]
        public static GLDelegate.IsTransformFeedback _IsTransformFeedback = null;
        public static GLDelegate.IsTransformFeedback IsTransformFeedbackNV = IsTransformFeedback;
        /// <summary>
        /// <para>determine if a name corresponds to a transform feedback object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsTransformFeedback.</para>
        /// <para>Fullname: IsTransformFeedback</para>
        /// <para>Aliases: IsTransformFeedbackNV, </para>
        /// <para>Extensions: ARB_transform_feedback2 NV_transform_feedback2</para>
        /// </summary>
        /// <param name="id">Specifies a value that may be the name of a transform feedback object.</param>
        public static bool IsTransformFeedback(uint id)
        {
            if (gl._IsTransformFeedback != null) return gl._IsTransformFeedback(id);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: IsVertexArray</para>
        /// </summary>
        [GLEntry("IsVertexArray", Category = "ARB", Alias = "IsVertexArrayAPPLE ")]
        public static GLDelegate.IsVertexArray _IsVertexArray = null;
        public static GLDelegate.IsVertexArray IsVertexArrayAPPLE = IsVertexArray;
        /// <summary>
        /// <para>determine if a name corresponds to a vertex array object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsVertexArray.</para>
        /// <para>Fullname: IsVertexArray</para>
        /// <para>Aliases: IsVertexArrayAPPLE, </para>
        /// <para>Extensions: ARB_vertex_array_object APPLE_vertex_array_object</para>
        /// </summary>
        /// <param name="array">Specifies a value that may be the name of a vertex array object.</param>
        public static bool IsVertexArray(uint array)
        {
            if (gl._IsVertexArray != null) return gl._IsVertexArray(array);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: MapBufferRange</para>
        /// </summary>
        [GLEntry("MapBufferRange", Category = "ARB")]
        public static GLDelegate.MapBufferRange _MapBufferRange = null;
        /// <summary>
        /// <para>map a section of a buffer object's data store</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MapBufferRange.</para>
        /// <para>Fullname: MapBufferRange</para>
        /// <para>Extensions: ARB_map_buffer_range</para>
        /// </summary>
        /// <param name="target">Specifies a binding to which the target buffer is bound.</param>
        /// <param name="offset">Specifies a the starting offset within the buffer of the range to be mapped.</param>
        /// <param name="length">Specifies a length of the range to be mapped.</param>
        /// <param name="access">Specifies a combination of access flags indicating the desired access to the range.</param>
        public static IntPtr MapBufferRange(int target, int offset, int length, int access)
        {
            if (gl._MapBufferRange != null) return gl._MapBufferRange(target, offset, length, access);
            else { return (IntPtr)0; }
        }
        /// <summary>
        /// <para>Fullname: MatrixIndexPointerARB</para>
        /// </summary>
        [GLEntry("MatrixIndexPointerARB", Category = "ARB")]
        public static GLDelegate.MatrixIndexPointer _MatrixIndexPointer = null;
        /// <summary>
        /// <para>This extension extends the abilities of ARB_vertex_blend to include a palette of modelview matrices.  The n vertex units use a palette of m modelview matrices.  (Where n and m are constrained to implementation defined maxima.)  Each vertex has a set of n indices into the palette, and a corresponding set of n weights. Matrix indices can be changed for each vertex (between Begin and End).  When this extension is utilized, the enabled units transform each vertex by the modelview matrices specified by the vertices' respective indices.  These results are subsequently scaled by the weights of the respective units and then summed to create the eyespace vertex.  A similar procedure is followed for normals.  Normals, however, are transformed by the inverse transpose of the modelview matrix.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixIndexPointer.</para>
        /// <para>Fullname: MatrixIndexPointerARB</para>
        /// <para>Extensions: ARB_matrix_palette</para>
        /// </summary>
        public static void MatrixIndexPointer(int size, int type, int stride, IntPtr pointer)
        {
            if (gl._MatrixIndexPointer != null) gl._MatrixIndexPointer(size, type, stride, pointer); else { }
        }
        /// <summary>
        /// <para>This extension extends the abilities of ARB_vertex_blend to include a palette of modelview matrices.  The n vertex units use a palette of m modelview matrices.  (Where n and m are constrained to implementation defined maxima.)  Each vertex has a set of n indices into the palette, and a corresponding set of n weights. Matrix indices can be changed for each vertex (between Begin and End).  When this extension is utilized, the enabled units transform each vertex by the modelview matrices specified by the vertices' respective indices.  These results are subsequently scaled by the weights of the respective units and then summed to create the eyespace vertex.  A similar procedure is followed for normals.  Normals, however, are transformed by the inverse transpose of the modelview matrix.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixIndexPointer.</para>
        /// <para>Fullname: MatrixIndexPointerARB</para>
        /// <para>Extensions: ARB_matrix_palette</para>
        /// </summary>
        public static void MatrixIndexPointer(int size, int type, int stride, Array pointer)
        {
            GCHandle h = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try { if (gl._MatrixIndexPointer != null) gl._MatrixIndexPointer(size, type, stride, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: MatrixIndexubvARB</para>
        /// </summary>
        [GLEntry("MatrixIndexubvARB", Category = "ARB")]
        public static GLDelegate.MatrixIndexubv _MatrixIndexubv = null;
        /// <summary>
        /// <para>This extension extends the abilities of ARB_vertex_blend to include a palette of modelview matrices.  The n vertex units use a palette of m modelview matrices.  (Where n and m are constrained to implementation defined maxima.)  Each vertex has a set of n indices into the palette, and a corresponding set of n weights. Matrix indices can be changed for each vertex (between Begin and End).  When this extension is utilized, the enabled units transform each vertex by the modelview matrices specified by the vertices' respective indices.  These results are subsequently scaled by the weights of the respective units and then summed to create the eyespace vertex.  A similar procedure is followed for normals.  Normals, however, are transformed by the inverse transpose of the modelview matrix.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixIndexubv.</para>
        /// <para>Fullname: MatrixIndexubvARB</para>
        /// <para>Extensions: ARB_matrix_palette</para>
        /// </summary>
        public static void MatrixIndexubv(int size, byte[] indices)
        {
            if (gl._MatrixIndexubv != null) gl._MatrixIndexubv(size, indices); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixIndexuivARB</para>
        /// </summary>
        [GLEntry("MatrixIndexuivARB", Category = "ARB")]
        public static GLDelegate.MatrixIndexuiv _MatrixIndexuiv = null;
        /// <summary>
        /// <para>This extension extends the abilities of ARB_vertex_blend to include a palette of modelview matrices.  The n vertex units use a palette of m modelview matrices.  (Where n and m are constrained to implementation defined maxima.)  Each vertex has a set of n indices into the palette, and a corresponding set of n weights. Matrix indices can be changed for each vertex (between Begin and End).  When this extension is utilized, the enabled units transform each vertex by the modelview matrices specified by the vertices' respective indices.  These results are subsequently scaled by the weights of the respective units and then summed to create the eyespace vertex.  A similar procedure is followed for normals.  Normals, however, are transformed by the inverse transpose of the modelview matrix.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixIndexuiv.</para>
        /// <para>Fullname: MatrixIndexuivARB</para>
        /// <para>Extensions: ARB_matrix_palette</para>
        /// </summary>
        public static void MatrixIndexuiv(int size, uint[] indices)
        {
            if (gl._MatrixIndexuiv != null) gl._MatrixIndexuiv(size, indices); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixIndexusvARB</para>
        /// </summary>
        [GLEntry("MatrixIndexusvARB", Category = "ARB")]
        public static GLDelegate.MatrixIndexusv _MatrixIndexusv = null;
        /// <summary>
        /// <para>This extension extends the abilities of ARB_vertex_blend to include a palette of modelview matrices.  The n vertex units use a palette of m modelview matrices.  (Where n and m are constrained to implementation defined maxima.)  Each vertex has a set of n indices into the palette, and a corresponding set of n weights. Matrix indices can be changed for each vertex (between Begin and End).  When this extension is utilized, the enabled units transform each vertex by the modelview matrices specified by the vertices' respective indices.  These results are subsequently scaled by the weights of the respective units and then summed to create the eyespace vertex.  A similar procedure is followed for normals.  Normals, however, are transformed by the inverse transpose of the modelview matrix.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixIndexusv.</para>
        /// <para>Fullname: MatrixIndexusvARB</para>
        /// <para>Extensions: ARB_matrix_palette</para>
        /// </summary>
        public static void MatrixIndexusv(int size, ushort[] indices)
        {
            if (gl._MatrixIndexusv != null) gl._MatrixIndexusv(size, indices); else { }
        }
        /// <summary>
        /// <para>Fullname: MemoryBarrier</para>
        /// </summary>
        [GLEntry("MemoryBarrier", Category = "ARB", Alias = "MemoryBarrierEXT ")]
        public static GLDelegate.MemoryBarrier _MemoryBarrier = null;
        public static GLDelegate.MemoryBarrier MemoryBarrierEXT = MemoryBarrier;
        /// <summary>
        /// <para>defines a barrier ordering memory transactions</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MemoryBarrier.</para>
        /// <para>Fullname: MemoryBarrier</para>
        /// <para>Aliases: MemoryBarrierEXT, </para>
        /// <para>Extensions: ARB_shader_image_load_store EXT_shader_image_load_store</para>
        /// </summary>
        /// <param name="barriers">Specifies the barriers to insert. Must be a bitwise combination of GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT, GL_ELEMENT_ARRAY_BARRIER_BIT, GL_UNIFORM_BARRIER_BIT, GL_TEXTURE_FETCH_BARRIER_BIT, GL_SHADER_IMAGE_ACCESS_BARRIER_BIT, GL_COMMAND_BARRIER_BIT, GL_PIXEL_BUFFER_BARRIER_BIT, GL_TEXTURE_UPDATE_BARRIER_BIT, GL_BUFFER_UPDATE_BARRIER_BIT, GL_FRAMEBUFFER_BARRIER_BIT, GL_TRANSFORM_FEEDBACK_BARRIER_BIT, GL_ATOMIC_COUNTER_BARRIER_BIT, or GL_SHADER_STORAGE_BARRIER_BIT. If the special value GL_ALL_BARRIER_BITS is specified, all supported barriers will be inserted.</param>
        public static void MemoryBarrier(int barriers)
        {
            if (gl._MemoryBarrier != null) gl._MemoryBarrier(barriers); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiDrawArraysIndirect</para>
        /// </summary>
        [GLEntry("MultiDrawArraysIndirect", Category = "ARB", Alias = "MultiDrawArraysIndirectAMD ")]
        public static GLDelegate.MultiDrawArraysIndirect _MultiDrawArraysIndirect = null;
        public static GLDelegate.MultiDrawArraysIndirect MultiDrawArraysIndirectAMD = MultiDrawArraysIndirect;
        /// <summary>
        /// <para>render multiple sets of primitives from array data, taking parameters from memory</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiDrawArraysIndirect.</para>
        /// <para>Fullname: MultiDrawArraysIndirect</para>
        /// <para>Aliases: MultiDrawArraysIndirectAMD, </para>
        /// <para>Extensions: ARB_multi_draw_indirect AMD_multi_draw_indirect</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.</param>
        /// <param name="indirect">Specifies the address of an array of structures containing the draw parameters.</param>
        /// <param name="drawcount">Specifies the the number of elements in the array of draw parameter structures.</param>
        /// <param name="stride">Specifies the distance in basic machine units between elements of the draw parameter array.</param>
        public static void MultiDrawArraysIndirect(int mode, IntPtr indirect, int drawcount, int stride)
        {
            if (gl._MultiDrawArraysIndirect != null) gl._MultiDrawArraysIndirect(mode, indirect, drawcount, stride); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiDrawElementsBaseVertex</para>
        /// </summary>
        [GLEntry("MultiDrawElementsBaseVertex", Category = "ARB")]
        public static GLDelegate.MultiDrawElementsBaseVertex _MultiDrawElementsBaseVertex = null;
        /// <summary>
        /// <para>render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiDrawElementsBaseVertex.</para>
        /// <para>Fullname: MultiDrawElementsBaseVertex</para>
        /// <para>Extensions: ARB_draw_elements_base_vertex</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="count">Points to an array of the elements counts.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="primcount">Specifies the size of the count array.</param>
        /// <param name="basevertex">Specifies a pointer to the location where the base vertices are stored.</param>
        public static void MultiDrawElementsBaseVertex(int mode, int[] count, int type, IntPtr indices, int drawcount, int[] basevertex)
        {
            if (gl._MultiDrawElementsBaseVertex != null) gl._MultiDrawElementsBaseVertex(mode, count, type, indices, drawcount, basevertex); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiDrawElementsIndirect</para>
        /// </summary>
        [GLEntry("MultiDrawElementsIndirect", Category = "ARB", Alias = "MultiDrawElementsIndirectAMD ")]
        public static GLDelegate.MultiDrawElementsIndirect _MultiDrawElementsIndirect = null;
        public static GLDelegate.MultiDrawElementsIndirect MultiDrawElementsIndirectAMD = MultiDrawElementsIndirect;
        /// <summary>
        /// <para>render indexed primitives from array data, taking parameters from memory</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiDrawElementsIndirect.</para>
        /// <para>Fullname: MultiDrawElementsIndirect</para>
        /// <para>Aliases: MultiDrawElementsIndirectAMD, </para>
        /// <para>Extensions: ARB_multi_draw_indirect AMD_multi_draw_indirect</para>
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.</param>
        /// <param name="type">Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding.</param>
        /// <param name="indirect">Specifies the address of a structure containing an array of draw parameters.</param>
        /// <param name="drawcount">Specifies the number of elements in the array addressed by indirect.</param>
        /// <param name="stride">Specifies the distance in basic machine units between elements of the draw parameter array.</param>
        public static void MultiDrawElementsIndirect(int mode, int type, IntPtr indirect, int drawcount, int stride)
        {
            if (gl._MultiDrawElementsIndirect != null) gl._MultiDrawElementsIndirect(mode, type, indirect, drawcount, stride); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoordP1ui</para>
        /// </summary>
        [GLEntry("MultiTexCoordP1ui", Category = "ARB")]
        public static GLDelegate.MultiTexCoordP1ui _MultiTexCoordP1ui = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoordP1ui.</para>
        /// <para>Fullname: MultiTexCoordP1ui</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void MultiTexCoordP1ui(int texture, int type, uint coords)
        {
            if (gl._MultiTexCoordP1ui != null) gl._MultiTexCoordP1ui(texture, type, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoordP1uiv</para>
        /// </summary>
        [GLEntry("MultiTexCoordP1uiv", Category = "ARB")]
        public static GLDelegate.MultiTexCoordP1uiv_uint _MultiTexCoordP1uiv_uint = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoordP1uiv_uint.</para>
        /// <para>Fullname: MultiTexCoordP1uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void MultiTexCoordP1uiv(int texture, int type, ref uint coords)
        {
            if (gl._MultiTexCoordP1uiv_uint != null) gl._MultiTexCoordP1uiv_uint(texture, type, ref coords); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoordP1uiv</para>
        /// </summary>
        [GLEntry("MultiTexCoordP1uiv", Category = "ARB")]
        public static GLDelegate.MultiTexCoordP1uiv _MultiTexCoordP1uiv = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoordP1uiv.</para>
        /// <para>Fullname: MultiTexCoordP1uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void MultiTexCoordP1uiv(int texture, int type, uint[] coords)
        {
            if (gl._MultiTexCoordP1uiv != null) gl._MultiTexCoordP1uiv(texture, type, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoordP2ui</para>
        /// </summary>
        [GLEntry("MultiTexCoordP2ui", Category = "ARB")]
        public static GLDelegate.MultiTexCoordP2ui _MultiTexCoordP2ui = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoordP2ui.</para>
        /// <para>Fullname: MultiTexCoordP2ui</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void MultiTexCoordP2ui(int texture, int type, uint coords)
        {
            if (gl._MultiTexCoordP2ui != null) gl._MultiTexCoordP2ui(texture, type, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoordP2uiv</para>
        /// </summary>
        [GLEntry("MultiTexCoordP2uiv", Category = "ARB")]
        public static GLDelegate.MultiTexCoordP2uiv _MultiTexCoordP2uiv = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoordP2uiv.</para>
        /// <para>Fullname: MultiTexCoordP2uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void MultiTexCoordP2uiv(int texture, int type, uint[] coords)
        {
            if (gl._MultiTexCoordP2uiv != null) gl._MultiTexCoordP2uiv(texture, type, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoordP2uiv</para>
        /// </summary>
        [GLEntry("MultiTexCoordP2uiv", Category = "ARB")]
        public static GLDelegate.MultiTexCoordP2uiv_uint _MultiTexCoordP2uiv_uint = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoordP2uiv_uint.</para>
        /// <para>Fullname: MultiTexCoordP2uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void MultiTexCoordP2uiv(int texture, int type, ref uint coords)
        {
            if (gl._MultiTexCoordP2uiv_uint != null) gl._MultiTexCoordP2uiv_uint(texture, type, ref coords); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoordP3ui</para>
        /// </summary>
        [GLEntry("MultiTexCoordP3ui", Category = "ARB")]
        public static GLDelegate.MultiTexCoordP3ui _MultiTexCoordP3ui = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoordP3ui.</para>
        /// <para>Fullname: MultiTexCoordP3ui</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void MultiTexCoordP3ui(int texture, int type, uint coords)
        {
            if (gl._MultiTexCoordP3ui != null) gl._MultiTexCoordP3ui(texture, type, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoordP3uiv</para>
        /// </summary>
        [GLEntry("MultiTexCoordP3uiv", Category = "ARB")]
        public static GLDelegate.MultiTexCoordP3uiv _MultiTexCoordP3uiv = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoordP3uiv.</para>
        /// <para>Fullname: MultiTexCoordP3uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void MultiTexCoordP3uiv(int texture, int type, uint[] coords)
        {
            if (gl._MultiTexCoordP3uiv != null) gl._MultiTexCoordP3uiv(texture, type, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoordP3uiv</para>
        /// </summary>
        [GLEntry("MultiTexCoordP3uiv", Category = "ARB")]
        public static GLDelegate.MultiTexCoordP3uiv_uint _MultiTexCoordP3uiv_uint = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoordP3uiv_uint.</para>
        /// <para>Fullname: MultiTexCoordP3uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void MultiTexCoordP3uiv(int texture, int type, ref uint coords)
        {
            if (gl._MultiTexCoordP3uiv_uint != null) gl._MultiTexCoordP3uiv_uint(texture, type, ref coords); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoordP4ui</para>
        /// </summary>
        [GLEntry("MultiTexCoordP4ui", Category = "ARB")]
        public static GLDelegate.MultiTexCoordP4ui _MultiTexCoordP4ui = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoordP4ui.</para>
        /// <para>Fullname: MultiTexCoordP4ui</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void MultiTexCoordP4ui(int texture, int type, uint coords)
        {
            if (gl._MultiTexCoordP4ui != null) gl._MultiTexCoordP4ui(texture, type, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoordP4uiv</para>
        /// </summary>
        [GLEntry("MultiTexCoordP4uiv", Category = "ARB")]
        public static GLDelegate.MultiTexCoordP4uiv _MultiTexCoordP4uiv = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoordP4uiv.</para>
        /// <para>Fullname: MultiTexCoordP4uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void MultiTexCoordP4uiv(int texture, int type, uint[] coords)
        {
            if (gl._MultiTexCoordP4uiv != null) gl._MultiTexCoordP4uiv(texture, type, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoordP4uiv</para>
        /// </summary>
        [GLEntry("MultiTexCoordP4uiv", Category = "ARB")]
        public static GLDelegate.MultiTexCoordP4uiv_uint _MultiTexCoordP4uiv_uint = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoordP4uiv_uint.</para>
        /// <para>Fullname: MultiTexCoordP4uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void MultiTexCoordP4uiv(int texture, int type, ref uint coords)
        {
            if (gl._MultiTexCoordP4uiv_uint != null) gl._MultiTexCoordP4uiv_uint(texture, type, ref coords); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedFramebufferParameteriEXT</para>
        /// </summary>
        [GLEntry("NamedFramebufferParameteriEXT", Category = "ARB")]
        public static GLDelegate.NamedFramebufferParameteri _NamedFramebufferParameteri = null;
        /// <summary>
        /// <para>Framebuffer objects as introduced by ARB_framebuffer_object and OpenGL 3.0 provide a generalized mechanism for rendering to off-screen surfaces. Each framebuffer object may have depth, stencil and zero or more color attachments that can be written to by the GL.  The size of the framebuffer (width, height, layer count, sample count) is derived from the attachments of that framebuffer.  In unextended OpenGL 4.2, it is not legal to render into a framebuffer object that has no attachments.  Such a framebuffer would be considered incomplete with the FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT status. With OpenGL 4.2 and ARB_shader_image_load_store, fragment shaders are capable of doing random access writes to buffer and texture memory via image loads, stores, and atomics.  This ability enables algorithms using the conventional rasterizer to generate a collection of fragments, where each fragment shader invocation will write its outputs to buffer or texture memory using image stores or atomics...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedFramebufferParameteri.</para>
        /// <para>Fullname: NamedFramebufferParameteriEXT</para>
        /// <para>Extensions: ARB_framebuffer_no_attachments</para>
        /// </summary>
        public static void NamedFramebufferParameteri(uint framebuffer, int pname, int param)
        {
            if (gl._NamedFramebufferParameteri != null) gl._NamedFramebufferParameteri(framebuffer, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedStringARB</para>
        /// </summary>
        [GLEntry("NamedStringARB", Category = "ARB")]
        public static GLDelegate.NamedString _NamedString = null;
        /// <summary>
        /// <para>This extension introduces a #include GLSL directive to allow reusing the same shader text in multiple shaders and defines the semantics and syntax of the names allowed in #include directives. It also defines API mechanisms to define the named string backing a #include. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedString.</para>
        /// <para>Fullname: NamedStringARB</para>
        /// <para>Extensions: ARB_shading_language_include</para>
        /// </summary>
        public static void NamedString(int type, int namelen, StringBuilder name, int stringlen, StringBuilder str)
        {
            if (gl._NamedString != null) gl._NamedString(type, namelen, name, stringlen, str); else { }
        }
        /// <summary>
        /// <para>Fullname: NormalP3ui</para>
        /// </summary>
        [GLEntry("NormalP3ui", Category = "ARB")]
        public static GLDelegate.NormalP3ui _NormalP3ui = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NormalP3ui.</para>
        /// <para>Fullname: NormalP3ui</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void NormalP3ui(int type, uint coords)
        {
            if (gl._NormalP3ui != null) gl._NormalP3ui(type, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: NormalP3uiv</para>
        /// </summary>
        [GLEntry("NormalP3uiv", Category = "ARB")]
        public static GLDelegate.NormalP3uiv_uint _NormalP3uiv_uint = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NormalP3uiv_uint.</para>
        /// <para>Fullname: NormalP3uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void NormalP3uiv(int type, ref uint coords)
        {
            if (gl._NormalP3uiv_uint != null) gl._NormalP3uiv_uint(type, ref coords); else { }
        }
        /// <summary>
        /// <para>Fullname: NormalP3uiv</para>
        /// </summary>
        [GLEntry("NormalP3uiv", Category = "ARB")]
        public static GLDelegate.NormalP3uiv _NormalP3uiv = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NormalP3uiv.</para>
        /// <para>Fullname: NormalP3uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void NormalP3uiv(int type, uint[] coords)
        {
            if (gl._NormalP3uiv != null) gl._NormalP3uiv(type, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: PatchParameterfv</para>
        /// </summary>
        [GLEntry("PatchParameterfv", Category = "ARB")]
        public static GLDelegate.PatchParameterfv _PatchParameterfv = null;
        /// <summary>
        /// <para>specifies the parameters for patch primitives</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PatchParameterfv.</para>
        /// <para>Fullname: PatchParameterfv</para>
        /// <para>Extensions: ARB_tessellation_shader</para>
        /// </summary>
        /// <param name="pname">Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted.</param>
        /// <param name="value">Specifies the new value for the parameter given by pname.</param>
        /// <param name="values">Specifies the address of an array containing the new values for the parameter given by pname.</param>
        public static void PatchParameterfv(int pname, float[] values)
        {
            if (gl._PatchParameterfv != null) gl._PatchParameterfv(pname, values); else { }
        }
        /// <summary>
        /// <para>Fullname: PatchParameteri</para>
        /// </summary>
        [GLEntry("PatchParameteri", Category = "ARB")]
        public static GLDelegate.PatchParameteri _PatchParameteri = null;
        /// <summary>
        /// <para>specifies the parameters for patch primitives</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PatchParameteri.</para>
        /// <para>Fullname: PatchParameteri</para>
        /// <para>Extensions: ARB_tessellation_shader</para>
        /// </summary>
        /// <param name="pname">Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted.</param>
        /// <param name="value">Specifies the new value for the parameter given by pname.</param>
        /// <param name="values">Specifies the address of an array containing the new values for the parameter given by pname.</param>
        public static void PatchParameteri(int pname, int value)
        {
            if (gl._PatchParameteri != null) gl._PatchParameteri(pname, value); else { }
        }
        /// <summary>
        /// <para>Fullname: PauseTransformFeedback</para>
        /// </summary>
        [GLEntry("PauseTransformFeedback", Category = "ARB", Alias = "PauseTransformFeedbackNV ")]
        public static GLDelegate.PauseTransformFeedback _PauseTransformFeedback = null;
        public static GLDelegate.PauseTransformFeedback PauseTransformFeedbackNV = PauseTransformFeedback;
        /// <summary>
        /// <para>pause transform feedback operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PauseTransformFeedback.</para>
        /// <para>Fullname: PauseTransformFeedback</para>
        /// <para>Aliases: PauseTransformFeedbackNV, </para>
        /// <para>Extensions: ARB_transform_feedback2 NV_transform_feedback2</para>
        /// </summary>
        public static void PauseTransformFeedback()
        {
            if (gl._PauseTransformFeedback != null) gl._PauseTransformFeedback(); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramBinary</para>
        /// </summary>
        [GLEntry("ProgramBinary", Category = "ARB")]
        public static GLDelegate.ProgramBinary _ProgramBinary = null;
        /// <summary>
        /// <para>load a program object with a program binary</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramBinary.</para>
        /// <para>Fullname: ProgramBinary</para>
        /// <para>Extensions: ARB_get_program_binary</para>
        /// </summary>
        /// <param name="program">Specifies the name of a program object into which to load a program binary.</param>
        /// <param name="binaryFormat">Specifies the format of the binary data in binary.</param>
        /// <param name="binary">Specifies the address an array containing the binary to be loaded into program.</param>
        /// <param name="length">Specifies the number of bytes contained in binary.</param>
        public static void ProgramBinary(uint program, int binaryFormat, IntPtr binary, int length)
        {
            if (gl._ProgramBinary != null) gl._ProgramBinary(program, binaryFormat, binary, length); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramEnvParameter4dARB</para>
        /// </summary>
        [GLEntry("ProgramEnvParameter4dARB", Category = "ARB")]
        public static GLDelegate.ProgramEnvParameter4d _ProgramEnvParameter4d = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramEnvParameter4d.</para>
        /// <para>Fullname: ProgramEnvParameter4dARB</para>
        /// <para>Extensions: ARB_vertex_program</para>
        /// </summary>
        public static void ProgramEnvParameter4d(int target, uint index, double x, double y, double z, double w)
        {
            if (gl._ProgramEnvParameter4d != null) gl._ProgramEnvParameter4d(target, index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramEnvParameter4dvARB</para>
        /// </summary>
        [GLEntry("ProgramEnvParameter4dvARB", Category = "ARB")]
        public static GLDelegate.ProgramEnvParameter4dv _ProgramEnvParameter4dv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramEnvParameter4dv.</para>
        /// <para>Fullname: ProgramEnvParameter4dvARB</para>
        /// <para>Extensions: ARB_vertex_program</para>
        /// </summary>
        public static void ProgramEnvParameter4dv(int target, uint index, double[] param)
        {
            if (gl._ProgramEnvParameter4dv != null) gl._ProgramEnvParameter4dv(target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramEnvParameter4fARB</para>
        /// </summary>
        [GLEntry("ProgramEnvParameter4fARB", Category = "ARB")]
        public static GLDelegate.ProgramEnvParameter4f _ProgramEnvParameter4f = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramEnvParameter4f.</para>
        /// <para>Fullname: ProgramEnvParameter4fARB</para>
        /// <para>Extensions: ARB_vertex_program</para>
        /// </summary>
        public static void ProgramEnvParameter4f(int target, uint index, float x, float y, float z, float w)
        {
            if (gl._ProgramEnvParameter4f != null) gl._ProgramEnvParameter4f(target, index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramEnvParameter4fvARB</para>
        /// </summary>
        [GLEntry("ProgramEnvParameter4fvARB", Category = "ARB")]
        public static GLDelegate.ProgramEnvParameter4fv _ProgramEnvParameter4fv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramEnvParameter4fv.</para>
        /// <para>Fullname: ProgramEnvParameter4fvARB</para>
        /// <para>Extensions: ARB_vertex_program</para>
        /// </summary>
        public static void ProgramEnvParameter4fv(int target, uint index, float[] param)
        {
            if (gl._ProgramEnvParameter4fv != null) gl._ProgramEnvParameter4fv(target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramLocalParameter4dARB</para>
        /// </summary>
        [GLEntry("ProgramLocalParameter4dARB", Category = "ARB")]
        public static GLDelegate.ProgramLocalParameter4d _ProgramLocalParameter4d = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramLocalParameter4d.</para>
        /// <para>Fullname: ProgramLocalParameter4dARB</para>
        /// <para>Extensions: ARB_vertex_program</para>
        /// </summary>
        public static void ProgramLocalParameter4d(int target, uint index, double x, double y, double z, double w)
        {
            if (gl._ProgramLocalParameter4d != null) gl._ProgramLocalParameter4d(target, index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramLocalParameter4dvARB</para>
        /// </summary>
        [GLEntry("ProgramLocalParameter4dvARB", Category = "ARB")]
        public static GLDelegate.ProgramLocalParameter4dv _ProgramLocalParameter4dv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramLocalParameter4dv.</para>
        /// <para>Fullname: ProgramLocalParameter4dvARB</para>
        /// <para>Extensions: ARB_vertex_program</para>
        /// </summary>
        public static void ProgramLocalParameter4dv(int target, uint index, double[] param)
        {
            if (gl._ProgramLocalParameter4dv != null) gl._ProgramLocalParameter4dv(target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramLocalParameter4fARB</para>
        /// </summary>
        [GLEntry("ProgramLocalParameter4fARB", Category = "ARB")]
        public static GLDelegate.ProgramLocalParameter4f _ProgramLocalParameter4f = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramLocalParameter4f.</para>
        /// <para>Fullname: ProgramLocalParameter4fARB</para>
        /// <para>Extensions: ARB_vertex_program</para>
        /// </summary>
        public static void ProgramLocalParameter4f(int target, uint index, float x, float y, float z, float w)
        {
            if (gl._ProgramLocalParameter4f != null) gl._ProgramLocalParameter4f(target, index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramLocalParameter4fvARB</para>
        /// </summary>
        [GLEntry("ProgramLocalParameter4fvARB", Category = "ARB")]
        public static GLDelegate.ProgramLocalParameter4fv _ProgramLocalParameter4fv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramLocalParameter4fv.</para>
        /// <para>Fullname: ProgramLocalParameter4fvARB</para>
        /// <para>Extensions: ARB_vertex_program</para>
        /// </summary>
        public static void ProgramLocalParameter4fv(int target, uint index, float[] param)
        {
            if (gl._ProgramLocalParameter4fv != null) gl._ProgramLocalParameter4fv(target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramParameteri</para>
        /// </summary>
        [GLEntry("ProgramParameteri", Category = "ARB", Alias = "ProgramParameteriARB ProgramParameteriEXT ")]
        public static GLDelegate.ProgramParameteri _ProgramParameteri = null;
        public static GLDelegate.ProgramParameteri ProgramParameteriARB = ProgramParameteri;
        public static GLDelegate.ProgramParameteri ProgramParameteriEXT = ProgramParameteri;
        /// <summary>
        /// <para>specify a parameter for a program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramParameteri.</para>
        /// <para>Fullname: ProgramParameteri</para>
        /// <para>Aliases: ProgramParameteriARB, ProgramParameteriEXT, </para>
        /// <para>Extensions: ARB_get_program_binary EXT_geometry_shader4</para>
        /// </summary>
        /// <param name="program">Specifies the name of a program object whose parameter to modify.</param>
        /// <param name="pname">Specifies the name of the parameter to modify.</param>
        /// <param name="value">Specifies the new value of the parameter specified by pname for program.</param>
        public static void ProgramParameteri(uint program, int pname, int value)
        {
            if (gl._ProgramParameteri != null) gl._ProgramParameteri(program, pname, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramStringARB</para>
        /// </summary>
        [GLEntry("ProgramStringARB", Category = "ARB")]
        public static GLDelegate.ProgramString _ProgramString = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (ARB_vertex_blend, EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT/ARB_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-v...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramString.</para>
        /// <para>Fullname: ProgramStringARB</para>
        /// <para>Extensions: ARB_vertex_program</para>
        /// </summary>
        public static void ProgramString(int target, int format, int len, IntPtr str)
        {
            if (gl._ProgramString != null) gl._ProgramString(target, format, len, str); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform1d</para>
        /// </summary>
        [GLEntry("ProgramUniform1d", Category = "ARB", Alias = "ProgramUniform1dEXT ")]
        public static GLDelegate.ProgramUniform1d _ProgramUniform1d = null;
        public static GLDelegate.ProgramUniform1d ProgramUniform1dEXT = ProgramUniform1d;
        /// <summary>
        /// <para>Conventional GLSL requires multiple shader stages (vertex, fragment, geometry, tessellation control, and tessellation evaluation) to be linked into a single monolithic program object to specify a GLSL shader for each stage. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple stages, all existing GPU hardware supports the more flexible mix-and-match approach. Shaders written for HLSL9, Cg, the prior OpenGL assembly program extensions, and game console favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader stages.  Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This extension adopts a "mix-and-match" shader stage model for GLSL allowing multiple different GLSL program objects to be bound at once each to an individual rendering pipeline stage independently of other...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform1d.</para>
        /// <para>Fullname: ProgramUniform1d</para>
        /// <para>Aliases: ProgramUniform1dEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        public static void ProgramUniform1d(uint program, int location, double v0)
        {
            if (gl._ProgramUniform1d != null) gl._ProgramUniform1d(program, location, v0); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform1dv</para>
        /// </summary>
        [GLEntry("ProgramUniform1dv", Category = "ARB", Alias = "ProgramUniform1dvEXT ")]
        public static GLDelegate.ProgramUniform1dv_double _ProgramUniform1dv_double = null;
        /// <summary>
        /// <para>Conventional GLSL requires multiple shader stages (vertex, fragment, geometry, tessellation control, and tessellation evaluation) to be linked into a single monolithic program object to specify a GLSL shader for each stage. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple stages, all existing GPU hardware supports the more flexible mix-and-match approach. Shaders written for HLSL9, Cg, the prior OpenGL assembly program extensions, and game console favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader stages.  Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This extension adopts a "mix-and-match" shader stage model for GLSL allowing multiple different GLSL program objects to be bound at once each to an individual rendering pipeline stage independently of other...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform1dv_double.</para>
        /// <para>Fullname: ProgramUniform1dv</para>
        /// <para>Aliases: ProgramUniform1dvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        public static void ProgramUniform1dv(uint program, int location, int count, ref double value)
        {
            if (gl._ProgramUniform1dv_double != null) gl._ProgramUniform1dv_double(program, location, count, ref value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform1dv</para>
        /// </summary>
        [GLEntry("ProgramUniform1dv", Category = "ARB", Alias = "ProgramUniform1dvEXT ")]
        public static GLDelegate.ProgramUniform1dv _ProgramUniform1dv = null;
        public static GLDelegate.ProgramUniform1dv ProgramUniform1dvEXT = ProgramUniform1dv;
        /// <summary>
        /// <para>Conventional GLSL requires multiple shader stages (vertex, fragment, geometry, tessellation control, and tessellation evaluation) to be linked into a single monolithic program object to specify a GLSL shader for each stage. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple stages, all existing GPU hardware supports the more flexible mix-and-match approach. Shaders written for HLSL9, Cg, the prior OpenGL assembly program extensions, and game console favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader stages.  Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This extension adopts a "mix-and-match" shader stage model for GLSL allowing multiple different GLSL program objects to be bound at once each to an individual rendering pipeline stage independently of other...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform1dv.</para>
        /// <para>Fullname: ProgramUniform1dv</para>
        /// <para>Aliases: ProgramUniform1dvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        public static void ProgramUniform1dv(uint program, int location, int count, double[] value)
        {
            if (gl._ProgramUniform1dv != null) gl._ProgramUniform1dv(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform1f</para>
        /// </summary>
        [GLEntry("ProgramUniform1f", Category = "ARB", Alias = "ProgramUniform1fEXT ")]
        public static GLDelegate.ProgramUniform1f _ProgramUniform1f = null;
        public static GLDelegate.ProgramUniform1f ProgramUniform1fEXT = ProgramUniform1f;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform1f.</para>
        /// <para>Fullname: ProgramUniform1f</para>
        /// <para>Aliases: ProgramUniform1fEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform1f(uint program, int location, float v0)
        {
            if (gl._ProgramUniform1f != null) gl._ProgramUniform1f(program, location, v0); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform1fv</para>
        /// </summary>
        [GLEntry("ProgramUniform1fv", Category = "ARB", Alias = "ProgramUniform1fvEXT ")]
        public static GLDelegate.ProgramUniform1fv_float _ProgramUniform1fv_float = null;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform1fv_float.</para>
        /// <para>Fullname: ProgramUniform1fv</para>
        /// <para>Aliases: ProgramUniform1fvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform1fv(uint program, int location, int count, ref float value)
        {
            if (gl._ProgramUniform1fv_float != null) gl._ProgramUniform1fv_float(program, location, count, ref value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform1fv</para>
        /// </summary>
        [GLEntry("ProgramUniform1fv", Category = "ARB", Alias = "ProgramUniform1fvEXT ")]
        public static GLDelegate.ProgramUniform1fv _ProgramUniform1fv = null;
        public static GLDelegate.ProgramUniform1fv ProgramUniform1fvEXT = ProgramUniform1fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform1fv.</para>
        /// <para>Fullname: ProgramUniform1fv</para>
        /// <para>Aliases: ProgramUniform1fvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform1fv(uint program, int location, int count, float[] value)
        {
            if (gl._ProgramUniform1fv != null) gl._ProgramUniform1fv(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform1i</para>
        /// </summary>
        [GLEntry("ProgramUniform1i", Category = "ARB", Alias = "ProgramUniform1iEXT ")]
        public static GLDelegate.ProgramUniform1i _ProgramUniform1i = null;
        public static GLDelegate.ProgramUniform1i ProgramUniform1iEXT = ProgramUniform1i;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform1i.</para>
        /// <para>Fullname: ProgramUniform1i</para>
        /// <para>Aliases: ProgramUniform1iEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform1i(uint program, int location, int v0)
        {
            if (gl._ProgramUniform1i != null) gl._ProgramUniform1i(program, location, v0); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform1iv</para>
        /// </summary>
        [GLEntry("ProgramUniform1iv", Category = "ARB", Alias = "ProgramUniform1ivEXT ")]
        public static GLDelegate.ProgramUniform1iv_int _ProgramUniform1iv_int = null;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform1iv_int.</para>
        /// <para>Fullname: ProgramUniform1iv</para>
        /// <para>Aliases: ProgramUniform1ivEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform1iv(uint program, int location, int count, ref int value)
        {
            if (gl._ProgramUniform1iv_int != null) gl._ProgramUniform1iv_int(program, location, count, ref value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform1iv</para>
        /// </summary>
        [GLEntry("ProgramUniform1iv", Category = "ARB", Alias = "ProgramUniform1ivEXT ")]
        public static GLDelegate.ProgramUniform1iv _ProgramUniform1iv = null;
        public static GLDelegate.ProgramUniform1iv ProgramUniform1ivEXT = ProgramUniform1iv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform1iv.</para>
        /// <para>Fullname: ProgramUniform1iv</para>
        /// <para>Aliases: ProgramUniform1ivEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform1iv(uint program, int location, int count, int[] value)
        {
            if (gl._ProgramUniform1iv != null) gl._ProgramUniform1iv(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform1ui</para>
        /// </summary>
        [GLEntry("ProgramUniform1ui", Category = "ARB", Alias = "ProgramUniform1uiEXT ")]
        public static GLDelegate.ProgramUniform1ui _ProgramUniform1ui = null;
        public static GLDelegate.ProgramUniform1ui ProgramUniform1uiEXT = ProgramUniform1ui;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform1ui.</para>
        /// <para>Fullname: ProgramUniform1ui</para>
        /// <para>Aliases: ProgramUniform1uiEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform1ui(uint program, int location, uint v0)
        {
            if (gl._ProgramUniform1ui != null) gl._ProgramUniform1ui(program, location, v0); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform1uiv</para>
        /// </summary>
        [GLEntry("ProgramUniform1uiv", Category = "ARB", Alias = "ProgramUniform1uivEXT ")]
        public static GLDelegate.ProgramUniform1uiv_uint _ProgramUniform1uiv_uint = null;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform1uiv_uint.</para>
        /// <para>Fullname: ProgramUniform1uiv</para>
        /// <para>Aliases: ProgramUniform1uivEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform1uiv(uint program, int location, int count, ref uint value)
        {
            if (gl._ProgramUniform1uiv_uint != null) gl._ProgramUniform1uiv_uint(program, location, count, ref value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform1uiv</para>
        /// </summary>
        [GLEntry("ProgramUniform1uiv", Category = "ARB", Alias = "ProgramUniform1uivEXT ")]
        public static GLDelegate.ProgramUniform1uiv _ProgramUniform1uiv = null;
        public static GLDelegate.ProgramUniform1uiv ProgramUniform1uivEXT = ProgramUniform1uiv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform1uiv.</para>
        /// <para>Fullname: ProgramUniform1uiv</para>
        /// <para>Aliases: ProgramUniform1uivEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform1uiv(uint program, int location, int count, uint[] value)
        {
            if (gl._ProgramUniform1uiv != null) gl._ProgramUniform1uiv(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform2d</para>
        /// </summary>
        [GLEntry("ProgramUniform2d", Category = "ARB", Alias = "ProgramUniform2dEXT ")]
        public static GLDelegate.ProgramUniform2d _ProgramUniform2d = null;
        public static GLDelegate.ProgramUniform2d ProgramUniform2dEXT = ProgramUniform2d;
        /// <summary>
        /// <para>Conventional GLSL requires multiple shader stages (vertex, fragment, geometry, tessellation control, and tessellation evaluation) to be linked into a single monolithic program object to specify a GLSL shader for each stage. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple stages, all existing GPU hardware supports the more flexible mix-and-match approach. Shaders written for HLSL9, Cg, the prior OpenGL assembly program extensions, and game console favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader stages.  Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This extension adopts a "mix-and-match" shader stage model for GLSL allowing multiple different GLSL program objects to be bound at once each to an individual rendering pipeline stage independently of other...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform2d.</para>
        /// <para>Fullname: ProgramUniform2d</para>
        /// <para>Aliases: ProgramUniform2dEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        public static void ProgramUniform2d(uint program, int location, double v0, double v1)
        {
            if (gl._ProgramUniform2d != null) gl._ProgramUniform2d(program, location, v0, v1); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform2dv</para>
        /// </summary>
        [GLEntry("ProgramUniform2dv", Category = "ARB", Alias = "ProgramUniform2dvEXT ")]
        public static GLDelegate.ProgramUniform2dv _ProgramUniform2dv = null;
        public static GLDelegate.ProgramUniform2dv ProgramUniform2dvEXT = ProgramUniform2dv;
        /// <summary>
        /// <para>Conventional GLSL requires multiple shader stages (vertex, fragment, geometry, tessellation control, and tessellation evaluation) to be linked into a single monolithic program object to specify a GLSL shader for each stage. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple stages, all existing GPU hardware supports the more flexible mix-and-match approach. Shaders written for HLSL9, Cg, the prior OpenGL assembly program extensions, and game console favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader stages.  Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This extension adopts a "mix-and-match" shader stage model for GLSL allowing multiple different GLSL program objects to be bound at once each to an individual rendering pipeline stage independently of other...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform2dv.</para>
        /// <para>Fullname: ProgramUniform2dv</para>
        /// <para>Aliases: ProgramUniform2dvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        public static void ProgramUniform2dv(uint program, int location, int count, double[] value)
        {
            if (gl._ProgramUniform2dv != null) gl._ProgramUniform2dv(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform2f</para>
        /// </summary>
        [GLEntry("ProgramUniform2f", Category = "ARB", Alias = "ProgramUniform2fEXT ")]
        public static GLDelegate.ProgramUniform2f _ProgramUniform2f = null;
        public static GLDelegate.ProgramUniform2f ProgramUniform2fEXT = ProgramUniform2f;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform2f.</para>
        /// <para>Fullname: ProgramUniform2f</para>
        /// <para>Aliases: ProgramUniform2fEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform2f(uint program, int location, float v0, float v1)
        {
            if (gl._ProgramUniform2f != null) gl._ProgramUniform2f(program, location, v0, v1); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform2fv</para>
        /// </summary>
        [GLEntry("ProgramUniform2fv", Category = "ARB", Alias = "ProgramUniform2fvEXT ")]
        public static GLDelegate.ProgramUniform2fv _ProgramUniform2fv = null;
        public static GLDelegate.ProgramUniform2fv ProgramUniform2fvEXT = ProgramUniform2fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform2fv.</para>
        /// <para>Fullname: ProgramUniform2fv</para>
        /// <para>Aliases: ProgramUniform2fvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform2fv(uint program, int location, int count, float[] value)
        {
            if (gl._ProgramUniform2fv != null) gl._ProgramUniform2fv(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform2i</para>
        /// </summary>
        [GLEntry("ProgramUniform2i", Category = "ARB", Alias = "ProgramUniform2iEXT ")]
        public static GLDelegate.ProgramUniform2i _ProgramUniform2i = null;
        public static GLDelegate.ProgramUniform2i ProgramUniform2iEXT = ProgramUniform2i;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform2i.</para>
        /// <para>Fullname: ProgramUniform2i</para>
        /// <para>Aliases: ProgramUniform2iEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform2i(uint program, int location, int v0, int v1)
        {
            if (gl._ProgramUniform2i != null) gl._ProgramUniform2i(program, location, v0, v1); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform2iv</para>
        /// </summary>
        [GLEntry("ProgramUniform2iv", Category = "ARB", Alias = "ProgramUniform2ivEXT ")]
        public static GLDelegate.ProgramUniform2iv _ProgramUniform2iv = null;
        public static GLDelegate.ProgramUniform2iv ProgramUniform2ivEXT = ProgramUniform2iv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform2iv.</para>
        /// <para>Fullname: ProgramUniform2iv</para>
        /// <para>Aliases: ProgramUniform2ivEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform2iv(uint program, int location, int count, int[] value)
        {
            if (gl._ProgramUniform2iv != null) gl._ProgramUniform2iv(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform2ui</para>
        /// </summary>
        [GLEntry("ProgramUniform2ui", Category = "ARB", Alias = "ProgramUniform2uiEXT ")]
        public static GLDelegate.ProgramUniform2ui _ProgramUniform2ui = null;
        public static GLDelegate.ProgramUniform2ui ProgramUniform2uiEXT = ProgramUniform2ui;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform2ui.</para>
        /// <para>Fullname: ProgramUniform2ui</para>
        /// <para>Aliases: ProgramUniform2uiEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform2ui(uint program, int location, uint v0, uint v1)
        {
            if (gl._ProgramUniform2ui != null) gl._ProgramUniform2ui(program, location, v0, v1); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform2uiv</para>
        /// </summary>
        [GLEntry("ProgramUniform2uiv", Category = "ARB", Alias = "ProgramUniform2uivEXT ")]
        public static GLDelegate.ProgramUniform2uiv _ProgramUniform2uiv = null;
        public static GLDelegate.ProgramUniform2uiv ProgramUniform2uivEXT = ProgramUniform2uiv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform2uiv.</para>
        /// <para>Fullname: ProgramUniform2uiv</para>
        /// <para>Aliases: ProgramUniform2uivEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform2uiv(uint program, int location, int count, uint[] value)
        {
            if (gl._ProgramUniform2uiv != null) gl._ProgramUniform2uiv(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform3d</para>
        /// </summary>
        [GLEntry("ProgramUniform3d", Category = "ARB", Alias = "ProgramUniform3dEXT ")]
        public static GLDelegate.ProgramUniform3d _ProgramUniform3d = null;
        public static GLDelegate.ProgramUniform3d ProgramUniform3dEXT = ProgramUniform3d;
        /// <summary>
        /// <para>Conventional GLSL requires multiple shader stages (vertex, fragment, geometry, tessellation control, and tessellation evaluation) to be linked into a single monolithic program object to specify a GLSL shader for each stage. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple stages, all existing GPU hardware supports the more flexible mix-and-match approach. Shaders written for HLSL9, Cg, the prior OpenGL assembly program extensions, and game console favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader stages.  Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This extension adopts a "mix-and-match" shader stage model for GLSL allowing multiple different GLSL program objects to be bound at once each to an individual rendering pipeline stage independently of other...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform3d.</para>
        /// <para>Fullname: ProgramUniform3d</para>
        /// <para>Aliases: ProgramUniform3dEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        public static void ProgramUniform3d(uint program, int location, double v0, double v1, double v2)
        {
            if (gl._ProgramUniform3d != null) gl._ProgramUniform3d(program, location, v0, v1, v2); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform3dv</para>
        /// </summary>
        [GLEntry("ProgramUniform3dv", Category = "ARB", Alias = "ProgramUniform3dvEXT ")]
        public static GLDelegate.ProgramUniform3dv _ProgramUniform3dv = null;
        public static GLDelegate.ProgramUniform3dv ProgramUniform3dvEXT = ProgramUniform3dv;
        /// <summary>
        /// <para>Conventional GLSL requires multiple shader stages (vertex, fragment, geometry, tessellation control, and tessellation evaluation) to be linked into a single monolithic program object to specify a GLSL shader for each stage. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple stages, all existing GPU hardware supports the more flexible mix-and-match approach. Shaders written for HLSL9, Cg, the prior OpenGL assembly program extensions, and game console favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader stages.  Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This extension adopts a "mix-and-match" shader stage model for GLSL allowing multiple different GLSL program objects to be bound at once each to an individual rendering pipeline stage independently of other...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform3dv.</para>
        /// <para>Fullname: ProgramUniform3dv</para>
        /// <para>Aliases: ProgramUniform3dvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        public static void ProgramUniform3dv(uint program, int location, int count, double[] value)
        {
            if (gl._ProgramUniform3dv != null) gl._ProgramUniform3dv(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform3f</para>
        /// </summary>
        [GLEntry("ProgramUniform3f", Category = "ARB", Alias = "ProgramUniform3fEXT ")]
        public static GLDelegate.ProgramUniform3f _ProgramUniform3f = null;
        public static GLDelegate.ProgramUniform3f ProgramUniform3fEXT = ProgramUniform3f;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform3f.</para>
        /// <para>Fullname: ProgramUniform3f</para>
        /// <para>Aliases: ProgramUniform3fEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform3f(uint program, int location, float v0, float v1, float v2)
        {
            if (gl._ProgramUniform3f != null) gl._ProgramUniform3f(program, location, v0, v1, v2); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform3fv</para>
        /// </summary>
        [GLEntry("ProgramUniform3fv", Category = "ARB", Alias = "ProgramUniform3fvEXT ")]
        public static GLDelegate.ProgramUniform3fv _ProgramUniform3fv = null;
        public static GLDelegate.ProgramUniform3fv ProgramUniform3fvEXT = ProgramUniform3fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform3fv.</para>
        /// <para>Fullname: ProgramUniform3fv</para>
        /// <para>Aliases: ProgramUniform3fvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform3fv(uint program, int location, int count, float[] value)
        {
            if (gl._ProgramUniform3fv != null) gl._ProgramUniform3fv(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform3i</para>
        /// </summary>
        [GLEntry("ProgramUniform3i", Category = "ARB", Alias = "ProgramUniform3iEXT ")]
        public static GLDelegate.ProgramUniform3i _ProgramUniform3i = null;
        public static GLDelegate.ProgramUniform3i ProgramUniform3iEXT = ProgramUniform3i;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform3i.</para>
        /// <para>Fullname: ProgramUniform3i</para>
        /// <para>Aliases: ProgramUniform3iEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform3i(uint program, int location, int v0, int v1, int v2)
        {
            if (gl._ProgramUniform3i != null) gl._ProgramUniform3i(program, location, v0, v1, v2); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform3iv</para>
        /// </summary>
        [GLEntry("ProgramUniform3iv", Category = "ARB", Alias = "ProgramUniform3ivEXT ")]
        public static GLDelegate.ProgramUniform3iv _ProgramUniform3iv = null;
        public static GLDelegate.ProgramUniform3iv ProgramUniform3ivEXT = ProgramUniform3iv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform3iv.</para>
        /// <para>Fullname: ProgramUniform3iv</para>
        /// <para>Aliases: ProgramUniform3ivEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform3iv(uint program, int location, int count, int[] value)
        {
            if (gl._ProgramUniform3iv != null) gl._ProgramUniform3iv(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform3ui</para>
        /// </summary>
        [GLEntry("ProgramUniform3ui", Category = "ARB", Alias = "ProgramUniform3uiEXT ")]
        public static GLDelegate.ProgramUniform3ui _ProgramUniform3ui = null;
        public static GLDelegate.ProgramUniform3ui ProgramUniform3uiEXT = ProgramUniform3ui;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform3ui.</para>
        /// <para>Fullname: ProgramUniform3ui</para>
        /// <para>Aliases: ProgramUniform3uiEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform3ui(uint program, int location, uint v0, uint v1, uint v2)
        {
            if (gl._ProgramUniform3ui != null) gl._ProgramUniform3ui(program, location, v0, v1, v2); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform3uiv</para>
        /// </summary>
        [GLEntry("ProgramUniform3uiv", Category = "ARB", Alias = "ProgramUniform3uivEXT ")]
        public static GLDelegate.ProgramUniform3uiv _ProgramUniform3uiv = null;
        public static GLDelegate.ProgramUniform3uiv ProgramUniform3uivEXT = ProgramUniform3uiv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform3uiv.</para>
        /// <para>Fullname: ProgramUniform3uiv</para>
        /// <para>Aliases: ProgramUniform3uivEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform3uiv(uint program, int location, int count, uint[] value)
        {
            if (gl._ProgramUniform3uiv != null) gl._ProgramUniform3uiv(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform4d</para>
        /// </summary>
        [GLEntry("ProgramUniform4d", Category = "ARB", Alias = "ProgramUniform4dEXT ")]
        public static GLDelegate.ProgramUniform4d _ProgramUniform4d = null;
        public static GLDelegate.ProgramUniform4d ProgramUniform4dEXT = ProgramUniform4d;
        /// <summary>
        /// <para>Conventional GLSL requires multiple shader stages (vertex, fragment, geometry, tessellation control, and tessellation evaluation) to be linked into a single monolithic program object to specify a GLSL shader for each stage. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple stages, all existing GPU hardware supports the more flexible mix-and-match approach. Shaders written for HLSL9, Cg, the prior OpenGL assembly program extensions, and game console favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader stages.  Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This extension adopts a "mix-and-match" shader stage model for GLSL allowing multiple different GLSL program objects to be bound at once each to an individual rendering pipeline stage independently of other...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform4d.</para>
        /// <para>Fullname: ProgramUniform4d</para>
        /// <para>Aliases: ProgramUniform4dEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        public static void ProgramUniform4d(uint program, int location, double v0, double v1, double v2, double v3)
        {
            if (gl._ProgramUniform4d != null) gl._ProgramUniform4d(program, location, v0, v1, v2, v3); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform4dv</para>
        /// </summary>
        [GLEntry("ProgramUniform4dv", Category = "ARB", Alias = "ProgramUniform4dvEXT ")]
        public static GLDelegate.ProgramUniform4dv _ProgramUniform4dv = null;
        public static GLDelegate.ProgramUniform4dv ProgramUniform4dvEXT = ProgramUniform4dv;
        /// <summary>
        /// <para>Conventional GLSL requires multiple shader stages (vertex, fragment, geometry, tessellation control, and tessellation evaluation) to be linked into a single monolithic program object to specify a GLSL shader for each stage. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple stages, all existing GPU hardware supports the more flexible mix-and-match approach. Shaders written for HLSL9, Cg, the prior OpenGL assembly program extensions, and game console favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader stages.  Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This extension adopts a "mix-and-match" shader stage model for GLSL allowing multiple different GLSL program objects to be bound at once each to an individual rendering pipeline stage independently of other...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform4dv.</para>
        /// <para>Fullname: ProgramUniform4dv</para>
        /// <para>Aliases: ProgramUniform4dvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        public static void ProgramUniform4dv(uint program, int location, int count, double[] value)
        {
            if (gl._ProgramUniform4dv != null) gl._ProgramUniform4dv(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform4f</para>
        /// </summary>
        [GLEntry("ProgramUniform4f", Category = "ARB", Alias = "ProgramUniform4fEXT ")]
        public static GLDelegate.ProgramUniform4f _ProgramUniform4f = null;
        public static GLDelegate.ProgramUniform4f ProgramUniform4fEXT = ProgramUniform4f;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform4f.</para>
        /// <para>Fullname: ProgramUniform4f</para>
        /// <para>Aliases: ProgramUniform4fEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform4f(uint program, int location, float v0, float v1, float v2, float v3)
        {
            if (gl._ProgramUniform4f != null) gl._ProgramUniform4f(program, location, v0, v1, v2, v3); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform4fv</para>
        /// </summary>
        [GLEntry("ProgramUniform4fv", Category = "ARB", Alias = "ProgramUniform4fvEXT ")]
        public static GLDelegate.ProgramUniform4fv _ProgramUniform4fv = null;
        public static GLDelegate.ProgramUniform4fv ProgramUniform4fvEXT = ProgramUniform4fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform4fv.</para>
        /// <para>Fullname: ProgramUniform4fv</para>
        /// <para>Aliases: ProgramUniform4fvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform4fv(uint program, int location, int count, float[] value)
        {
            if (gl._ProgramUniform4fv != null) gl._ProgramUniform4fv(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform4i</para>
        /// </summary>
        [GLEntry("ProgramUniform4i", Category = "ARB", Alias = "ProgramUniform4iEXT ")]
        public static GLDelegate.ProgramUniform4i _ProgramUniform4i = null;
        public static GLDelegate.ProgramUniform4i ProgramUniform4iEXT = ProgramUniform4i;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform4i.</para>
        /// <para>Fullname: ProgramUniform4i</para>
        /// <para>Aliases: ProgramUniform4iEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform4i(uint program, int location, int v0, int v1, int v2, int v3)
        {
            if (gl._ProgramUniform4i != null) gl._ProgramUniform4i(program, location, v0, v1, v2, v3); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform4iv</para>
        /// </summary>
        [GLEntry("ProgramUniform4iv", Category = "ARB", Alias = "ProgramUniform4ivEXT ")]
        public static GLDelegate.ProgramUniform4iv _ProgramUniform4iv = null;
        public static GLDelegate.ProgramUniform4iv ProgramUniform4ivEXT = ProgramUniform4iv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform4iv.</para>
        /// <para>Fullname: ProgramUniform4iv</para>
        /// <para>Aliases: ProgramUniform4ivEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform4iv(uint program, int location, int count, int[] value)
        {
            if (gl._ProgramUniform4iv != null) gl._ProgramUniform4iv(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform4ui</para>
        /// </summary>
        [GLEntry("ProgramUniform4ui", Category = "ARB", Alias = "ProgramUniform4uiEXT ")]
        public static GLDelegate.ProgramUniform4ui _ProgramUniform4ui = null;
        public static GLDelegate.ProgramUniform4ui ProgramUniform4uiEXT = ProgramUniform4ui;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform4ui.</para>
        /// <para>Fullname: ProgramUniform4ui</para>
        /// <para>Aliases: ProgramUniform4uiEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform4ui(uint program, int location, uint v0, uint v1, uint v2, uint v3)
        {
            if (gl._ProgramUniform4ui != null) gl._ProgramUniform4ui(program, location, v0, v1, v2, v3); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform4uiv</para>
        /// </summary>
        [GLEntry("ProgramUniform4uiv", Category = "ARB", Alias = "ProgramUniform4uivEXT ")]
        public static GLDelegate.ProgramUniform4uiv _ProgramUniform4uiv = null;
        public static GLDelegate.ProgramUniform4uiv ProgramUniform4uivEXT = ProgramUniform4uiv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform4uiv.</para>
        /// <para>Fullname: ProgramUniform4uiv</para>
        /// <para>Aliases: ProgramUniform4uivEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniform4uiv(uint program, int location, int count, uint[] value)
        {
            if (gl._ProgramUniform4uiv != null) gl._ProgramUniform4uiv(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformMatrix2dv</para>
        /// </summary>
        [GLEntry("ProgramUniformMatrix2dv", Category = "ARB", Alias = "ProgramUniformMatrix2dvEXT ")]
        public static GLDelegate.ProgramUniformMatrix2dv _ProgramUniformMatrix2dv = null;
        public static GLDelegate.ProgramUniformMatrix2dv ProgramUniformMatrix2dvEXT = ProgramUniformMatrix2dv;
        /// <summary>
        /// <para>Conventional GLSL requires multiple shader stages (vertex, fragment, geometry, tessellation control, and tessellation evaluation) to be linked into a single monolithic program object to specify a GLSL shader for each stage. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple stages, all existing GPU hardware supports the more flexible mix-and-match approach. Shaders written for HLSL9, Cg, the prior OpenGL assembly program extensions, and game console favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader stages.  Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This extension adopts a "mix-and-match" shader stage model for GLSL allowing multiple different GLSL program objects to be bound at once each to an individual rendering pipeline stage independently of other...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformMatrix2dv.</para>
        /// <para>Fullname: ProgramUniformMatrix2dv</para>
        /// <para>Aliases: ProgramUniformMatrix2dvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        public static void ProgramUniformMatrix2dv(uint program, int location, int count, bool transpose, double[] value)
        {
            if (gl._ProgramUniformMatrix2dv != null) gl._ProgramUniformMatrix2dv(program, location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformMatrix2fv</para>
        /// </summary>
        [GLEntry("ProgramUniformMatrix2fv", Category = "ARB", Alias = "ProgramUniformMatrix2fvEXT ")]
        public static GLDelegate.ProgramUniformMatrix2fv _ProgramUniformMatrix2fv = null;
        public static GLDelegate.ProgramUniformMatrix2fv ProgramUniformMatrix2fvEXT = ProgramUniformMatrix2fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformMatrix2fv.</para>
        /// <para>Fullname: ProgramUniformMatrix2fv</para>
        /// <para>Aliases: ProgramUniformMatrix2fvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniformMatrix2fv(uint program, int location, int count, bool transpose, float[] value)
        {
            if (gl._ProgramUniformMatrix2fv != null) gl._ProgramUniformMatrix2fv(program, location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformMatrix2x3dv</para>
        /// </summary>
        [GLEntry("ProgramUniformMatrix2x3dv", Category = "ARB", Alias = "ProgramUniformMatrix2x3dvEXT ")]
        public static GLDelegate.ProgramUniformMatrix2x3dv _ProgramUniformMatrix2x3dv = null;
        public static GLDelegate.ProgramUniformMatrix2x3dv ProgramUniformMatrix2x3dvEXT = ProgramUniformMatrix2x3dv;
        /// <summary>
        /// <para>Conventional GLSL requires multiple shader stages (vertex, fragment, geometry, tessellation control, and tessellation evaluation) to be linked into a single monolithic program object to specify a GLSL shader for each stage. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple stages, all existing GPU hardware supports the more flexible mix-and-match approach. Shaders written for HLSL9, Cg, the prior OpenGL assembly program extensions, and game console favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader stages.  Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This extension adopts a "mix-and-match" shader stage model for GLSL allowing multiple different GLSL program objects to be bound at once each to an individual rendering pipeline stage independently of other...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformMatrix2x3dv.</para>
        /// <para>Fullname: ProgramUniformMatrix2x3dv</para>
        /// <para>Aliases: ProgramUniformMatrix2x3dvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        public static void ProgramUniformMatrix2x3dv(uint program, int location, int count, bool transpose, double[] value)
        {
            if (gl._ProgramUniformMatrix2x3dv != null) gl._ProgramUniformMatrix2x3dv(program, location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformMatrix2x3fv</para>
        /// </summary>
        [GLEntry("ProgramUniformMatrix2x3fv", Category = "ARB", Alias = "ProgramUniformMatrix2x3fvEXT ")]
        public static GLDelegate.ProgramUniformMatrix2x3fv _ProgramUniformMatrix2x3fv = null;
        public static GLDelegate.ProgramUniformMatrix2x3fv ProgramUniformMatrix2x3fvEXT = ProgramUniformMatrix2x3fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformMatrix2x3fv.</para>
        /// <para>Fullname: ProgramUniformMatrix2x3fv</para>
        /// <para>Aliases: ProgramUniformMatrix2x3fvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniformMatrix2x3fv(uint program, int location, int count, bool transpose, float[] value)
        {
            if (gl._ProgramUniformMatrix2x3fv != null) gl._ProgramUniformMatrix2x3fv(program, location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformMatrix2x4dv</para>
        /// </summary>
        [GLEntry("ProgramUniformMatrix2x4dv", Category = "ARB", Alias = "ProgramUniformMatrix2x4dvEXT ")]
        public static GLDelegate.ProgramUniformMatrix2x4dv _ProgramUniformMatrix2x4dv = null;
        public static GLDelegate.ProgramUniformMatrix2x4dv ProgramUniformMatrix2x4dvEXT = ProgramUniformMatrix2x4dv;
        /// <summary>
        /// <para>Conventional GLSL requires multiple shader stages (vertex, fragment, geometry, tessellation control, and tessellation evaluation) to be linked into a single monolithic program object to specify a GLSL shader for each stage. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple stages, all existing GPU hardware supports the more flexible mix-and-match approach. Shaders written for HLSL9, Cg, the prior OpenGL assembly program extensions, and game console favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader stages.  Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This extension adopts a "mix-and-match" shader stage model for GLSL allowing multiple different GLSL program objects to be bound at once each to an individual rendering pipeline stage independently of other...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformMatrix2x4dv.</para>
        /// <para>Fullname: ProgramUniformMatrix2x4dv</para>
        /// <para>Aliases: ProgramUniformMatrix2x4dvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        public static void ProgramUniformMatrix2x4dv(uint program, int location, int count, bool transpose, double[] value)
        {
            if (gl._ProgramUniformMatrix2x4dv != null) gl._ProgramUniformMatrix2x4dv(program, location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformMatrix2x4fv</para>
        /// </summary>
        [GLEntry("ProgramUniformMatrix2x4fv", Category = "ARB", Alias = "ProgramUniformMatrix2x4fvEXT ")]
        public static GLDelegate.ProgramUniformMatrix2x4fv _ProgramUniformMatrix2x4fv = null;
        public static GLDelegate.ProgramUniformMatrix2x4fv ProgramUniformMatrix2x4fvEXT = ProgramUniformMatrix2x4fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformMatrix2x4fv.</para>
        /// <para>Fullname: ProgramUniformMatrix2x4fv</para>
        /// <para>Aliases: ProgramUniformMatrix2x4fvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniformMatrix2x4fv(uint program, int location, int count, bool transpose, float[] value)
        {
            if (gl._ProgramUniformMatrix2x4fv != null) gl._ProgramUniformMatrix2x4fv(program, location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformMatrix3dv</para>
        /// </summary>
        [GLEntry("ProgramUniformMatrix3dv", Category = "ARB", Alias = "ProgramUniformMatrix3dvEXT ")]
        public static GLDelegate.ProgramUniformMatrix3dv _ProgramUniformMatrix3dv = null;
        public static GLDelegate.ProgramUniformMatrix3dv ProgramUniformMatrix3dvEXT = ProgramUniformMatrix3dv;
        /// <summary>
        /// <para>Conventional GLSL requires multiple shader stages (vertex, fragment, geometry, tessellation control, and tessellation evaluation) to be linked into a single monolithic program object to specify a GLSL shader for each stage. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple stages, all existing GPU hardware supports the more flexible mix-and-match approach. Shaders written for HLSL9, Cg, the prior OpenGL assembly program extensions, and game console favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader stages.  Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This extension adopts a "mix-and-match" shader stage model for GLSL allowing multiple different GLSL program objects to be bound at once each to an individual rendering pipeline stage independently of other...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformMatrix3dv.</para>
        /// <para>Fullname: ProgramUniformMatrix3dv</para>
        /// <para>Aliases: ProgramUniformMatrix3dvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        public static void ProgramUniformMatrix3dv(uint program, int location, int count, bool transpose, double[] value)
        {
            if (gl._ProgramUniformMatrix3dv != null) gl._ProgramUniformMatrix3dv(program, location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformMatrix3fv</para>
        /// </summary>
        [GLEntry("ProgramUniformMatrix3fv", Category = "ARB", Alias = "ProgramUniformMatrix3fvEXT ")]
        public static GLDelegate.ProgramUniformMatrix3fv _ProgramUniformMatrix3fv = null;
        public static GLDelegate.ProgramUniformMatrix3fv ProgramUniformMatrix3fvEXT = ProgramUniformMatrix3fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformMatrix3fv.</para>
        /// <para>Fullname: ProgramUniformMatrix3fv</para>
        /// <para>Aliases: ProgramUniformMatrix3fvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniformMatrix3fv(uint program, int location, int count, bool transpose, float[] value)
        {
            if (gl._ProgramUniformMatrix3fv != null) gl._ProgramUniformMatrix3fv(program, location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformMatrix3x2dv</para>
        /// </summary>
        [GLEntry("ProgramUniformMatrix3x2dv", Category = "ARB", Alias = "ProgramUniformMatrix3x2dvEXT ")]
        public static GLDelegate.ProgramUniformMatrix3x2dv _ProgramUniformMatrix3x2dv = null;
        public static GLDelegate.ProgramUniformMatrix3x2dv ProgramUniformMatrix3x2dvEXT = ProgramUniformMatrix3x2dv;
        /// <summary>
        /// <para>Conventional GLSL requires multiple shader stages (vertex, fragment, geometry, tessellation control, and tessellation evaluation) to be linked into a single monolithic program object to specify a GLSL shader for each stage. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple stages, all existing GPU hardware supports the more flexible mix-and-match approach. Shaders written for HLSL9, Cg, the prior OpenGL assembly program extensions, and game console favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader stages.  Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This extension adopts a "mix-and-match" shader stage model for GLSL allowing multiple different GLSL program objects to be bound at once each to an individual rendering pipeline stage independently of other...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformMatrix3x2dv.</para>
        /// <para>Fullname: ProgramUniformMatrix3x2dv</para>
        /// <para>Aliases: ProgramUniformMatrix3x2dvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        public static void ProgramUniformMatrix3x2dv(uint program, int location, int count, bool transpose, double[] value)
        {
            if (gl._ProgramUniformMatrix3x2dv != null) gl._ProgramUniformMatrix3x2dv(program, location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformMatrix3x2fv</para>
        /// </summary>
        [GLEntry("ProgramUniformMatrix3x2fv", Category = "ARB", Alias = "ProgramUniformMatrix3x2fvEXT ")]
        public static GLDelegate.ProgramUniformMatrix3x2fv _ProgramUniformMatrix3x2fv = null;
        public static GLDelegate.ProgramUniformMatrix3x2fv ProgramUniformMatrix3x2fvEXT = ProgramUniformMatrix3x2fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformMatrix3x2fv.</para>
        /// <para>Fullname: ProgramUniformMatrix3x2fv</para>
        /// <para>Aliases: ProgramUniformMatrix3x2fvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniformMatrix3x2fv(uint program, int location, int count, bool transpose, float[] value)
        {
            if (gl._ProgramUniformMatrix3x2fv != null) gl._ProgramUniformMatrix3x2fv(program, location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformMatrix3x4dv</para>
        /// </summary>
        [GLEntry("ProgramUniformMatrix3x4dv", Category = "ARB", Alias = "ProgramUniformMatrix3x4dvEXT ")]
        public static GLDelegate.ProgramUniformMatrix3x4dv _ProgramUniformMatrix3x4dv = null;
        public static GLDelegate.ProgramUniformMatrix3x4dv ProgramUniformMatrix3x4dvEXT = ProgramUniformMatrix3x4dv;
        /// <summary>
        /// <para>Conventional GLSL requires multiple shader stages (vertex, fragment, geometry, tessellation control, and tessellation evaluation) to be linked into a single monolithic program object to specify a GLSL shader for each stage. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple stages, all existing GPU hardware supports the more flexible mix-and-match approach. Shaders written for HLSL9, Cg, the prior OpenGL assembly program extensions, and game console favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader stages.  Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This extension adopts a "mix-and-match" shader stage model for GLSL allowing multiple different GLSL program objects to be bound at once each to an individual rendering pipeline stage independently of other...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformMatrix3x4dv.</para>
        /// <para>Fullname: ProgramUniformMatrix3x4dv</para>
        /// <para>Aliases: ProgramUniformMatrix3x4dvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        public static void ProgramUniformMatrix3x4dv(uint program, int location, int count, bool transpose, double[] value)
        {
            if (gl._ProgramUniformMatrix3x4dv != null) gl._ProgramUniformMatrix3x4dv(program, location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformMatrix3x4fv</para>
        /// </summary>
        [GLEntry("ProgramUniformMatrix3x4fv", Category = "ARB", Alias = "ProgramUniformMatrix3x4fvEXT ")]
        public static GLDelegate.ProgramUniformMatrix3x4fv _ProgramUniformMatrix3x4fv = null;
        public static GLDelegate.ProgramUniformMatrix3x4fv ProgramUniformMatrix3x4fvEXT = ProgramUniformMatrix3x4fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformMatrix3x4fv.</para>
        /// <para>Fullname: ProgramUniformMatrix3x4fv</para>
        /// <para>Aliases: ProgramUniformMatrix3x4fvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniformMatrix3x4fv(uint program, int location, int count, bool transpose, float[] value)
        {
            if (gl._ProgramUniformMatrix3x4fv != null) gl._ProgramUniformMatrix3x4fv(program, location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformMatrix4dv</para>
        /// </summary>
        [GLEntry("ProgramUniformMatrix4dv", Category = "ARB", Alias = "ProgramUniformMatrix4dvEXT ")]
        public static GLDelegate.ProgramUniformMatrix4dv _ProgramUniformMatrix4dv = null;
        public static GLDelegate.ProgramUniformMatrix4dv ProgramUniformMatrix4dvEXT = ProgramUniformMatrix4dv;
        /// <summary>
        /// <para>Conventional GLSL requires multiple shader stages (vertex, fragment, geometry, tessellation control, and tessellation evaluation) to be linked into a single monolithic program object to specify a GLSL shader for each stage. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple stages, all existing GPU hardware supports the more flexible mix-and-match approach. Shaders written for HLSL9, Cg, the prior OpenGL assembly program extensions, and game console favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader stages.  Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This extension adopts a "mix-and-match" shader stage model for GLSL allowing multiple different GLSL program objects to be bound at once each to an individual rendering pipeline stage independently of other...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformMatrix4dv.</para>
        /// <para>Fullname: ProgramUniformMatrix4dv</para>
        /// <para>Aliases: ProgramUniformMatrix4dvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        public static void ProgramUniformMatrix4dv(uint program, int location, int count, bool transpose, double[] value)
        {
            if (gl._ProgramUniformMatrix4dv != null) gl._ProgramUniformMatrix4dv(program, location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformMatrix4fv</para>
        /// </summary>
        [GLEntry("ProgramUniformMatrix4fv", Category = "ARB", Alias = "ProgramUniformMatrix4fvEXT ")]
        public static GLDelegate.ProgramUniformMatrix4fv _ProgramUniformMatrix4fv = null;
        public static GLDelegate.ProgramUniformMatrix4fv ProgramUniformMatrix4fvEXT = ProgramUniformMatrix4fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformMatrix4fv.</para>
        /// <para>Fullname: ProgramUniformMatrix4fv</para>
        /// <para>Aliases: ProgramUniformMatrix4fvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniformMatrix4fv(uint program, int location, int count, bool transpose, float[] value)
        {
            if (gl._ProgramUniformMatrix4fv != null) gl._ProgramUniformMatrix4fv(program, location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformMatrix4x2dv</para>
        /// </summary>
        [GLEntry("ProgramUniformMatrix4x2dv", Category = "ARB", Alias = "ProgramUniformMatrix4x2dvEXT ")]
        public static GLDelegate.ProgramUniformMatrix4x2dv _ProgramUniformMatrix4x2dv = null;
        public static GLDelegate.ProgramUniformMatrix4x2dv ProgramUniformMatrix4x2dvEXT = ProgramUniformMatrix4x2dv;
        /// <summary>
        /// <para>Conventional GLSL requires multiple shader stages (vertex, fragment, geometry, tessellation control, and tessellation evaluation) to be linked into a single monolithic program object to specify a GLSL shader for each stage. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple stages, all existing GPU hardware supports the more flexible mix-and-match approach. Shaders written for HLSL9, Cg, the prior OpenGL assembly program extensions, and game console favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader stages.  Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This extension adopts a "mix-and-match" shader stage model for GLSL allowing multiple different GLSL program objects to be bound at once each to an individual rendering pipeline stage independently of other...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformMatrix4x2dv.</para>
        /// <para>Fullname: ProgramUniformMatrix4x2dv</para>
        /// <para>Aliases: ProgramUniformMatrix4x2dvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        public static void ProgramUniformMatrix4x2dv(uint program, int location, int count, bool transpose, double[] value)
        {
            if (gl._ProgramUniformMatrix4x2dv != null) gl._ProgramUniformMatrix4x2dv(program, location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformMatrix4x2fv</para>
        /// </summary>
        [GLEntry("ProgramUniformMatrix4x2fv", Category = "ARB", Alias = "ProgramUniformMatrix4x2fvEXT ")]
        public static GLDelegate.ProgramUniformMatrix4x2fv _ProgramUniformMatrix4x2fv = null;
        public static GLDelegate.ProgramUniformMatrix4x2fv ProgramUniformMatrix4x2fvEXT = ProgramUniformMatrix4x2fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformMatrix4x2fv.</para>
        /// <para>Fullname: ProgramUniformMatrix4x2fv</para>
        /// <para>Aliases: ProgramUniformMatrix4x2fvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniformMatrix4x2fv(uint program, int location, int count, bool transpose, float[] value)
        {
            if (gl._ProgramUniformMatrix4x2fv != null) gl._ProgramUniformMatrix4x2fv(program, location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformMatrix4x3dv</para>
        /// </summary>
        [GLEntry("ProgramUniformMatrix4x3dv", Category = "ARB", Alias = "ProgramUniformMatrix4x3dvEXT ")]
        public static GLDelegate.ProgramUniformMatrix4x3dv _ProgramUniformMatrix4x3dv = null;
        public static GLDelegate.ProgramUniformMatrix4x3dv ProgramUniformMatrix4x3dvEXT = ProgramUniformMatrix4x3dv;
        /// <summary>
        /// <para>Conventional GLSL requires multiple shader stages (vertex, fragment, geometry, tessellation control, and tessellation evaluation) to be linked into a single monolithic program object to specify a GLSL shader for each stage. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple stages, all existing GPU hardware supports the more flexible mix-and-match approach. Shaders written for HLSL9, Cg, the prior OpenGL assembly program extensions, and game console favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader stages.  Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This extension adopts a "mix-and-match" shader stage model for GLSL allowing multiple different GLSL program objects to be bound at once each to an individual rendering pipeline stage independently of other...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformMatrix4x3dv.</para>
        /// <para>Fullname: ProgramUniformMatrix4x3dv</para>
        /// <para>Aliases: ProgramUniformMatrix4x3dvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        public static void ProgramUniformMatrix4x3dv(uint program, int location, int count, bool transpose, double[] value)
        {
            if (gl._ProgramUniformMatrix4x3dv != null) gl._ProgramUniformMatrix4x3dv(program, location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformMatrix4x3fv</para>
        /// </summary>
        [GLEntry("ProgramUniformMatrix4x3fv", Category = "ARB", Alias = "ProgramUniformMatrix4x3fvEXT ")]
        public static GLDelegate.ProgramUniformMatrix4x3fv _ProgramUniformMatrix4x3fv = null;
        public static GLDelegate.ProgramUniformMatrix4x3fv ProgramUniformMatrix4x3fvEXT = ProgramUniformMatrix4x3fv;
        /// <summary>
        /// <para>Specify the value of a uniform variable for a specified program object</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformMatrix4x3fv.</para>
        /// <para>Fullname: ProgramUniformMatrix4x3fv</para>
        /// <para>Aliases: ProgramUniformMatrix4x3fvEXT, </para>
        /// <para>Extensions: ARB_separate_shader_objects EXT_direct_state_access</para>
        /// </summary>
        /// <param name="program">Specifies the handle of the program containing the uniform variable to be modified.</param>
        /// <param name="location">Specifies the location of the uniform variable to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v1">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v2">Specifies the new values to be used for the specified uniform variable.</param>
        /// <param name="v3">Specifies the new values to be used for the specified uniform variable.</param>
        public static void ProgramUniformMatrix4x3fv(uint program, int location, int count, bool transpose, float[] value)
        {
            if (gl._ProgramUniformMatrix4x3fv != null) gl._ProgramUniformMatrix4x3fv(program, location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProvokingVertex</para>
        /// </summary>
        [GLEntry("ProvokingVertex", Category = "ARB", Alias = "ProvokingVertexEXT ")]
        public static GLDelegate.ProvokingVertex _ProvokingVertex = null;
        public static GLDelegate.ProvokingVertex ProvokingVertexEXT = ProvokingVertex;
        /// <summary>
        /// <para>specifiy the vertex to be used as the source of data for flat shaded varyings</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProvokingVertex.</para>
        /// <para>Fullname: ProvokingVertex</para>
        /// <para>Aliases: ProvokingVertexEXT, </para>
        /// <para>Extensions: ARB_provoking_vertex EXT_provoking_vertex</para>
        /// </summary>
        /// <param name="provokeMode">Specifies the vertex to be used as the source of data for flat shaded varyings.</param>
        public static void ProvokingVertex(int mode)
        {
            if (gl._ProvokingVertex != null) gl._ProvokingVertex(mode); else { }
        }
        /// <summary>
        /// <para>Fullname: QueryCounter</para>
        /// </summary>
        [GLEntry("QueryCounter", Category = "ARB")]
        public static GLDelegate.QueryCounter _QueryCounter = null;
        /// <summary>
        /// <para>record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _QueryCounter.</para>
        /// <para>Fullname: QueryCounter</para>
        /// <para>Extensions: ARB_timer_query</para>
        /// </summary>
        /// <param name="id">Specify the name of a query object into which to record the GL time.</param>
        /// <param name="target">Specify the counter to query. target must be GL_TIMESTAMP.</param>
        public static void QueryCounter(uint id, int target)
        {
            if (gl._QueryCounter != null) gl._QueryCounter(id, target); else { }
        }
        /// <summary>
        /// <para>Fullname: ReadnPixelsARB</para>
        /// </summary>
        [GLEntry("ReadnPixelsARB", Category = "ARB")]
        public static GLDelegate.ReadnPixels _ReadnPixels = null;
        /// <summary>
        /// <para>Several recent trends in how OpenGL integrates into modern computer systems have created new requirements for robustness and security for OpenGL rendering contexts.  Additionally GPU architectures now support hardware fault detection; for example, video memory supporting ECC (error correcting codes) and error detection.  OpenGL contexts should be capable of recovering from hardware faults such as uncorrectable memory errors.  Along with recovery from such hardware faults, the recovery mechanism can also allow recovery from video memory access exceptions and system software failures.  System software failures can be due to device changes or driver failures. Demands for increased software robustness and concerns about malware exploiting buffer overflows have lead API designers to provide additional "safe" APIs that bound the amount of data returned by an API query.  For example, the safer "snprintf" or "_snprintf" routines are prefered over "sprintf".  The OpenGL API has many such robust...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReadnPixels.</para>
        /// <para>Fullname: ReadnPixelsARB</para>
        /// <para>Extensions: ARB_robustness</para>
        /// </summary>
        public static void ReadnPixels(int x, int y, int width, int height, int format, int type, int bufSize, IntPtr data)
        {
            if (gl._ReadnPixels != null) gl._ReadnPixels(x, y, width, height, format, type, bufSize, data); else { }
        }
        /// <summary>
        /// <para>Fullname: ReleaseShaderCompiler</para>
        /// </summary>
        [GLEntry("ReleaseShaderCompiler", Category = "ARB")]
        public static GLDelegate.ReleaseShaderCompiler _ReleaseShaderCompiler = null;
        /// <summary>
        /// <para>release resources consumed by the implementation's shader compiler</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReleaseShaderCompiler.</para>
        /// <para>Fullname: ReleaseShaderCompiler</para>
        /// <para>Extensions: ARB_ES2_compatibility</para>
        /// </summary>
        public static void ReleaseShaderCompiler()
        {
            if (gl._ReleaseShaderCompiler != null) gl._ReleaseShaderCompiler(); else { }
        }
        /// <summary>
        /// <para>Fullname: RenderbufferStorage</para>
        /// </summary>
        [GLEntry("RenderbufferStorage", Category = "ARB", Alias = "RenderbufferStorageEXT ")]
        public static GLDelegate.RenderbufferStorage _RenderbufferStorage = null;
        public static GLDelegate.RenderbufferStorage RenderbufferStorageEXT = RenderbufferStorage;
        /// <summary>
        /// <para>establish data storage, format and dimensions of a renderbuffer object's image</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RenderbufferStorage.</para>
        /// <para>Fullname: RenderbufferStorage</para>
        /// <para>Aliases: RenderbufferStorageEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_object</para>
        /// </summary>
        /// <param name="target">Specifies a binding to which the target of the allocation and must be GL_RENDERBUFFER.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object's image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        public static void RenderbufferStorage(int target, int internalformat, int width, int height)
        {
            if (gl._RenderbufferStorage != null) gl._RenderbufferStorage(target, internalformat, width, height); else { }
        }
        /// <summary>
        /// <para>Fullname: RenderbufferStorageMultisample</para>
        /// </summary>
        [GLEntry("RenderbufferStorageMultisample", Category = "ARB", Alias = "RenderbufferStorageMultisampleEXT ")]
        public static GLDelegate.RenderbufferStorageMultisample _RenderbufferStorageMultisample = null;
        public static GLDelegate.RenderbufferStorageMultisample RenderbufferStorageMultisampleEXT = RenderbufferStorageMultisample;
        /// <summary>
        /// <para>establish data storage, format, dimensions and sample count of a renderbuffer object's image</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RenderbufferStorageMultisample.</para>
        /// <para>Fullname: RenderbufferStorageMultisample</para>
        /// <para>Aliases: RenderbufferStorageMultisampleEXT, </para>
        /// <para>Extensions: ARB_framebuffer_object EXT_framebuffer_multisample</para>
        /// </summary>
        /// <param name="target">Specifies a binding to which the target of the allocation and must be GL_RENDERBUFFER.</param>
        /// <param name="samples">Specifies the number of samples to be used for the renderbuffer object's storage.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer object's image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        public static void RenderbufferStorageMultisample(int target, int samples, int internalformat, int width, int height)
        {
            if (gl._RenderbufferStorageMultisample != null) gl._RenderbufferStorageMultisample(target, samples, internalformat, width, height); else { }
        }
        /// <summary>
        /// <para>Fullname: ResumeTransformFeedback</para>
        /// </summary>
        [GLEntry("ResumeTransformFeedback", Category = "ARB", Alias = "ResumeTransformFeedbackNV ")]
        public static GLDelegate.ResumeTransformFeedback _ResumeTransformFeedback = null;
        public static GLDelegate.ResumeTransformFeedback ResumeTransformFeedbackNV = ResumeTransformFeedback;
        /// <summary>
        /// <para>resume transform feedback operations</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ResumeTransformFeedback.</para>
        /// <para>Fullname: ResumeTransformFeedback</para>
        /// <para>Aliases: ResumeTransformFeedbackNV, </para>
        /// <para>Extensions: ARB_transform_feedback2 NV_transform_feedback2</para>
        /// </summary>
        public static void ResumeTransformFeedback()
        {
            if (gl._ResumeTransformFeedback != null) gl._ResumeTransformFeedback(); else { }
        }
        /// <summary>
        /// <para>Fullname: SampleMaski</para>
        /// </summary>
        [GLEntry("SampleMaski", Category = "ARB")]
        public static GLDelegate.SampleMaski _SampleMaski = null;
        /// <summary>
        /// <para>set the value of a sub-word of the sample mask</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SampleMaski.</para>
        /// <para>Fullname: SampleMaski</para>
        /// <para>Extensions: ARB_texture_multisample</para>
        /// </summary>
        /// <param name="maskNumber">Specifies which 32-bit sub-word of the sample mask to update.</param>
        /// <param name="mask">Specifies the new value of the mask sub-word.</param>
        public static void SampleMaski(uint index, int mask)
        {
            if (gl._SampleMaski != null) gl._SampleMaski(index, mask); else { }
        }
        /// <summary>
        /// <para>Fullname: SamplerParameterf</para>
        /// </summary>
        [GLEntry("SamplerParameterf", Category = "ARB")]
        public static GLDelegate.SamplerParameterf _SamplerParameterf = null;
        /// <summary>
        /// <para>set sampler parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SamplerParameterf.</para>
        /// <para>Fullname: SamplerParameterf</para>
        /// <para>Extensions: ARB_sampler_objects</para>
        /// </summary>
        /// <param name="sampler">Specifies the sampler object whose parameter to modify.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIASGL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.</param>
        /// <param name="param">Specifies the value of pname.</param>
        public static void SamplerParameterf(uint sampler, int pname, float param)
        {
            if (gl._SamplerParameterf != null) gl._SamplerParameterf(sampler, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: SamplerParameterfv</para>
        /// </summary>
        [GLEntry("SamplerParameterfv", Category = "ARB")]
        public static GLDelegate.SamplerParameterfv _SamplerParameterfv = null;
        /// <summary>
        /// <para>set sampler parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SamplerParameterfv.</para>
        /// <para>Fullname: SamplerParameterfv</para>
        /// <para>Extensions: ARB_sampler_objects</para>
        /// </summary>
        /// <param name="sampler">Specifies the sampler object whose parameter to modify.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIASGL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.</param>
        /// <param name="param">Specifies the value of pname.</param>
        public static void SamplerParameterfv(uint sampler, int pname, float[] param)
        {
            if (gl._SamplerParameterfv != null) gl._SamplerParameterfv(sampler, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: SamplerParameteri</para>
        /// </summary>
        [GLEntry("SamplerParameteri", Category = "ARB")]
        public static GLDelegate.SamplerParameteri _SamplerParameteri = null;
        /// <summary>
        /// <para>set sampler parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SamplerParameteri.</para>
        /// <para>Fullname: SamplerParameteri</para>
        /// <para>Extensions: ARB_sampler_objects</para>
        /// </summary>
        /// <param name="sampler">Specifies the sampler object whose parameter to modify.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIASGL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.</param>
        /// <param name="param">Specifies the value of pname.</param>
        public static void SamplerParameteri(uint sampler, int pname, int param)
        {
            if (gl._SamplerParameteri != null) gl._SamplerParameteri(sampler, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: SamplerParameterIiv</para>
        /// </summary>
        [GLEntry("SamplerParameterIiv", Category = "ARB")]
        public static GLDelegate.SamplerParameterIiv _SamplerParameterIiv = null;
        /// <summary>
        /// <para>set sampler parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SamplerParameterIiv.</para>
        /// <para>Fullname: SamplerParameterIiv</para>
        /// <para>Extensions: ARB_sampler_objects</para>
        /// </summary>
        /// <param name="sampler">Specifies the sampler object whose parameter to modify.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIASGL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.</param>
        /// <param name="param">Specifies the value of pname.</param>
        public static void SamplerParameterIiv(uint sampler, int pname, int[] param)
        {
            if (gl._SamplerParameterIiv != null) gl._SamplerParameterIiv(sampler, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: SamplerParameterIuiv</para>
        /// </summary>
        [GLEntry("SamplerParameterIuiv", Category = "ARB")]
        public static GLDelegate.SamplerParameterIuiv _SamplerParameterIuiv = null;
        /// <summary>
        /// <para>set sampler parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SamplerParameterIuiv.</para>
        /// <para>Fullname: SamplerParameterIuiv</para>
        /// <para>Extensions: ARB_sampler_objects</para>
        /// </summary>
        /// <param name="sampler">Specifies the sampler object whose parameter to modify.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIASGL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.</param>
        /// <param name="param">Specifies the value of pname.</param>
        public static void SamplerParameterIuiv(uint sampler, int pname, uint[] param)
        {
            if (gl._SamplerParameterIuiv != null) gl._SamplerParameterIuiv(sampler, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: SamplerParameteriv</para>
        /// </summary>
        [GLEntry("SamplerParameteriv", Category = "ARB")]
        public static GLDelegate.SamplerParameteriv _SamplerParameteriv = null;
        /// <summary>
        /// <para>set sampler parameters</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SamplerParameteriv.</para>
        /// <para>Fullname: SamplerParameteriv</para>
        /// <para>Extensions: ARB_sampler_objects</para>
        /// </summary>
        /// <param name="sampler">Specifies the sampler object whose parameter to modify.</param>
        /// <param name="pname">Specifies the symbolic name of a single-valued sampler parameter. pname can be one of the following: GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIASGL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.</param>
        /// <param name="param">Specifies the value of pname.</param>
        public static void SamplerParameteriv(uint sampler, int pname, int[] param)
        {
            if (gl._SamplerParameteriv != null) gl._SamplerParameteriv(sampler, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ScissorArrayv</para>
        /// </summary>
        [GLEntry("ScissorArrayv", Category = "ARB")]
        public static GLDelegate.ScissorArrayv _ScissorArrayv = null;
        /// <summary>
        /// <para>define the scissor box for multiple viewports</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ScissorArrayv.</para>
        /// <para>Fullname: ScissorArrayv</para>
        /// <para>Extensions: ARB_viewport_array</para>
        /// </summary>
        /// <param name="first">Specifies the index of the first viewport whose scissor box to modify.</param>
        /// <param name="count">Specifies the number of scissor boxes to modify.</param>
        /// <param name="v">Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.</param>
        public static void ScissorArrayv(uint first, int count, int[] v)
        {
            if (gl._ScissorArrayv != null) gl._ScissorArrayv(first, count, v); else { }
        }
        /// <summary>
        /// <para>Fullname: ScissorIndexed</para>
        /// </summary>
        [GLEntry("ScissorIndexed", Category = "ARB")]
        public static GLDelegate.ScissorIndexed _ScissorIndexed = null;
        /// <summary>
        /// <para>define the scissor box for a specific viewport</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ScissorIndexed.</para>
        /// <para>Fullname: ScissorIndexed</para>
        /// <para>Extensions: ARB_viewport_array</para>
        /// </summary>
        /// <param name="index">Specifies the index of the viewport whose scissor box to modify.</param>
        /// <param name="left">Specify the coordinate of the bottom left corner of the scissor box, in pixels.</param>
        /// <param name="bottom">Specify the coordinate of the bottom left corner of the scissor box, in pixels.</param>
        /// <param name="width">Specify ths dimensions of the scissor box, in pixels.</param>
        /// <param name="height">Specify ths dimensions of the scissor box, in pixels.</param>
        /// <param name="v">For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.</param>
        public static void ScissorIndexed(uint index, int left, int bottom, int width, int height)
        {
            if (gl._ScissorIndexed != null) gl._ScissorIndexed(index, left, bottom, width, height); else { }
        }
        /// <summary>
        /// <para>Fullname: ScissorIndexedv</para>
        /// </summary>
        [GLEntry("ScissorIndexedv", Category = "ARB")]
        public static GLDelegate.ScissorIndexedv _ScissorIndexedv = null;
        /// <summary>
        /// <para>define the scissor box for a specific viewport</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ScissorIndexedv.</para>
        /// <para>Fullname: ScissorIndexedv</para>
        /// <para>Extensions: ARB_viewport_array</para>
        /// </summary>
        /// <param name="index">Specifies the index of the viewport whose scissor box to modify.</param>
        /// <param name="left">Specify the coordinate of the bottom left corner of the scissor box, in pixels.</param>
        /// <param name="bottom">Specify the coordinate of the bottom left corner of the scissor box, in pixels.</param>
        /// <param name="width">Specify ths dimensions of the scissor box, in pixels.</param>
        /// <param name="height">Specify ths dimensions of the scissor box, in pixels.</param>
        /// <param name="v">For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.</param>
        public static void ScissorIndexedv(uint index, int[] v)
        {
            if (gl._ScissorIndexedv != null) gl._ScissorIndexedv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColorP3ui</para>
        /// </summary>
        [GLEntry("SecondaryColorP3ui", Category = "ARB")]
        public static GLDelegate.SecondaryColorP3ui _SecondaryColorP3ui = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColorP3ui.</para>
        /// <para>Fullname: SecondaryColorP3ui</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void SecondaryColorP3ui(int type, uint color)
        {
            if (gl._SecondaryColorP3ui != null) gl._SecondaryColorP3ui(type, color); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColorP3uiv</para>
        /// </summary>
        [GLEntry("SecondaryColorP3uiv", Category = "ARB")]
        public static GLDelegate.SecondaryColorP3uiv _SecondaryColorP3uiv = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColorP3uiv.</para>
        /// <para>Fullname: SecondaryColorP3uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void SecondaryColorP3uiv(int type, uint[] color)
        {
            if (gl._SecondaryColorP3uiv != null) gl._SecondaryColorP3uiv(type, color); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColorP3uiv</para>
        /// </summary>
        [GLEntry("SecondaryColorP3uiv", Category = "ARB")]
        public static GLDelegate.SecondaryColorP3uiv_uint _SecondaryColorP3uiv_uint = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColorP3uiv_uint.</para>
        /// <para>Fullname: SecondaryColorP3uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void SecondaryColorP3uiv(int type, ref uint color)
        {
            if (gl._SecondaryColorP3uiv_uint != null) gl._SecondaryColorP3uiv_uint(type, ref color); else { }
        }
        /// <summary>
        /// <para>Fullname: ShaderBinary</para>
        /// </summary>
        [GLEntry("ShaderBinary", Category = "ARB")]
        public static GLDelegate.ShaderBinary _ShaderBinary = null;
        /// <summary>
        /// <para>load pre-compiled shader binaries</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ShaderBinary.</para>
        /// <para>Fullname: ShaderBinary</para>
        /// <para>Extensions: ARB_ES2_compatibility</para>
        /// </summary>
        /// <param name="count">Specifies the number of shader object handles contained in shaders.</param>
        /// <param name="shaders">Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.</param>
        /// <param name="binaryFormat">Specifies the format of the shader binaries contained in binary.</param>
        /// <param name="binary">Specifies the address of an array of bytes containing pre-compiled binary shader code.</param>
        /// <param name="length">Specifies the length of the array whose address is given in binary.</param>
        public static void ShaderBinary(int count, uint[] shaders, int binaryformat, IntPtr binary, int length)
        {
            if (gl._ShaderBinary != null) gl._ShaderBinary(count, shaders, binaryformat, binary, length); else { }
        }
        /// <summary>
        /// <para>Fullname: ShaderStorageBlockBinding</para>
        /// </summary>
        [GLEntry("ShaderStorageBlockBinding", Category = "ARB")]
        public static GLDelegate.ShaderStorageBlockBinding _ShaderStorageBlockBinding = null;
        /// <summary>
        /// <para>change an active shader storage block binding</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ShaderStorageBlockBinding.</para>
        /// <para>Fullname: ShaderStorageBlockBinding</para>
        /// <para>Extensions: ARB_shader_storage_buffer_object</para>
        /// </summary>
        /// <param name="program">The name of the program containing the block whose binding to change.</param>
        /// <param name="storageBlockIndex">The index storage block within the program.</param>
        /// <param name="storageBlockBinding">The index storage block binding to associate with the specified storage block.</param>
        public static void ShaderStorageBlockBinding(uint program, uint storageBlockIndex, uint storageBlockBinding)
        {
            if (gl._ShaderStorageBlockBinding != null) gl._ShaderStorageBlockBinding(program, storageBlockIndex, storageBlockBinding); else { }
        }
        /// <summary>
        /// <para>Fullname: TexBufferRange</para>
        /// </summary>
        [GLEntry("TexBufferRange", Category = "ARB")]
        public static GLDelegate.TexBufferRange _TexBufferRange = null;
        /// <summary>
        /// <para>bind a range of a buffer's data store to a buffer texture</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexBufferRange.</para>
        /// <para>Fullname: TexBufferRange</para>
        /// <para>Extensions: ARB_texture_buffer_range</para>
        /// </summary>
        /// <param name="target">Specifies the target of the operation and must be GL_TEXTURE_BUFFER.</param>
        /// <param name="internalFormat">Specifies the internal format of the data in the store belonging to buffer.</param>
        /// <param name="buffer">Specifies the name of the buffer object whose storage to attach to the active buffer texture.</param>
        /// <param name="offset">Specifies the offset of the start of the range of the buffer's data store to attach.</param>
        /// <param name="size">Specifies the size of the range of the buffer's data store to attach.</param>
        public static void TexBufferRange(int target, int internalformat, uint buffer, int offset, int size)
        {
            if (gl._TexBufferRange != null) gl._TexBufferRange(target, internalformat, buffer, offset, size); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoordP1ui</para>
        /// </summary>
        [GLEntry("TexCoordP1ui", Category = "ARB")]
        public static GLDelegate.TexCoordP1ui _TexCoordP1ui = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoordP1ui.</para>
        /// <para>Fullname: TexCoordP1ui</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void TexCoordP1ui(int type, uint coords)
        {
            if (gl._TexCoordP1ui != null) gl._TexCoordP1ui(type, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoordP1uiv</para>
        /// </summary>
        [GLEntry("TexCoordP1uiv", Category = "ARB")]
        public static GLDelegate.TexCoordP1uiv_uint _TexCoordP1uiv_uint = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoordP1uiv_uint.</para>
        /// <para>Fullname: TexCoordP1uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void TexCoordP1uiv(int type, ref uint coords)
        {
            if (gl._TexCoordP1uiv_uint != null) gl._TexCoordP1uiv_uint(type, ref coords); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoordP1uiv</para>
        /// </summary>
        [GLEntry("TexCoordP1uiv", Category = "ARB")]
        public static GLDelegate.TexCoordP1uiv _TexCoordP1uiv = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoordP1uiv.</para>
        /// <para>Fullname: TexCoordP1uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void TexCoordP1uiv(int type, uint[] coords)
        {
            if (gl._TexCoordP1uiv != null) gl._TexCoordP1uiv(type, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoordP2ui</para>
        /// </summary>
        [GLEntry("TexCoordP2ui", Category = "ARB")]
        public static GLDelegate.TexCoordP2ui _TexCoordP2ui = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoordP2ui.</para>
        /// <para>Fullname: TexCoordP2ui</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void TexCoordP2ui(int type, uint coords)
        {
            if (gl._TexCoordP2ui != null) gl._TexCoordP2ui(type, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoordP2uiv</para>
        /// </summary>
        [GLEntry("TexCoordP2uiv", Category = "ARB")]
        public static GLDelegate.TexCoordP2uiv _TexCoordP2uiv = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoordP2uiv.</para>
        /// <para>Fullname: TexCoordP2uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void TexCoordP2uiv(int type, uint[] coords)
        {
            if (gl._TexCoordP2uiv != null) gl._TexCoordP2uiv(type, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoordP2uiv</para>
        /// </summary>
        [GLEntry("TexCoordP2uiv", Category = "ARB")]
        public static GLDelegate.TexCoordP2uiv_uint _TexCoordP2uiv_uint = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoordP2uiv_uint.</para>
        /// <para>Fullname: TexCoordP2uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void TexCoordP2uiv(int type, ref uint coords)
        {
            if (gl._TexCoordP2uiv_uint != null) gl._TexCoordP2uiv_uint(type, ref coords); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoordP3ui</para>
        /// </summary>
        [GLEntry("TexCoordP3ui", Category = "ARB")]
        public static GLDelegate.TexCoordP3ui _TexCoordP3ui = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoordP3ui.</para>
        /// <para>Fullname: TexCoordP3ui</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void TexCoordP3ui(int type, uint coords)
        {
            if (gl._TexCoordP3ui != null) gl._TexCoordP3ui(type, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoordP3uiv</para>
        /// </summary>
        [GLEntry("TexCoordP3uiv", Category = "ARB")]
        public static GLDelegate.TexCoordP3uiv _TexCoordP3uiv = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoordP3uiv.</para>
        /// <para>Fullname: TexCoordP3uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void TexCoordP3uiv(int type, uint[] coords)
        {
            if (gl._TexCoordP3uiv != null) gl._TexCoordP3uiv(type, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoordP3uiv</para>
        /// </summary>
        [GLEntry("TexCoordP3uiv", Category = "ARB")]
        public static GLDelegate.TexCoordP3uiv_uint _TexCoordP3uiv_uint = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoordP3uiv_uint.</para>
        /// <para>Fullname: TexCoordP3uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void TexCoordP3uiv(int type, ref uint coords)
        {
            if (gl._TexCoordP3uiv_uint != null) gl._TexCoordP3uiv_uint(type, ref coords); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoordP4ui</para>
        /// </summary>
        [GLEntry("TexCoordP4ui", Category = "ARB")]
        public static GLDelegate.TexCoordP4ui _TexCoordP4ui = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoordP4ui.</para>
        /// <para>Fullname: TexCoordP4ui</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void TexCoordP4ui(int type, uint coords)
        {
            if (gl._TexCoordP4ui != null) gl._TexCoordP4ui(type, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoordP4uiv</para>
        /// </summary>
        [GLEntry("TexCoordP4uiv", Category = "ARB")]
        public static GLDelegate.TexCoordP4uiv _TexCoordP4uiv = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoordP4uiv.</para>
        /// <para>Fullname: TexCoordP4uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void TexCoordP4uiv(int type, uint[] coords)
        {
            if (gl._TexCoordP4uiv != null) gl._TexCoordP4uiv(type, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoordP4uiv</para>
        /// </summary>
        [GLEntry("TexCoordP4uiv", Category = "ARB")]
        public static GLDelegate.TexCoordP4uiv_uint _TexCoordP4uiv_uint = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoordP4uiv_uint.</para>
        /// <para>Fullname: TexCoordP4uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void TexCoordP4uiv(int type, ref uint coords)
        {
            if (gl._TexCoordP4uiv_uint != null) gl._TexCoordP4uiv_uint(type, ref coords); else { }
        }
        /// <summary>
        /// <para>Fullname: TexImage2DMultisample</para>
        /// </summary>
        [GLEntry("TexImage2DMultisample", Category = "ARB")]
        public static GLDelegate.TexImage2DMultisample _TexImage2DMultisample = null;
        /// <summary>
        /// <para>establish the data storage, format, dimensions, and number of samples of a multisample texture's image</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexImage2DMultisample.</para>
        /// <para>Fullname: TexImage2DMultisample</para>
        /// <para>Extensions: ARB_texture_multisample</para>
        /// </summary>
        /// <param name="target">Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE.</param>
        /// <param name="samples">The number of samples in the multisample texture's image.</param>
        /// <param name="internalformat">The internal format to be used to store the multisample texture's image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format.</param>
        /// <param name="width">The width of the multisample texture's image, in texels.</param>
        /// <param name="height">The height of the multisample texture's image, in texels.</param>
        /// <param name="fixedsamplelocations">Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.</param>
        public static void TexImage2DMultisample(int target, int samples, int internalformat, int width, int height, bool fixedsamplelocations)
        {
            if (gl._TexImage2DMultisample != null) gl._TexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations); else { }
        }
        /// <summary>
        /// <para>Fullname: TexImage3DMultisample</para>
        /// </summary>
        [GLEntry("TexImage3DMultisample", Category = "ARB")]
        public static GLDelegate.TexImage3DMultisample _TexImage3DMultisample = null;
        /// <summary>
        /// <para>establish the data storage, format, dimensions, and number of samples of a multisample texture's image</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexImage3DMultisample.</para>
        /// <para>Fullname: TexImage3DMultisample</para>
        /// <para>Extensions: ARB_texture_multisample</para>
        /// </summary>
        /// <param name="target">Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY.</param>
        /// <param name="samples">The number of samples in the multisample texture's image.</param>
        /// <param name="internalformat">The internal format to be used to store the multisample texture's image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format.</param>
        /// <param name="width">The width of the multisample texture's image, in texels.</param>
        /// <param name="height">The height of the multisample texture's image, in texels.</param>
        /// <param name="fixedsamplelocations">Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.</param>
        public static void TexImage3DMultisample(int target, int samples, int internalformat, int width, int height, int depth, bool fixedsamplelocations)
        {
            if (gl._TexImage3DMultisample != null) gl._TexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations); else { }
        }
        /// <summary>
        /// <para>Fullname: TexStorage1D</para>
        /// </summary>
        [GLEntry("TexStorage1D", Category = "ARB")]
        public static GLDelegate.TexStorage1D _TexStorage1D = null;
        /// <summary>
        /// <para>simultaneously specify storage for all levels of a one-dimensional texture</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexStorage1D.</para>
        /// <para>Fullname: TexStorage1D</para>
        /// <para>Extensions: ARB_texture_storage</para>
        /// </summary>
        /// <param name="target">Specify the target of the operation. target must be either GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.</param>
        /// <param name="levels">Specify the number of texture levels.</param>
        /// <param name="internalformat">Specifies the sized internal format to be used to store texture image data.</param>
        /// <param name="width">Specifies the width of the texture, in texels.</param>
        public static void TexStorage1D(int target, int levels, int internalformat, int width)
        {
            if (gl._TexStorage1D != null) gl._TexStorage1D(target, levels, internalformat, width); else { }
        }
        /// <summary>
        /// <para>Fullname: TexStorage2D</para>
        /// </summary>
        [GLEntry("TexStorage2D", Category = "ARB")]
        public static GLDelegate.TexStorage2D _TexStorage2D = null;
        /// <summary>
        /// <para>simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexStorage2D.</para>
        /// <para>Fullname: TexStorage2D</para>
        /// <para>Extensions: ARB_texture_storage</para>
        /// </summary>
        /// <param name="target">Specify the target of the operation. target must be one of GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP.</param>
        /// <param name="levels">Specify the number of texture levels.</param>
        /// <param name="internalformat">Specifies the sized internal format to be used to store texture image data.</param>
        /// <param name="width">Specifies the width of the texture, in texels.</param>
        /// <param name="height">Specifies the height of the texture, in texels.</param>
        public static void TexStorage2D(int target, int levels, int internalformat, int width, int height)
        {
            if (gl._TexStorage2D != null) gl._TexStorage2D(target, levels, internalformat, width, height); else { }
        }
        /// <summary>
        /// <para>Fullname: TexStorage2DMultisample</para>
        /// </summary>
        [GLEntry("TexStorage2DMultisample", Category = "ARB")]
        public static GLDelegate.TexStorage2DMultisample _TexStorage2DMultisample = null;
        /// <summary>
        /// <para>specify storage for a two-dimensional multisample texture</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexStorage2DMultisample.</para>
        /// <para>Fullname: TexStorage2DMultisample</para>
        /// <para>Extensions: ARB_texture_storage_multisample</para>
        /// </summary>
        /// <param name="target">Specify the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE.</param>
        /// <param name="samples">Specify the number of samples in the texture.</param>
        /// <param name="internalformat">Specifies the sized internal format to be used to store texture image data.</param>
        /// <param name="width">Specifies the width of the texture, in texels.</param>
        /// <param name="height">Specifies the height of the texture, in texels.</param>
        /// <param name="fixedsamplelocations">Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.</param>
        public static void TexStorage2DMultisample(int target, int samples, int internalformat, int width, int height, bool fixedsamplelocations)
        {
            if (gl._TexStorage2DMultisample != null) gl._TexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations); else { }
        }
        /// <summary>
        /// <para>Fullname: TexStorage3D</para>
        /// </summary>
        [GLEntry("TexStorage3D", Category = "ARB")]
        public static GLDelegate.TexStorage3D _TexStorage3D = null;
        /// <summary>
        /// <para>simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexStorage3D.</para>
        /// <para>Fullname: TexStorage3D</para>
        /// <para>Extensions: ARB_texture_storage</para>
        /// </summary>
        /// <param name="target">Specify the target of the operation. target must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_ARRAY, or GL_PROXY_TEXTURE_CUBE_ARRAY.</param>
        /// <param name="levels">Specify the number of texture levels.</param>
        /// <param name="internalformat">Specifies the sized internal format to be used to store texture image data.</param>
        /// <param name="width">Specifies the width of the texture, in texels.</param>
        /// <param name="height">Specifies the height of the texture, in texels.</param>
        /// <param name="depth">Specifies the depth of the texture, in texels.</param>
        public static void TexStorage3D(int target, int levels, int internalformat, int width, int height, int depth)
        {
            if (gl._TexStorage3D != null) gl._TexStorage3D(target, levels, internalformat, width, height, depth); else { }
        }
        /// <summary>
        /// <para>Fullname: TexStorage3DMultisample</para>
        /// </summary>
        [GLEntry("TexStorage3DMultisample", Category = "ARB")]
        public static GLDelegate.TexStorage3DMultisample _TexStorage3DMultisample = null;
        /// <summary>
        /// <para>specify storage for a two-dimensional multisample array texture</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexStorage3DMultisample.</para>
        /// <para>Fullname: TexStorage3DMultisample</para>
        /// <para>Extensions: ARB_texture_storage_multisample</para>
        /// </summary>
        /// <param name="target">Specify the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_MULTISAMPLE.</param>
        /// <param name="samples">Specify the number of samples in the texture.</param>
        /// <param name="internalformat">Specifies the sized internal format to be used to store texture image data.</param>
        /// <param name="width">Specifies the width of the texture, in texels.</param>
        /// <param name="height">Specifies the height of the texture, in texels.</param>
        /// <param name="depth">Specifies the depth of the texture, in layers.</param>
        /// <param name="fixedsamplelocations">Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.</param>
        public static void TexStorage3DMultisample(int target, int samples, int internalformat, int width, int height, int depth, bool fixedsamplelocations)
        {
            if (gl._TexStorage3DMultisample != null) gl._TexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureBufferRangeEXT</para>
        /// </summary>
        [GLEntry("TextureBufferRangeEXT", Category = "ARB")]
        public static GLDelegate.TextureBufferRange _TextureBufferRange = null;
        /// <summary>
        /// <para>ARB_texture_buffer_object (which was promoted to core in OpenGL 3.1) introduced the ability to attach the data store of a buffer object to a buffer texture and access it from shaders. The extension only allows the entire store of the buffer object to the texture. This extension expands on this and allows a sub-range of the buffer's data store to be attached to a texture. This can be used, for example, to allow multiple buffer textures to be backed by independent sub-ranges of the same buffer object, or for different sub-ranges of a single buffer object to be used for different purposes. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureBufferRange.</para>
        /// <para>Fullname: TextureBufferRangeEXT</para>
        /// <para>Extensions: ARB_texture_buffer_range</para>
        /// </summary>
        public static void TextureBufferRange(uint texture, int target, int internalformat, uint buffer, int offset, int size)
        {
            if (gl._TextureBufferRange != null) gl._TextureBufferRange(texture, target, internalformat, buffer, offset, size); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureStorage1DEXT</para>
        /// </summary>
        [GLEntry("TextureStorage1DEXT", Category = "ARB")]
        public static GLDelegate.TextureStorage1D _TextureStorage1D = null;
        /// <summary>
        /// <para>The texture image specification commands in OpenGL allow each level to be separately specified with different sizes, formats, types and so on, and only imposes consistency checks at draw time. This adds overhead for implementations. This extension provides a mechanism for specifying the entire structure of a texture in a single call, allowing certain consistency checks and memory allocations to be done up front. Once specified, the format and dimensions of the image array become immutable, to simplify completeness checks in the implementation. When using this extension, it is no longer possible to supply texture data using TexImage*. Instead, data can be uploaded using TexSubImage*, or produced by other means (such as render-to-texture, mipmap generation, or rendering to a sibling EGLImage). This extension has complicated interactions with other extensions. The goal of most of these interactions is to ensure that a texture is always mipmap complete (and cube complete for cubemap textur...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureStorage1D.</para>
        /// <para>Fullname: TextureStorage1DEXT</para>
        /// <para>Extensions: ARB_texture_storage</para>
        /// </summary>
        public static void TextureStorage1D(uint texture, int target, int levels, int internalformat, int width)
        {
            if (gl._TextureStorage1D != null) gl._TextureStorage1D(texture, target, levels, internalformat, width); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureStorage2DEXT</para>
        /// </summary>
        [GLEntry("TextureStorage2DEXT", Category = "ARB")]
        public static GLDelegate.TextureStorage2D _TextureStorage2D = null;
        /// <summary>
        /// <para>The texture image specification commands in OpenGL allow each level to be separately specified with different sizes, formats, types and so on, and only imposes consistency checks at draw time. This adds overhead for implementations. This extension provides a mechanism for specifying the entire structure of a texture in a single call, allowing certain consistency checks and memory allocations to be done up front. Once specified, the format and dimensions of the image array become immutable, to simplify completeness checks in the implementation. When using this extension, it is no longer possible to supply texture data using TexImage*. Instead, data can be uploaded using TexSubImage*, or produced by other means (such as render-to-texture, mipmap generation, or rendering to a sibling EGLImage). This extension has complicated interactions with other extensions. The goal of most of these interactions is to ensure that a texture is always mipmap complete (and cube complete for cubemap textur...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureStorage2D.</para>
        /// <para>Fullname: TextureStorage2DEXT</para>
        /// <para>Extensions: ARB_texture_storage</para>
        /// </summary>
        public static void TextureStorage2D(uint texture, int target, int levels, int internalformat, int width, int height)
        {
            if (gl._TextureStorage2D != null) gl._TextureStorage2D(texture, target, levels, internalformat, width, height); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureStorage2DMultisampleEXT</para>
        /// </summary>
        [GLEntry("TextureStorage2DMultisampleEXT", Category = "ARB")]
        public static GLDelegate.TextureStorage2DMultisample _TextureStorage2DMultisample = null;
        /// <summary>
        /// <para>The ARB_texture_storage extension and OpenGL 4.2 introduced the concept of immutable texture objects. With these objects, once their data store has been sized and allocated, it could not be resized for the lifetime of the objects (although its content could be updated). OpenGL implementations may be able to take advantage of the knowledge that the underlying data store of certain objects cannot be deleted or otherwise reallocated without destruction of the whole object (normally, a much heavier weight and less frequent operation). Immutable storage for all types of textures besides multisample and buffer textures was introduced by ARB_texture_storage. For completeness, this extension introduces immutable storage for multisampled textures. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureStorage2DMultisample.</para>
        /// <para>Fullname: TextureStorage2DMultisampleEXT</para>
        /// <para>Extensions: ARB_texture_storage_multisample</para>
        /// </summary>
        public static void TextureStorage2DMultisample(uint texture, int target, int samples, int internalformat, int width, int height, bool fixedsamplelocations)
        {
            if (gl._TextureStorage2DMultisample != null) gl._TextureStorage2DMultisample(texture, target, samples, internalformat, width, height, fixedsamplelocations); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureStorage3DEXT</para>
        /// </summary>
        [GLEntry("TextureStorage3DEXT", Category = "ARB")]
        public static GLDelegate.TextureStorage3D _TextureStorage3D = null;
        /// <summary>
        /// <para>The texture image specification commands in OpenGL allow each level to be separately specified with different sizes, formats, types and so on, and only imposes consistency checks at draw time. This adds overhead for implementations. This extension provides a mechanism for specifying the entire structure of a texture in a single call, allowing certain consistency checks and memory allocations to be done up front. Once specified, the format and dimensions of the image array become immutable, to simplify completeness checks in the implementation. When using this extension, it is no longer possible to supply texture data using TexImage*. Instead, data can be uploaded using TexSubImage*, or produced by other means (such as render-to-texture, mipmap generation, or rendering to a sibling EGLImage). This extension has complicated interactions with other extensions. The goal of most of these interactions is to ensure that a texture is always mipmap complete (and cube complete for cubemap textur...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureStorage3D.</para>
        /// <para>Fullname: TextureStorage3DEXT</para>
        /// <para>Extensions: ARB_texture_storage</para>
        /// </summary>
        public static void TextureStorage3D(uint texture, int target, int levels, int internalformat, int width, int height, int depth)
        {
            if (gl._TextureStorage3D != null) gl._TextureStorage3D(texture, target, levels, internalformat, width, height, depth); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureStorage3DMultisampleEXT</para>
        /// </summary>
        [GLEntry("TextureStorage3DMultisampleEXT", Category = "ARB")]
        public static GLDelegate.TextureStorage3DMultisample _TextureStorage3DMultisample = null;
        /// <summary>
        /// <para>The ARB_texture_storage extension and OpenGL 4.2 introduced the concept of immutable texture objects. With these objects, once their data store has been sized and allocated, it could not be resized for the lifetime of the objects (although its content could be updated). OpenGL implementations may be able to take advantage of the knowledge that the underlying data store of certain objects cannot be deleted or otherwise reallocated without destruction of the whole object (normally, a much heavier weight and less frequent operation). Immutable storage for all types of textures besides multisample and buffer textures was introduced by ARB_texture_storage. For completeness, this extension introduces immutable storage for multisampled textures. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureStorage3DMultisample.</para>
        /// <para>Fullname: TextureStorage3DMultisampleEXT</para>
        /// <para>Extensions: ARB_texture_storage_multisample</para>
        /// </summary>
        public static void TextureStorage3DMultisample(uint texture, int target, int samples, int internalformat, int width, int height, int depth, bool fixedsamplelocations)
        {
            if (gl._TextureStorage3DMultisample != null) gl._TextureStorage3DMultisample(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureView</para>
        /// </summary>
        [GLEntry("TextureView", Category = "ARB")]
        public static GLDelegate.TextureView _TextureView = null;
        /// <summary>
        /// <para>initialize a texture as a data alias of another texture's data store</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureView.</para>
        /// <para>Fullname: TextureView</para>
        /// <para>Extensions: ARB_texture_view</para>
        /// </summary>
        /// <param name="texture">Specifies the texture object to be initialized as a view.</param>
        /// <param name="target">Specifies the target to be used for the newly initialized texture.</param>
        /// <param name="origtexture">Specifies the name of a texture object of which to make a view.</param>
        /// <param name="internalFormat">Specifies the internal format for the newly created view.</param>
        /// <param name="minlevel">Specifies lowest level of detail of the view.</param>
        /// <param name="numlevels">Specifies the number of levels of detail to include in the view.</param>
        /// <param name="minlayer">Specifies the index of the first layer to include in the view.</param>
        /// <param name="numlayers">Specifies the number of layers to include in the view.</param>
        public static void TextureView(uint texture, int target, uint origtexture, int internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers)
        {
            if (gl._TextureView != null) gl._TextureView(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform1d</para>
        /// </summary>
        [GLEntry("Uniform1d", Category = "ARB")]
        public static GLDelegate.Uniform1d _Uniform1d = null;
        /// <summary>
        /// <para>This extension allows GLSL shaders to use double-precision floating-point data types, including vectors and matrices of doubles.  Doubles may be used as inputs, outputs, and uniforms. The shading language supports various arithmetic and comparison operators on double-precision scalar, vector, and matrix types, and provides a set of built-in functions including: * square roots and inverse square roots; * fused floating-point multiply-add operations; * splitting a floating-point number into a significand and exponent (frexp), or building a floating-point number from a significand and exponent (ldexp); * absolute value, sign tests, various functions to round to an integer value, modulus, minimum, maximum, clamping, blending two values, step functions, and testing for infinity and NaN values; * packing and unpacking doubles into a pair of 32-bit unsigned integers; * matrix component-wise multiplication, and computation of outer products, transposes, determinants, and inverses; and * vector...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform1d.</para>
        /// <para>Fullname: Uniform1d</para>
        /// <para>Extensions: ARB_gpu_shader_fp64</para>
        /// </summary>
        public static void Uniform1d(int location, double x)
        {
            if (gl._Uniform1d != null) gl._Uniform1d(location, x); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform1dv</para>
        /// </summary>
        [GLEntry("Uniform1dv", Category = "ARB")]
        public static GLDelegate.Uniform1dv _Uniform1dv = null;
        /// <summary>
        /// <para>This extension allows GLSL shaders to use double-precision floating-point data types, including vectors and matrices of doubles.  Doubles may be used as inputs, outputs, and uniforms. The shading language supports various arithmetic and comparison operators on double-precision scalar, vector, and matrix types, and provides a set of built-in functions including: * square roots and inverse square roots; * fused floating-point multiply-add operations; * splitting a floating-point number into a significand and exponent (frexp), or building a floating-point number from a significand and exponent (ldexp); * absolute value, sign tests, various functions to round to an integer value, modulus, minimum, maximum, clamping, blending two values, step functions, and testing for infinity and NaN values; * packing and unpacking doubles into a pair of 32-bit unsigned integers; * matrix component-wise multiplication, and computation of outer products, transposes, determinants, and inverses; and * vector...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform1dv.</para>
        /// <para>Fullname: Uniform1dv</para>
        /// <para>Extensions: ARB_gpu_shader_fp64</para>
        /// </summary>
        public static void Uniform1dv(int location, int count, double[] value)
        {
            if (gl._Uniform1dv != null) gl._Uniform1dv(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform2d</para>
        /// </summary>
        [GLEntry("Uniform2d", Category = "ARB")]
        public static GLDelegate.Uniform2d _Uniform2d = null;
        /// <summary>
        /// <para>This extension allows GLSL shaders to use double-precision floating-point data types, including vectors and matrices of doubles.  Doubles may be used as inputs, outputs, and uniforms. The shading language supports various arithmetic and comparison operators on double-precision scalar, vector, and matrix types, and provides a set of built-in functions including: * square roots and inverse square roots; * fused floating-point multiply-add operations; * splitting a floating-point number into a significand and exponent (frexp), or building a floating-point number from a significand and exponent (ldexp); * absolute value, sign tests, various functions to round to an integer value, modulus, minimum, maximum, clamping, blending two values, step functions, and testing for infinity and NaN values; * packing and unpacking doubles into a pair of 32-bit unsigned integers; * matrix component-wise multiplication, and computation of outer products, transposes, determinants, and inverses; and * vector...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform2d.</para>
        /// <para>Fullname: Uniform2d</para>
        /// <para>Extensions: ARB_gpu_shader_fp64</para>
        /// </summary>
        public static void Uniform2d(int location, double x, double y)
        {
            if (gl._Uniform2d != null) gl._Uniform2d(location, x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform2dv</para>
        /// </summary>
        [GLEntry("Uniform2dv", Category = "ARB")]
        public static GLDelegate.Uniform2dv _Uniform2dv = null;
        /// <summary>
        /// <para>This extension allows GLSL shaders to use double-precision floating-point data types, including vectors and matrices of doubles.  Doubles may be used as inputs, outputs, and uniforms. The shading language supports various arithmetic and comparison operators on double-precision scalar, vector, and matrix types, and provides a set of built-in functions including: * square roots and inverse square roots; * fused floating-point multiply-add operations; * splitting a floating-point number into a significand and exponent (frexp), or building a floating-point number from a significand and exponent (ldexp); * absolute value, sign tests, various functions to round to an integer value, modulus, minimum, maximum, clamping, blending two values, step functions, and testing for infinity and NaN values; * packing and unpacking doubles into a pair of 32-bit unsigned integers; * matrix component-wise multiplication, and computation of outer products, transposes, determinants, and inverses; and * vector...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform2dv.</para>
        /// <para>Fullname: Uniform2dv</para>
        /// <para>Extensions: ARB_gpu_shader_fp64</para>
        /// </summary>
        public static void Uniform2dv(int location, int count, double[] value)
        {
            if (gl._Uniform2dv != null) gl._Uniform2dv(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform3d</para>
        /// </summary>
        [GLEntry("Uniform3d", Category = "ARB")]
        public static GLDelegate.Uniform3d _Uniform3d = null;
        /// <summary>
        /// <para>This extension allows GLSL shaders to use double-precision floating-point data types, including vectors and matrices of doubles.  Doubles may be used as inputs, outputs, and uniforms. The shading language supports various arithmetic and comparison operators on double-precision scalar, vector, and matrix types, and provides a set of built-in functions including: * square roots and inverse square roots; * fused floating-point multiply-add operations; * splitting a floating-point number into a significand and exponent (frexp), or building a floating-point number from a significand and exponent (ldexp); * absolute value, sign tests, various functions to round to an integer value, modulus, minimum, maximum, clamping, blending two values, step functions, and testing for infinity and NaN values; * packing and unpacking doubles into a pair of 32-bit unsigned integers; * matrix component-wise multiplication, and computation of outer products, transposes, determinants, and inverses; and * vector...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform3d.</para>
        /// <para>Fullname: Uniform3d</para>
        /// <para>Extensions: ARB_gpu_shader_fp64</para>
        /// </summary>
        public static void Uniform3d(int location, double x, double y, double z)
        {
            if (gl._Uniform3d != null) gl._Uniform3d(location, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform3dv</para>
        /// </summary>
        [GLEntry("Uniform3dv", Category = "ARB")]
        public static GLDelegate.Uniform3dv _Uniform3dv = null;
        /// <summary>
        /// <para>This extension allows GLSL shaders to use double-precision floating-point data types, including vectors and matrices of doubles.  Doubles may be used as inputs, outputs, and uniforms. The shading language supports various arithmetic and comparison operators on double-precision scalar, vector, and matrix types, and provides a set of built-in functions including: * square roots and inverse square roots; * fused floating-point multiply-add operations; * splitting a floating-point number into a significand and exponent (frexp), or building a floating-point number from a significand and exponent (ldexp); * absolute value, sign tests, various functions to round to an integer value, modulus, minimum, maximum, clamping, blending two values, step functions, and testing for infinity and NaN values; * packing and unpacking doubles into a pair of 32-bit unsigned integers; * matrix component-wise multiplication, and computation of outer products, transposes, determinants, and inverses; and * vector...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform3dv.</para>
        /// <para>Fullname: Uniform3dv</para>
        /// <para>Extensions: ARB_gpu_shader_fp64</para>
        /// </summary>
        public static void Uniform3dv(int location, int count, double[] value)
        {
            if (gl._Uniform3dv != null) gl._Uniform3dv(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform4d</para>
        /// </summary>
        [GLEntry("Uniform4d", Category = "ARB")]
        public static GLDelegate.Uniform4d _Uniform4d = null;
        /// <summary>
        /// <para>This extension allows GLSL shaders to use double-precision floating-point data types, including vectors and matrices of doubles.  Doubles may be used as inputs, outputs, and uniforms. The shading language supports various arithmetic and comparison operators on double-precision scalar, vector, and matrix types, and provides a set of built-in functions including: * square roots and inverse square roots; * fused floating-point multiply-add operations; * splitting a floating-point number into a significand and exponent (frexp), or building a floating-point number from a significand and exponent (ldexp); * absolute value, sign tests, various functions to round to an integer value, modulus, minimum, maximum, clamping, blending two values, step functions, and testing for infinity and NaN values; * packing and unpacking doubles into a pair of 32-bit unsigned integers; * matrix component-wise multiplication, and computation of outer products, transposes, determinants, and inverses; and * vector...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform4d.</para>
        /// <para>Fullname: Uniform4d</para>
        /// <para>Extensions: ARB_gpu_shader_fp64</para>
        /// </summary>
        public static void Uniform4d(int location, double x, double y, double z, double w)
        {
            if (gl._Uniform4d != null) gl._Uniform4d(location, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform4dv</para>
        /// </summary>
        [GLEntry("Uniform4dv", Category = "ARB")]
        public static GLDelegate.Uniform4dv _Uniform4dv = null;
        /// <summary>
        /// <para>This extension allows GLSL shaders to use double-precision floating-point data types, including vectors and matrices of doubles.  Doubles may be used as inputs, outputs, and uniforms. The shading language supports various arithmetic and comparison operators on double-precision scalar, vector, and matrix types, and provides a set of built-in functions including: * square roots and inverse square roots; * fused floating-point multiply-add operations; * splitting a floating-point number into a significand and exponent (frexp), or building a floating-point number from a significand and exponent (ldexp); * absolute value, sign tests, various functions to round to an integer value, modulus, minimum, maximum, clamping, blending two values, step functions, and testing for infinity and NaN values; * packing and unpacking doubles into a pair of 32-bit unsigned integers; * matrix component-wise multiplication, and computation of outer products, transposes, determinants, and inverses; and * vector...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform4dv.</para>
        /// <para>Fullname: Uniform4dv</para>
        /// <para>Extensions: ARB_gpu_shader_fp64</para>
        /// </summary>
        public static void Uniform4dv(int location, int count, double[] value)
        {
            if (gl._Uniform4dv != null) gl._Uniform4dv(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformBlockBinding</para>
        /// </summary>
        [GLEntry("UniformBlockBinding", Category = "ARB")]
        public static GLDelegate.UniformBlockBinding _UniformBlockBinding = null;
        /// <summary>
        /// <para>assign a binding point to an active uniform block</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformBlockBinding.</para>
        /// <para>Fullname: UniformBlockBinding</para>
        /// <para>Extensions: ARB_uniform_buffer_object</para>
        /// </summary>
        /// <param name="program">The name of a program object containing the active uniform block whose binding to assign.</param>
        /// <param name="uniformBlockIndex">The index of the active uniform block within program whose binding to assign.</param>
        /// <param name="uniformBlockBinding">Specifies the binding point to which to bind the uniform block with index uniformBlockIndex within program.</param>
        public static void UniformBlockBinding(uint program, uint uniformBlockIndex, uint uniformBlockBinding)
        {
            if (gl._UniformBlockBinding != null) gl._UniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformMatrix2dv</para>
        /// </summary>
        [GLEntry("UniformMatrix2dv", Category = "ARB")]
        public static GLDelegate.UniformMatrix2dv _UniformMatrix2dv = null;
        /// <summary>
        /// <para>This extension allows GLSL shaders to use double-precision floating-point data types, including vectors and matrices of doubles.  Doubles may be used as inputs, outputs, and uniforms. The shading language supports various arithmetic and comparison operators on double-precision scalar, vector, and matrix types, and provides a set of built-in functions including: * square roots and inverse square roots; * fused floating-point multiply-add operations; * splitting a floating-point number into a significand and exponent (frexp), or building a floating-point number from a significand and exponent (ldexp); * absolute value, sign tests, various functions to round to an integer value, modulus, minimum, maximum, clamping, blending two values, step functions, and testing for infinity and NaN values; * packing and unpacking doubles into a pair of 32-bit unsigned integers; * matrix component-wise multiplication, and computation of outer products, transposes, determinants, and inverses; and * vector...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformMatrix2dv.</para>
        /// <para>Fullname: UniformMatrix2dv</para>
        /// <para>Extensions: ARB_gpu_shader_fp64</para>
        /// </summary>
        public static void UniformMatrix2dv(int location, int count, bool transpose, double[] value)
        {
            if (gl._UniformMatrix2dv != null) gl._UniformMatrix2dv(location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformMatrix2x3dv</para>
        /// </summary>
        [GLEntry("UniformMatrix2x3dv", Category = "ARB")]
        public static GLDelegate.UniformMatrix2x3dv _UniformMatrix2x3dv = null;
        /// <summary>
        /// <para>This extension allows GLSL shaders to use double-precision floating-point data types, including vectors and matrices of doubles.  Doubles may be used as inputs, outputs, and uniforms. The shading language supports various arithmetic and comparison operators on double-precision scalar, vector, and matrix types, and provides a set of built-in functions including: * square roots and inverse square roots; * fused floating-point multiply-add operations; * splitting a floating-point number into a significand and exponent (frexp), or building a floating-point number from a significand and exponent (ldexp); * absolute value, sign tests, various functions to round to an integer value, modulus, minimum, maximum, clamping, blending two values, step functions, and testing for infinity and NaN values; * packing and unpacking doubles into a pair of 32-bit unsigned integers; * matrix component-wise multiplication, and computation of outer products, transposes, determinants, and inverses; and * vector...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformMatrix2x3dv.</para>
        /// <para>Fullname: UniformMatrix2x3dv</para>
        /// <para>Extensions: ARB_gpu_shader_fp64</para>
        /// </summary>
        public static void UniformMatrix2x3dv(int location, int count, bool transpose, double[] value)
        {
            if (gl._UniformMatrix2x3dv != null) gl._UniformMatrix2x3dv(location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformMatrix2x4dv</para>
        /// </summary>
        [GLEntry("UniformMatrix2x4dv", Category = "ARB")]
        public static GLDelegate.UniformMatrix2x4dv _UniformMatrix2x4dv = null;
        /// <summary>
        /// <para>This extension allows GLSL shaders to use double-precision floating-point data types, including vectors and matrices of doubles.  Doubles may be used as inputs, outputs, and uniforms. The shading language supports various arithmetic and comparison operators on double-precision scalar, vector, and matrix types, and provides a set of built-in functions including: * square roots and inverse square roots; * fused floating-point multiply-add operations; * splitting a floating-point number into a significand and exponent (frexp), or building a floating-point number from a significand and exponent (ldexp); * absolute value, sign tests, various functions to round to an integer value, modulus, minimum, maximum, clamping, blending two values, step functions, and testing for infinity and NaN values; * packing and unpacking doubles into a pair of 32-bit unsigned integers; * matrix component-wise multiplication, and computation of outer products, transposes, determinants, and inverses; and * vector...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformMatrix2x4dv.</para>
        /// <para>Fullname: UniformMatrix2x4dv</para>
        /// <para>Extensions: ARB_gpu_shader_fp64</para>
        /// </summary>
        public static void UniformMatrix2x4dv(int location, int count, bool transpose, double[] value)
        {
            if (gl._UniformMatrix2x4dv != null) gl._UniformMatrix2x4dv(location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformMatrix3dv</para>
        /// </summary>
        [GLEntry("UniformMatrix3dv", Category = "ARB")]
        public static GLDelegate.UniformMatrix3dv _UniformMatrix3dv = null;
        /// <summary>
        /// <para>This extension allows GLSL shaders to use double-precision floating-point data types, including vectors and matrices of doubles.  Doubles may be used as inputs, outputs, and uniforms. The shading language supports various arithmetic and comparison operators on double-precision scalar, vector, and matrix types, and provides a set of built-in functions including: * square roots and inverse square roots; * fused floating-point multiply-add operations; * splitting a floating-point number into a significand and exponent (frexp), or building a floating-point number from a significand and exponent (ldexp); * absolute value, sign tests, various functions to round to an integer value, modulus, minimum, maximum, clamping, blending two values, step functions, and testing for infinity and NaN values; * packing and unpacking doubles into a pair of 32-bit unsigned integers; * matrix component-wise multiplication, and computation of outer products, transposes, determinants, and inverses; and * vector...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformMatrix3dv.</para>
        /// <para>Fullname: UniformMatrix3dv</para>
        /// <para>Extensions: ARB_gpu_shader_fp64</para>
        /// </summary>
        public static void UniformMatrix3dv(int location, int count, bool transpose, double[] value)
        {
            if (gl._UniformMatrix3dv != null) gl._UniformMatrix3dv(location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformMatrix3x2dv</para>
        /// </summary>
        [GLEntry("UniformMatrix3x2dv", Category = "ARB")]
        public static GLDelegate.UniformMatrix3x2dv _UniformMatrix3x2dv = null;
        /// <summary>
        /// <para>This extension allows GLSL shaders to use double-precision floating-point data types, including vectors and matrices of doubles.  Doubles may be used as inputs, outputs, and uniforms. The shading language supports various arithmetic and comparison operators on double-precision scalar, vector, and matrix types, and provides a set of built-in functions including: * square roots and inverse square roots; * fused floating-point multiply-add operations; * splitting a floating-point number into a significand and exponent (frexp), or building a floating-point number from a significand and exponent (ldexp); * absolute value, sign tests, various functions to round to an integer value, modulus, minimum, maximum, clamping, blending two values, step functions, and testing for infinity and NaN values; * packing and unpacking doubles into a pair of 32-bit unsigned integers; * matrix component-wise multiplication, and computation of outer products, transposes, determinants, and inverses; and * vector...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformMatrix3x2dv.</para>
        /// <para>Fullname: UniformMatrix3x2dv</para>
        /// <para>Extensions: ARB_gpu_shader_fp64</para>
        /// </summary>
        public static void UniformMatrix3x2dv(int location, int count, bool transpose, double[] value)
        {
            if (gl._UniformMatrix3x2dv != null) gl._UniformMatrix3x2dv(location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformMatrix3x4dv</para>
        /// </summary>
        [GLEntry("UniformMatrix3x4dv", Category = "ARB")]
        public static GLDelegate.UniformMatrix3x4dv _UniformMatrix3x4dv = null;
        /// <summary>
        /// <para>This extension allows GLSL shaders to use double-precision floating-point data types, including vectors and matrices of doubles.  Doubles may be used as inputs, outputs, and uniforms. The shading language supports various arithmetic and comparison operators on double-precision scalar, vector, and matrix types, and provides a set of built-in functions including: * square roots and inverse square roots; * fused floating-point multiply-add operations; * splitting a floating-point number into a significand and exponent (frexp), or building a floating-point number from a significand and exponent (ldexp); * absolute value, sign tests, various functions to round to an integer value, modulus, minimum, maximum, clamping, blending two values, step functions, and testing for infinity and NaN values; * packing and unpacking doubles into a pair of 32-bit unsigned integers; * matrix component-wise multiplication, and computation of outer products, transposes, determinants, and inverses; and * vector...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformMatrix3x4dv.</para>
        /// <para>Fullname: UniformMatrix3x4dv</para>
        /// <para>Extensions: ARB_gpu_shader_fp64</para>
        /// </summary>
        public static void UniformMatrix3x4dv(int location, int count, bool transpose, double[] value)
        {
            if (gl._UniformMatrix3x4dv != null) gl._UniformMatrix3x4dv(location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformMatrix4dv</para>
        /// </summary>
        [GLEntry("UniformMatrix4dv", Category = "ARB")]
        public static GLDelegate.UniformMatrix4dv _UniformMatrix4dv = null;
        /// <summary>
        /// <para>This extension allows GLSL shaders to use double-precision floating-point data types, including vectors and matrices of doubles.  Doubles may be used as inputs, outputs, and uniforms. The shading language supports various arithmetic and comparison operators on double-precision scalar, vector, and matrix types, and provides a set of built-in functions including: * square roots and inverse square roots; * fused floating-point multiply-add operations; * splitting a floating-point number into a significand and exponent (frexp), or building a floating-point number from a significand and exponent (ldexp); * absolute value, sign tests, various functions to round to an integer value, modulus, minimum, maximum, clamping, blending two values, step functions, and testing for infinity and NaN values; * packing and unpacking doubles into a pair of 32-bit unsigned integers; * matrix component-wise multiplication, and computation of outer products, transposes, determinants, and inverses; and * vector...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformMatrix4dv.</para>
        /// <para>Fullname: UniformMatrix4dv</para>
        /// <para>Extensions: ARB_gpu_shader_fp64</para>
        /// </summary>
        public static void UniformMatrix4dv(int location, int count, bool transpose, double[] value)
        {
            if (gl._UniformMatrix4dv != null) gl._UniformMatrix4dv(location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformMatrix4x2dv</para>
        /// </summary>
        [GLEntry("UniformMatrix4x2dv", Category = "ARB")]
        public static GLDelegate.UniformMatrix4x2dv _UniformMatrix4x2dv = null;
        /// <summary>
        /// <para>This extension allows GLSL shaders to use double-precision floating-point data types, including vectors and matrices of doubles.  Doubles may be used as inputs, outputs, and uniforms. The shading language supports various arithmetic and comparison operators on double-precision scalar, vector, and matrix types, and provides a set of built-in functions including: * square roots and inverse square roots; * fused floating-point multiply-add operations; * splitting a floating-point number into a significand and exponent (frexp), or building a floating-point number from a significand and exponent (ldexp); * absolute value, sign tests, various functions to round to an integer value, modulus, minimum, maximum, clamping, blending two values, step functions, and testing for infinity and NaN values; * packing and unpacking doubles into a pair of 32-bit unsigned integers; * matrix component-wise multiplication, and computation of outer products, transposes, determinants, and inverses; and * vector...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformMatrix4x2dv.</para>
        /// <para>Fullname: UniformMatrix4x2dv</para>
        /// <para>Extensions: ARB_gpu_shader_fp64</para>
        /// </summary>
        public static void UniformMatrix4x2dv(int location, int count, bool transpose, double[] value)
        {
            if (gl._UniformMatrix4x2dv != null) gl._UniformMatrix4x2dv(location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformMatrix4x3dv</para>
        /// </summary>
        [GLEntry("UniformMatrix4x3dv", Category = "ARB")]
        public static GLDelegate.UniformMatrix4x3dv _UniformMatrix4x3dv = null;
        /// <summary>
        /// <para>This extension allows GLSL shaders to use double-precision floating-point data types, including vectors and matrices of doubles.  Doubles may be used as inputs, outputs, and uniforms. The shading language supports various arithmetic and comparison operators on double-precision scalar, vector, and matrix types, and provides a set of built-in functions including: * square roots and inverse square roots; * fused floating-point multiply-add operations; * splitting a floating-point number into a significand and exponent (frexp), or building a floating-point number from a significand and exponent (ldexp); * absolute value, sign tests, various functions to round to an integer value, modulus, minimum, maximum, clamping, blending two values, step functions, and testing for infinity and NaN values; * packing and unpacking doubles into a pair of 32-bit unsigned integers; * matrix component-wise multiplication, and computation of outer products, transposes, determinants, and inverses; and * vector...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformMatrix4x3dv.</para>
        /// <para>Fullname: UniformMatrix4x3dv</para>
        /// <para>Extensions: ARB_gpu_shader_fp64</para>
        /// </summary>
        public static void UniformMatrix4x3dv(int location, int count, bool transpose, double[] value)
        {
            if (gl._UniformMatrix4x3dv != null) gl._UniformMatrix4x3dv(location, count, transpose, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformSubroutinesuiv</para>
        /// </summary>
        [GLEntry("UniformSubroutinesuiv", Category = "ARB")]
        public static GLDelegate.UniformSubroutinesuiv _UniformSubroutinesuiv = null;
        /// <summary>
        /// <para>load active subroutine uniforms</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformSubroutinesuiv.</para>
        /// <para>Fullname: UniformSubroutinesuiv</para>
        /// <para>Extensions: ARB_shader_subroutine</para>
        /// </summary>
        /// <param name="shadertype">Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER.</param>
        /// <param name="count">Specifies the number of uniform indices stored in indices.</param>
        /// <param name="indices">Specifies the address of an array holding the indices to load into the shader subroutine variables.</param>
        public static void UniformSubroutinesuiv(int shadertype, int count, uint[] indices)
        {
            if (gl._UniformSubroutinesuiv != null) gl._UniformSubroutinesuiv(shadertype, count, indices); else { }
        }
        /// <summary>
        /// <para>Fullname: UseProgramObjectARB</para>
        /// </summary>
        [GLEntry("UseProgramObjectARB", Category = "ARB")]
        public static GLDelegate.UseProgramObject _UseProgramObject = null;
        /// <summary>
        /// <para>This extension adds API calls that are necessary to manage shader objects and program objects as defined in the OpenGL 2.0 white papers by 3Dlabs. The generation of an executable that runs on one of OpenGL's programmable units is modeled to that of developing a typical C/C++ application. There are one or more source files, each of which are stored by OpenGL in a shader object. Each shader object (source file) needs to be compiled and attached to a program object. Once all shader objects are compiled successfully, the program object needs to be linked to produce an executable. This executable is part of the program object, and can now be loaded onto the programmable units to make it part of the current OpenGL state. Both the compile and link stages generate a text string that can be queried to get more information. This information could be, but is not limited to, compile errors, link errors, optimization hints, etc. Values for uniform variables, declared in a shader, can be set by the ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UseProgramObject.</para>
        /// <para>Fullname: UseProgramObjectARB</para>
        /// <para>Extensions: ARB_shader_objects</para>
        /// </summary>
        public static void UseProgramObject(uint programObj)
        {
            if (gl._UseProgramObject != null) gl._UseProgramObject(programObj); else { }
        }
        /// <summary>
        /// <para>Fullname: UseProgramStages</para>
        /// </summary>
        [GLEntry("UseProgramStages", Category = "ARB")]
        public static GLDelegate.UseProgramStages _UseProgramStages = null;
        /// <summary>
        /// <para>bind stages of a program object to a program pipeline</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UseProgramStages.</para>
        /// <para>Fullname: UseProgramStages</para>
        /// <para>Extensions: ARB_separate_shader_objects</para>
        /// </summary>
        /// <param name="pipeline">Specifies the program pipeline object to which to bind stages from program.</param>
        /// <param name="stages">Specifies a set of program stages to bind to the program pipeline object.</param>
        /// <param name="program">Specifies the program object containing the shader executables to use in pipeline.</param>
        public static void UseProgramStages(uint pipeline, int stages, uint program)
        {
            if (gl._UseProgramStages != null) gl._UseProgramStages(pipeline, stages, program); else { }
        }
        /// <summary>
        /// <para>Fullname: ValidateProgramPipeline</para>
        /// </summary>
        [GLEntry("ValidateProgramPipeline", Category = "ARB")]
        public static GLDelegate.ValidateProgramPipeline _ValidateProgramPipeline = null;
        /// <summary>
        /// <para>validate a program pipeline object against current GL state</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ValidateProgramPipeline.</para>
        /// <para>Fullname: ValidateProgramPipeline</para>
        /// <para>Extensions: ARB_separate_shader_objects</para>
        /// </summary>
        /// <param name="pipeline">Specifies the name of a program pipeline object to validate.</param>
        public static void ValidateProgramPipeline(uint pipeline)
        {
            if (gl._ValidateProgramPipeline != null) gl._ValidateProgramPipeline(pipeline); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexArrayBindVertexBufferEXT</para>
        /// </summary>
        [GLEntry("VertexArrayBindVertexBufferEXT", Category = "ARB")]
        public static GLDelegate.VertexArrayBindVertexBuffer _VertexArrayBindVertexBuffer = null;
        /// <summary>
        /// <para>OpenGL currently supports (at least) 16 vertex attributes and 16 vertex buffer bindings, with a fixed mapping between vertex attributes and vertex buffer bindings. This extension allows the application to change the mapping between attributes and bindings, which can make it more efficient to update vertex buffer bindings for interleaved vertex formats where many attributes share the same buffer. This extension also separates the vertex binding update from the vertex attribute format update, which saves applications the effort of redundantly specifying the same format state over and over. Conceptually, this extension splits the state for generic vertex attribute arrays into: - An array of vertex buffer binding points, each of which specifies: - a bound buffer object, - a starting offset for the vertex attribute data in that buffer object, - a stride used by all attributes using that binding point, and - a frequency divisor used by all attributes using that binding point. - An array of g...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexArrayBindVertexBuffer.</para>
        /// <para>Fullname: VertexArrayBindVertexBufferEXT</para>
        /// <para>Extensions: ARB_vertex_attrib_binding</para>
        /// </summary>
        public static void VertexArrayBindVertexBuffer(uint vaobj, uint bindingindex, uint buffer, int offset, int stride)
        {
            if (gl._VertexArrayBindVertexBuffer != null) gl._VertexArrayBindVertexBuffer(vaobj, bindingindex, buffer, offset, stride); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexArrayVertexAttribBindingEXT</para>
        /// </summary>
        [GLEntry("VertexArrayVertexAttribBindingEXT", Category = "ARB")]
        public static GLDelegate.VertexArrayVertexAttribBinding _VertexArrayVertexAttribBinding = null;
        /// <summary>
        /// <para>OpenGL currently supports (at least) 16 vertex attributes and 16 vertex buffer bindings, with a fixed mapping between vertex attributes and vertex buffer bindings. This extension allows the application to change the mapping between attributes and bindings, which can make it more efficient to update vertex buffer bindings for interleaved vertex formats where many attributes share the same buffer. This extension also separates the vertex binding update from the vertex attribute format update, which saves applications the effort of redundantly specifying the same format state over and over. Conceptually, this extension splits the state for generic vertex attribute arrays into: - An array of vertex buffer binding points, each of which specifies: - a bound buffer object, - a starting offset for the vertex attribute data in that buffer object, - a stride used by all attributes using that binding point, and - a frequency divisor used by all attributes using that binding point. - An array of g...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexArrayVertexAttribBinding.</para>
        /// <para>Fullname: VertexArrayVertexAttribBindingEXT</para>
        /// <para>Extensions: ARB_vertex_attrib_binding</para>
        /// </summary>
        public static void VertexArrayVertexAttribBinding(uint vaobj, uint attribindex, uint bindingindex)
        {
            if (gl._VertexArrayVertexAttribBinding != null) gl._VertexArrayVertexAttribBinding(vaobj, attribindex, bindingindex); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexArrayVertexAttribFormatEXT</para>
        /// </summary>
        [GLEntry("VertexArrayVertexAttribFormatEXT", Category = "ARB")]
        public static GLDelegate.VertexArrayVertexAttribFormat _VertexArrayVertexAttribFormat = null;
        /// <summary>
        /// <para>OpenGL currently supports (at least) 16 vertex attributes and 16 vertex buffer bindings, with a fixed mapping between vertex attributes and vertex buffer bindings. This extension allows the application to change the mapping between attributes and bindings, which can make it more efficient to update vertex buffer bindings for interleaved vertex formats where many attributes share the same buffer. This extension also separates the vertex binding update from the vertex attribute format update, which saves applications the effort of redundantly specifying the same format state over and over. Conceptually, this extension splits the state for generic vertex attribute arrays into: - An array of vertex buffer binding points, each of which specifies: - a bound buffer object, - a starting offset for the vertex attribute data in that buffer object, - a stride used by all attributes using that binding point, and - a frequency divisor used by all attributes using that binding point. - An array of g...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexArrayVertexAttribFormat.</para>
        /// <para>Fullname: VertexArrayVertexAttribFormatEXT</para>
        /// <para>Extensions: ARB_vertex_attrib_binding</para>
        /// </summary>
        public static void VertexArrayVertexAttribFormat(uint vaobj, uint attribindex, int size, int type, bool normalized, uint relativeoffset)
        {
            if (gl._VertexArrayVertexAttribFormat != null) gl._VertexArrayVertexAttribFormat(vaobj, attribindex, size, type, normalized, relativeoffset); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexArrayVertexAttribIFormatEXT</para>
        /// </summary>
        [GLEntry("VertexArrayVertexAttribIFormatEXT", Category = "ARB")]
        public static GLDelegate.VertexArrayVertexAttribIFormat _VertexArrayVertexAttribIFormat = null;
        /// <summary>
        /// <para>OpenGL currently supports (at least) 16 vertex attributes and 16 vertex buffer bindings, with a fixed mapping between vertex attributes and vertex buffer bindings. This extension allows the application to change the mapping between attributes and bindings, which can make it more efficient to update vertex buffer bindings for interleaved vertex formats where many attributes share the same buffer. This extension also separates the vertex binding update from the vertex attribute format update, which saves applications the effort of redundantly specifying the same format state over and over. Conceptually, this extension splits the state for generic vertex attribute arrays into: - An array of vertex buffer binding points, each of which specifies: - a bound buffer object, - a starting offset for the vertex attribute data in that buffer object, - a stride used by all attributes using that binding point, and - a frequency divisor used by all attributes using that binding point. - An array of g...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexArrayVertexAttribIFormat.</para>
        /// <para>Fullname: VertexArrayVertexAttribIFormatEXT</para>
        /// <para>Extensions: ARB_vertex_attrib_binding</para>
        /// </summary>
        public static void VertexArrayVertexAttribIFormat(uint vaobj, uint attribindex, int size, int type, uint relativeoffset)
        {
            if (gl._VertexArrayVertexAttribIFormat != null) gl._VertexArrayVertexAttribIFormat(vaobj, attribindex, size, type, relativeoffset); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexArrayVertexAttribLFormatEXT</para>
        /// </summary>
        [GLEntry("VertexArrayVertexAttribLFormatEXT", Category = "ARB")]
        public static GLDelegate.VertexArrayVertexAttribLFormat _VertexArrayVertexAttribLFormat = null;
        /// <summary>
        /// <para>OpenGL currently supports (at least) 16 vertex attributes and 16 vertex buffer bindings, with a fixed mapping between vertex attributes and vertex buffer bindings. This extension allows the application to change the mapping between attributes and bindings, which can make it more efficient to update vertex buffer bindings for interleaved vertex formats where many attributes share the same buffer. This extension also separates the vertex binding update from the vertex attribute format update, which saves applications the effort of redundantly specifying the same format state over and over. Conceptually, this extension splits the state for generic vertex attribute arrays into: - An array of vertex buffer binding points, each of which specifies: - a bound buffer object, - a starting offset for the vertex attribute data in that buffer object, - a stride used by all attributes using that binding point, and - a frequency divisor used by all attributes using that binding point. - An array of g...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexArrayVertexAttribLFormat.</para>
        /// <para>Fullname: VertexArrayVertexAttribLFormatEXT</para>
        /// <para>Extensions: ARB_vertex_attrib_binding</para>
        /// </summary>
        public static void VertexArrayVertexAttribLFormat(uint vaobj, uint attribindex, int size, int type, uint relativeoffset)
        {
            if (gl._VertexArrayVertexAttribLFormat != null) gl._VertexArrayVertexAttribLFormat(vaobj, attribindex, size, type, relativeoffset); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexArrayVertexBindingDivisorEXT</para>
        /// </summary>
        [GLEntry("VertexArrayVertexBindingDivisorEXT", Category = "ARB")]
        public static GLDelegate.VertexArrayVertexBindingDivisor _VertexArrayVertexBindingDivisor = null;
        /// <summary>
        /// <para>OpenGL currently supports (at least) 16 vertex attributes and 16 vertex buffer bindings, with a fixed mapping between vertex attributes and vertex buffer bindings. This extension allows the application to change the mapping between attributes and bindings, which can make it more efficient to update vertex buffer bindings for interleaved vertex formats where many attributes share the same buffer. This extension also separates the vertex binding update from the vertex attribute format update, which saves applications the effort of redundantly specifying the same format state over and over. Conceptually, this extension splits the state for generic vertex attribute arrays into: - An array of vertex buffer binding points, each of which specifies: - a bound buffer object, - a starting offset for the vertex attribute data in that buffer object, - a stride used by all attributes using that binding point, and - a frequency divisor used by all attributes using that binding point. - An array of g...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexArrayVertexBindingDivisor.</para>
        /// <para>Fullname: VertexArrayVertexBindingDivisorEXT</para>
        /// <para>Extensions: ARB_vertex_attrib_binding</para>
        /// </summary>
        public static void VertexArrayVertexBindingDivisor(uint vaobj, uint bindingindex, uint divisor)
        {
            if (gl._VertexArrayVertexBindingDivisor != null) gl._VertexArrayVertexBindingDivisor(vaobj, bindingindex, divisor); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribBinding</para>
        /// </summary>
        [GLEntry("VertexAttribBinding", Category = "ARB")]
        public static GLDelegate.VertexAttribBinding _VertexAttribBinding = null;
        /// <summary>
        /// <para>associate a vertex attribute and a vertex buffer binding</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribBinding.</para>
        /// <para>Fullname: VertexAttribBinding</para>
        /// <para>Extensions: ARB_vertex_attrib_binding</para>
        /// </summary>
        /// <param name="attribindex">The index of the attribute to associate with a vertex buffer binding.</param>
        /// <param name="bindingindex">The index of the vertex buffer binding with which to associate the generic vertex attribute.</param>
        public static void VertexAttribBinding(uint attribindex, uint bindingindex)
        {
            if (gl._VertexAttribBinding != null) gl._VertexAttribBinding(attribindex, bindingindex); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribFormat</para>
        /// </summary>
        [GLEntry("VertexAttribFormat", Category = "ARB")]
        public static GLDelegate.VertexAttribFormat _VertexAttribFormat = null;
        /// <summary>
        /// <para>specify the organization of vertex arrays</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribFormat.</para>
        /// <para>Fullname: VertexAttribFormat</para>
        /// <para>Extensions: ARB_vertex_attrib_binding</para>
        /// </summary>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="normalized">The distance between elements within the buffer.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        public static void VertexAttribFormat(uint attribindex, int size, int type, bool normalized, uint relativeoffset)
        {
            if (gl._VertexAttribFormat != null) gl._VertexAttribFormat(attribindex, size, type, normalized, relativeoffset); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribIFormat</para>
        /// </summary>
        [GLEntry("VertexAttribIFormat", Category = "ARB")]
        public static GLDelegate.VertexAttribIFormat _VertexAttribIFormat = null;
        /// <summary>
        /// <para>OpenGL currently supports (at least) 16 vertex attributes and 16 vertex buffer bindings, with a fixed mapping between vertex attributes and vertex buffer bindings. This extension allows the application to change the mapping between attributes and bindings, which can make it more efficient to update vertex buffer bindings for interleaved vertex formats where many attributes share the same buffer. This extension also separates the vertex binding update from the vertex attribute format update, which saves applications the effort of redundantly specifying the same format state over and over. Conceptually, this extension splits the state for generic vertex attribute arrays into: - An array of vertex buffer binding points, each of which specifies: - a bound buffer object, - a starting offset for the vertex attribute data in that buffer object, - a stride used by all attributes using that binding point, and - a frequency divisor used by all attributes using that binding point. - An array of g...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribIFormat.</para>
        /// <para>Fullname: VertexAttribIFormat</para>
        /// <para>Extensions: ARB_vertex_attrib_binding</para>
        /// </summary>
        public static void VertexAttribIFormat(uint attribindex, int size, int type, uint relativeoffset)
        {
            if (gl._VertexAttribIFormat != null) gl._VertexAttribIFormat(attribindex, size, type, relativeoffset); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL1d</para>
        /// </summary>
        [GLEntry("VertexAttribL1d", Category = "ARB", Alias = "VertexAttribL1dEXT ")]
        public static GLDelegate.VertexAttribL1d _VertexAttribL1d = null;
        public static GLDelegate.VertexAttribL1d VertexAttribL1dEXT = VertexAttribL1d;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL1d.</para>
        /// <para>Fullname: VertexAttribL1d</para>
        /// <para>Aliases: VertexAttribL1dEXT, </para>
        /// <para>Extensions: ARB_vertex_attrib_64bit EXT_vertex_attrib_64bit</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribL1d(uint index, double x)
        {
            if (gl._VertexAttribL1d != null) gl._VertexAttribL1d(index, x); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL1dv</para>
        /// </summary>
        [GLEntry("VertexAttribL1dv", Category = "ARB", Alias = "VertexAttribL1dvEXT ")]
        public static GLDelegate.VertexAttribL1dv _VertexAttribL1dv = null;
        public static GLDelegate.VertexAttribL1dv VertexAttribL1dvEXT = VertexAttribL1dv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL1dv.</para>
        /// <para>Fullname: VertexAttribL1dv</para>
        /// <para>Aliases: VertexAttribL1dvEXT, </para>
        /// <para>Extensions: ARB_vertex_attrib_64bit EXT_vertex_attrib_64bit</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribL1dv(uint index, double[] v)
        {
            if (gl._VertexAttribL1dv != null) gl._VertexAttribL1dv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL1dv</para>
        /// </summary>
        [GLEntry("VertexAttribL1dv", Category = "ARB", Alias = "VertexAttribL1dvEXT ")]
        public static GLDelegate.VertexAttribL1dv_double _VertexAttribL1dv_double = null;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL1dv_double.</para>
        /// <para>Fullname: VertexAttribL1dv</para>
        /// <para>Aliases: VertexAttribL1dvEXT, </para>
        /// <para>Extensions: ARB_vertex_attrib_64bit EXT_vertex_attrib_64bit</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribL1dv(uint index, ref double v)
        {
            if (gl._VertexAttribL1dv_double != null) gl._VertexAttribL1dv_double(index, ref v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL2d</para>
        /// </summary>
        [GLEntry("VertexAttribL2d", Category = "ARB", Alias = "VertexAttribL2dEXT ")]
        public static GLDelegate.VertexAttribL2d _VertexAttribL2d = null;
        public static GLDelegate.VertexAttribL2d VertexAttribL2dEXT = VertexAttribL2d;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL2d.</para>
        /// <para>Fullname: VertexAttribL2d</para>
        /// <para>Aliases: VertexAttribL2dEXT, </para>
        /// <para>Extensions: ARB_vertex_attrib_64bit EXT_vertex_attrib_64bit</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribL2d(uint index, double x, double y)
        {
            if (gl._VertexAttribL2d != null) gl._VertexAttribL2d(index, x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL2dv</para>
        /// </summary>
        [GLEntry("VertexAttribL2dv", Category = "ARB", Alias = "VertexAttribL2dvEXT ")]
        public static GLDelegate.VertexAttribL2dv _VertexAttribL2dv = null;
        public static GLDelegate.VertexAttribL2dv VertexAttribL2dvEXT = VertexAttribL2dv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL2dv.</para>
        /// <para>Fullname: VertexAttribL2dv</para>
        /// <para>Aliases: VertexAttribL2dvEXT, </para>
        /// <para>Extensions: ARB_vertex_attrib_64bit EXT_vertex_attrib_64bit</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribL2dv(uint index, double[] v)
        {
            if (gl._VertexAttribL2dv != null) gl._VertexAttribL2dv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL3d</para>
        /// </summary>
        [GLEntry("VertexAttribL3d", Category = "ARB", Alias = "VertexAttribL3dEXT ")]
        public static GLDelegate.VertexAttribL3d _VertexAttribL3d = null;
        public static GLDelegate.VertexAttribL3d VertexAttribL3dEXT = VertexAttribL3d;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL3d.</para>
        /// <para>Fullname: VertexAttribL3d</para>
        /// <para>Aliases: VertexAttribL3dEXT, </para>
        /// <para>Extensions: ARB_vertex_attrib_64bit EXT_vertex_attrib_64bit</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribL3d(uint index, double x, double y, double z)
        {
            if (gl._VertexAttribL3d != null) gl._VertexAttribL3d(index, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL3dv</para>
        /// </summary>
        [GLEntry("VertexAttribL3dv", Category = "ARB", Alias = "VertexAttribL3dvEXT ")]
        public static GLDelegate.VertexAttribL3dv _VertexAttribL3dv = null;
        public static GLDelegate.VertexAttribL3dv VertexAttribL3dvEXT = VertexAttribL3dv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL3dv.</para>
        /// <para>Fullname: VertexAttribL3dv</para>
        /// <para>Aliases: VertexAttribL3dvEXT, </para>
        /// <para>Extensions: ARB_vertex_attrib_64bit EXT_vertex_attrib_64bit</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribL3dv(uint index, double[] v)
        {
            if (gl._VertexAttribL3dv != null) gl._VertexAttribL3dv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL4d</para>
        /// </summary>
        [GLEntry("VertexAttribL4d", Category = "ARB", Alias = "VertexAttribL4dEXT ")]
        public static GLDelegate.VertexAttribL4d _VertexAttribL4d = null;
        public static GLDelegate.VertexAttribL4d VertexAttribL4dEXT = VertexAttribL4d;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL4d.</para>
        /// <para>Fullname: VertexAttribL4d</para>
        /// <para>Aliases: VertexAttribL4dEXT, </para>
        /// <para>Extensions: ARB_vertex_attrib_64bit EXT_vertex_attrib_64bit</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribL4d(uint index, double x, double y, double z, double w)
        {
            if (gl._VertexAttribL4d != null) gl._VertexAttribL4d(index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL4dv</para>
        /// </summary>
        [GLEntry("VertexAttribL4dv", Category = "ARB", Alias = "VertexAttribL4dvEXT ")]
        public static GLDelegate.VertexAttribL4dv _VertexAttribL4dv = null;
        public static GLDelegate.VertexAttribL4dv VertexAttribL4dvEXT = VertexAttribL4dv;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL4dv.</para>
        /// <para>Fullname: VertexAttribL4dv</para>
        /// <para>Aliases: VertexAttribL4dvEXT, </para>
        /// <para>Extensions: ARB_vertex_attrib_64bit EXT_vertex_attrib_64bit</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribL4dv(uint index, double[] v)
        {
            if (gl._VertexAttribL4dv != null) gl._VertexAttribL4dv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribLFormat</para>
        /// </summary>
        [GLEntry("VertexAttribLFormat", Category = "ARB")]
        public static GLDelegate.VertexAttribLFormat _VertexAttribLFormat = null;
        /// <summary>
        /// <para>OpenGL currently supports (at least) 16 vertex attributes and 16 vertex buffer bindings, with a fixed mapping between vertex attributes and vertex buffer bindings. This extension allows the application to change the mapping between attributes and bindings, which can make it more efficient to update vertex buffer bindings for interleaved vertex formats where many attributes share the same buffer. This extension also separates the vertex binding update from the vertex attribute format update, which saves applications the effort of redundantly specifying the same format state over and over. Conceptually, this extension splits the state for generic vertex attribute arrays into: - An array of vertex buffer binding points, each of which specifies: - a bound buffer object, - a starting offset for the vertex attribute data in that buffer object, - a stride used by all attributes using that binding point, and - a frequency divisor used by all attributes using that binding point. - An array of g...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribLFormat.</para>
        /// <para>Fullname: VertexAttribLFormat</para>
        /// <para>Extensions: ARB_vertex_attrib_binding</para>
        /// </summary>
        public static void VertexAttribLFormat(uint attribindex, int size, int type, uint relativeoffset)
        {
            if (gl._VertexAttribLFormat != null) gl._VertexAttribLFormat(attribindex, size, type, relativeoffset); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribLPointer</para>
        /// </summary>
        [GLEntry("VertexAttribLPointer", Category = "ARB", Alias = "VertexAttribLPointerEXT ")]
        public static GLDelegate.VertexAttribLPointer _VertexAttribLPointer = null;
        public static GLDelegate.VertexAttribLPointer VertexAttribLPointerEXT = VertexAttribLPointer;
        /// <summary>
        /// <para>This extension provides OpenGL shading language support for vertex shader inputs with 64-bit floating-point components and OpenGL API support for specifying the value of those inputs using vertex array or immediate mode entry points.  This builds on the support for general-purpose support for 64-bit floating-point values in the ARB_gpu_shader_fp64 extension. This extension provides a new class of vertex attribute functions, beginning with "VertexAttribL" ("L" for "long"), that can be used to specify attributes with 64-bit floating-point components.  This extension provides no automatic type conversion between attribute and shader variables; single-precision attributes are not automatically converted to double-precision or vice versa.  For shader variables with 64-bit component types, the "VertexAttribL" functions must be used to specify attribute values.  For other shader variables, the "VertexAttribL" functions must not be used.  If a vertex attribute is specified using the wrong attr...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribLPointer.</para>
        /// <para>Fullname: VertexAttribLPointer</para>
        /// <para>Aliases: VertexAttribLPointerEXT, </para>
        /// <para>Extensions: ARB_vertex_attrib_64bit EXT_vertex_attrib_64bit</para>
        /// </summary>
        public static void VertexAttribLPointer(uint index, int size, int type, int stride, IntPtr pointer)
        {
            if (gl._VertexAttribLPointer != null) gl._VertexAttribLPointer(index, size, type, stride, pointer); else { }
        }
        /// <summary>
        /// <para>This extension provides OpenGL shading language support for vertex shader inputs with 64-bit floating-point components and OpenGL API support for specifying the value of those inputs using vertex array or immediate mode entry points.  This builds on the support for general-purpose support for 64-bit floating-point values in the ARB_gpu_shader_fp64 extension. This extension provides a new class of vertex attribute functions, beginning with "VertexAttribL" ("L" for "long"), that can be used to specify attributes with 64-bit floating-point components.  This extension provides no automatic type conversion between attribute and shader variables; single-precision attributes are not automatically converted to double-precision or vice versa.  For shader variables with 64-bit component types, the "VertexAttribL" functions must be used to specify attribute values.  For other shader variables, the "VertexAttribL" functions must not be used.  If a vertex attribute is specified using the wrong attr...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribLPointer.</para>
        /// <para>Fullname: VertexAttribLPointer</para>
        /// <para>Aliases: VertexAttribLPointerEXT, </para>
        /// <para>Extensions: ARB_vertex_attrib_64bit EXT_vertex_attrib_64bit</para>
        /// </summary>
        public static void VertexAttribLPointer(uint index, int size, int type, int stride, Array pointer)
        {
            GCHandle h = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try { if (gl._VertexAttribLPointer != null) gl._VertexAttribLPointer(index, size, type, stride, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribP1ui</para>
        /// </summary>
        [GLEntry("VertexAttribP1ui", Category = "ARB")]
        public static GLDelegate.VertexAttribP1ui _VertexAttribP1ui = null;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribP1ui.</para>
        /// <para>Fullname: VertexAttribP1ui</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribP1ui(uint index, int type, bool normalized, uint value)
        {
            if (gl._VertexAttribP1ui != null) gl._VertexAttribP1ui(index, type, normalized, value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribP1uiv</para>
        /// </summary>
        [GLEntry("VertexAttribP1uiv", Category = "ARB")]
        public static GLDelegate.VertexAttribP1uiv _VertexAttribP1uiv = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribP1uiv.</para>
        /// <para>Fullname: VertexAttribP1uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void VertexAttribP1uiv(uint index, int type, bool normalized, uint[] value)
        {
            if (gl._VertexAttribP1uiv != null) gl._VertexAttribP1uiv(index, type, normalized, value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribP1uiv</para>
        /// </summary>
        [GLEntry("VertexAttribP1uiv", Category = "ARB")]
        public static GLDelegate.VertexAttribP1uiv_uint _VertexAttribP1uiv_uint = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribP1uiv_uint.</para>
        /// <para>Fullname: VertexAttribP1uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void VertexAttribP1uiv(uint index, int type, bool normalized, ref uint value)
        {
            if (gl._VertexAttribP1uiv_uint != null) gl._VertexAttribP1uiv_uint(index, type, normalized, ref value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribP2ui</para>
        /// </summary>
        [GLEntry("VertexAttribP2ui", Category = "ARB")]
        public static GLDelegate.VertexAttribP2ui _VertexAttribP2ui = null;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribP2ui.</para>
        /// <para>Fullname: VertexAttribP2ui</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribP2ui(uint index, int type, bool normalized, uint value)
        {
            if (gl._VertexAttribP2ui != null) gl._VertexAttribP2ui(index, type, normalized, value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribP2uiv</para>
        /// </summary>
        [GLEntry("VertexAttribP2uiv", Category = "ARB")]
        public static GLDelegate.VertexAttribP2uiv_uint _VertexAttribP2uiv_uint = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribP2uiv_uint.</para>
        /// <para>Fullname: VertexAttribP2uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void VertexAttribP2uiv(uint index, int type, bool normalized, ref uint value)
        {
            if (gl._VertexAttribP2uiv_uint != null) gl._VertexAttribP2uiv_uint(index, type, normalized, ref value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribP2uiv</para>
        /// </summary>
        [GLEntry("VertexAttribP2uiv", Category = "ARB")]
        public static GLDelegate.VertexAttribP2uiv _VertexAttribP2uiv = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribP2uiv.</para>
        /// <para>Fullname: VertexAttribP2uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void VertexAttribP2uiv(uint index, int type, bool normalized, uint[] value)
        {
            if (gl._VertexAttribP2uiv != null) gl._VertexAttribP2uiv(index, type, normalized, value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribP3ui</para>
        /// </summary>
        [GLEntry("VertexAttribP3ui", Category = "ARB")]
        public static GLDelegate.VertexAttribP3ui _VertexAttribP3ui = null;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribP3ui.</para>
        /// <para>Fullname: VertexAttribP3ui</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribP3ui(uint index, int type, bool normalized, uint value)
        {
            if (gl._VertexAttribP3ui != null) gl._VertexAttribP3ui(index, type, normalized, value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribP3uiv</para>
        /// </summary>
        [GLEntry("VertexAttribP3uiv", Category = "ARB")]
        public static GLDelegate.VertexAttribP3uiv_uint _VertexAttribP3uiv_uint = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribP3uiv_uint.</para>
        /// <para>Fullname: VertexAttribP3uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void VertexAttribP3uiv(uint index, int type, bool normalized, ref uint value)
        {
            if (gl._VertexAttribP3uiv_uint != null) gl._VertexAttribP3uiv_uint(index, type, normalized, ref value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribP3uiv</para>
        /// </summary>
        [GLEntry("VertexAttribP3uiv", Category = "ARB")]
        public static GLDelegate.VertexAttribP3uiv _VertexAttribP3uiv = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribP3uiv.</para>
        /// <para>Fullname: VertexAttribP3uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void VertexAttribP3uiv(uint index, int type, bool normalized, uint[] value)
        {
            if (gl._VertexAttribP3uiv != null) gl._VertexAttribP3uiv(index, type, normalized, value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribP4ui</para>
        /// </summary>
        [GLEntry("VertexAttribP4ui", Category = "ARB")]
        public static GLDelegate.VertexAttribP4ui _VertexAttribP4ui = null;
        /// <summary>
        /// <para>Specifies the value of a generic vertex attribute</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribP4ui.</para>
        /// <para>Fullname: VertexAttribP4ui</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex attribute to be modified.</param>
        /// <param name="v0">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v1">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v2">Specifies the new values to be used for the specified vertex attribute.</param>
        /// <param name="v3">Specifies the new values to be used for the specified vertex attribute.</param>
        public static void VertexAttribP4ui(uint index, int type, bool normalized, uint value)
        {
            if (gl._VertexAttribP4ui != null) gl._VertexAttribP4ui(index, type, normalized, value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribP4uiv</para>
        /// </summary>
        [GLEntry("VertexAttribP4uiv", Category = "ARB")]
        public static GLDelegate.VertexAttribP4uiv _VertexAttribP4uiv = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribP4uiv.</para>
        /// <para>Fullname: VertexAttribP4uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void VertexAttribP4uiv(uint index, int type, bool normalized, uint[] value)
        {
            if (gl._VertexAttribP4uiv != null) gl._VertexAttribP4uiv(index, type, normalized, value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribP4uiv</para>
        /// </summary>
        [GLEntry("VertexAttribP4uiv", Category = "ARB")]
        public static GLDelegate.VertexAttribP4uiv_uint _VertexAttribP4uiv_uint = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribP4uiv_uint.</para>
        /// <para>Fullname: VertexAttribP4uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void VertexAttribP4uiv(uint index, int type, bool normalized, ref uint value)
        {
            if (gl._VertexAttribP4uiv_uint != null) gl._VertexAttribP4uiv_uint(index, type, normalized, ref value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexBindingDivisor</para>
        /// </summary>
        [GLEntry("VertexBindingDivisor", Category = "ARB")]
        public static GLDelegate.VertexBindingDivisor _VertexBindingDivisor = null;
        /// <summary>
        /// <para>modify the rate at which generic vertex attributes advance</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexBindingDivisor.</para>
        /// <para>Fullname: VertexBindingDivisor</para>
        /// <para>Extensions: ARB_vertex_attrib_binding</para>
        /// </summary>
        /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
        /// <param name="divisor">The new value for the instance step rate to apply.</param>
        public static void VertexBindingDivisor(uint bindingindex, uint divisor)
        {
            if (gl._VertexBindingDivisor != null) gl._VertexBindingDivisor(bindingindex, divisor); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexBlendARB</para>
        /// </summary>
        [GLEntry("VertexBlendARB", Category = "ARB")]
        public static GLDelegate.VertexBlend _VertexBlend = null;
        /// <summary>
        /// <para>This extension provides the ability to replace the single modelview transformation with a set of n vertex units. (Where n is constrained to an implementation defined maximum.) Each unit has its own modelview transform matrix. For each unit, there is a current weight associated with the vertex. When this extension is enabled the vertices are transformed by the modelview matrices of all of the enabled units. Afterward, these results are scaled by the weights for the respective units and then summed to create the eye-space vertex. A similar procedure is followed for the normals, except they are transformed by the inverse transpose of the modelview matrices. This extension is an orthoganalized version of functionality already provided by other 3D graphics API's.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexBlend.</para>
        /// <para>Fullname: VertexBlendARB</para>
        /// <para>Extensions: ARB_vertex_blend</para>
        /// </summary>
        public static void VertexBlend(int count)
        {
            if (gl._VertexBlend != null) gl._VertexBlend(count); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexP2ui</para>
        /// </summary>
        [GLEntry("VertexP2ui", Category = "ARB")]
        public static GLDelegate.VertexP2ui _VertexP2ui = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexP2ui.</para>
        /// <para>Fullname: VertexP2ui</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void VertexP2ui(int type, uint value)
        {
            if (gl._VertexP2ui != null) gl._VertexP2ui(type, value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexP2uiv</para>
        /// </summary>
        [GLEntry("VertexP2uiv", Category = "ARB")]
        public static GLDelegate.VertexP2uiv _VertexP2uiv = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexP2uiv.</para>
        /// <para>Fullname: VertexP2uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void VertexP2uiv(int type, uint[] value)
        {
            if (gl._VertexP2uiv != null) gl._VertexP2uiv(type, value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexP2uiv</para>
        /// </summary>
        [GLEntry("VertexP2uiv", Category = "ARB")]
        public static GLDelegate.VertexP2uiv_uint _VertexP2uiv_uint = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexP2uiv_uint.</para>
        /// <para>Fullname: VertexP2uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void VertexP2uiv(int type, ref uint value)
        {
            if (gl._VertexP2uiv_uint != null) gl._VertexP2uiv_uint(type, ref value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexP3ui</para>
        /// </summary>
        [GLEntry("VertexP3ui", Category = "ARB")]
        public static GLDelegate.VertexP3ui _VertexP3ui = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexP3ui.</para>
        /// <para>Fullname: VertexP3ui</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void VertexP3ui(int type, uint value)
        {
            if (gl._VertexP3ui != null) gl._VertexP3ui(type, value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexP3uiv</para>
        /// </summary>
        [GLEntry("VertexP3uiv", Category = "ARB")]
        public static GLDelegate.VertexP3uiv_uint _VertexP3uiv_uint = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexP3uiv_uint.</para>
        /// <para>Fullname: VertexP3uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void VertexP3uiv(int type, ref uint value)
        {
            if (gl._VertexP3uiv_uint != null) gl._VertexP3uiv_uint(type, ref value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexP3uiv</para>
        /// </summary>
        [GLEntry("VertexP3uiv", Category = "ARB")]
        public static GLDelegate.VertexP3uiv _VertexP3uiv = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexP3uiv.</para>
        /// <para>Fullname: VertexP3uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void VertexP3uiv(int type, uint[] value)
        {
            if (gl._VertexP3uiv != null) gl._VertexP3uiv(type, value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexP4ui</para>
        /// </summary>
        [GLEntry("VertexP4ui", Category = "ARB")]
        public static GLDelegate.VertexP4ui _VertexP4ui = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexP4ui.</para>
        /// <para>Fullname: VertexP4ui</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void VertexP4ui(int type, uint value)
        {
            if (gl._VertexP4ui != null) gl._VertexP4ui(type, value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexP4uiv</para>
        /// </summary>
        [GLEntry("VertexP4uiv", Category = "ARB")]
        public static GLDelegate.VertexP4uiv_uint _VertexP4uiv_uint = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexP4uiv_uint.</para>
        /// <para>Fullname: VertexP4uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void VertexP4uiv(int type, ref uint value)
        {
            if (gl._VertexP4uiv_uint != null) gl._VertexP4uiv_uint(type, ref value); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexP4uiv</para>
        /// </summary>
        [GLEntry("VertexP4uiv", Category = "ARB")]
        public static GLDelegate.VertexP4uiv _VertexP4uiv = null;
        /// <summary>
        /// <para>This extension adds the following data formats: Two new vertex attribute data formats: a signed 2.10.10.10 and an unsigned 2.10.10.10 vertex data format. These vertex data formats describe a 4 component stream which can be used to store normals or other attributes in a quantized form. Normals, tangents, binormals and other vertex attributes can often be specified at reduced precision without introducing noticeable artifacts, reducing the amount of memory and memory bandwidth they consume. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexP4uiv.</para>
        /// <para>Fullname: VertexP4uiv</para>
        /// <para>Extensions: ARB_vertex_type_2_10_10_10_rev</para>
        /// </summary>
        public static void VertexP4uiv(int type, uint[] value)
        {
            if (gl._VertexP4uiv != null) gl._VertexP4uiv(type, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ViewportArrayv</para>
        /// </summary>
        [GLEntry("ViewportArrayv", Category = "ARB")]
        public static GLDelegate.ViewportArrayv _ViewportArrayv = null;
        /// <summary>
        /// <para>set multiple viewports</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ViewportArrayv.</para>
        /// <para>Fullname: ViewportArrayv</para>
        /// <para>Extensions: ARB_viewport_array</para>
        /// </summary>
        /// <param name="first">Specify the first viewport to set.</param>
        /// <param name="count">Specify the number of viewports to set.</param>
        /// <param name="v">Specify the address of an array containing the viewport parameters.</param>
        public static void ViewportArrayv(uint first, int count, float[] v)
        {
            if (gl._ViewportArrayv != null) gl._ViewportArrayv(first, count, v); else { }
        }
        /// <summary>
        /// <para>Fullname: ViewportIndexedf</para>
        /// </summary>
        [GLEntry("ViewportIndexedf", Category = "ARB")]
        public static GLDelegate.ViewportIndexedf _ViewportIndexedf = null;
        /// <summary>
        /// <para>set a specified viewport</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ViewportIndexedf.</para>
        /// <para>Fullname: ViewportIndexedf</para>
        /// <para>Extensions: ARB_viewport_array</para>
        /// </summary>
        /// <param name="index">Specify the first viewport to set.</param>
        /// <param name="x">For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).</param>
        /// <param name="y">For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).</param>
        /// <param name="width">For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.</param>
        /// <param name="height">For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.</param>
        /// <param name="v">For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.</param>
        public static void ViewportIndexedf(uint index, float x, float y, float w, float h)
        {
            if (gl._ViewportIndexedf != null) gl._ViewportIndexedf(index, x, y, w, h); else { }
        }
        /// <summary>
        /// <para>Fullname: ViewportIndexedfv</para>
        /// </summary>
        [GLEntry("ViewportIndexedfv", Category = "ARB")]
        public static GLDelegate.ViewportIndexedfv _ViewportIndexedfv = null;
        /// <summary>
        /// <para>set a specified viewport</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ViewportIndexedfv.</para>
        /// <para>Fullname: ViewportIndexedfv</para>
        /// <para>Extensions: ARB_viewport_array</para>
        /// </summary>
        /// <param name="index">Specify the first viewport to set.</param>
        /// <param name="x">For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).</param>
        /// <param name="y">For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).</param>
        /// <param name="width">For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.</param>
        /// <param name="height">For glViewportIndexedf, specifies the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.</param>
        /// <param name="v">For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.</param>
        public static void ViewportIndexedfv(uint index, float[] v)
        {
            if (gl._ViewportIndexedfv != null) gl._ViewportIndexedfv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: WaitSync</para>
        /// </summary>
        [GLEntry("WaitSync", Category = "ARB")]
        public static GLDelegate.WaitSync _WaitSync = null;
        /// <summary>
        /// <para>instruct the GL server to block until the specified sync object becomes signaled</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WaitSync.</para>
        /// <para>Fullname: WaitSync</para>
        /// <para>Extensions: ARB_sync</para>
        /// </summary>
        /// <param name="sync">Specifies the sync object whose status to wait on.</param>
        /// <param name="flags">A bitfield controlling the command flushing behavior. flags may be zero.</param>
        /// <param name="timeout">Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED.</param>
        public static void WaitSync(IntPtr sync, int flags, ulong timeout)
        {
            if (gl._WaitSync != null) gl._WaitSync(sync, flags, timeout); else { }
        }
        /// <summary>
        /// <para>Fullname: WeightbvARB</para>
        /// </summary>
        [GLEntry("WeightbvARB", Category = "ARB")]
        public static GLDelegate.Weightbv _Weightbv = null;
        /// <summary>
        /// <para>This extension provides the ability to replace the single modelview transformation with a set of n vertex units. (Where n is constrained to an implementation defined maximum.) Each unit has its own modelview transform matrix. For each unit, there is a current weight associated with the vertex. When this extension is enabled the vertices are transformed by the modelview matrices of all of the enabled units. Afterward, these results are scaled by the weights for the respective units and then summed to create the eye-space vertex. A similar procedure is followed for the normals, except they are transformed by the inverse transpose of the modelview matrices. This extension is an orthoganalized version of functionality already provided by other 3D graphics API's.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Weightbv.</para>
        /// <para>Fullname: WeightbvARB</para>
        /// <para>Extensions: ARB_vertex_blend</para>
        /// </summary>
        public static void Weightbv(int size, byte[] weights)
        {
            if (gl._Weightbv != null) gl._Weightbv(size, weights); else { }
        }
        /// <summary>
        /// <para>Fullname: WeightdvARB</para>
        /// </summary>
        [GLEntry("WeightdvARB", Category = "ARB")]
        public static GLDelegate.Weightdv _Weightdv = null;
        /// <summary>
        /// <para>This extension provides the ability to replace the single modelview transformation with a set of n vertex units. (Where n is constrained to an implementation defined maximum.) Each unit has its own modelview transform matrix. For each unit, there is a current weight associated with the vertex. When this extension is enabled the vertices are transformed by the modelview matrices of all of the enabled units. Afterward, these results are scaled by the weights for the respective units and then summed to create the eye-space vertex. A similar procedure is followed for the normals, except they are transformed by the inverse transpose of the modelview matrices. This extension is an orthoganalized version of functionality already provided by other 3D graphics API's.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Weightdv.</para>
        /// <para>Fullname: WeightdvARB</para>
        /// <para>Extensions: ARB_vertex_blend</para>
        /// </summary>
        public static void Weightdv(int size, double[] weights)
        {
            if (gl._Weightdv != null) gl._Weightdv(size, weights); else { }
        }
        /// <summary>
        /// <para>Fullname: WeightfvARB</para>
        /// </summary>
        [GLEntry("WeightfvARB", Category = "ARB")]
        public static GLDelegate.Weightfv _Weightfv = null;
        /// <summary>
        /// <para>This extension provides the ability to replace the single modelview transformation with a set of n vertex units. (Where n is constrained to an implementation defined maximum.) Each unit has its own modelview transform matrix. For each unit, there is a current weight associated with the vertex. When this extension is enabled the vertices are transformed by the modelview matrices of all of the enabled units. Afterward, these results are scaled by the weights for the respective units and then summed to create the eye-space vertex. A similar procedure is followed for the normals, except they are transformed by the inverse transpose of the modelview matrices. This extension is an orthoganalized version of functionality already provided by other 3D graphics API's.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Weightfv.</para>
        /// <para>Fullname: WeightfvARB</para>
        /// <para>Extensions: ARB_vertex_blend</para>
        /// </summary>
        public static void Weightfv(int size, float[] weights)
        {
            if (gl._Weightfv != null) gl._Weightfv(size, weights); else { }
        }
        /// <summary>
        /// <para>Fullname: WeightivARB</para>
        /// </summary>
        [GLEntry("WeightivARB", Category = "ARB")]
        public static GLDelegate.Weightiv _Weightiv = null;
        /// <summary>
        /// <para>This extension provides the ability to replace the single modelview transformation with a set of n vertex units. (Where n is constrained to an implementation defined maximum.) Each unit has its own modelview transform matrix. For each unit, there is a current weight associated with the vertex. When this extension is enabled the vertices are transformed by the modelview matrices of all of the enabled units. Afterward, these results are scaled by the weights for the respective units and then summed to create the eye-space vertex. A similar procedure is followed for the normals, except they are transformed by the inverse transpose of the modelview matrices. This extension is an orthoganalized version of functionality already provided by other 3D graphics API's.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Weightiv.</para>
        /// <para>Fullname: WeightivARB</para>
        /// <para>Extensions: ARB_vertex_blend</para>
        /// </summary>
        public static void Weightiv(int size, int[] weights)
        {
            if (gl._Weightiv != null) gl._Weightiv(size, weights); else { }
        }
        /// <summary>
        /// <para>Fullname: WeightPointerARB</para>
        /// </summary>
        [GLEntry("WeightPointerARB", Category = "ARB")]
        public static GLDelegate.WeightPointer _WeightPointer = null;
        /// <summary>
        /// <para>This extension provides the ability to replace the single modelview transformation with a set of n vertex units. (Where n is constrained to an implementation defined maximum.) Each unit has its own modelview transform matrix. For each unit, there is a current weight associated with the vertex. When this extension is enabled the vertices are transformed by the modelview matrices of all of the enabled units. Afterward, these results are scaled by the weights for the respective units and then summed to create the eye-space vertex. A similar procedure is followed for the normals, except they are transformed by the inverse transpose of the modelview matrices. This extension is an orthoganalized version of functionality already provided by other 3D graphics API's.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WeightPointer.</para>
        /// <para>Fullname: WeightPointerARB</para>
        /// <para>Extensions: ARB_vertex_blend</para>
        /// </summary>
        public static void WeightPointer(int size, int type, int stride, IntPtr pointer)
        {
            if (gl._WeightPointer != null) gl._WeightPointer(size, type, stride, pointer); else { }
        }
        /// <summary>
        /// <para>This extension provides the ability to replace the single modelview transformation with a set of n vertex units. (Where n is constrained to an implementation defined maximum.) Each unit has its own modelview transform matrix. For each unit, there is a current weight associated with the vertex. When this extension is enabled the vertices are transformed by the modelview matrices of all of the enabled units. Afterward, these results are scaled by the weights for the respective units and then summed to create the eye-space vertex. A similar procedure is followed for the normals, except they are transformed by the inverse transpose of the modelview matrices. This extension is an orthoganalized version of functionality already provided by other 3D graphics API's.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WeightPointer.</para>
        /// <para>Fullname: WeightPointerARB</para>
        /// <para>Extensions: ARB_vertex_blend</para>
        /// </summary>
        public static void WeightPointer(int size, int type, int stride, Array pointer)
        {
            GCHandle h = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try { if (gl._WeightPointer != null) gl._WeightPointer(size, type, stride, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: WeightsvARB</para>
        /// </summary>
        [GLEntry("WeightsvARB", Category = "ARB")]
        public static GLDelegate.Weightsv _Weightsv = null;
        /// <summary>
        /// <para>This extension provides the ability to replace the single modelview transformation with a set of n vertex units. (Where n is constrained to an implementation defined maximum.) Each unit has its own modelview transform matrix. For each unit, there is a current weight associated with the vertex. When this extension is enabled the vertices are transformed by the modelview matrices of all of the enabled units. Afterward, these results are scaled by the weights for the respective units and then summed to create the eye-space vertex. A similar procedure is followed for the normals, except they are transformed by the inverse transpose of the modelview matrices. This extension is an orthoganalized version of functionality already provided by other 3D graphics API's.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Weightsv.</para>
        /// <para>Fullname: WeightsvARB</para>
        /// <para>Extensions: ARB_vertex_blend</para>
        /// </summary>
        public static void Weightsv(int size, short[] weights)
        {
            if (gl._Weightsv != null) gl._Weightsv(size, weights); else { }
        }
        /// <summary>
        /// <para>Fullname: WeightubvARB</para>
        /// </summary>
        [GLEntry("WeightubvARB", Category = "ARB")]
        public static GLDelegate.Weightubv _Weightubv = null;
        /// <summary>
        /// <para>This extension provides the ability to replace the single modelview transformation with a set of n vertex units. (Where n is constrained to an implementation defined maximum.) Each unit has its own modelview transform matrix. For each unit, there is a current weight associated with the vertex. When this extension is enabled the vertices are transformed by the modelview matrices of all of the enabled units. Afterward, these results are scaled by the weights for the respective units and then summed to create the eye-space vertex. A similar procedure is followed for the normals, except they are transformed by the inverse transpose of the modelview matrices. This extension is an orthoganalized version of functionality already provided by other 3D graphics API's.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Weightubv.</para>
        /// <para>Fullname: WeightubvARB</para>
        /// <para>Extensions: ARB_vertex_blend</para>
        /// </summary>
        public static void Weightubv(int size, byte[] weights)
        {
            if (gl._Weightubv != null) gl._Weightubv(size, weights); else { }
        }
        /// <summary>
        /// <para>Fullname: WeightuivARB</para>
        /// </summary>
        [GLEntry("WeightuivARB", Category = "ARB")]
        public static GLDelegate.Weightuiv _Weightuiv = null;
        /// <summary>
        /// <para>This extension provides the ability to replace the single modelview transformation with a set of n vertex units. (Where n is constrained to an implementation defined maximum.) Each unit has its own modelview transform matrix. For each unit, there is a current weight associated with the vertex. When this extension is enabled the vertices are transformed by the modelview matrices of all of the enabled units. Afterward, these results are scaled by the weights for the respective units and then summed to create the eye-space vertex. A similar procedure is followed for the normals, except they are transformed by the inverse transpose of the modelview matrices. This extension is an orthoganalized version of functionality already provided by other 3D graphics API's.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Weightuiv.</para>
        /// <para>Fullname: WeightuivARB</para>
        /// <para>Extensions: ARB_vertex_blend</para>
        /// </summary>
        public static void Weightuiv(int size, uint[] weights)
        {
            if (gl._Weightuiv != null) gl._Weightuiv(size, weights); else { }
        }
        /// <summary>
        /// <para>Fullname: WeightusvARB</para>
        /// </summary>
        [GLEntry("WeightusvARB", Category = "ARB")]
        public static GLDelegate.Weightusv _Weightusv = null;
        /// <summary>
        /// <para>This extension provides the ability to replace the single modelview transformation with a set of n vertex units. (Where n is constrained to an implementation defined maximum.) Each unit has its own modelview transform matrix. For each unit, there is a current weight associated with the vertex. When this extension is enabled the vertices are transformed by the modelview matrices of all of the enabled units. Afterward, these results are scaled by the weights for the respective units and then summed to create the eye-space vertex. A similar procedure is followed for the normals, except they are transformed by the inverse transpose of the modelview matrices. This extension is an orthoganalized version of functionality already provided by other 3D graphics API's.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Weightusv.</para>
        /// <para>Fullname: WeightusvARB</para>
        /// <para>Extensions: ARB_vertex_blend</para>
        /// </summary>
        public static void Weightusv(int size, ushort[] weights)
        {
            if (gl._Weightusv != null) gl._Weightusv(size, weights); else { }
        }
        /// <summary>
        /// <para>Fullname: DebugMessageCallback</para>
        /// </summary>
        [GLEntry("DebugMessageCallback", Category = "KHR", Alias = "DebugMessageCallbackARB ")]
        public static GLDelegate.DebugMessageCallback _DebugMessageCallback = null;
        public static GLDelegate.DebugMessageCallback DebugMessageCallbackARB = DebugMessageCallback;
        /// <summary>
        /// <para>specify a callback to receive debugging messages from the GL</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DebugMessageCallback.</para>
        /// <para>Fullname: DebugMessageCallback</para>
        /// <para>Aliases: DebugMessageCallbackARB, </para>
        /// <para>Extensions: KHR_debug</para>
        /// </summary>
        /// <param name="callback">The address of a callback function that will be called when a debug message is generated.</param>
        /// <param name="userParam">A user supplied pointer that will be passed on each invocation of callback.</param>
        public static void DebugMessageCallback(GLDEBUGPROC callback, IntPtr userParam)
        {
            if (gl._DebugMessageCallback != null) gl._DebugMessageCallback(callback, userParam); else { }
        }
        /// <summary>
        /// <para>Fullname: DebugMessageControl</para>
        /// </summary>
        [GLEntry("DebugMessageControl", Category = "KHR", Alias = "DebugMessageControlARB ")]
        public static GLDelegate.DebugMessageControl _DebugMessageControl = null;
        public static GLDelegate.DebugMessageControl DebugMessageControlARB = DebugMessageControl;
        /// <summary>
        /// <para>control the reporting of debug messages in a debug context</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DebugMessageControl.</para>
        /// <para>Fullname: DebugMessageControl</para>
        /// <para>Aliases: DebugMessageControlARB, </para>
        /// <para>Extensions: KHR_debug</para>
        /// </summary>
        /// <param name="source">The source of debug messages to enable or disable.</param>
        /// <param name="type">The type of debug messages to enable or disable.</param>
        /// <param name="severity">The severity of debug messages to enable or disable.</param>
        /// <param name="count">The length of the array ids.</param>
        /// <param name="ids">The address of an array of unsigned integers contianing the ids of the messages to enable or disable.</param>
        /// <param name="enabled">A Boolean flag determining whether the selected messages should be enabled or disabled.</param>
        public static void DebugMessageControl(int source, int type, int severity, int count, uint[] ids, bool enabled)
        {
            if (gl._DebugMessageControl != null) gl._DebugMessageControl(source, type, severity, count, ids, enabled); else { }
        }
        /// <summary>
        /// <para>Fullname: DebugMessageInsert</para>
        /// </summary>
        [GLEntry("DebugMessageInsert", Category = "KHR", Alias = "DebugMessageInsertARB ")]
        public static GLDelegate.DebugMessageInsert _DebugMessageInsert = null;
        public static GLDelegate.DebugMessageInsert DebugMessageInsertARB = DebugMessageInsert;
        /// <summary>
        /// <para>inject an application-supplied message into the debug message queue</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DebugMessageInsert.</para>
        /// <para>Fullname: DebugMessageInsert</para>
        /// <para>Aliases: DebugMessageInsertARB, </para>
        /// <para>Extensions: KHR_debug</para>
        /// </summary>
        /// <param name="source">The source of the debug message to insert.</param>
        /// <param name="type">The type of the debug message insert.</param>
        /// <param name="id">The user-supplied identifier of the message to insert.</param>
        /// <param name="severity">The severity of the debug messages to insert.</param>
        /// <param name="length">The length string contained in the character array whose address is given by message.</param>
        /// <param name="message">The address of a character array containing the message to insert.</param>
        public static void DebugMessageInsert(int source, int type, uint id, int severity, int length, StringBuilder buf)
        {
            if (gl._DebugMessageInsert != null) gl._DebugMessageInsert(source, type, id, severity, length, buf); else { }
        }
        /// <summary>
        /// <para>Fullname: GetDebugMessageLog</para>
        /// </summary>
        [GLEntry("GetDebugMessageLog", Category = "KHR", Alias = "GetDebugMessageLogARB ")]
        public static GLDelegate.GetDebugMessageLog _GetDebugMessageLog = null;
        public static GLDelegate.GetDebugMessageLog GetDebugMessageLogARB = GetDebugMessageLog;
        /// <summary>
        /// <para>retrieve messages from the debug message log</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetDebugMessageLog.</para>
        /// <para>Fullname: GetDebugMessageLog</para>
        /// <para>Aliases: GetDebugMessageLogARB, </para>
        /// <para>Extensions: KHR_debug</para>
        /// </summary>
        /// <param name="count">The number of debug messages to retrieve from the log.</param>
        /// <param name="bufSize">The size of the buffer whose address is given by messageLog.</param>
        /// <param name="sources">The address of an array of variables to receive the sources of the retrieved messages.</param>
        /// <param name="types">The address of an array of variables to receive the types of the retrieved messages.</param>
        /// <param name="ids">The address of an array of unsigned integers to receive the ids of the retrieved messages.</param>
        /// <param name="severities">The address of an array of variables to receive the severites of the retrieved messages.</param>
        /// <param name="lengths">The address of an array of variables to receive the lengths of the received messages.</param>
        /// <param name="messageLog">The address of an array of characters that will receive the messages.</param>
        public static uint GetDebugMessageLog(uint count, int bufsize, int[] sources, int[] types, uint[] ids, int[] severities, int[] lengths, StringBuilder messageLog)
        {
            if (gl._GetDebugMessageLog != null) return gl._GetDebugMessageLog(count, bufsize, sources, types, ids, severities, lengths, messageLog);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: GetObjectLabel</para>
        /// </summary>
        [GLEntry("GetObjectLabel", Category = "KHR")]
        public static GLDelegate.GetObjectLabel _GetObjectLabel = null;
        /// <summary>
        /// <para>retrieve the label of a named object identified within a namespace</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetObjectLabel.</para>
        /// <para>Fullname: GetObjectLabel</para>
        /// <para>Extensions: KHR_debug</para>
        /// </summary>
        /// <param name="identifier">The namespace from which the name of the object is allocated.</param>
        /// <param name="name">The name of the object whose label to retrieve.</param>
        /// <param name="bufSize">The length of the buffer whose address is in label.</param>
        /// <param name="length">The address of a variable to receive the length of the object label.</param>
        /// <param name="label">The address of a string that will receive the object label.</param>
        public static void GetObjectLabel(int identifier, uint name, int bufSize, int[] length, StringBuilder label)
        {
            if (gl._GetObjectLabel != null) gl._GetObjectLabel(identifier, name, bufSize, length, label); else { }
        }
        /// <summary>
        /// <para>Fullname: GetObjectPtrLabel</para>
        /// </summary>
        [GLEntry("GetObjectPtrLabel", Category = "KHR")]
        public static GLDelegate.GetObjectPtrLabel _GetObjectPtrLabel = null;
        /// <summary>
        /// <para>retrieve the label of a sync object identified by a pointer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetObjectPtrLabel.</para>
        /// <para>Fullname: GetObjectPtrLabel</para>
        /// <para>Extensions: KHR_debug</para>
        /// </summary>
        /// <param name="ptr">The name of the sync object whose label to retrieve.</param>
        /// <param name="bufSize">The length of the buffer whose address is in label.</param>
        /// <param name="length">The address of a variable to receive the length of the object label.</param>
        /// <param name="label">The address of a string that will receive the object label.</param>
        public static void GetObjectPtrLabel(IntPtr ptr, int bufSize, int[] length, StringBuilder label)
        {
            if (gl._GetObjectPtrLabel != null) gl._GetObjectPtrLabel(ptr, bufSize, length, label); else { }
        }
        /// <summary>
        /// <para>Fullname: ObjectLabel</para>
        /// </summary>
        [GLEntry("ObjectLabel", Category = "KHR")]
        public static GLDelegate.ObjectLabel _ObjectLabel = null;
        /// <summary>
        /// <para>label a named object identified within a namespace</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ObjectLabel.</para>
        /// <para>Fullname: ObjectLabel</para>
        /// <para>Extensions: KHR_debug</para>
        /// </summary>
        /// <param name="identifier">The namespace from which the name of the object is allocated.</param>
        /// <param name="name">The name of the object to label.</param>
        /// <param name="length">The length of the label to be used for the object.</param>
        /// <param name="label">The address of a string containing the label to assign to the object.</param>
        public static void ObjectLabel(int identifier, uint name, int length, StringBuilder label)
        {
            if (gl._ObjectLabel != null) gl._ObjectLabel(identifier, name, length, label); else { }
        }
        /// <summary>
        /// <para>Fullname: ObjectPtrLabel</para>
        /// </summary>
        [GLEntry("ObjectPtrLabel", Category = "KHR")]
        public static GLDelegate.ObjectPtrLabel _ObjectPtrLabel = null;
        /// <summary>
        /// <para>label a a sync object identified by a pointer</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ObjectPtrLabel.</para>
        /// <para>Fullname: ObjectPtrLabel</para>
        /// <para>Extensions: KHR_debug</para>
        /// </summary>
        /// <param name="ptr">A pointer identifying a sync object.</param>
        /// <param name="length">The length of the label to be used for the object.</param>
        /// <param name="label">The address of a string containing the label to assign to the object.</param>
        public static void ObjectPtrLabel(IntPtr ptr, int length, StringBuilder label)
        {
            if (gl._ObjectPtrLabel != null) gl._ObjectPtrLabel(ptr, length, label); else { }
        }
        /// <summary>
        /// <para>Fullname: PopDebugGroup</para>
        /// </summary>
        [GLEntry("PopDebugGroup", Category = "KHR")]
        public static GLDelegate.PopDebugGroup _PopDebugGroup = null;
        /// <summary>
        /// <para>pop the active debug group</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PopDebugGroup.</para>
        /// <para>Fullname: PopDebugGroup</para>
        /// <para>Extensions: KHR_debug</para>
        /// </summary>
        public static void PopDebugGroup()
        {
            if (gl._PopDebugGroup != null) gl._PopDebugGroup(); else { }
        }
        /// <summary>
        /// <para>Fullname: PushDebugGroup</para>
        /// </summary>
        [GLEntry("PushDebugGroup", Category = "KHR")]
        public static GLDelegate.PushDebugGroup _PushDebugGroup = null;
        /// <summary>
        /// <para>push a named debug group into the command stream</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PushDebugGroup.</para>
        /// <para>Fullname: PushDebugGroup</para>
        /// <para>Extensions: KHR_debug</para>
        /// </summary>
        /// <param name="source">The source of the debug message.</param>
        /// <param name="id">The identifier of the message.</param>
        /// <param name="length">The length of the message to be sent to the debug output stream.</param>
        /// <param name="message">The a string containing the message to be sent to the debug output stream.</param>
        public static void PushDebugGroup(int source, uint id, int length, StringBuilder message)
        {
            if (gl._PushDebugGroup != null) gl._PushDebugGroup(source, id, length, message); else { }
        }
        /// <summary>
        /// <para>Fullname: ActiveProgramEXT</para>
        /// </summary>
        [GLEntry("ActiveProgramEXT", Category = "EXT")]
        public static GLDelegate.ActiveProgram _ActiveProgram = null;
        /// <summary>
        /// <para>Prior to this extension, GLSL requires multiple shader domains (vertex, fragment, geometry) to be linked into a single monolithic program object to specify a GLSL shader for each domain. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple domains, all existing GPU hardware supports the more flexible mix-and-match approach. HLSL9, Cg, the prior OpenGL assembly program extensions, and game console programmers favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader domains. Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This keep-it-simple extension adapts the "mix-and-match" shader domain model for GLSL so different GLSL program objects can be bound to different shader domains. This extension redefines the operation of glUseProgram(GLenum program) to be equivalent ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ActiveProgram.</para>
        /// <para>Fullname: ActiveProgramEXT</para>
        /// <para>Extensions: EXT_separate_shader_objects</para>
        /// </summary>
        public static void ActiveProgram(uint program)
        {
            if (gl._ActiveProgram != null) gl._ActiveProgram(program); else { }
        }
        /// <summary>
        /// <para>Fullname: ActiveStencilFaceEXT</para>
        /// </summary>
        [GLEntry("ActiveStencilFaceEXT", Category = "EXT")]
        public static GLDelegate.ActiveStencilFace _ActiveStencilFace = null;
        /// <summary>
        /// <para>This extension provides two-sided stencil testing where the stencil-related state (stencil operations, reference value, compare mask, and write mask) may be different for front- and back-facing polygons.  Two-sided stencil testing may improve the performance of stenciled shadow volume and Constructive Solid Geometry (CSG) rendering algorithms. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ActiveStencilFace.</para>
        /// <para>Fullname: ActiveStencilFaceEXT</para>
        /// <para>Extensions: EXT_stencil_two_side</para>
        /// </summary>
        public static void ActiveStencilFace(int face)
        {
            if (gl._ActiveStencilFace != null) gl._ActiveStencilFace(face); else { }
        }
        /// <summary>
        /// <para>Fullname: ApplyTextureEXT</para>
        /// </summary>
        [GLEntry("ApplyTextureEXT", Category = "EXT")]
        public static GLDelegate.ApplyTexture _ApplyTexture = null;
        /// <summary>
        /// <para>This extension defines a general mechanism for substituting the fragment color computed during texture environment processing in place of other fragment attributes such as the fragment normal, or as sources for some of the computations in the fragment processing pipeline, for example as material or light parameters in the fragment lighting computations. Cf ----------------------+ |                 +-> to lighting parameters v                 | +------------+        +--------+     +-------------+ |            |        |        |     |             | | texel      |------->| texenv |-----| texture     |---> Cf' (to Light Environment | generation |        |        |     | application |          or Fog) |            |        |        |     |             | +------------+        +--------+     +-------------+ </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ApplyTexture.</para>
        /// <para>Fullname: ApplyTextureEXT</para>
        /// <para>Extensions: EXT_light_texture</para>
        /// </summary>
        public static void ApplyTexture(int mode)
        {
            if (gl._ApplyTexture != null) gl._ApplyTexture(mode); else { }
        }
        /// <summary>
        /// <para>Fullname: BeginVertexShaderEXT</para>
        /// </summary>
        [GLEntry("BeginVertexShaderEXT", Category = "EXT")]
        public static GLDelegate.BeginVertexShader _BeginVertexShader = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BeginVertexShader.</para>
        /// <para>Fullname: BeginVertexShaderEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void BeginVertexShader()
        {
            if (gl._BeginVertexShader != null) gl._BeginVertexShader(); else { }
        }
        /// <summary>
        /// <para>Fullname: BindBufferOffsetEXT</para>
        /// </summary>
        [GLEntry("BindBufferOffsetEXT", Category = "EXT", Alias = "BindBufferOffsetNV ")]
        public static GLDelegate.BindBufferOffset _BindBufferOffset = null;
        public static GLDelegate.BindBufferOffset BindBufferOffsetNV = BindBufferOffset;
        /// <summary>
        /// <para>This extension provides a new mode to the GL, called transform feedback, which records selected vertex attributes for each primitive processed by the GL.  The selected attributes are written into buffer objects, and can be written with each attribute in a separate buffer object or with all attributes interleaved into a single buffer object.  If a geometry shader is active, the primitives recorded are those emitted by the geometry shader.  Otherwise, transform feedback captures primitives whose vertices are transformed by a vertex shader.  In either case, the primitives captured are those generated prior to clipping.  Transform feedback mode captures the values of specified varying variables emitted from GLSL vertex or geometry shaders. The vertex data recorded in transform feedback mode is stored into buffer objects as an array of vertex attributes.  The regular representation and the use of buffer objects allows the recorded data to be processed directly by the GL without requiring CP...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindBufferOffset.</para>
        /// <para>Fullname: BindBufferOffsetEXT</para>
        /// <para>Aliases: BindBufferOffsetNV, </para>
        /// <para>Extensions: EXT_transform_feedback NV_transform_feedback</para>
        /// </summary>
        public static void BindBufferOffset(int target, uint index, uint buffer, int offset)
        {
            if (gl._BindBufferOffset != null) gl._BindBufferOffset(target, index, buffer, offset); else { }
        }
        /// <summary>
        /// <para>Fullname: BindLightParameterEXT</para>
        /// </summary>
        [GLEntry("BindLightParameterEXT", Category = "EXT")]
        public static GLDelegate.BindLightParameter _BindLightParameter = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindLightParameter.</para>
        /// <para>Fullname: BindLightParameterEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static uint BindLightParameter(int light, int value)
        {
            if (gl._BindLightParameter != null) return gl._BindLightParameter(light, value);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: BindMaterialParameterEXT</para>
        /// </summary>
        [GLEntry("BindMaterialParameterEXT", Category = "EXT")]
        public static GLDelegate.BindMaterialParameter _BindMaterialParameter = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindMaterialParameter.</para>
        /// <para>Fullname: BindMaterialParameterEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static uint BindMaterialParameter(int face, int value)
        {
            if (gl._BindMaterialParameter != null) return gl._BindMaterialParameter(face, value);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: BindMultiTextureEXT</para>
        /// </summary>
        [GLEntry("BindMultiTextureEXT", Category = "EXT")]
        public static GLDelegate.BindMultiTexture _BindMultiTexture = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindMultiTexture.</para>
        /// <para>Fullname: BindMultiTextureEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void BindMultiTexture(int texunit, int target, uint texture)
        {
            if (gl._BindMultiTexture != null) gl._BindMultiTexture(texunit, target, texture); else { }
        }
        /// <summary>
        /// <para>Fullname: BindParameterEXT</para>
        /// </summary>
        [GLEntry("BindParameterEXT", Category = "EXT")]
        public static GLDelegate.BindParameter _BindParameter = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindParameter.</para>
        /// <para>Fullname: BindParameterEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static uint BindParameter(int value)
        {
            if (gl._BindParameter != null) return gl._BindParameter(value);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: BindTexGenParameterEXT</para>
        /// </summary>
        [GLEntry("BindTexGenParameterEXT", Category = "EXT")]
        public static GLDelegate.BindTexGenParameter _BindTexGenParameter = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindTexGenParameter.</para>
        /// <para>Fullname: BindTexGenParameterEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static uint BindTexGenParameter(int unit, int coord, int value)
        {
            if (gl._BindTexGenParameter != null) return gl._BindTexGenParameter(unit, coord, value);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: BindTextureUnitParameterEXT</para>
        /// </summary>
        [GLEntry("BindTextureUnitParameterEXT", Category = "EXT")]
        public static GLDelegate.BindTextureUnitParameter _BindTextureUnitParameter = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindTextureUnitParameter.</para>
        /// <para>Fullname: BindTextureUnitParameterEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static uint BindTextureUnitParameter(int unit, int value)
        {
            if (gl._BindTextureUnitParameter != null) return gl._BindTextureUnitParameter(unit, value);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: BindVertexShaderEXT</para>
        /// </summary>
        [GLEntry("BindVertexShaderEXT", Category = "EXT")]
        public static GLDelegate.BindVertexShader _BindVertexShader = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindVertexShader.</para>
        /// <para>Fullname: BindVertexShaderEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void BindVertexShader(uint id)
        {
            if (gl._BindVertexShader != null) gl._BindVertexShader(id); else { }
        }
        /// <summary>
        /// <para>Fullname: Binormal3bEXT</para>
        /// </summary>
        [GLEntry("Binormal3bEXT", Category = "EXT")]
        public static GLDelegate.Binormal3b _Binormal3b = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Binormal3b.</para>
        /// <para>Fullname: Binormal3bEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Binormal3b(byte bx, byte by, byte bz)
        {
            if (gl._Binormal3b != null) gl._Binormal3b(bx, by, bz); else { }
        }
        /// <summary>
        /// <para>Fullname: Binormal3bvEXT</para>
        /// </summary>
        [GLEntry("Binormal3bvEXT", Category = "EXT")]
        public static GLDelegate.Binormal3bv _Binormal3bv = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Binormal3bv.</para>
        /// <para>Fullname: Binormal3bvEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Binormal3bv(byte[] v)
        {
            if (gl._Binormal3bv != null) gl._Binormal3bv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Binormal3dEXT</para>
        /// </summary>
        [GLEntry("Binormal3dEXT", Category = "EXT")]
        public static GLDelegate.Binormal3d _Binormal3d = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Binormal3d.</para>
        /// <para>Fullname: Binormal3dEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Binormal3d(double bx, double by, double bz)
        {
            if (gl._Binormal3d != null) gl._Binormal3d(bx, by, bz); else { }
        }
        /// <summary>
        /// <para>Fullname: Binormal3dvEXT</para>
        /// </summary>
        [GLEntry("Binormal3dvEXT", Category = "EXT")]
        public static GLDelegate.Binormal3dv _Binormal3dv = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Binormal3dv.</para>
        /// <para>Fullname: Binormal3dvEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Binormal3dv(double[] v)
        {
            if (gl._Binormal3dv != null) gl._Binormal3dv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Binormal3fEXT</para>
        /// </summary>
        [GLEntry("Binormal3fEXT", Category = "EXT")]
        public static GLDelegate.Binormal3f _Binormal3f = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Binormal3f.</para>
        /// <para>Fullname: Binormal3fEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Binormal3f(float bx, float by, float bz)
        {
            if (gl._Binormal3f != null) gl._Binormal3f(bx, by, bz); else { }
        }
        /// <summary>
        /// <para>Fullname: Binormal3fvEXT</para>
        /// </summary>
        [GLEntry("Binormal3fvEXT", Category = "EXT")]
        public static GLDelegate.Binormal3fv _Binormal3fv = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Binormal3fv.</para>
        /// <para>Fullname: Binormal3fvEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Binormal3fv(float[] v)
        {
            if (gl._Binormal3fv != null) gl._Binormal3fv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Binormal3iEXT</para>
        /// </summary>
        [GLEntry("Binormal3iEXT", Category = "EXT")]
        public static GLDelegate.Binormal3i _Binormal3i = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Binormal3i.</para>
        /// <para>Fullname: Binormal3iEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Binormal3i(int bx, int by, int bz)
        {
            if (gl._Binormal3i != null) gl._Binormal3i(bx, by, bz); else { }
        }
        /// <summary>
        /// <para>Fullname: Binormal3ivEXT</para>
        /// </summary>
        [GLEntry("Binormal3ivEXT", Category = "EXT")]
        public static GLDelegate.Binormal3iv _Binormal3iv = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Binormal3iv.</para>
        /// <para>Fullname: Binormal3ivEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Binormal3iv(int[] v)
        {
            if (gl._Binormal3iv != null) gl._Binormal3iv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Binormal3sEXT</para>
        /// </summary>
        [GLEntry("Binormal3sEXT", Category = "EXT")]
        public static GLDelegate.Binormal3s _Binormal3s = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Binormal3s.</para>
        /// <para>Fullname: Binormal3sEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Binormal3s(short bx, short by, short bz)
        {
            if (gl._Binormal3s != null) gl._Binormal3s(bx, by, bz); else { }
        }
        /// <summary>
        /// <para>Fullname: Binormal3svEXT</para>
        /// </summary>
        [GLEntry("Binormal3svEXT", Category = "EXT")]
        public static GLDelegate.Binormal3sv _Binormal3sv = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Binormal3sv.</para>
        /// <para>Fullname: Binormal3svEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Binormal3sv(short[] v)
        {
            if (gl._Binormal3sv != null) gl._Binormal3sv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: BinormalPointerEXT</para>
        /// </summary>
        [GLEntry("BinormalPointerEXT", Category = "EXT")]
        public static GLDelegate.BinormalPointer _BinormalPointer = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BinormalPointer.</para>
        /// <para>Fullname: BinormalPointerEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void BinormalPointer(int type, int stride, IntPtr pointer)
        {
            if (gl._BinormalPointer != null) gl._BinormalPointer(type, stride, pointer); else { }
        }
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BinormalPointer.</para>
        /// <para>Fullname: BinormalPointerEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void BinormalPointer(int type, int stride, Array pointer)
        {
            GCHandle h = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try { if (gl._BinormalPointer != null) gl._BinormalPointer(type, stride, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: CheckNamedFramebufferStatusEXT</para>
        /// </summary>
        [GLEntry("CheckNamedFramebufferStatusEXT", Category = "EXT")]
        public static GLDelegate.CheckNamedFramebufferStatus _CheckNamedFramebufferStatus = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CheckNamedFramebufferStatus.</para>
        /// <para>Fullname: CheckNamedFramebufferStatusEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static int CheckNamedFramebufferStatus(uint framebuffer, int target)
        {
            if (gl._CheckNamedFramebufferStatus != null) return gl._CheckNamedFramebufferStatus(framebuffer, target);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: ClearColorIiEXT</para>
        /// </summary>
        [GLEntry("ClearColorIiEXT", Category = "EXT")]
        public static GLDelegate.ClearColorIi _ClearColorIi = null;
        /// <summary>
        /// <para>Fixed-point textures in unextended OpenGL have integer components, but those values are taken to represent floating-point values in the range [0,1].  These integer components are considered "normalized" integers.  When such a texture is accessed by a shader or by fixed-function fragment processing, floating-point values are returned. This extension provides a set of new "unnormalized" integer texture formats.  Formats with both signed and unsigned integers are provided.  In these formats, the components are treated as true integers.  When such textures are accessed by a shader, actual integer values are returned. Pixel operations that read from or write to a texture or color buffer with unnormalized integer components follow a path similar to that used for color index pixel operations, except that more than one component may be provided at once.  Integer values flow through the pixel processing pipe, and no pixel transfer operations are performed.  Integer format enumerants used for su...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClearColorIi.</para>
        /// <para>Fullname: ClearColorIiEXT</para>
        /// <para>Extensions: EXT_texture_integer</para>
        /// </summary>
        public static void ClearColorIi(int red, int green, int blue, int alpha)
        {
            if (gl._ClearColorIi != null) gl._ClearColorIi(red, green, blue, alpha); else { }
        }
        /// <summary>
        /// <para>Fullname: ClearColorIuiEXT</para>
        /// </summary>
        [GLEntry("ClearColorIuiEXT", Category = "EXT")]
        public static GLDelegate.ClearColorIui _ClearColorIui = null;
        /// <summary>
        /// <para>Fixed-point textures in unextended OpenGL have integer components, but those values are taken to represent floating-point values in the range [0,1].  These integer components are considered "normalized" integers.  When such a texture is accessed by a shader or by fixed-function fragment processing, floating-point values are returned. This extension provides a set of new "unnormalized" integer texture formats.  Formats with both signed and unsigned integers are provided.  In these formats, the components are treated as true integers.  When such textures are accessed by a shader, actual integer values are returned. Pixel operations that read from or write to a texture or color buffer with unnormalized integer components follow a path similar to that used for color index pixel operations, except that more than one component may be provided at once.  Integer values flow through the pixel processing pipe, and no pixel transfer operations are performed.  Integer format enumerants used for su...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClearColorIui.</para>
        /// <para>Fullname: ClearColorIuiEXT</para>
        /// <para>Extensions: EXT_texture_integer</para>
        /// </summary>
        public static void ClearColorIui(uint red, uint green, uint blue, uint alpha)
        {
            if (gl._ClearColorIui != null) gl._ClearColorIui(red, green, blue, alpha); else { }
        }
        /// <summary>
        /// <para>Fullname: ClientAttribDefaultEXT</para>
        /// </summary>
        [GLEntry("ClientAttribDefaultEXT", Category = "EXT")]
        public static GLDelegate.ClientAttribDefault _ClientAttribDefault = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClientAttribDefault.</para>
        /// <para>Fullname: ClientAttribDefaultEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void ClientAttribDefault(int mask)
        {
            if (gl._ClientAttribDefault != null) gl._ClientAttribDefault(mask); else { }
        }
        /// <summary>
        /// <para>Fullname: ColorMaskIndexedEXT</para>
        /// </summary>
        [GLEntry("ColorMaskIndexedEXT", Category = "EXT")]
        public static GLDelegate.ColorMaskIndexed _ColorMaskIndexed = null;
        /// <summary>
        /// <para>This extension builds upon the ARB_draw_buffers extension and provides separate blend enables and color write masks for each color output.  In ARB_draw_buffers (part of OpenGL 2.0), separate values can be written to each color buffer, but the blend enable and color write mask are global and apply to all color outputs. While this extension does provide separate blend enables, it does not provide separate blend functions or blend equations per color output. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorMaskIndexed.</para>
        /// <para>Fullname: ColorMaskIndexedEXT</para>
        /// <para>Extensions: EXT_draw_buffers2</para>
        /// </summary>
        public static void ColorMaskIndexed(uint index, bool r, bool g, bool b, bool a)
        {
            if (gl._ColorMaskIndexed != null) gl._ColorMaskIndexed(index, r, g, b, a); else { }
        }
        /// <summary>
        /// <para>Fullname: ColorPointerEXT</para>
        /// </summary>
        [GLEntry("ColorPointerEXT", Category = "EXT")]
        public static GLDelegate.ColorPointerEXT _ColorPointerEXT = null;
        /// <summary>
        /// <para>This extension adds the ability to specify multiple geometric primitives with very few subroutine calls.  Instead of calling an OpenGL procedure to pass each individual vertex, normal, or color, separate arrays of vertexes, normals, and colors are prespecified, and are used to define a sequence of primitives (all of the same type) when a single call is made to DrawArraysEXT.  A stride mechanism is provided so that an application can choose to keep all vertex data staggered in a single array, or sparsely in separate arrays.  Single-array storage may optimize performance on some implementations. This extension also supports the rendering of individual array elements, each specified as an index into the enabled arrays. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorPointerEXT.</para>
        /// <para>Fullname: ColorPointerEXT</para>
        /// <para>Extensions: EXT_vertex_array</para>
        /// </summary>
        public static void ColorPointerEXT(int size, int type, int stride, int count, IntPtr pointer)
        {
            if (gl._ColorPointerEXT != null) gl._ColorPointerEXT(size, type, stride, count, pointer); else { }
        }
        /// <summary>
        /// <para>Fullname: CompressedMultiTexImage1DEXT</para>
        /// </summary>
        [GLEntry("CompressedMultiTexImage1DEXT", Category = "EXT")]
        public static GLDelegate.CompressedMultiTexImage1D _CompressedMultiTexImage1D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedMultiTexImage1D.</para>
        /// <para>Fullname: CompressedMultiTexImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedMultiTexImage1D(int texunit, int target, int level, int internalformat, int width, int border, int imageSize, IntPtr bits)
        {
            if (gl._CompressedMultiTexImage1D != null) gl._CompressedMultiTexImage1D(texunit, target, level, internalformat, width, border, imageSize, bits); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedMultiTexImage1D.</para>
        /// <para>Fullname: CompressedMultiTexImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedMultiTexImage1D(int texunit, int target, int level, int internalformat, int width, int border, int imageSize, Array bits)
        {
            GCHandle h = GCHandle.Alloc(bits, GCHandleType.Pinned);
            try { if (gl._CompressedMultiTexImage1D != null) gl._CompressedMultiTexImage1D(texunit, target, level, internalformat, width, border, imageSize, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: CompressedMultiTexImage2DEXT</para>
        /// </summary>
        [GLEntry("CompressedMultiTexImage2DEXT", Category = "EXT")]
        public static GLDelegate.CompressedMultiTexImage2D _CompressedMultiTexImage2D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedMultiTexImage2D.</para>
        /// <para>Fullname: CompressedMultiTexImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedMultiTexImage2D(int texunit, int target, int level, int internalformat, int width, int height, int border, int imageSize, IntPtr bits)
        {
            if (gl._CompressedMultiTexImage2D != null) gl._CompressedMultiTexImage2D(texunit, target, level, internalformat, width, height, border, imageSize, bits); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedMultiTexImage2D.</para>
        /// <para>Fullname: CompressedMultiTexImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedMultiTexImage2D(int texunit, int target, int level, int internalformat, int width, int height, int border, int imageSize, Array bits)
        {
            GCHandle h = GCHandle.Alloc(bits, GCHandleType.Pinned);
            try { if (gl._CompressedMultiTexImage2D != null) gl._CompressedMultiTexImage2D(texunit, target, level, internalformat, width, height, border, imageSize, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: CompressedMultiTexImage3DEXT</para>
        /// </summary>
        [GLEntry("CompressedMultiTexImage3DEXT", Category = "EXT")]
        public static GLDelegate.CompressedMultiTexImage3D _CompressedMultiTexImage3D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedMultiTexImage3D.</para>
        /// <para>Fullname: CompressedMultiTexImage3DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedMultiTexImage3D(int texunit, int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, IntPtr bits)
        {
            if (gl._CompressedMultiTexImage3D != null) gl._CompressedMultiTexImage3D(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedMultiTexImage3D.</para>
        /// <para>Fullname: CompressedMultiTexImage3DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedMultiTexImage3D(int texunit, int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Array bits)
        {
            GCHandle h = GCHandle.Alloc(bits, GCHandleType.Pinned);
            try { if (gl._CompressedMultiTexImage3D != null) gl._CompressedMultiTexImage3D(texunit, target, level, internalformat, width, height, depth, border, imageSize, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: CompressedMultiTexSubImage1DEXT</para>
        /// </summary>
        [GLEntry("CompressedMultiTexSubImage1DEXT", Category = "EXT")]
        public static GLDelegate.CompressedMultiTexSubImage1D _CompressedMultiTexSubImage1D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedMultiTexSubImage1D.</para>
        /// <para>Fullname: CompressedMultiTexSubImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedMultiTexSubImage1D(int texunit, int target, int level, int xoffset, int width, int format, int imageSize, IntPtr bits)
        {
            if (gl._CompressedMultiTexSubImage1D != null) gl._CompressedMultiTexSubImage1D(texunit, target, level, xoffset, width, format, imageSize, bits); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedMultiTexSubImage1D.</para>
        /// <para>Fullname: CompressedMultiTexSubImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedMultiTexSubImage1D(int texunit, int target, int level, int xoffset, int width, int format, int imageSize, Array bits)
        {
            GCHandle h = GCHandle.Alloc(bits, GCHandleType.Pinned);
            try { if (gl._CompressedMultiTexSubImage1D != null) gl._CompressedMultiTexSubImage1D(texunit, target, level, xoffset, width, format, imageSize, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: CompressedMultiTexSubImage2DEXT</para>
        /// </summary>
        [GLEntry("CompressedMultiTexSubImage2DEXT", Category = "EXT")]
        public static GLDelegate.CompressedMultiTexSubImage2D _CompressedMultiTexSubImage2D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedMultiTexSubImage2D.</para>
        /// <para>Fullname: CompressedMultiTexSubImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedMultiTexSubImage2D(int texunit, int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, IntPtr bits)
        {
            if (gl._CompressedMultiTexSubImage2D != null) gl._CompressedMultiTexSubImage2D(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedMultiTexSubImage2D.</para>
        /// <para>Fullname: CompressedMultiTexSubImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedMultiTexSubImage2D(int texunit, int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Array bits)
        {
            GCHandle h = GCHandle.Alloc(bits, GCHandleType.Pinned);
            try { if (gl._CompressedMultiTexSubImage2D != null) gl._CompressedMultiTexSubImage2D(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: CompressedMultiTexSubImage3DEXT</para>
        /// </summary>
        [GLEntry("CompressedMultiTexSubImage3DEXT", Category = "EXT")]
        public static GLDelegate.CompressedMultiTexSubImage3D _CompressedMultiTexSubImage3D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedMultiTexSubImage3D.</para>
        /// <para>Fullname: CompressedMultiTexSubImage3DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedMultiTexSubImage3D(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, IntPtr bits)
        {
            if (gl._CompressedMultiTexSubImage3D != null) gl._CompressedMultiTexSubImage3D(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedMultiTexSubImage3D.</para>
        /// <para>Fullname: CompressedMultiTexSubImage3DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedMultiTexSubImage3D(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Array bits)
        {
            GCHandle h = GCHandle.Alloc(bits, GCHandleType.Pinned);
            try { if (gl._CompressedMultiTexSubImage3D != null) gl._CompressedMultiTexSubImage3D(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: CompressedTextureImage1DEXT</para>
        /// </summary>
        [GLEntry("CompressedTextureImage1DEXT", Category = "EXT")]
        public static GLDelegate.CompressedTextureImage1D _CompressedTextureImage1D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTextureImage1D.</para>
        /// <para>Fullname: CompressedTextureImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedTextureImage1D(uint texture, int target, int level, int internalformat, int width, int border, int imageSize, IntPtr bits)
        {
            if (gl._CompressedTextureImage1D != null) gl._CompressedTextureImage1D(texture, target, level, internalformat, width, border, imageSize, bits); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTextureImage1D.</para>
        /// <para>Fullname: CompressedTextureImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedTextureImage1D(uint texture, int target, int level, int internalformat, int width, int border, int imageSize, Array bits)
        {
            GCHandle h = GCHandle.Alloc(bits, GCHandleType.Pinned);
            try { if (gl._CompressedTextureImage1D != null) gl._CompressedTextureImage1D(texture, target, level, internalformat, width, border, imageSize, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: CompressedTextureImage2DEXT</para>
        /// </summary>
        [GLEntry("CompressedTextureImage2DEXT", Category = "EXT")]
        public static GLDelegate.CompressedTextureImage2D _CompressedTextureImage2D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTextureImage2D.</para>
        /// <para>Fullname: CompressedTextureImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedTextureImage2D(uint texture, int target, int level, int internalformat, int width, int height, int border, int imageSize, IntPtr bits)
        {
            if (gl._CompressedTextureImage2D != null) gl._CompressedTextureImage2D(texture, target, level, internalformat, width, height, border, imageSize, bits); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTextureImage2D.</para>
        /// <para>Fullname: CompressedTextureImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedTextureImage2D(uint texture, int target, int level, int internalformat, int width, int height, int border, int imageSize, Array bits)
        {
            GCHandle h = GCHandle.Alloc(bits, GCHandleType.Pinned);
            try { if (gl._CompressedTextureImage2D != null) gl._CompressedTextureImage2D(texture, target, level, internalformat, width, height, border, imageSize, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: CompressedTextureImage3DEXT</para>
        /// </summary>
        [GLEntry("CompressedTextureImage3DEXT", Category = "EXT")]
        public static GLDelegate.CompressedTextureImage3D _CompressedTextureImage3D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTextureImage3D.</para>
        /// <para>Fullname: CompressedTextureImage3DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedTextureImage3D(uint texture, int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, IntPtr bits)
        {
            if (gl._CompressedTextureImage3D != null) gl._CompressedTextureImage3D(texture, target, level, internalformat, width, height, depth, border, imageSize, bits); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTextureImage3D.</para>
        /// <para>Fullname: CompressedTextureImage3DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedTextureImage3D(uint texture, int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Array bits)
        {
            GCHandle h = GCHandle.Alloc(bits, GCHandleType.Pinned);
            try { if (gl._CompressedTextureImage3D != null) gl._CompressedTextureImage3D(texture, target, level, internalformat, width, height, depth, border, imageSize, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: CompressedTextureSubImage1DEXT</para>
        /// </summary>
        [GLEntry("CompressedTextureSubImage1DEXT", Category = "EXT")]
        public static GLDelegate.CompressedTextureSubImage1D _CompressedTextureSubImage1D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTextureSubImage1D.</para>
        /// <para>Fullname: CompressedTextureSubImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedTextureSubImage1D(uint texture, int target, int level, int xoffset, int width, int format, int imageSize, IntPtr bits)
        {
            if (gl._CompressedTextureSubImage1D != null) gl._CompressedTextureSubImage1D(texture, target, level, xoffset, width, format, imageSize, bits); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTextureSubImage1D.</para>
        /// <para>Fullname: CompressedTextureSubImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedTextureSubImage1D(uint texture, int target, int level, int xoffset, int width, int format, int imageSize, Array bits)
        {
            GCHandle h = GCHandle.Alloc(bits, GCHandleType.Pinned);
            try { if (gl._CompressedTextureSubImage1D != null) gl._CompressedTextureSubImage1D(texture, target, level, xoffset, width, format, imageSize, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: CompressedTextureSubImage2DEXT</para>
        /// </summary>
        [GLEntry("CompressedTextureSubImage2DEXT", Category = "EXT")]
        public static GLDelegate.CompressedTextureSubImage2D _CompressedTextureSubImage2D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTextureSubImage2D.</para>
        /// <para>Fullname: CompressedTextureSubImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedTextureSubImage2D(uint texture, int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, IntPtr bits)
        {
            if (gl._CompressedTextureSubImage2D != null) gl._CompressedTextureSubImage2D(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTextureSubImage2D.</para>
        /// <para>Fullname: CompressedTextureSubImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedTextureSubImage2D(uint texture, int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Array bits)
        {
            GCHandle h = GCHandle.Alloc(bits, GCHandleType.Pinned);
            try { if (gl._CompressedTextureSubImage2D != null) gl._CompressedTextureSubImage2D(texture, target, level, xoffset, yoffset, width, height, format, imageSize, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: CompressedTextureSubImage3DEXT</para>
        /// </summary>
        [GLEntry("CompressedTextureSubImage3DEXT", Category = "EXT")]
        public static GLDelegate.CompressedTextureSubImage3D _CompressedTextureSubImage3D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTextureSubImage3D.</para>
        /// <para>Fullname: CompressedTextureSubImage3DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedTextureSubImage3D(uint texture, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, IntPtr bits)
        {
            if (gl._CompressedTextureSubImage3D != null) gl._CompressedTextureSubImage3D(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CompressedTextureSubImage3D.</para>
        /// <para>Fullname: CompressedTextureSubImage3DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CompressedTextureSubImage3D(uint texture, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Array bits)
        {
            GCHandle h = GCHandle.Alloc(bits, GCHandleType.Pinned);
            try { if (gl._CompressedTextureSubImage3D != null) gl._CompressedTextureSubImage3D(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: CopyMultiTexImage1DEXT</para>
        /// </summary>
        [GLEntry("CopyMultiTexImage1DEXT", Category = "EXT")]
        public static GLDelegate.CopyMultiTexImage1D _CopyMultiTexImage1D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyMultiTexImage1D.</para>
        /// <para>Fullname: CopyMultiTexImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CopyMultiTexImage1D(int texunit, int target, int level, int internalformat, int x, int y, int width, int border)
        {
            if (gl._CopyMultiTexImage1D != null) gl._CopyMultiTexImage1D(texunit, target, level, internalformat, x, y, width, border); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyMultiTexImage2DEXT</para>
        /// </summary>
        [GLEntry("CopyMultiTexImage2DEXT", Category = "EXT")]
        public static GLDelegate.CopyMultiTexImage2D _CopyMultiTexImage2D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyMultiTexImage2D.</para>
        /// <para>Fullname: CopyMultiTexImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CopyMultiTexImage2D(int texunit, int target, int level, int internalformat, int x, int y, int width, int height, int border)
        {
            if (gl._CopyMultiTexImage2D != null) gl._CopyMultiTexImage2D(texunit, target, level, internalformat, x, y, width, height, border); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyMultiTexSubImage1DEXT</para>
        /// </summary>
        [GLEntry("CopyMultiTexSubImage1DEXT", Category = "EXT")]
        public static GLDelegate.CopyMultiTexSubImage1D _CopyMultiTexSubImage1D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyMultiTexSubImage1D.</para>
        /// <para>Fullname: CopyMultiTexSubImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CopyMultiTexSubImage1D(int texunit, int target, int level, int xoffset, int x, int y, int width)
        {
            if (gl._CopyMultiTexSubImage1D != null) gl._CopyMultiTexSubImage1D(texunit, target, level, xoffset, x, y, width); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyMultiTexSubImage2DEXT</para>
        /// </summary>
        [GLEntry("CopyMultiTexSubImage2DEXT", Category = "EXT")]
        public static GLDelegate.CopyMultiTexSubImage2D _CopyMultiTexSubImage2D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyMultiTexSubImage2D.</para>
        /// <para>Fullname: CopyMultiTexSubImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CopyMultiTexSubImage2D(int texunit, int target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
        {
            if (gl._CopyMultiTexSubImage2D != null) gl._CopyMultiTexSubImage2D(texunit, target, level, xoffset, yoffset, x, y, width, height); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyMultiTexSubImage3DEXT</para>
        /// </summary>
        [GLEntry("CopyMultiTexSubImage3DEXT", Category = "EXT")]
        public static GLDelegate.CopyMultiTexSubImage3D _CopyMultiTexSubImage3D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyMultiTexSubImage3D.</para>
        /// <para>Fullname: CopyMultiTexSubImage3DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CopyMultiTexSubImage3D(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
        {
            if (gl._CopyMultiTexSubImage3D != null) gl._CopyMultiTexSubImage3D(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyTextureImage1DEXT</para>
        /// </summary>
        [GLEntry("CopyTextureImage1DEXT", Category = "EXT")]
        public static GLDelegate.CopyTextureImage1D _CopyTextureImage1D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyTextureImage1D.</para>
        /// <para>Fullname: CopyTextureImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CopyTextureImage1D(uint texture, int target, int level, int internalformat, int x, int y, int width, int border)
        {
            if (gl._CopyTextureImage1D != null) gl._CopyTextureImage1D(texture, target, level, internalformat, x, y, width, border); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyTextureImage2DEXT</para>
        /// </summary>
        [GLEntry("CopyTextureImage2DEXT", Category = "EXT")]
        public static GLDelegate.CopyTextureImage2D _CopyTextureImage2D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyTextureImage2D.</para>
        /// <para>Fullname: CopyTextureImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CopyTextureImage2D(uint texture, int target, int level, int internalformat, int x, int y, int width, int height, int border)
        {
            if (gl._CopyTextureImage2D != null) gl._CopyTextureImage2D(texture, target, level, internalformat, x, y, width, height, border); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyTextureSubImage1DEXT</para>
        /// </summary>
        [GLEntry("CopyTextureSubImage1DEXT", Category = "EXT")]
        public static GLDelegate.CopyTextureSubImage1D _CopyTextureSubImage1D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyTextureSubImage1D.</para>
        /// <para>Fullname: CopyTextureSubImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CopyTextureSubImage1D(uint texture, int target, int level, int xoffset, int x, int y, int width)
        {
            if (gl._CopyTextureSubImage1D != null) gl._CopyTextureSubImage1D(texture, target, level, xoffset, x, y, width); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyTextureSubImage2DEXT</para>
        /// </summary>
        [GLEntry("CopyTextureSubImage2DEXT", Category = "EXT")]
        public static GLDelegate.CopyTextureSubImage2D _CopyTextureSubImage2D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyTextureSubImage2D.</para>
        /// <para>Fullname: CopyTextureSubImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CopyTextureSubImage2D(uint texture, int target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
        {
            if (gl._CopyTextureSubImage2D != null) gl._CopyTextureSubImage2D(texture, target, level, xoffset, yoffset, x, y, width, height); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyTextureSubImage3DEXT</para>
        /// </summary>
        [GLEntry("CopyTextureSubImage3DEXT", Category = "EXT")]
        public static GLDelegate.CopyTextureSubImage3D _CopyTextureSubImage3D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyTextureSubImage3D.</para>
        /// <para>Fullname: CopyTextureSubImage3DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void CopyTextureSubImage3D(uint texture, int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
        {
            if (gl._CopyTextureSubImage3D != null) gl._CopyTextureSubImage3D(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height); else { }
        }
        /// <summary>
        /// <para>Fullname: CreateShaderProgramEXT</para>
        /// </summary>
        [GLEntry("CreateShaderProgramEXT", Category = "EXT")]
        public static GLDelegate.CreateShaderProgram _CreateShaderProgram = null;
        /// <summary>
        /// <para>Prior to this extension, GLSL requires multiple shader domains (vertex, fragment, geometry) to be linked into a single monolithic program object to specify a GLSL shader for each domain. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple domains, all existing GPU hardware supports the more flexible mix-and-match approach. HLSL9, Cg, the prior OpenGL assembly program extensions, and game console programmers favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader domains. Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This keep-it-simple extension adapts the "mix-and-match" shader domain model for GLSL so different GLSL program objects can be bound to different shader domains. This extension redefines the operation of glUseProgram(GLenum program) to be equivalent ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CreateShaderProgram.</para>
        /// <para>Fullname: CreateShaderProgramEXT</para>
        /// <para>Extensions: EXT_separate_shader_objects</para>
        /// </summary>
        public static uint CreateShaderProgram(int type, StringBuilder str)
        {
            if (gl._CreateShaderProgram != null) return gl._CreateShaderProgram(type, str);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: CullParameterdvEXT</para>
        /// </summary>
        [GLEntry("CullParameterdvEXT", Category = "EXT")]
        public static GLDelegate.CullParameterdv _CullParameterdv = null;
        /// <summary>
        /// <para>This extension introduces a method for culling vertexes in object space based on the value of the dot product between the normal at the vertex and a culling eye direction. Culling a polygon by examining its vertexes in object space can be more efficient than screen space polygon culling since the transformation to screen space (which may include a division by w) can be avoided for culled vertexes.  Also, vertex culling can be computed before vertexes are assembled into primitives.  This is a useful property when drawing meshes with shared vertexes, since a vertex can be culled once, and the resulting state can be used for all primitives which share the vertex. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CullParameterdv.</para>
        /// <para>Fullname: CullParameterdvEXT</para>
        /// <para>Extensions: EXT_cull_vertex</para>
        /// </summary>
        public static void CullParameterdv(int pname, double[] param)
        {
            if (gl._CullParameterdv != null) gl._CullParameterdv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: CullParameterfvEXT</para>
        /// </summary>
        [GLEntry("CullParameterfvEXT", Category = "EXT")]
        public static GLDelegate.CullParameterfv _CullParameterfv = null;
        /// <summary>
        /// <para>This extension introduces a method for culling vertexes in object space based on the value of the dot product between the normal at the vertex and a culling eye direction. Culling a polygon by examining its vertexes in object space can be more efficient than screen space polygon culling since the transformation to screen space (which may include a division by w) can be avoided for culled vertexes.  Also, vertex culling can be computed before vertexes are assembled into primitives.  This is a useful property when drawing meshes with shared vertexes, since a vertex can be culled once, and the resulting state can be used for all primitives which share the vertex. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CullParameterfv.</para>
        /// <para>Fullname: CullParameterfvEXT</para>
        /// <para>Extensions: EXT_cull_vertex</para>
        /// </summary>
        public static void CullParameterfv(int pname, float[] param)
        {
            if (gl._CullParameterfv != null) gl._CullParameterfv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteVertexShaderEXT</para>
        /// </summary>
        [GLEntry("DeleteVertexShaderEXT", Category = "EXT")]
        public static GLDelegate.DeleteVertexShader _DeleteVertexShader = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteVertexShader.</para>
        /// <para>Fullname: DeleteVertexShaderEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void DeleteVertexShader(uint id)
        {
            if (gl._DeleteVertexShader != null) gl._DeleteVertexShader(id); else { }
        }
        /// <summary>
        /// <para>Fullname: DepthBoundsEXT</para>
        /// </summary>
        [GLEntry("DepthBoundsEXT", Category = "EXT")]
        public static GLDelegate.DepthBounds _DepthBounds = null;
        /// <summary>
        /// <para>This extension adds a new per-fragment test that is, logically, after the scissor test and before the alpha test.  The depth bounds test compares the depth value stored at the location given by the incoming fragment's (xw,yw) coordinates to a user-defined minimum and maximum depth value.  If the stored depth value is outside the user-defined range (exclusive), the incoming fragment is discarded. Unlike the depth test, the depth bounds test has NO dependency on the fragment's window-space depth value. This functionality is useful in the context of attenuated stenciled shadow volume rendering.  To motivate the functionality's utility in this context, we first describe how conventional scissor testing can be used to optimize shadow volume rendering. If an attenuated light source's illumination can be bounded to a rectangle in XY window-space, the conventional scissor test can be used to discard shadow volume fragments that are guaranteed to be outside the light source's window-space XY re...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DepthBounds.</para>
        /// <para>Fullname: DepthBoundsEXT</para>
        /// <para>Extensions: EXT_depth_bounds_test</para>
        /// </summary>
        public static void DepthBounds(double zmin, double zmax)
        {
            if (gl._DepthBounds != null) gl._DepthBounds(zmin, zmax); else { }
        }
        /// <summary>
        /// <para>Fullname: DisableClientStateIndexedEXT</para>
        /// </summary>
        [GLEntry("DisableClientStateIndexedEXT", Category = "EXT")]
        public static GLDelegate.DisableClientStateIndexed _DisableClientStateIndexed = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DisableClientStateIndexed.</para>
        /// <para>Fullname: DisableClientStateIndexedEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void DisableClientStateIndexed(int array, uint index)
        {
            if (gl._DisableClientStateIndexed != null) gl._DisableClientStateIndexed(array, index); else { }
        }
        /// <summary>
        /// <para>Fullname: DisableIndexedEXT</para>
        /// </summary>
        [GLEntry("DisableIndexedEXT", Category = "EXT")]
        public static GLDelegate.DisableIndexed _DisableIndexed = null;
        /// <summary>
        /// <para>This extension builds upon the ARB_draw_buffers extension and provides separate blend enables and color write masks for each color output.  In ARB_draw_buffers (part of OpenGL 2.0), separate values can be written to each color buffer, but the blend enable and color write mask are global and apply to all color outputs. While this extension does provide separate blend enables, it does not provide separate blend functions or blend equations per color output. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DisableIndexed.</para>
        /// <para>Fullname: DisableIndexedEXT</para>
        /// <para>Extensions: EXT_draw_buffers2</para>
        /// </summary>
        public static void DisableIndexed(int target, uint index)
        {
            if (gl._DisableIndexed != null) gl._DisableIndexed(target, index); else { }
        }
        /// <summary>
        /// <para>Fullname: DisableVariantClientStateEXT</para>
        /// </summary>
        [GLEntry("DisableVariantClientStateEXT", Category = "EXT")]
        public static GLDelegate.DisableVariantClientState _DisableVariantClientState = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DisableVariantClientState.</para>
        /// <para>Fullname: DisableVariantClientStateEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void DisableVariantClientState(uint id)
        {
            if (gl._DisableVariantClientState != null) gl._DisableVariantClientState(id); else { }
        }
        /// <summary>
        /// <para>Fullname: EdgeFlagPointerEXT</para>
        /// </summary>
        [GLEntry("EdgeFlagPointerEXT", Category = "EXT")]
        public static GLDelegate.EdgeFlagPointerEXT _EdgeFlagPointerEXT = null;
        /// <summary>
        /// <para>This extension adds the ability to specify multiple geometric primitives with very few subroutine calls.  Instead of calling an OpenGL procedure to pass each individual vertex, normal, or color, separate arrays of vertexes, normals, and colors are prespecified, and are used to define a sequence of primitives (all of the same type) when a single call is made to DrawArraysEXT.  A stride mechanism is provided so that an application can choose to keep all vertex data staggered in a single array, or sparsely in separate arrays.  Single-array storage may optimize performance on some implementations. This extension also supports the rendering of individual array elements, each specified as an index into the enabled arrays. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EdgeFlagPointerEXT.</para>
        /// <para>Fullname: EdgeFlagPointerEXT</para>
        /// <para>Extensions: EXT_vertex_array</para>
        /// </summary>
        public static void EdgeFlagPointerEXT(int stride, int count, IntPtr pointer)
        {
            if (gl._EdgeFlagPointerEXT != null) gl._EdgeFlagPointerEXT(stride, count, pointer); else { }
        }
        /// <summary>
        /// <para>Fullname: EnableClientStateIndexedEXT</para>
        /// </summary>
        [GLEntry("EnableClientStateIndexedEXT", Category = "EXT")]
        public static GLDelegate.EnableClientStateIndexed _EnableClientStateIndexed = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EnableClientStateIndexed.</para>
        /// <para>Fullname: EnableClientStateIndexedEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void EnableClientStateIndexed(int array, uint index)
        {
            if (gl._EnableClientStateIndexed != null) gl._EnableClientStateIndexed(array, index); else { }
        }
        /// <summary>
        /// <para>Fullname: EnableIndexedEXT</para>
        /// </summary>
        [GLEntry("EnableIndexedEXT", Category = "EXT")]
        public static GLDelegate.EnableIndexed _EnableIndexed = null;
        /// <summary>
        /// <para>This extension builds upon the ARB_draw_buffers extension and provides separate blend enables and color write masks for each color output.  In ARB_draw_buffers (part of OpenGL 2.0), separate values can be written to each color buffer, but the blend enable and color write mask are global and apply to all color outputs. While this extension does provide separate blend enables, it does not provide separate blend functions or blend equations per color output. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EnableIndexed.</para>
        /// <para>Fullname: EnableIndexedEXT</para>
        /// <para>Extensions: EXT_draw_buffers2</para>
        /// </summary>
        public static void EnableIndexed(int target, uint index)
        {
            if (gl._EnableIndexed != null) gl._EnableIndexed(target, index); else { }
        }
        /// <summary>
        /// <para>Fullname: EnableVariantClientStateEXT</para>
        /// </summary>
        [GLEntry("EnableVariantClientStateEXT", Category = "EXT")]
        public static GLDelegate.EnableVariantClientState _EnableVariantClientState = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EnableVariantClientState.</para>
        /// <para>Fullname: EnableVariantClientStateEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void EnableVariantClientState(uint id)
        {
            if (gl._EnableVariantClientState != null) gl._EnableVariantClientState(id); else { }
        }
        /// <summary>
        /// <para>Fullname: EndVertexShaderEXT</para>
        /// </summary>
        [GLEntry("EndVertexShaderEXT", Category = "EXT")]
        public static GLDelegate.EndVertexShader _EndVertexShader = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EndVertexShader.</para>
        /// <para>Fullname: EndVertexShaderEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void EndVertexShader()
        {
            if (gl._EndVertexShader != null) gl._EndVertexShader(); else { }
        }
        /// <summary>
        /// <para>Fullname: ExtractComponentEXT</para>
        /// </summary>
        [GLEntry("ExtractComponentEXT", Category = "EXT")]
        public static GLDelegate.ExtractComponent _ExtractComponent = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ExtractComponent.</para>
        /// <para>Fullname: ExtractComponentEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void ExtractComponent(uint res, uint src, uint num)
        {
            if (gl._ExtractComponent != null) gl._ExtractComponent(res, src, num); else { }
        }
        /// <summary>
        /// <para>Fullname: FlushMappedNamedBufferRangeEXT</para>
        /// </summary>
        [GLEntry("FlushMappedNamedBufferRangeEXT", Category = "EXT")]
        public static GLDelegate.FlushMappedNamedBufferRange _FlushMappedNamedBufferRange = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FlushMappedNamedBufferRange.</para>
        /// <para>Fullname: FlushMappedNamedBufferRangeEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void FlushMappedNamedBufferRange(uint buffer, int offset, int length)
        {
            if (gl._FlushMappedNamedBufferRange != null) gl._FlushMappedNamedBufferRange(buffer, offset, length); else { }
        }
        /// <summary>
        /// <para>Fullname: FramebufferDrawBufferEXT</para>
        /// </summary>
        [GLEntry("FramebufferDrawBufferEXT", Category = "EXT")]
        public static GLDelegate.FramebufferDrawBuffer _FramebufferDrawBuffer = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FramebufferDrawBuffer.</para>
        /// <para>Fullname: FramebufferDrawBufferEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void FramebufferDrawBuffer(uint framebuffer, int mode)
        {
            if (gl._FramebufferDrawBuffer != null) gl._FramebufferDrawBuffer(framebuffer, mode); else { }
        }
        /// <summary>
        /// <para>Fullname: FramebufferDrawBuffersEXT</para>
        /// </summary>
        [GLEntry("FramebufferDrawBuffersEXT", Category = "EXT")]
        public static GLDelegate.FramebufferDrawBuffers _FramebufferDrawBuffers = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FramebufferDrawBuffers.</para>
        /// <para>Fullname: FramebufferDrawBuffersEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void FramebufferDrawBuffers(uint framebuffer, int n, int[] bufs)
        {
            if (gl._FramebufferDrawBuffers != null) gl._FramebufferDrawBuffers(framebuffer, n, bufs); else { }
        }
        /// <summary>
        /// <para>Fullname: FramebufferDrawBuffersEXT</para>
        /// </summary>
        [GLEntry("FramebufferDrawBuffersEXT", Category = "EXT")]
        public static GLDelegate.FramebufferDrawBuffers_int _FramebufferDrawBuffers_int = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FramebufferDrawBuffers_int.</para>
        /// <para>Fullname: FramebufferDrawBuffersEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void FramebufferDrawBuffers(uint framebuffer, int n, ref int bufs)
        {
            if (gl._FramebufferDrawBuffers_int != null) gl._FramebufferDrawBuffers_int(framebuffer, n, ref bufs); else { }
        }
        /// <summary>
        /// <para>Fullname: FramebufferReadBufferEXT</para>
        /// </summary>
        [GLEntry("FramebufferReadBufferEXT", Category = "EXT")]
        public static GLDelegate.FramebufferReadBuffer _FramebufferReadBuffer = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FramebufferReadBuffer.</para>
        /// <para>Fullname: FramebufferReadBufferEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void FramebufferReadBuffer(uint framebuffer, int mode)
        {
            if (gl._FramebufferReadBuffer != null) gl._FramebufferReadBuffer(framebuffer, mode); else { }
        }
        /// <summary>
        /// <para>Fullname: GenerateMultiTexMipmapEXT</para>
        /// </summary>
        [GLEntry("GenerateMultiTexMipmapEXT", Category = "EXT")]
        public static GLDelegate.GenerateMultiTexMipmap _GenerateMultiTexMipmap = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenerateMultiTexMipmap.</para>
        /// <para>Fullname: GenerateMultiTexMipmapEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GenerateMultiTexMipmap(int texunit, int target)
        {
            if (gl._GenerateMultiTexMipmap != null) gl._GenerateMultiTexMipmap(texunit, target); else { }
        }
        /// <summary>
        /// <para>Fullname: GenerateTextureMipmapEXT</para>
        /// </summary>
        [GLEntry("GenerateTextureMipmapEXT", Category = "EXT")]
        public static GLDelegate.GenerateTextureMipmap _GenerateTextureMipmap = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenerateTextureMipmap.</para>
        /// <para>Fullname: GenerateTextureMipmapEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GenerateTextureMipmap(uint texture, int target)
        {
            if (gl._GenerateTextureMipmap != null) gl._GenerateTextureMipmap(texture, target); else { }
        }
        /// <summary>
        /// <para>Fullname: GenSymbolsEXT</para>
        /// </summary>
        [GLEntry("GenSymbolsEXT", Category = "EXT")]
        public static GLDelegate.GenSymbols _GenSymbols = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenSymbols.</para>
        /// <para>Fullname: GenSymbolsEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static uint GenSymbols(int datatype, int storagetype, int range, uint components)
        {
            if (gl._GenSymbols != null) return gl._GenSymbols(datatype, storagetype, range, components);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: GenVertexShadersEXT</para>
        /// </summary>
        [GLEntry("GenVertexShadersEXT", Category = "EXT")]
        public static GLDelegate.GenVertexShaders _GenVertexShaders = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenVertexShaders.</para>
        /// <para>Fullname: GenVertexShadersEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static uint GenVertexShaders(uint range)
        {
            if (gl._GenVertexShaders != null) return gl._GenVertexShaders(range);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: GetBooleanIndexedvEXT</para>
        /// </summary>
        [GLEntry("GetBooleanIndexedvEXT", Category = "EXT")]
        public static GLDelegate.GetBooleanIndexedv _GetBooleanIndexedv = null;
        /// <summary>
        /// <para>This extension builds upon the ARB_draw_buffers extension and provides separate blend enables and color write masks for each color output.  In ARB_draw_buffers (part of OpenGL 2.0), separate values can be written to each color buffer, but the blend enable and color write mask are global and apply to all color outputs. While this extension does provide separate blend enables, it does not provide separate blend functions or blend equations per color output. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetBooleanIndexedv.</para>
        /// <para>Fullname: GetBooleanIndexedvEXT</para>
        /// <para>Extensions: EXT_draw_buffers2</para>
        /// </summary>
        public static void GetBooleanIndexedv(int target, uint index, bool[] data)
        {
            if (gl._GetBooleanIndexedv != null) gl._GetBooleanIndexedv(target, index, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetCompressedMultiTexImageEXT</para>
        /// </summary>
        [GLEntry("GetCompressedMultiTexImageEXT", Category = "EXT")]
        public static GLDelegate.GetCompressedMultiTexImage _GetCompressedMultiTexImage = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetCompressedMultiTexImage.</para>
        /// <para>Fullname: GetCompressedMultiTexImageEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetCompressedMultiTexImage(int texunit, int target, int lod, IntPtr img)
        {
            if (gl._GetCompressedMultiTexImage != null) gl._GetCompressedMultiTexImage(texunit, target, lod, img); else { }
        }
        /// <summary>
        /// <para>Fullname: GetCompressedTextureImageEXT</para>
        /// </summary>
        [GLEntry("GetCompressedTextureImageEXT", Category = "EXT")]
        public static GLDelegate.GetCompressedTextureImage _GetCompressedTextureImage = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetCompressedTextureImage.</para>
        /// <para>Fullname: GetCompressedTextureImageEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetCompressedTextureImage(uint texture, int target, int lod, IntPtr img)
        {
            if (gl._GetCompressedTextureImage != null) gl._GetCompressedTextureImage(texture, target, lod, img); else { }
        }
        /// <summary>
        /// <para>Fullname: GetDoubleIndexedvEXT</para>
        /// </summary>
        [GLEntry("GetDoubleIndexedvEXT", Category = "EXT")]
        public static GLDelegate.GetDoubleIndexedv _GetDoubleIndexedv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetDoubleIndexedv.</para>
        /// <para>Fullname: GetDoubleIndexedvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetDoubleIndexedv(int target, uint index, double[] data)
        {
            if (gl._GetDoubleIndexedv != null) gl._GetDoubleIndexedv(target, index, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetFloatIndexedvEXT</para>
        /// </summary>
        [GLEntry("GetFloatIndexedvEXT", Category = "EXT")]
        public static GLDelegate.GetFloatIndexedv _GetFloatIndexedv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetFloatIndexedv.</para>
        /// <para>Fullname: GetFloatIndexedvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetFloatIndexedv(int target, uint index, float[] data)
        {
            if (gl._GetFloatIndexedv != null) gl._GetFloatIndexedv(target, index, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetFramebufferParameterivEXT</para>
        /// </summary>
        [GLEntry("GetFramebufferParameterivEXT", Category = "EXT")]
        public static GLDelegate.GetFramebufferParameterivEXT _GetFramebufferParameterivEXT = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetFramebufferParameterivEXT.</para>
        /// <para>Fullname: GetFramebufferParameterivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetFramebufferParameterivEXT(uint framebuffer, int pname, int[] param)
        {
            if (gl._GetFramebufferParameterivEXT != null) gl._GetFramebufferParameterivEXT(framebuffer, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetIntegerIndexedvEXT</para>
        /// </summary>
        [GLEntry("GetIntegerIndexedvEXT", Category = "EXT")]
        public static GLDelegate.GetIntegerIndexedv _GetIntegerIndexedv = null;
        /// <summary>
        /// <para>This extension builds upon the ARB_draw_buffers extension and provides separate blend enables and color write masks for each color output.  In ARB_draw_buffers (part of OpenGL 2.0), separate values can be written to each color buffer, but the blend enable and color write mask are global and apply to all color outputs. While this extension does provide separate blend enables, it does not provide separate blend functions or blend equations per color output. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetIntegerIndexedv.</para>
        /// <para>Fullname: GetIntegerIndexedvEXT</para>
        /// <para>Extensions: EXT_draw_buffers2</para>
        /// </summary>
        public static void GetIntegerIndexedv(int target, uint index, int[] data)
        {
            if (gl._GetIntegerIndexedv != null) gl._GetIntegerIndexedv(target, index, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetInvariantBooleanvEXT</para>
        /// </summary>
        [GLEntry("GetInvariantBooleanvEXT", Category = "EXT")]
        public static GLDelegate.GetInvariantBooleanv _GetInvariantBooleanv = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetInvariantBooleanv.</para>
        /// <para>Fullname: GetInvariantBooleanvEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void GetInvariantBooleanv(uint id, int value, bool[] data)
        {
            if (gl._GetInvariantBooleanv != null) gl._GetInvariantBooleanv(id, value, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetInvariantFloatvEXT</para>
        /// </summary>
        [GLEntry("GetInvariantFloatvEXT", Category = "EXT")]
        public static GLDelegate.GetInvariantFloatv _GetInvariantFloatv = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetInvariantFloatv.</para>
        /// <para>Fullname: GetInvariantFloatvEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void GetInvariantFloatv(uint id, int value, float[] data)
        {
            if (gl._GetInvariantFloatv != null) gl._GetInvariantFloatv(id, value, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetInvariantIntegervEXT</para>
        /// </summary>
        [GLEntry("GetInvariantIntegervEXT", Category = "EXT")]
        public static GLDelegate.GetInvariantIntegerv _GetInvariantIntegerv = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetInvariantIntegerv.</para>
        /// <para>Fullname: GetInvariantIntegervEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void GetInvariantIntegerv(uint id, int value, int[] data)
        {
            if (gl._GetInvariantIntegerv != null) gl._GetInvariantIntegerv(id, value, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetLocalConstantBooleanvEXT</para>
        /// </summary>
        [GLEntry("GetLocalConstantBooleanvEXT", Category = "EXT")]
        public static GLDelegate.GetLocalConstantBooleanv _GetLocalConstantBooleanv = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetLocalConstantBooleanv.</para>
        /// <para>Fullname: GetLocalConstantBooleanvEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void GetLocalConstantBooleanv(uint id, int value, bool[] data)
        {
            if (gl._GetLocalConstantBooleanv != null) gl._GetLocalConstantBooleanv(id, value, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetLocalConstantFloatvEXT</para>
        /// </summary>
        [GLEntry("GetLocalConstantFloatvEXT", Category = "EXT")]
        public static GLDelegate.GetLocalConstantFloatv _GetLocalConstantFloatv = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetLocalConstantFloatv.</para>
        /// <para>Fullname: GetLocalConstantFloatvEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void GetLocalConstantFloatv(uint id, int value, float[] data)
        {
            if (gl._GetLocalConstantFloatv != null) gl._GetLocalConstantFloatv(id, value, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetLocalConstantIntegervEXT</para>
        /// </summary>
        [GLEntry("GetLocalConstantIntegervEXT", Category = "EXT")]
        public static GLDelegate.GetLocalConstantIntegerv _GetLocalConstantIntegerv = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetLocalConstantIntegerv.</para>
        /// <para>Fullname: GetLocalConstantIntegervEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void GetLocalConstantIntegerv(uint id, int value, int[] data)
        {
            if (gl._GetLocalConstantIntegerv != null) gl._GetLocalConstantIntegerv(id, value, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMultiTexEnvfvEXT</para>
        /// </summary>
        [GLEntry("GetMultiTexEnvfvEXT", Category = "EXT")]
        public static GLDelegate.GetMultiTexEnvfv _GetMultiTexEnvfv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMultiTexEnvfv.</para>
        /// <para>Fullname: GetMultiTexEnvfvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetMultiTexEnvfv(int texunit, int target, int pname, float[] param)
        {
            if (gl._GetMultiTexEnvfv != null) gl._GetMultiTexEnvfv(texunit, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMultiTexEnvivEXT</para>
        /// </summary>
        [GLEntry("GetMultiTexEnvivEXT", Category = "EXT")]
        public static GLDelegate.GetMultiTexEnviv _GetMultiTexEnviv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMultiTexEnviv.</para>
        /// <para>Fullname: GetMultiTexEnvivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetMultiTexEnviv(int texunit, int target, int pname, int[] param)
        {
            if (gl._GetMultiTexEnviv != null) gl._GetMultiTexEnviv(texunit, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMultiTexGendvEXT</para>
        /// </summary>
        [GLEntry("GetMultiTexGendvEXT", Category = "EXT")]
        public static GLDelegate.GetMultiTexGendv _GetMultiTexGendv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMultiTexGendv.</para>
        /// <para>Fullname: GetMultiTexGendvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetMultiTexGendv(int texunit, int coord, int pname, double[] param)
        {
            if (gl._GetMultiTexGendv != null) gl._GetMultiTexGendv(texunit, coord, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMultiTexGenfvEXT</para>
        /// </summary>
        [GLEntry("GetMultiTexGenfvEXT", Category = "EXT")]
        public static GLDelegate.GetMultiTexGenfv _GetMultiTexGenfv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMultiTexGenfv.</para>
        /// <para>Fullname: GetMultiTexGenfvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetMultiTexGenfv(int texunit, int coord, int pname, float[] param)
        {
            if (gl._GetMultiTexGenfv != null) gl._GetMultiTexGenfv(texunit, coord, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMultiTexGenivEXT</para>
        /// </summary>
        [GLEntry("GetMultiTexGenivEXT", Category = "EXT")]
        public static GLDelegate.GetMultiTexGeniv _GetMultiTexGeniv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMultiTexGeniv.</para>
        /// <para>Fullname: GetMultiTexGenivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetMultiTexGeniv(int texunit, int coord, int pname, int[] param)
        {
            if (gl._GetMultiTexGeniv != null) gl._GetMultiTexGeniv(texunit, coord, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMultiTexImageEXT</para>
        /// </summary>
        [GLEntry("GetMultiTexImageEXT", Category = "EXT")]
        public static GLDelegate.GetMultiTexImage _GetMultiTexImage = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMultiTexImage.</para>
        /// <para>Fullname: GetMultiTexImageEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetMultiTexImage(int texunit, int target, int level, int format, int type, IntPtr pixels)
        {
            if (gl._GetMultiTexImage != null) gl._GetMultiTexImage(texunit, target, level, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMultiTexLevelParameterfvEXT</para>
        /// </summary>
        [GLEntry("GetMultiTexLevelParameterfvEXT", Category = "EXT")]
        public static GLDelegate.GetMultiTexLevelParameterfv _GetMultiTexLevelParameterfv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMultiTexLevelParameterfv.</para>
        /// <para>Fullname: GetMultiTexLevelParameterfvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetMultiTexLevelParameterfv(int texunit, int target, int level, int pname, float[] param)
        {
            if (gl._GetMultiTexLevelParameterfv != null) gl._GetMultiTexLevelParameterfv(texunit, target, level, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMultiTexLevelParameterivEXT</para>
        /// </summary>
        [GLEntry("GetMultiTexLevelParameterivEXT", Category = "EXT")]
        public static GLDelegate.GetMultiTexLevelParameteriv _GetMultiTexLevelParameteriv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMultiTexLevelParameteriv.</para>
        /// <para>Fullname: GetMultiTexLevelParameterivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetMultiTexLevelParameteriv(int texunit, int target, int level, int pname, int[] param)
        {
            if (gl._GetMultiTexLevelParameteriv != null) gl._GetMultiTexLevelParameteriv(texunit, target, level, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMultiTexParameterfvEXT</para>
        /// </summary>
        [GLEntry("GetMultiTexParameterfvEXT", Category = "EXT")]
        public static GLDelegate.GetMultiTexParameterfv _GetMultiTexParameterfv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMultiTexParameterfv.</para>
        /// <para>Fullname: GetMultiTexParameterfvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetMultiTexParameterfv(int texunit, int target, int pname, float[] param)
        {
            if (gl._GetMultiTexParameterfv != null) gl._GetMultiTexParameterfv(texunit, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMultiTexParameterIivEXT</para>
        /// </summary>
        [GLEntry("GetMultiTexParameterIivEXT", Category = "EXT")]
        public static GLDelegate.GetMultiTexParameterIiv _GetMultiTexParameterIiv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMultiTexParameterIiv.</para>
        /// <para>Fullname: GetMultiTexParameterIivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetMultiTexParameterIiv(int texunit, int target, int pname, int[] param)
        {
            if (gl._GetMultiTexParameterIiv != null) gl._GetMultiTexParameterIiv(texunit, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMultiTexParameterIuivEXT</para>
        /// </summary>
        [GLEntry("GetMultiTexParameterIuivEXT", Category = "EXT")]
        public static GLDelegate.GetMultiTexParameterIuiv _GetMultiTexParameterIuiv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMultiTexParameterIuiv.</para>
        /// <para>Fullname: GetMultiTexParameterIuivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetMultiTexParameterIuiv(int texunit, int target, int pname, uint[] param)
        {
            if (gl._GetMultiTexParameterIuiv != null) gl._GetMultiTexParameterIuiv(texunit, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMultiTexParameterivEXT</para>
        /// </summary>
        [GLEntry("GetMultiTexParameterivEXT", Category = "EXT")]
        public static GLDelegate.GetMultiTexParameteriv _GetMultiTexParameteriv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMultiTexParameteriv.</para>
        /// <para>Fullname: GetMultiTexParameterivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetMultiTexParameteriv(int texunit, int target, int pname, int[] param)
        {
            if (gl._GetMultiTexParameteriv != null) gl._GetMultiTexParameteriv(texunit, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetNamedBufferParameterivEXT</para>
        /// </summary>
        [GLEntry("GetNamedBufferParameterivEXT", Category = "EXT")]
        public static GLDelegate.GetNamedBufferParameteriv _GetNamedBufferParameteriv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetNamedBufferParameteriv.</para>
        /// <para>Fullname: GetNamedBufferParameterivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetNamedBufferParameteriv(uint buffer, int pname, int[] param)
        {
            if (gl._GetNamedBufferParameteriv != null) gl._GetNamedBufferParameteriv(buffer, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetNamedBufferPointervEXT</para>
        /// </summary>
        [GLEntry("GetNamedBufferPointervEXT", Category = "EXT")]
        public static GLDelegate.GetNamedBufferPointerv _GetNamedBufferPointerv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetNamedBufferPointerv.</para>
        /// <para>Fullname: GetNamedBufferPointervEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetNamedBufferPointerv(uint buffer, int pname, IntPtr[] param)
        {
            if (gl._GetNamedBufferPointerv != null) gl._GetNamedBufferPointerv(buffer, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetNamedBufferSubDataEXT</para>
        /// </summary>
        [GLEntry("GetNamedBufferSubDataEXT", Category = "EXT")]
        public static GLDelegate.GetNamedBufferSubData _GetNamedBufferSubData = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetNamedBufferSubData.</para>
        /// <para>Fullname: GetNamedBufferSubDataEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetNamedBufferSubData(uint buffer, int offset, int size, IntPtr data)
        {
            if (gl._GetNamedBufferSubData != null) gl._GetNamedBufferSubData(buffer, offset, size, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetNamedFramebufferAttachmentParameterivEXT</para>
        /// </summary>
        [GLEntry("GetNamedFramebufferAttachmentParameterivEXT", Category = "EXT")]
        public static GLDelegate.GetNamedFramebufferAttachmentParameteriv _GetNamedFramebufferAttachmentParameteriv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetNamedFramebufferAttachmentParameteriv.</para>
        /// <para>Fullname: GetNamedFramebufferAttachmentParameterivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetNamedFramebufferAttachmentParameteriv(uint framebuffer, int attachment, int pname, int[] param)
        {
            if (gl._GetNamedFramebufferAttachmentParameteriv != null) gl._GetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetNamedProgramivEXT</para>
        /// </summary>
        [GLEntry("GetNamedProgramivEXT", Category = "EXT")]
        public static GLDelegate.GetNamedProgramiv_int _GetNamedProgramiv_int = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetNamedProgramiv_int.</para>
        /// <para>Fullname: GetNamedProgramivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetNamedProgramiv(uint program, int target, int pname, out int param)
        {
            if (gl._GetNamedProgramiv_int != null) gl._GetNamedProgramiv_int(program, target, pname, out param); else { param = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetNamedProgramivEXT</para>
        /// </summary>
        [GLEntry("GetNamedProgramivEXT", Category = "EXT")]
        public static GLDelegate.GetNamedProgramiv _GetNamedProgramiv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetNamedProgramiv.</para>
        /// <para>Fullname: GetNamedProgramivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetNamedProgramiv(uint program, int target, int pname, int[] param)
        {
            if (gl._GetNamedProgramiv != null) gl._GetNamedProgramiv(program, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetNamedProgramLocalParameterdvEXT</para>
        /// </summary>
        [GLEntry("GetNamedProgramLocalParameterdvEXT", Category = "EXT")]
        public static GLDelegate.GetNamedProgramLocalParameterdv _GetNamedProgramLocalParameterdv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetNamedProgramLocalParameterdv.</para>
        /// <para>Fullname: GetNamedProgramLocalParameterdvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetNamedProgramLocalParameterdv(uint program, int target, uint index, double[] param)
        {
            if (gl._GetNamedProgramLocalParameterdv != null) gl._GetNamedProgramLocalParameterdv(program, target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetNamedProgramLocalParameterfvEXT</para>
        /// </summary>
        [GLEntry("GetNamedProgramLocalParameterfvEXT", Category = "EXT")]
        public static GLDelegate.GetNamedProgramLocalParameterfv _GetNamedProgramLocalParameterfv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetNamedProgramLocalParameterfv.</para>
        /// <para>Fullname: GetNamedProgramLocalParameterfvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetNamedProgramLocalParameterfv(uint program, int target, uint index, float[] param)
        {
            if (gl._GetNamedProgramLocalParameterfv != null) gl._GetNamedProgramLocalParameterfv(program, target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetNamedProgramLocalParameterIivEXT</para>
        /// </summary>
        [GLEntry("GetNamedProgramLocalParameterIivEXT", Category = "EXT")]
        public static GLDelegate.GetNamedProgramLocalParameterIiv _GetNamedProgramLocalParameterIiv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetNamedProgramLocalParameterIiv.</para>
        /// <para>Fullname: GetNamedProgramLocalParameterIivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetNamedProgramLocalParameterIiv(uint program, int target, uint index, int[] param)
        {
            if (gl._GetNamedProgramLocalParameterIiv != null) gl._GetNamedProgramLocalParameterIiv(program, target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetNamedProgramLocalParameterIuivEXT</para>
        /// </summary>
        [GLEntry("GetNamedProgramLocalParameterIuivEXT", Category = "EXT")]
        public static GLDelegate.GetNamedProgramLocalParameterIuiv _GetNamedProgramLocalParameterIuiv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetNamedProgramLocalParameterIuiv.</para>
        /// <para>Fullname: GetNamedProgramLocalParameterIuivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetNamedProgramLocalParameterIuiv(uint program, int target, uint index, uint[] param)
        {
            if (gl._GetNamedProgramLocalParameterIuiv != null) gl._GetNamedProgramLocalParameterIuiv(program, target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetNamedProgramStringEXT</para>
        /// </summary>
        [GLEntry("GetNamedProgramStringEXT", Category = "EXT")]
        public static GLDelegate.GetNamedProgramString _GetNamedProgramString = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetNamedProgramString.</para>
        /// <para>Fullname: GetNamedProgramStringEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetNamedProgramString(uint program, int target, int pname, IntPtr str)
        {
            if (gl._GetNamedProgramString != null) gl._GetNamedProgramString(program, target, pname, str); else { }
        }
        /// <summary>
        /// <para>Fullname: GetNamedRenderbufferParameterivEXT</para>
        /// </summary>
        [GLEntry("GetNamedRenderbufferParameterivEXT", Category = "EXT")]
        public static GLDelegate.GetNamedRenderbufferParameteriv _GetNamedRenderbufferParameteriv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetNamedRenderbufferParameteriv.</para>
        /// <para>Fullname: GetNamedRenderbufferParameterivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetNamedRenderbufferParameteriv(uint renderbuffer, int pname, int[] param)
        {
            if (gl._GetNamedRenderbufferParameteriv != null) gl._GetNamedRenderbufferParameteriv(renderbuffer, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPointerIndexedvEXT</para>
        /// </summary>
        [GLEntry("GetPointerIndexedvEXT", Category = "EXT")]
        public static GLDelegate.GetPointerIndexedv _GetPointerIndexedv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPointerIndexedv.</para>
        /// <para>Fullname: GetPointerIndexedvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetPointerIndexedv(int target, uint index, IntPtr[] data)
        {
            if (gl._GetPointerIndexedv != null) gl._GetPointerIndexedv(target, index, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTextureImageEXT</para>
        /// </summary>
        [GLEntry("GetTextureImageEXT", Category = "EXT")]
        public static GLDelegate.GetTextureImage _GetTextureImage = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTextureImage.</para>
        /// <para>Fullname: GetTextureImageEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetTextureImage(uint texture, int target, int level, int format, int type, IntPtr pixels)
        {
            if (gl._GetTextureImage != null) gl._GetTextureImage(texture, target, level, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTextureLevelParameterfvEXT</para>
        /// </summary>
        [GLEntry("GetTextureLevelParameterfvEXT", Category = "EXT")]
        public static GLDelegate.GetTextureLevelParameterfv _GetTextureLevelParameterfv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTextureLevelParameterfv.</para>
        /// <para>Fullname: GetTextureLevelParameterfvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetTextureLevelParameterfv(uint texture, int target, int level, int pname, float[] param)
        {
            if (gl._GetTextureLevelParameterfv != null) gl._GetTextureLevelParameterfv(texture, target, level, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTextureLevelParameterivEXT</para>
        /// </summary>
        [GLEntry("GetTextureLevelParameterivEXT", Category = "EXT")]
        public static GLDelegate.GetTextureLevelParameteriv _GetTextureLevelParameteriv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTextureLevelParameteriv.</para>
        /// <para>Fullname: GetTextureLevelParameterivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetTextureLevelParameteriv(uint texture, int target, int level, int pname, int[] param)
        {
            if (gl._GetTextureLevelParameteriv != null) gl._GetTextureLevelParameteriv(texture, target, level, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTextureParameterfvEXT</para>
        /// </summary>
        [GLEntry("GetTextureParameterfvEXT", Category = "EXT")]
        public static GLDelegate.GetTextureParameterfv _GetTextureParameterfv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTextureParameterfv.</para>
        /// <para>Fullname: GetTextureParameterfvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetTextureParameterfv(uint texture, int target, int pname, float[] param)
        {
            if (gl._GetTextureParameterfv != null) gl._GetTextureParameterfv(texture, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTextureParameterIivEXT</para>
        /// </summary>
        [GLEntry("GetTextureParameterIivEXT", Category = "EXT")]
        public static GLDelegate.GetTextureParameterIiv _GetTextureParameterIiv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTextureParameterIiv.</para>
        /// <para>Fullname: GetTextureParameterIivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetTextureParameterIiv(uint texture, int target, int pname, int[] param)
        {
            if (gl._GetTextureParameterIiv != null) gl._GetTextureParameterIiv(texture, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTextureParameterIuivEXT</para>
        /// </summary>
        [GLEntry("GetTextureParameterIuivEXT", Category = "EXT")]
        public static GLDelegate.GetTextureParameterIuiv _GetTextureParameterIuiv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTextureParameterIuiv.</para>
        /// <para>Fullname: GetTextureParameterIuivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetTextureParameterIuiv(uint texture, int target, int pname, uint[] param)
        {
            if (gl._GetTextureParameterIuiv != null) gl._GetTextureParameterIuiv(texture, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTextureParameterivEXT</para>
        /// </summary>
        [GLEntry("GetTextureParameterivEXT", Category = "EXT")]
        public static GLDelegate.GetTextureParameteriv _GetTextureParameteriv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTextureParameteriv.</para>
        /// <para>Fullname: GetTextureParameterivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void GetTextureParameteriv(uint texture, int target, int pname, int[] param)
        {
            if (gl._GetTextureParameteriv != null) gl._GetTextureParameteriv(texture, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetUniformBufferSizeEXT</para>
        /// </summary>
        [GLEntry("GetUniformBufferSizeEXT", Category = "EXT")]
        public static GLDelegate.GetUniformBufferSize _GetUniformBufferSize = null;
        /// <summary>
        /// <para>This extension introduces the concept of bindable uniforms to the OpenGL Shading Language.  A uniform variable can be declared bindable, which means that the storage for the uniform is not allocated by the compiler/linker anymore, but is backed by a buffer object.  This buffer object is bound to the bindable uniform through the new command UniformBufferEXT().  Binding needs to happen after linking a program object. Binding different buffer objects to a bindable uniform allows an application to easily use different "uniform data sets", without having to re-specify the data every time. A buffer object can be bound to bindable uniforms in different program objects. If those bindable uniforms are all of the same type, accessing a bindable uniform in program object A will result in the same data if the same access is made in program object B.  This provides a mechanism for 'environment uniforms', uniform values that can be shared among multiple program objects. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetUniformBufferSize.</para>
        /// <para>Fullname: GetUniformBufferSizeEXT</para>
        /// <para>Extensions: EXT_bindable_uniform</para>
        /// </summary>
        public static int GetUniformBufferSize(uint program, int location)
        {
            if (gl._GetUniformBufferSize != null) return gl._GetUniformBufferSize(program, location);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: GetUniformOffsetEXT</para>
        /// </summary>
        [GLEntry("GetUniformOffsetEXT", Category = "EXT")]
        public static GLDelegate.GetUniformOffset _GetUniformOffset = null;
        /// <summary>
        /// <para>This extension introduces the concept of bindable uniforms to the OpenGL Shading Language.  A uniform variable can be declared bindable, which means that the storage for the uniform is not allocated by the compiler/linker anymore, but is backed by a buffer object.  This buffer object is bound to the bindable uniform through the new command UniformBufferEXT().  Binding needs to happen after linking a program object. Binding different buffer objects to a bindable uniform allows an application to easily use different "uniform data sets", without having to re-specify the data every time. A buffer object can be bound to bindable uniforms in different program objects. If those bindable uniforms are all of the same type, accessing a bindable uniform in program object A will result in the same data if the same access is made in program object B.  This provides a mechanism for 'environment uniforms', uniform values that can be shared among multiple program objects. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetUniformOffset.</para>
        /// <para>Fullname: GetUniformOffsetEXT</para>
        /// <para>Extensions: EXT_bindable_uniform</para>
        /// </summary>
        public static int GetUniformOffset(uint program, int location)
        {
            if (gl._GetUniformOffset != null) return gl._GetUniformOffset(program, location);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: GetVariantBooleanvEXT</para>
        /// </summary>
        [GLEntry("GetVariantBooleanvEXT", Category = "EXT")]
        public static GLDelegate.GetVariantBooleanv _GetVariantBooleanv = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVariantBooleanv.</para>
        /// <para>Fullname: GetVariantBooleanvEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void GetVariantBooleanv(uint id, int value, bool[] data)
        {
            if (gl._GetVariantBooleanv != null) gl._GetVariantBooleanv(id, value, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVariantFloatvEXT</para>
        /// </summary>
        [GLEntry("GetVariantFloatvEXT", Category = "EXT")]
        public static GLDelegate.GetVariantFloatv _GetVariantFloatv = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVariantFloatv.</para>
        /// <para>Fullname: GetVariantFloatvEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void GetVariantFloatv(uint id, int value, float[] data)
        {
            if (gl._GetVariantFloatv != null) gl._GetVariantFloatv(id, value, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVariantIntegervEXT</para>
        /// </summary>
        [GLEntry("GetVariantIntegervEXT", Category = "EXT")]
        public static GLDelegate.GetVariantIntegerv _GetVariantIntegerv = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVariantIntegerv.</para>
        /// <para>Fullname: GetVariantIntegervEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void GetVariantIntegerv(uint id, int value, int[] data)
        {
            if (gl._GetVariantIntegerv != null) gl._GetVariantIntegerv(id, value, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVariantPointervEXT</para>
        /// </summary>
        [GLEntry("GetVariantPointervEXT", Category = "EXT")]
        public static GLDelegate.GetVariantPointerv _GetVariantPointerv = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVariantPointerv.</para>
        /// <para>Fullname: GetVariantPointervEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void GetVariantPointerv(uint id, int value, IntPtr[] data)
        {
            if (gl._GetVariantPointerv != null) gl._GetVariantPointerv(id, value, data); else { }
        }
        /// <summary>
        /// <para>Fullname: ImportSyncEXT</para>
        /// </summary>
        [GLEntry("ImportSyncEXT", Category = "EXT")]
        public static GLDelegate.ImportSync _ImportSync = null;
        /// <summary>
        /// <para>Synchronization objects added the ability to better coordinate operations between multiple GL command streams.  However, it is desirable to have the same level of coordination between GL command streams and external rendering APIs.  This extension introduces two new concepts to build upon the synchronization infrastructure provided by ARB_sync: 1) A means to import an X Synchronization Fence object into the GL and use it as a sync object. 2) The concept of a reusable sync object. The latter is necessary because the import operation is expensive and performing it every time a synchronization point was reached would make the synchronization prohibitively slow. This extension stops short of allowing the GL to change the state of imported/reusable sync objects, but does not add any language that would prohibit such functionality from being added in a subsequent extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ImportSync.</para>
        /// <para>Fullname: ImportSyncEXT</para>
        /// <para>Extensions: EXT_x11_sync_object</para>
        /// </summary>
        public static IntPtr ImportSync(int external_sync_type, int external_sync, int flags)
        {
            if (gl._ImportSync != null) return gl._ImportSync(external_sync_type, external_sync, flags);
            else { return (IntPtr)0; }
        }
        /// <summary>
        /// <para>Fullname: IndexFuncEXT</para>
        /// </summary>
        [GLEntry("IndexFuncEXT", Category = "EXT")]
        public static GLDelegate.IndexFunc _IndexFunc = null;
        /// <summary>
        /// <para>This extension provides a way to discard fragments when a comparison between the fragment's index value and a reference index fails.  This may be used similarly to the alpha test which is available in RGBA mode. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IndexFunc.</para>
        /// <para>Fullname: IndexFuncEXT</para>
        /// <para>Extensions: EXT_index_func</para>
        /// </summary>
        public static void IndexFunc(int func, float reference)
        {
            if (gl._IndexFunc != null) gl._IndexFunc(func, reference); else { }
        }
        /// <summary>
        /// <para>Fullname: IndexMaterialEXT</para>
        /// </summary>
        [GLEntry("IndexMaterialEXT", Category = "EXT")]
        public static GLDelegate.IndexMaterial _IndexMaterial = null;
        /// <summary>
        /// <para>This extends color index lighting to include a way for the current index to contribute to the color index produced by lighting.  This works much like ColorMaterial does for RGBA lighting by allowing one or more color index material properties to be attached to the current index. The color index lighting formula is also modified so that the lit color index may be bitwise shifted in order to allow greater control when using lighting and fog together in color index mode. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IndexMaterial.</para>
        /// <para>Fullname: IndexMaterialEXT</para>
        /// <para>Extensions: EXT_index_material</para>
        /// </summary>
        public static void IndexMaterial(int face, int mode)
        {
            if (gl._IndexMaterial != null) gl._IndexMaterial(face, mode); else { }
        }
        /// <summary>
        /// <para>Fullname: IndexPointerEXT</para>
        /// </summary>
        [GLEntry("IndexPointerEXT", Category = "EXT")]
        public static GLDelegate.IndexPointerEXT _IndexPointerEXT = null;
        /// <summary>
        /// <para>This extension adds the ability to specify multiple geometric primitives with very few subroutine calls.  Instead of calling an OpenGL procedure to pass each individual vertex, normal, or color, separate arrays of vertexes, normals, and colors are prespecified, and are used to define a sequence of primitives (all of the same type) when a single call is made to DrawArraysEXT.  A stride mechanism is provided so that an application can choose to keep all vertex data staggered in a single array, or sparsely in separate arrays.  Single-array storage may optimize performance on some implementations. This extension also supports the rendering of individual array elements, each specified as an index into the enabled arrays. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IndexPointerEXT.</para>
        /// <para>Fullname: IndexPointerEXT</para>
        /// <para>Extensions: EXT_vertex_array</para>
        /// </summary>
        public static void IndexPointerEXT(int type, int stride, int count, IntPtr pointer)
        {
            if (gl._IndexPointerEXT != null) gl._IndexPointerEXT(type, stride, count, pointer); else { }
        }
        /// <summary>
        /// <para>Fullname: InsertComponentEXT</para>
        /// </summary>
        [GLEntry("InsertComponentEXT", Category = "EXT")]
        public static GLDelegate.InsertComponent _InsertComponent = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _InsertComponent.</para>
        /// <para>Fullname: InsertComponentEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void InsertComponent(uint res, uint src, uint num)
        {
            if (gl._InsertComponent != null) gl._InsertComponent(res, src, num); else { }
        }
        /// <summary>
        /// <para>Fullname: IsEnabledIndexedEXT</para>
        /// </summary>
        [GLEntry("IsEnabledIndexedEXT", Category = "EXT")]
        public static GLDelegate.IsEnabledIndexed _IsEnabledIndexed = null;
        /// <summary>
        /// <para>This extension builds upon the ARB_draw_buffers extension and provides separate blend enables and color write masks for each color output.  In ARB_draw_buffers (part of OpenGL 2.0), separate values can be written to each color buffer, but the blend enable and color write mask are global and apply to all color outputs. While this extension does provide separate blend enables, it does not provide separate blend functions or blend equations per color output. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsEnabledIndexed.</para>
        /// <para>Fullname: IsEnabledIndexedEXT</para>
        /// <para>Extensions: EXT_draw_buffers2</para>
        /// </summary>
        public static bool IsEnabledIndexed(int target, uint index)
        {
            if (gl._IsEnabledIndexed != null) return gl._IsEnabledIndexed(target, index);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: IsVariantEnabledEXT</para>
        /// </summary>
        [GLEntry("IsVariantEnabledEXT", Category = "EXT")]
        public static GLDelegate.IsVariantEnabled _IsVariantEnabled = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsVariantEnabled.</para>
        /// <para>Fullname: IsVariantEnabledEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static bool IsVariantEnabled(uint id, int cap)
        {
            if (gl._IsVariantEnabled != null) return gl._IsVariantEnabled(id, cap);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: LockArraysEXT</para>
        /// </summary>
        [GLEntry("LockArraysEXT", Category = "EXT")]
        public static GLDelegate.LockArrays _LockArrays = null;
        /// <summary>
        /// <para>This extension defines an interface which allows static vertex array data to be cached or pre-compiled for more efficient rendering.  This is useful for implementations which can cache the transformed results of array data for reuse by several DrawArrays, ArrayElement, or DrawElements commands.  It is also useful for implementations which can transfer array data to fast memory for more efficient processing. For example, rendering an M by N mesh of quadrilaterals can be accomplished by setting up vertex arrays containing all of the vertexes in the mesh and issuing M DrawElements commands each of which operate on 2 * N vertexes.  Each DrawElements command after the first will share N vertexes with the preceding DrawElements command.  If the vertex array data is locked while the DrawElements commands are executed, then OpenGL may be able to transform each of these shared vertexes just once. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _LockArrays.</para>
        /// <para>Fullname: LockArraysEXT</para>
        /// <para>Extensions: EXT_compiled_vertex_array</para>
        /// </summary>
        public static void LockArrays(int first, int count)
        {
            if (gl._LockArrays != null) gl._LockArrays(first, count); else { }
        }
        /// <summary>
        /// <para>Fullname: MapNamedBufferEXT</para>
        /// </summary>
        [GLEntry("MapNamedBufferEXT", Category = "EXT")]
        public static GLDelegate.MapNamedBuffer _MapNamedBuffer = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MapNamedBuffer.</para>
        /// <para>Fullname: MapNamedBufferEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static IntPtr MapNamedBuffer(uint buffer, int access)
        {
            if (gl._MapNamedBuffer != null) return gl._MapNamedBuffer(buffer, access);
            else { return (IntPtr)0; }
        }
        /// <summary>
        /// <para>Fullname: MapNamedBufferRangeEXT</para>
        /// </summary>
        [GLEntry("MapNamedBufferRangeEXT", Category = "EXT")]
        public static GLDelegate.MapNamedBufferRange _MapNamedBufferRange = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MapNamedBufferRange.</para>
        /// <para>Fullname: MapNamedBufferRangeEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static IntPtr MapNamedBufferRange(uint buffer, int offset, int length, int access)
        {
            if (gl._MapNamedBufferRange != null) return gl._MapNamedBufferRange(buffer, offset, length, access);
            else { return (IntPtr)0; }
        }
        /// <summary>
        /// <para>Fullname: MatrixFrustumEXT</para>
        /// </summary>
        [GLEntry("MatrixFrustumEXT", Category = "EXT")]
        public static GLDelegate.MatrixFrustum _MatrixFrustum = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixFrustum.</para>
        /// <para>Fullname: MatrixFrustumEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MatrixFrustum(int mode, double left, double right, double bottom, double top, double zNear, double zFar)
        {
            if (gl._MatrixFrustum != null) gl._MatrixFrustum(mode, left, right, bottom, top, zNear, zFar); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixLoaddEXT</para>
        /// </summary>
        [GLEntry("MatrixLoaddEXT", Category = "EXT")]
        public static GLDelegate.MatrixLoadd _MatrixLoadd = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixLoadd.</para>
        /// <para>Fullname: MatrixLoaddEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MatrixLoadd(int mode, double[] m)
        {
            if (gl._MatrixLoadd != null) gl._MatrixLoadd(mode, m); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixLoadfEXT</para>
        /// </summary>
        [GLEntry("MatrixLoadfEXT", Category = "EXT")]
        public static GLDelegate.MatrixLoadf _MatrixLoadf = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixLoadf.</para>
        /// <para>Fullname: MatrixLoadfEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MatrixLoadf(int mode, float[] m)
        {
            if (gl._MatrixLoadf != null) gl._MatrixLoadf(mode, m); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixLoadIdentityEXT</para>
        /// </summary>
        [GLEntry("MatrixLoadIdentityEXT", Category = "EXT")]
        public static GLDelegate.MatrixLoadIdentity _MatrixLoadIdentity = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixLoadIdentity.</para>
        /// <para>Fullname: MatrixLoadIdentityEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MatrixLoadIdentity(int mode)
        {
            if (gl._MatrixLoadIdentity != null) gl._MatrixLoadIdentity(mode); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixLoadTransposedEXT</para>
        /// </summary>
        [GLEntry("MatrixLoadTransposedEXT", Category = "EXT")]
        public static GLDelegate.MatrixLoadTransposed _MatrixLoadTransposed = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixLoadTransposed.</para>
        /// <para>Fullname: MatrixLoadTransposedEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MatrixLoadTransposed(int mode, double[] m)
        {
            if (gl._MatrixLoadTransposed != null) gl._MatrixLoadTransposed(mode, m); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixLoadTransposefEXT</para>
        /// </summary>
        [GLEntry("MatrixLoadTransposefEXT", Category = "EXT")]
        public static GLDelegate.MatrixLoadTransposef _MatrixLoadTransposef = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixLoadTransposef.</para>
        /// <para>Fullname: MatrixLoadTransposefEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MatrixLoadTransposef(int mode, float[] m)
        {
            if (gl._MatrixLoadTransposef != null) gl._MatrixLoadTransposef(mode, m); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixMultdEXT</para>
        /// </summary>
        [GLEntry("MatrixMultdEXT", Category = "EXT")]
        public static GLDelegate.MatrixMultd _MatrixMultd = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixMultd.</para>
        /// <para>Fullname: MatrixMultdEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MatrixMultd(int mode, double[] m)
        {
            if (gl._MatrixMultd != null) gl._MatrixMultd(mode, m); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixMultfEXT</para>
        /// </summary>
        [GLEntry("MatrixMultfEXT", Category = "EXT")]
        public static GLDelegate.MatrixMultf _MatrixMultf = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixMultf.</para>
        /// <para>Fullname: MatrixMultfEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MatrixMultf(int mode, float[] m)
        {
            if (gl._MatrixMultf != null) gl._MatrixMultf(mode, m); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixMultTransposedEXT</para>
        /// </summary>
        [GLEntry("MatrixMultTransposedEXT", Category = "EXT")]
        public static GLDelegate.MatrixMultTransposed _MatrixMultTransposed = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixMultTransposed.</para>
        /// <para>Fullname: MatrixMultTransposedEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MatrixMultTransposed(int mode, double[] m)
        {
            if (gl._MatrixMultTransposed != null) gl._MatrixMultTransposed(mode, m); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixMultTransposefEXT</para>
        /// </summary>
        [GLEntry("MatrixMultTransposefEXT", Category = "EXT")]
        public static GLDelegate.MatrixMultTransposef _MatrixMultTransposef = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixMultTransposef.</para>
        /// <para>Fullname: MatrixMultTransposefEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MatrixMultTransposef(int mode, float[] m)
        {
            if (gl._MatrixMultTransposef != null) gl._MatrixMultTransposef(mode, m); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixOrthoEXT</para>
        /// </summary>
        [GLEntry("MatrixOrthoEXT", Category = "EXT")]
        public static GLDelegate.MatrixOrtho _MatrixOrtho = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixOrtho.</para>
        /// <para>Fullname: MatrixOrthoEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MatrixOrtho(int mode, double left, double right, double bottom, double top, double zNear, double zFar)
        {
            if (gl._MatrixOrtho != null) gl._MatrixOrtho(mode, left, right, bottom, top, zNear, zFar); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixPopEXT</para>
        /// </summary>
        [GLEntry("MatrixPopEXT", Category = "EXT")]
        public static GLDelegate.MatrixPop _MatrixPop = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixPop.</para>
        /// <para>Fullname: MatrixPopEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MatrixPop(int mode)
        {
            if (gl._MatrixPop != null) gl._MatrixPop(mode); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixPushEXT</para>
        /// </summary>
        [GLEntry("MatrixPushEXT", Category = "EXT")]
        public static GLDelegate.MatrixPush _MatrixPush = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixPush.</para>
        /// <para>Fullname: MatrixPushEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MatrixPush(int mode)
        {
            if (gl._MatrixPush != null) gl._MatrixPush(mode); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixRotatedEXT</para>
        /// </summary>
        [GLEntry("MatrixRotatedEXT", Category = "EXT")]
        public static GLDelegate.MatrixRotated _MatrixRotated = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixRotated.</para>
        /// <para>Fullname: MatrixRotatedEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MatrixRotated(int mode, double angle, double x, double y, double z)
        {
            if (gl._MatrixRotated != null) gl._MatrixRotated(mode, angle, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixRotatefEXT</para>
        /// </summary>
        [GLEntry("MatrixRotatefEXT", Category = "EXT")]
        public static GLDelegate.MatrixRotatef _MatrixRotatef = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixRotatef.</para>
        /// <para>Fullname: MatrixRotatefEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MatrixRotatef(int mode, float angle, float x, float y, float z)
        {
            if (gl._MatrixRotatef != null) gl._MatrixRotatef(mode, angle, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixScaledEXT</para>
        /// </summary>
        [GLEntry("MatrixScaledEXT", Category = "EXT")]
        public static GLDelegate.MatrixScaled _MatrixScaled = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixScaled.</para>
        /// <para>Fullname: MatrixScaledEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MatrixScaled(int mode, double x, double y, double z)
        {
            if (gl._MatrixScaled != null) gl._MatrixScaled(mode, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixScalefEXT</para>
        /// </summary>
        [GLEntry("MatrixScalefEXT", Category = "EXT")]
        public static GLDelegate.MatrixScalef _MatrixScalef = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixScalef.</para>
        /// <para>Fullname: MatrixScalefEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MatrixScalef(int mode, float x, float y, float z)
        {
            if (gl._MatrixScalef != null) gl._MatrixScalef(mode, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixTranslatedEXT</para>
        /// </summary>
        [GLEntry("MatrixTranslatedEXT", Category = "EXT")]
        public static GLDelegate.MatrixTranslated _MatrixTranslated = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixTranslated.</para>
        /// <para>Fullname: MatrixTranslatedEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MatrixTranslated(int mode, double x, double y, double z)
        {
            if (gl._MatrixTranslated != null) gl._MatrixTranslated(mode, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: MatrixTranslatefEXT</para>
        /// </summary>
        [GLEntry("MatrixTranslatefEXT", Category = "EXT")]
        public static GLDelegate.MatrixTranslatef _MatrixTranslatef = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MatrixTranslatef.</para>
        /// <para>Fullname: MatrixTranslatefEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MatrixTranslatef(int mode, float x, float y, float z)
        {
            if (gl._MatrixTranslatef != null) gl._MatrixTranslatef(mode, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiDrawElementsEXT</para>
        /// </summary>
        [GLEntry("MultiDrawElementsEXT", Category = "EXT")]
        public static GLDelegate.MultiDrawElementsEXT _MultiDrawElementsEXT = null;
        /// <summary>
        /// <para>These functions behave identically to the standard OpenGL 1.1 functions glDrawArrays() and glDrawElements() except they handle multiple lists of vertices in one call. Their main purpose is to allow one function call to render more than one primitive such as triangle strip, triangle fan, etc. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiDrawElementsEXT.</para>
        /// <para>Fullname: MultiDrawElementsEXT</para>
        /// <para>Extensions: EXT_multi_draw_arrays</para>
        /// </summary>
        public static void MultiDrawElementsEXT(int mode, int[] count, int type, IntPtr[] indices, int primcount)
        {
            if (gl._MultiDrawElementsEXT != null) gl._MultiDrawElementsEXT(mode, count, type, indices, primcount); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexBufferEXT</para>
        /// </summary>
        [GLEntry("MultiTexBufferEXT", Category = "EXT")]
        public static GLDelegate.MultiTexBuffer _MultiTexBuffer = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexBuffer.</para>
        /// <para>Fullname: MultiTexBufferEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexBuffer(int texunit, int target, int internalformat, uint buffer)
        {
            if (gl._MultiTexBuffer != null) gl._MultiTexBuffer(texunit, target, internalformat, buffer); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoordPointerEXT</para>
        /// </summary>
        [GLEntry("MultiTexCoordPointerEXT", Category = "EXT")]
        public static GLDelegate.MultiTexCoordPointer _MultiTexCoordPointer = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoordPointer.</para>
        /// <para>Fullname: MultiTexCoordPointerEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexCoordPointer(int texunit, int size, int type, int stride, IntPtr pointer)
        {
            if (gl._MultiTexCoordPointer != null) gl._MultiTexCoordPointer(texunit, size, type, stride, pointer); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoordPointer.</para>
        /// <para>Fullname: MultiTexCoordPointerEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexCoordPointer(int texunit, int size, int type, int stride, Array pointer)
        {
            GCHandle h = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try { if (gl._MultiTexCoordPointer != null) gl._MultiTexCoordPointer(texunit, size, type, stride, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: MultiTexEnvfEXT</para>
        /// </summary>
        [GLEntry("MultiTexEnvfEXT", Category = "EXT")]
        public static GLDelegate.MultiTexEnvf _MultiTexEnvf = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexEnvf.</para>
        /// <para>Fullname: MultiTexEnvfEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexEnvf(int texunit, int target, int pname, float param)
        {
            if (gl._MultiTexEnvf != null) gl._MultiTexEnvf(texunit, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexEnvfvEXT</para>
        /// </summary>
        [GLEntry("MultiTexEnvfvEXT", Category = "EXT")]
        public static GLDelegate.MultiTexEnvfv _MultiTexEnvfv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexEnvfv.</para>
        /// <para>Fullname: MultiTexEnvfvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexEnvfv(int texunit, int target, int pname, float[] param)
        {
            if (gl._MultiTexEnvfv != null) gl._MultiTexEnvfv(texunit, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexEnviEXT</para>
        /// </summary>
        [GLEntry("MultiTexEnviEXT", Category = "EXT")]
        public static GLDelegate.MultiTexEnvi _MultiTexEnvi = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexEnvi.</para>
        /// <para>Fullname: MultiTexEnviEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexEnvi(int texunit, int target, int pname, int param)
        {
            if (gl._MultiTexEnvi != null) gl._MultiTexEnvi(texunit, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexEnvivEXT</para>
        /// </summary>
        [GLEntry("MultiTexEnvivEXT", Category = "EXT")]
        public static GLDelegate.MultiTexEnviv _MultiTexEnviv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexEnviv.</para>
        /// <para>Fullname: MultiTexEnvivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexEnviv(int texunit, int target, int pname, int[] param)
        {
            if (gl._MultiTexEnviv != null) gl._MultiTexEnviv(texunit, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexGendEXT</para>
        /// </summary>
        [GLEntry("MultiTexGendEXT", Category = "EXT")]
        public static GLDelegate.MultiTexGend _MultiTexGend = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexGend.</para>
        /// <para>Fullname: MultiTexGendEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexGend(int texunit, int coord, int pname, double param)
        {
            if (gl._MultiTexGend != null) gl._MultiTexGend(texunit, coord, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexGendvEXT</para>
        /// </summary>
        [GLEntry("MultiTexGendvEXT", Category = "EXT")]
        public static GLDelegate.MultiTexGendv _MultiTexGendv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexGendv.</para>
        /// <para>Fullname: MultiTexGendvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexGendv(int texunit, int coord, int pname, double[] param)
        {
            if (gl._MultiTexGendv != null) gl._MultiTexGendv(texunit, coord, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexGenfEXT</para>
        /// </summary>
        [GLEntry("MultiTexGenfEXT", Category = "EXT")]
        public static GLDelegate.MultiTexGenf _MultiTexGenf = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexGenf.</para>
        /// <para>Fullname: MultiTexGenfEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexGenf(int texunit, int coord, int pname, float param)
        {
            if (gl._MultiTexGenf != null) gl._MultiTexGenf(texunit, coord, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexGenfvEXT</para>
        /// </summary>
        [GLEntry("MultiTexGenfvEXT", Category = "EXT")]
        public static GLDelegate.MultiTexGenfv _MultiTexGenfv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexGenfv.</para>
        /// <para>Fullname: MultiTexGenfvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexGenfv(int texunit, int coord, int pname, float[] param)
        {
            if (gl._MultiTexGenfv != null) gl._MultiTexGenfv(texunit, coord, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexGeniEXT</para>
        /// </summary>
        [GLEntry("MultiTexGeniEXT", Category = "EXT")]
        public static GLDelegate.MultiTexGeni _MultiTexGeni = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexGeni.</para>
        /// <para>Fullname: MultiTexGeniEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexGeni(int texunit, int coord, int pname, int param)
        {
            if (gl._MultiTexGeni != null) gl._MultiTexGeni(texunit, coord, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexGenivEXT</para>
        /// </summary>
        [GLEntry("MultiTexGenivEXT", Category = "EXT")]
        public static GLDelegate.MultiTexGeniv _MultiTexGeniv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexGeniv.</para>
        /// <para>Fullname: MultiTexGenivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexGeniv(int texunit, int coord, int pname, int[] param)
        {
            if (gl._MultiTexGeniv != null) gl._MultiTexGeniv(texunit, coord, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexImage1DEXT</para>
        /// </summary>
        [GLEntry("MultiTexImage1DEXT", Category = "EXT")]
        public static GLDelegate.MultiTexImage1D _MultiTexImage1D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexImage1D.</para>
        /// <para>Fullname: MultiTexImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexImage1D(int texunit, int target, int level, int internalformat, int width, int border, int format, int type, IntPtr pixels)
        {
            if (gl._MultiTexImage1D != null) gl._MultiTexImage1D(texunit, target, level, internalformat, width, border, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexImage1D.</para>
        /// <para>Fullname: MultiTexImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexImage1D(int texunit, int target, int level, int internalformat, int width, int border, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._MultiTexImage1D != null) gl._MultiTexImage1D(texunit, target, level, internalformat, width, border, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: MultiTexImage2DEXT</para>
        /// </summary>
        [GLEntry("MultiTexImage2DEXT", Category = "EXT")]
        public static GLDelegate.MultiTexImage2D _MultiTexImage2D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexImage2D.</para>
        /// <para>Fullname: MultiTexImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexImage2D(int texunit, int target, int level, int internalformat, int width, int height, int border, int format, int type, IntPtr pixels)
        {
            if (gl._MultiTexImage2D != null) gl._MultiTexImage2D(texunit, target, level, internalformat, width, height, border, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexImage2D.</para>
        /// <para>Fullname: MultiTexImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexImage2D(int texunit, int target, int level, int internalformat, int width, int height, int border, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._MultiTexImage2D != null) gl._MultiTexImage2D(texunit, target, level, internalformat, width, height, border, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: MultiTexImage3DEXT</para>
        /// </summary>
        [GLEntry("MultiTexImage3DEXT", Category = "EXT")]
        public static GLDelegate.MultiTexImage3D _MultiTexImage3D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexImage3D.</para>
        /// <para>Fullname: MultiTexImage3DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexImage3D(int texunit, int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, IntPtr pixels)
        {
            if (gl._MultiTexImage3D != null) gl._MultiTexImage3D(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexImage3D.</para>
        /// <para>Fullname: MultiTexImage3DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexImage3D(int texunit, int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._MultiTexImage3D != null) gl._MultiTexImage3D(texunit, target, level, internalformat, width, height, depth, border, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: MultiTexParameterfEXT</para>
        /// </summary>
        [GLEntry("MultiTexParameterfEXT", Category = "EXT")]
        public static GLDelegate.MultiTexParameterf _MultiTexParameterf = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexParameterf.</para>
        /// <para>Fullname: MultiTexParameterfEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexParameterf(int texunit, int target, int pname, float param)
        {
            if (gl._MultiTexParameterf != null) gl._MultiTexParameterf(texunit, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexParameterfvEXT</para>
        /// </summary>
        [GLEntry("MultiTexParameterfvEXT", Category = "EXT")]
        public static GLDelegate.MultiTexParameterfv _MultiTexParameterfv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexParameterfv.</para>
        /// <para>Fullname: MultiTexParameterfvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexParameterfv(int texunit, int target, int pname, float[] param)
        {
            if (gl._MultiTexParameterfv != null) gl._MultiTexParameterfv(texunit, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexParameteriEXT</para>
        /// </summary>
        [GLEntry("MultiTexParameteriEXT", Category = "EXT")]
        public static GLDelegate.MultiTexParameteri _MultiTexParameteri = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexParameteri.</para>
        /// <para>Fullname: MultiTexParameteriEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexParameteri(int texunit, int target, int pname, int param)
        {
            if (gl._MultiTexParameteri != null) gl._MultiTexParameteri(texunit, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexParameterIivEXT</para>
        /// </summary>
        [GLEntry("MultiTexParameterIivEXT", Category = "EXT")]
        public static GLDelegate.MultiTexParameterIiv _MultiTexParameterIiv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexParameterIiv.</para>
        /// <para>Fullname: MultiTexParameterIivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexParameterIiv(int texunit, int target, int pname, int[] param)
        {
            if (gl._MultiTexParameterIiv != null) gl._MultiTexParameterIiv(texunit, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexParameterIuivEXT</para>
        /// </summary>
        [GLEntry("MultiTexParameterIuivEXT", Category = "EXT")]
        public static GLDelegate.MultiTexParameterIuiv _MultiTexParameterIuiv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexParameterIuiv.</para>
        /// <para>Fullname: MultiTexParameterIuivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexParameterIuiv(int texunit, int target, int pname, uint[] param)
        {
            if (gl._MultiTexParameterIuiv != null) gl._MultiTexParameterIuiv(texunit, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexParameterivEXT</para>
        /// </summary>
        [GLEntry("MultiTexParameterivEXT", Category = "EXT")]
        public static GLDelegate.MultiTexParameteriv _MultiTexParameteriv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexParameteriv.</para>
        /// <para>Fullname: MultiTexParameterivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexParameteriv(int texunit, int target, int pname, int[] param)
        {
            if (gl._MultiTexParameteriv != null) gl._MultiTexParameteriv(texunit, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexRenderbufferEXT</para>
        /// </summary>
        [GLEntry("MultiTexRenderbufferEXT", Category = "EXT")]
        public static GLDelegate.MultiTexRenderbuffer _MultiTexRenderbuffer = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexRenderbuffer.</para>
        /// <para>Fullname: MultiTexRenderbufferEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexRenderbuffer(int texunit, int target, uint renderbuffer)
        {
            if (gl._MultiTexRenderbuffer != null) gl._MultiTexRenderbuffer(texunit, target, renderbuffer); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexSubImage1DEXT</para>
        /// </summary>
        [GLEntry("MultiTexSubImage1DEXT", Category = "EXT")]
        public static GLDelegate.MultiTexSubImage1D _MultiTexSubImage1D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexSubImage1D.</para>
        /// <para>Fullname: MultiTexSubImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexSubImage1D(int texunit, int target, int level, int xoffset, int width, int format, int type, IntPtr pixels)
        {
            if (gl._MultiTexSubImage1D != null) gl._MultiTexSubImage1D(texunit, target, level, xoffset, width, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexSubImage1D.</para>
        /// <para>Fullname: MultiTexSubImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexSubImage1D(int texunit, int target, int level, int xoffset, int width, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._MultiTexSubImage1D != null) gl._MultiTexSubImage1D(texunit, target, level, xoffset, width, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: MultiTexSubImage2DEXT</para>
        /// </summary>
        [GLEntry("MultiTexSubImage2DEXT", Category = "EXT")]
        public static GLDelegate.MultiTexSubImage2D _MultiTexSubImage2D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexSubImage2D.</para>
        /// <para>Fullname: MultiTexSubImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexSubImage2D(int texunit, int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, IntPtr pixels)
        {
            if (gl._MultiTexSubImage2D != null) gl._MultiTexSubImage2D(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexSubImage2D.</para>
        /// <para>Fullname: MultiTexSubImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexSubImage2D(int texunit, int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._MultiTexSubImage2D != null) gl._MultiTexSubImage2D(texunit, target, level, xoffset, yoffset, width, height, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: MultiTexSubImage3DEXT</para>
        /// </summary>
        [GLEntry("MultiTexSubImage3DEXT", Category = "EXT")]
        public static GLDelegate.MultiTexSubImage3D _MultiTexSubImage3D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexSubImage3D.</para>
        /// <para>Fullname: MultiTexSubImage3DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexSubImage3D(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, IntPtr pixels)
        {
            if (gl._MultiTexSubImage3D != null) gl._MultiTexSubImage3D(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexSubImage3D.</para>
        /// <para>Fullname: MultiTexSubImage3DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void MultiTexSubImage3D(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._MultiTexSubImage3D != null) gl._MultiTexSubImage3D(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: NamedBufferDataEXT</para>
        /// </summary>
        [GLEntry("NamedBufferDataEXT", Category = "EXT")]
        public static GLDelegate.NamedBufferData _NamedBufferData = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedBufferData.</para>
        /// <para>Fullname: NamedBufferDataEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedBufferData(uint buffer, int size, IntPtr data, int usage)
        {
            if (gl._NamedBufferData != null) gl._NamedBufferData(buffer, size, data, usage); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedBufferData.</para>
        /// <para>Fullname: NamedBufferDataEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedBufferData(uint buffer, int size, Array data, int usage)
        {
            GCHandle h = GCHandle.Alloc(data, GCHandleType.Pinned);
            try { if (gl._NamedBufferData != null) gl._NamedBufferData(buffer, size, h.AddrOfPinnedObject(), usage); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: NamedBufferSubDataEXT</para>
        /// </summary>
        [GLEntry("NamedBufferSubDataEXT", Category = "EXT")]
        public static GLDelegate.NamedBufferSubData _NamedBufferSubData = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedBufferSubData.</para>
        /// <para>Fullname: NamedBufferSubDataEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedBufferSubData(uint buffer, int offset, int size, IntPtr data)
        {
            if (gl._NamedBufferSubData != null) gl._NamedBufferSubData(buffer, offset, size, data); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedBufferSubData.</para>
        /// <para>Fullname: NamedBufferSubDataEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedBufferSubData(uint buffer, int offset, int size, Array data)
        {
            GCHandle h = GCHandle.Alloc(data, GCHandleType.Pinned);
            try { if (gl._NamedBufferSubData != null) gl._NamedBufferSubData(buffer, offset, size, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: NamedCopyBufferSubDataEXT</para>
        /// </summary>
        [GLEntry("NamedCopyBufferSubDataEXT", Category = "EXT")]
        public static GLDelegate.NamedCopyBufferSubData _NamedCopyBufferSubData = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedCopyBufferSubData.</para>
        /// <para>Fullname: NamedCopyBufferSubDataEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedCopyBufferSubData(uint readBuffer, uint writeBuffer, int readOffset, int writeOffset, int size)
        {
            if (gl._NamedCopyBufferSubData != null) gl._NamedCopyBufferSubData(readBuffer, writeBuffer, readOffset, writeOffset, size); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedFramebufferRenderbufferEXT</para>
        /// </summary>
        [GLEntry("NamedFramebufferRenderbufferEXT", Category = "EXT")]
        public static GLDelegate.NamedFramebufferRenderbuffer _NamedFramebufferRenderbuffer = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedFramebufferRenderbuffer.</para>
        /// <para>Fullname: NamedFramebufferRenderbufferEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedFramebufferRenderbuffer(uint framebuffer, int attachment, int renderbuffertarget, uint renderbuffer)
        {
            if (gl._NamedFramebufferRenderbuffer != null) gl._NamedFramebufferRenderbuffer(framebuffer, attachment, renderbuffertarget, renderbuffer); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedFramebufferTextureEXT</para>
        /// </summary>
        [GLEntry("NamedFramebufferTextureEXT", Category = "EXT")]
        public static GLDelegate.NamedFramebufferTexture _NamedFramebufferTexture = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedFramebufferTexture.</para>
        /// <para>Fullname: NamedFramebufferTextureEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedFramebufferTexture(uint framebuffer, int attachment, uint texture, int level)
        {
            if (gl._NamedFramebufferTexture != null) gl._NamedFramebufferTexture(framebuffer, attachment, texture, level); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedFramebufferTexture1DEXT</para>
        /// </summary>
        [GLEntry("NamedFramebufferTexture1DEXT", Category = "EXT")]
        public static GLDelegate.NamedFramebufferTexture1D _NamedFramebufferTexture1D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedFramebufferTexture1D.</para>
        /// <para>Fullname: NamedFramebufferTexture1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedFramebufferTexture1D(uint framebuffer, int attachment, int textarget, uint texture, int level)
        {
            if (gl._NamedFramebufferTexture1D != null) gl._NamedFramebufferTexture1D(framebuffer, attachment, textarget, texture, level); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedFramebufferTexture2DEXT</para>
        /// </summary>
        [GLEntry("NamedFramebufferTexture2DEXT", Category = "EXT")]
        public static GLDelegate.NamedFramebufferTexture2D _NamedFramebufferTexture2D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedFramebufferTexture2D.</para>
        /// <para>Fullname: NamedFramebufferTexture2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedFramebufferTexture2D(uint framebuffer, int attachment, int textarget, uint texture, int level)
        {
            if (gl._NamedFramebufferTexture2D != null) gl._NamedFramebufferTexture2D(framebuffer, attachment, textarget, texture, level); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedFramebufferTexture3DEXT</para>
        /// </summary>
        [GLEntry("NamedFramebufferTexture3DEXT", Category = "EXT")]
        public static GLDelegate.NamedFramebufferTexture3D _NamedFramebufferTexture3D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedFramebufferTexture3D.</para>
        /// <para>Fullname: NamedFramebufferTexture3DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedFramebufferTexture3D(uint framebuffer, int attachment, int textarget, uint texture, int level, int zoffset)
        {
            if (gl._NamedFramebufferTexture3D != null) gl._NamedFramebufferTexture3D(framebuffer, attachment, textarget, texture, level, zoffset); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedFramebufferTextureFaceEXT</para>
        /// </summary>
        [GLEntry("NamedFramebufferTextureFaceEXT", Category = "EXT")]
        public static GLDelegate.NamedFramebufferTextureFace _NamedFramebufferTextureFace = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedFramebufferTextureFace.</para>
        /// <para>Fullname: NamedFramebufferTextureFaceEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedFramebufferTextureFace(uint framebuffer, int attachment, uint texture, int level, int face)
        {
            if (gl._NamedFramebufferTextureFace != null) gl._NamedFramebufferTextureFace(framebuffer, attachment, texture, level, face); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedFramebufferTextureLayerEXT</para>
        /// </summary>
        [GLEntry("NamedFramebufferTextureLayerEXT", Category = "EXT")]
        public static GLDelegate.NamedFramebufferTextureLayer _NamedFramebufferTextureLayer = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedFramebufferTextureLayer.</para>
        /// <para>Fullname: NamedFramebufferTextureLayerEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedFramebufferTextureLayer(uint framebuffer, int attachment, uint texture, int level, int layer)
        {
            if (gl._NamedFramebufferTextureLayer != null) gl._NamedFramebufferTextureLayer(framebuffer, attachment, texture, level, layer); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedProgramLocalParameter4dEXT</para>
        /// </summary>
        [GLEntry("NamedProgramLocalParameter4dEXT", Category = "EXT")]
        public static GLDelegate.NamedProgramLocalParameter4d _NamedProgramLocalParameter4d = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedProgramLocalParameter4d.</para>
        /// <para>Fullname: NamedProgramLocalParameter4dEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedProgramLocalParameter4d(uint program, int target, uint index, double x, double y, double z, double w)
        {
            if (gl._NamedProgramLocalParameter4d != null) gl._NamedProgramLocalParameter4d(program, target, index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedProgramLocalParameter4dvEXT</para>
        /// </summary>
        [GLEntry("NamedProgramLocalParameter4dvEXT", Category = "EXT")]
        public static GLDelegate.NamedProgramLocalParameter4dv _NamedProgramLocalParameter4dv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedProgramLocalParameter4dv.</para>
        /// <para>Fullname: NamedProgramLocalParameter4dvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedProgramLocalParameter4dv(uint program, int target, uint index, double[] param)
        {
            if (gl._NamedProgramLocalParameter4dv != null) gl._NamedProgramLocalParameter4dv(program, target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedProgramLocalParameter4fEXT</para>
        /// </summary>
        [GLEntry("NamedProgramLocalParameter4fEXT", Category = "EXT")]
        public static GLDelegate.NamedProgramLocalParameter4f _NamedProgramLocalParameter4f = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedProgramLocalParameter4f.</para>
        /// <para>Fullname: NamedProgramLocalParameter4fEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedProgramLocalParameter4f(uint program, int target, uint index, float x, float y, float z, float w)
        {
            if (gl._NamedProgramLocalParameter4f != null) gl._NamedProgramLocalParameter4f(program, target, index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedProgramLocalParameter4fvEXT</para>
        /// </summary>
        [GLEntry("NamedProgramLocalParameter4fvEXT", Category = "EXT")]
        public static GLDelegate.NamedProgramLocalParameter4fv _NamedProgramLocalParameter4fv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedProgramLocalParameter4fv.</para>
        /// <para>Fullname: NamedProgramLocalParameter4fvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedProgramLocalParameter4fv(uint program, int target, uint index, float[] param)
        {
            if (gl._NamedProgramLocalParameter4fv != null) gl._NamedProgramLocalParameter4fv(program, target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedProgramLocalParameterI4iEXT</para>
        /// </summary>
        [GLEntry("NamedProgramLocalParameterI4iEXT", Category = "EXT")]
        public static GLDelegate.NamedProgramLocalParameterI4i _NamedProgramLocalParameterI4i = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedProgramLocalParameterI4i.</para>
        /// <para>Fullname: NamedProgramLocalParameterI4iEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedProgramLocalParameterI4i(uint program, int target, uint index, int x, int y, int z, int w)
        {
            if (gl._NamedProgramLocalParameterI4i != null) gl._NamedProgramLocalParameterI4i(program, target, index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedProgramLocalParameterI4ivEXT</para>
        /// </summary>
        [GLEntry("NamedProgramLocalParameterI4ivEXT", Category = "EXT")]
        public static GLDelegate.NamedProgramLocalParameterI4iv _NamedProgramLocalParameterI4iv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedProgramLocalParameterI4iv.</para>
        /// <para>Fullname: NamedProgramLocalParameterI4ivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedProgramLocalParameterI4iv(uint program, int target, uint index, int[] param)
        {
            if (gl._NamedProgramLocalParameterI4iv != null) gl._NamedProgramLocalParameterI4iv(program, target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedProgramLocalParameterI4uiEXT</para>
        /// </summary>
        [GLEntry("NamedProgramLocalParameterI4uiEXT", Category = "EXT")]
        public static GLDelegate.NamedProgramLocalParameterI4ui _NamedProgramLocalParameterI4ui = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedProgramLocalParameterI4ui.</para>
        /// <para>Fullname: NamedProgramLocalParameterI4uiEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedProgramLocalParameterI4ui(uint program, int target, uint index, uint x, uint y, uint z, uint w)
        {
            if (gl._NamedProgramLocalParameterI4ui != null) gl._NamedProgramLocalParameterI4ui(program, target, index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedProgramLocalParameterI4uivEXT</para>
        /// </summary>
        [GLEntry("NamedProgramLocalParameterI4uivEXT", Category = "EXT")]
        public static GLDelegate.NamedProgramLocalParameterI4uiv _NamedProgramLocalParameterI4uiv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedProgramLocalParameterI4uiv.</para>
        /// <para>Fullname: NamedProgramLocalParameterI4uivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedProgramLocalParameterI4uiv(uint program, int target, uint index, uint[] param)
        {
            if (gl._NamedProgramLocalParameterI4uiv != null) gl._NamedProgramLocalParameterI4uiv(program, target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedProgramLocalParameters4fvEXT</para>
        /// </summary>
        [GLEntry("NamedProgramLocalParameters4fvEXT", Category = "EXT")]
        public static GLDelegate.NamedProgramLocalParameters4fv _NamedProgramLocalParameters4fv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedProgramLocalParameters4fv.</para>
        /// <para>Fullname: NamedProgramLocalParameters4fvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedProgramLocalParameters4fv(uint program, int target, uint index, int count, float[] param)
        {
            if (gl._NamedProgramLocalParameters4fv != null) gl._NamedProgramLocalParameters4fv(program, target, index, count, param); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedProgramLocalParametersI4ivEXT</para>
        /// </summary>
        [GLEntry("NamedProgramLocalParametersI4ivEXT", Category = "EXT")]
        public static GLDelegate.NamedProgramLocalParametersI4iv _NamedProgramLocalParametersI4iv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedProgramLocalParametersI4iv.</para>
        /// <para>Fullname: NamedProgramLocalParametersI4ivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedProgramLocalParametersI4iv(uint program, int target, uint index, int count, int[] param)
        {
            if (gl._NamedProgramLocalParametersI4iv != null) gl._NamedProgramLocalParametersI4iv(program, target, index, count, param); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedProgramLocalParametersI4uivEXT</para>
        /// </summary>
        [GLEntry("NamedProgramLocalParametersI4uivEXT", Category = "EXT")]
        public static GLDelegate.NamedProgramLocalParametersI4uiv _NamedProgramLocalParametersI4uiv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedProgramLocalParametersI4uiv.</para>
        /// <para>Fullname: NamedProgramLocalParametersI4uivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedProgramLocalParametersI4uiv(uint program, int target, uint index, int count, uint[] param)
        {
            if (gl._NamedProgramLocalParametersI4uiv != null) gl._NamedProgramLocalParametersI4uiv(program, target, index, count, param); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedProgramStringEXT</para>
        /// </summary>
        [GLEntry("NamedProgramStringEXT", Category = "EXT")]
        public static GLDelegate.NamedProgramString _NamedProgramString = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedProgramString.</para>
        /// <para>Fullname: NamedProgramStringEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedProgramString(uint program, int target, int format, int len, IntPtr str)
        {
            if (gl._NamedProgramString != null) gl._NamedProgramString(program, target, format, len, str); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedRenderbufferStorageEXT</para>
        /// </summary>
        [GLEntry("NamedRenderbufferStorageEXT", Category = "EXT")]
        public static GLDelegate.NamedRenderbufferStorage _NamedRenderbufferStorage = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedRenderbufferStorage.</para>
        /// <para>Fullname: NamedRenderbufferStorageEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedRenderbufferStorage(uint renderbuffer, int internalformat, int width, int height)
        {
            if (gl._NamedRenderbufferStorage != null) gl._NamedRenderbufferStorage(renderbuffer, internalformat, width, height); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedRenderbufferStorageMultisampleEXT</para>
        /// </summary>
        [GLEntry("NamedRenderbufferStorageMultisampleEXT", Category = "EXT")]
        public static GLDelegate.NamedRenderbufferStorageMultisample _NamedRenderbufferStorageMultisample = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedRenderbufferStorageMultisample.</para>
        /// <para>Fullname: NamedRenderbufferStorageMultisampleEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedRenderbufferStorageMultisample(uint renderbuffer, int samples, int internalformat, int width, int height)
        {
            if (gl._NamedRenderbufferStorageMultisample != null) gl._NamedRenderbufferStorageMultisample(renderbuffer, samples, internalformat, width, height); else { }
        }
        /// <summary>
        /// <para>Fullname: NamedRenderbufferStorageMultisampleCoverageEXT</para>
        /// </summary>
        [GLEntry("NamedRenderbufferStorageMultisampleCoverageEXT", Category = "EXT")]
        public static GLDelegate.NamedRenderbufferStorageMultisampleCoverage _NamedRenderbufferStorageMultisampleCoverage = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NamedRenderbufferStorageMultisampleCoverage.</para>
        /// <para>Fullname: NamedRenderbufferStorageMultisampleCoverageEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void NamedRenderbufferStorageMultisampleCoverage(uint renderbuffer, int coverageSamples, int colorSamples, int internalformat, int width, int height)
        {
            if (gl._NamedRenderbufferStorageMultisampleCoverage != null) gl._NamedRenderbufferStorageMultisampleCoverage(renderbuffer, coverageSamples, colorSamples, internalformat, width, height); else { }
        }
        /// <summary>
        /// <para>Fullname: NormalPointerEXT</para>
        /// </summary>
        [GLEntry("NormalPointerEXT", Category = "EXT")]
        public static GLDelegate.NormalPointerEXT _NormalPointerEXT = null;
        /// <summary>
        /// <para>This extension adds the ability to specify multiple geometric primitives with very few subroutine calls.  Instead of calling an OpenGL procedure to pass each individual vertex, normal, or color, separate arrays of vertexes, normals, and colors are prespecified, and are used to define a sequence of primitives (all of the same type) when a single call is made to DrawArraysEXT.  A stride mechanism is provided so that an application can choose to keep all vertex data staggered in a single array, or sparsely in separate arrays.  Single-array storage may optimize performance on some implementations. This extension also supports the rendering of individual array elements, each specified as an index into the enabled arrays. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NormalPointerEXT.</para>
        /// <para>Fullname: NormalPointerEXT</para>
        /// <para>Extensions: EXT_vertex_array</para>
        /// </summary>
        public static void NormalPointerEXT(int type, int stride, int count, IntPtr pointer)
        {
            if (gl._NormalPointerEXT != null) gl._NormalPointerEXT(type, stride, count, pointer); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelTransformParameterfEXT</para>
        /// </summary>
        [GLEntry("PixelTransformParameterfEXT", Category = "EXT")]
        public static GLDelegate.PixelTransformParameterf _PixelTransformParameterf = null;
        /// <summary>
        /// <para>This extension provides support for scaling, rotation, translation and shearing of two-dimensional pixel rectangles in the pixel rasterizer. The transformation is defined via a 4x4 matrix, where only those entries which apply as a 2D affine transformation will be accepted and used. These matrices can be manipulated using the same functions as the other OpenGL matrix stacks.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelTransformParameterf.</para>
        /// <para>Fullname: PixelTransformParameterfEXT</para>
        /// <para>Extensions: EXT_pixel_transform</para>
        /// </summary>
        public static void PixelTransformParameterf(int target, int pname, float param)
        {
            if (gl._PixelTransformParameterf != null) gl._PixelTransformParameterf(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelTransformParameterfvEXT</para>
        /// </summary>
        [GLEntry("PixelTransformParameterfvEXT", Category = "EXT")]
        public static GLDelegate.PixelTransformParameterfv _PixelTransformParameterfv = null;
        /// <summary>
        /// <para>This extension provides support for scaling, rotation, translation and shearing of two-dimensional pixel rectangles in the pixel rasterizer. The transformation is defined via a 4x4 matrix, where only those entries which apply as a 2D affine transformation will be accepted and used. These matrices can be manipulated using the same functions as the other OpenGL matrix stacks.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelTransformParameterfv.</para>
        /// <para>Fullname: PixelTransformParameterfvEXT</para>
        /// <para>Extensions: EXT_pixel_transform</para>
        /// </summary>
        public static void PixelTransformParameterfv(int target, int pname, float[] param)
        {
            if (gl._PixelTransformParameterfv != null) gl._PixelTransformParameterfv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelTransformParameterfvEXT</para>
        /// </summary>
        [GLEntry("PixelTransformParameterfvEXT", Category = "EXT")]
        public static GLDelegate.PixelTransformParameterfv_float _PixelTransformParameterfv_float = null;
        /// <summary>
        /// <para>This extension provides support for scaling, rotation, translation and shearing of two-dimensional pixel rectangles in the pixel rasterizer. The transformation is defined via a 4x4 matrix, where only those entries which apply as a 2D affine transformation will be accepted and used. These matrices can be manipulated using the same functions as the other OpenGL matrix stacks.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelTransformParameterfv_float.</para>
        /// <para>Fullname: PixelTransformParameterfvEXT</para>
        /// <para>Extensions: EXT_pixel_transform</para>
        /// </summary>
        public static void PixelTransformParameterfv(int target, int pname, ref float param)
        {
            if (gl._PixelTransformParameterfv_float != null) gl._PixelTransformParameterfv_float(target, pname, ref param); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelTransformParameteriEXT</para>
        /// </summary>
        [GLEntry("PixelTransformParameteriEXT", Category = "EXT")]
        public static GLDelegate.PixelTransformParameteri _PixelTransformParameteri = null;
        /// <summary>
        /// <para>This extension provides support for scaling, rotation, translation and shearing of two-dimensional pixel rectangles in the pixel rasterizer. The transformation is defined via a 4x4 matrix, where only those entries which apply as a 2D affine transformation will be accepted and used. These matrices can be manipulated using the same functions as the other OpenGL matrix stacks.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelTransformParameteri.</para>
        /// <para>Fullname: PixelTransformParameteriEXT</para>
        /// <para>Extensions: EXT_pixel_transform</para>
        /// </summary>
        public static void PixelTransformParameteri(int target, int pname, int param)
        {
            if (gl._PixelTransformParameteri != null) gl._PixelTransformParameteri(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelTransformParameterivEXT</para>
        /// </summary>
        [GLEntry("PixelTransformParameterivEXT", Category = "EXT")]
        public static GLDelegate.PixelTransformParameteriv _PixelTransformParameteriv = null;
        /// <summary>
        /// <para>This extension provides support for scaling, rotation, translation and shearing of two-dimensional pixel rectangles in the pixel rasterizer. The transformation is defined via a 4x4 matrix, where only those entries which apply as a 2D affine transformation will be accepted and used. These matrices can be manipulated using the same functions as the other OpenGL matrix stacks.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelTransformParameteriv.</para>
        /// <para>Fullname: PixelTransformParameterivEXT</para>
        /// <para>Extensions: EXT_pixel_transform</para>
        /// </summary>
        public static void PixelTransformParameteriv(int target, int pname, int[] param)
        {
            if (gl._PixelTransformParameteriv != null) gl._PixelTransformParameteriv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelTransformParameterivEXT</para>
        /// </summary>
        [GLEntry("PixelTransformParameterivEXT", Category = "EXT")]
        public static GLDelegate.PixelTransformParameteriv_int _PixelTransformParameteriv_int = null;
        /// <summary>
        /// <para>This extension provides support for scaling, rotation, translation and shearing of two-dimensional pixel rectangles in the pixel rasterizer. The transformation is defined via a 4x4 matrix, where only those entries which apply as a 2D affine transformation will be accepted and used. These matrices can be manipulated using the same functions as the other OpenGL matrix stacks.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelTransformParameteriv_int.</para>
        /// <para>Fullname: PixelTransformParameterivEXT</para>
        /// <para>Extensions: EXT_pixel_transform</para>
        /// </summary>
        public static void PixelTransformParameteriv(int target, int pname, ref int param)
        {
            if (gl._PixelTransformParameteriv_int != null) gl._PixelTransformParameteriv_int(target, pname, ref param); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramEnvParameters4fvEXT</para>
        /// </summary>
        [GLEntry("ProgramEnvParameters4fvEXT", Category = "EXT")]
        public static GLDelegate.ProgramEnvParameters4fv _ProgramEnvParameters4fv = null;
        /// <summary>
        /// <para>This extension provides a new set of procedures to load multiple consecutive program environment parameters more efficiently, via a single GL call instead of multiple calls.  This will reduce the amount of CPU overhead involved in loading parameters. With the existing ARB_vertex_program and ARB_fragment_program APIs, program parameters must be loaded one at a time, via separate calls. While the NV_vertex_program extension provides a set of similar functions that can be used to load program environment parameters (which are equivalent to "program parameters" in NV_vertex_program), no such function exists for program local parameters. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramEnvParameters4fv.</para>
        /// <para>Fullname: ProgramEnvParameters4fvEXT</para>
        /// <para>Extensions: EXT_gpu_program_parameters</para>
        /// </summary>
        public static void ProgramEnvParameters4fv(int target, uint index, int count, float[] param)
        {
            if (gl._ProgramEnvParameters4fv != null) gl._ProgramEnvParameters4fv(target, index, count, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramLocalParameters4fvEXT</para>
        /// </summary>
        [GLEntry("ProgramLocalParameters4fvEXT", Category = "EXT")]
        public static GLDelegate.ProgramLocalParameters4fv _ProgramLocalParameters4fv = null;
        /// <summary>
        /// <para>This extension provides a new set of procedures to load multiple consecutive program environment parameters more efficiently, via a single GL call instead of multiple calls.  This will reduce the amount of CPU overhead involved in loading parameters. With the existing ARB_vertex_program and ARB_fragment_program APIs, program parameters must be loaded one at a time, via separate calls. While the NV_vertex_program extension provides a set of similar functions that can be used to load program environment parameters (which are equivalent to "program parameters" in NV_vertex_program), no such function exists for program local parameters. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramLocalParameters4fv.</para>
        /// <para>Fullname: ProgramLocalParameters4fvEXT</para>
        /// <para>Extensions: EXT_gpu_program_parameters</para>
        /// </summary>
        public static void ProgramLocalParameters4fv(int target, uint index, int count, float[] param)
        {
            if (gl._ProgramLocalParameters4fv != null) gl._ProgramLocalParameters4fv(target, index, count, param); else { }
        }
        /// <summary>
        /// <para>Fullname: PushClientAttribDefaultEXT</para>
        /// </summary>
        [GLEntry("PushClientAttribDefaultEXT", Category = "EXT")]
        public static GLDelegate.PushClientAttribDefault _PushClientAttribDefault = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PushClientAttribDefault.</para>
        /// <para>Fullname: PushClientAttribDefaultEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void PushClientAttribDefault(int mask)
        {
            if (gl._PushClientAttribDefault != null) gl._PushClientAttribDefault(mask); else { }
        }
        /// <summary>
        /// <para>Fullname: SampleMaskEXT</para>
        /// </summary>
        [GLEntry("SampleMaskEXT", Category = "EXT", Alias = "SampleMaskSGIS ")]
        public static GLDelegate.SampleMask _SampleMask = null;
        public static GLDelegate.SampleMask SampleMaskSGIS = SampleMask;
        /// <summary>
        /// <para>This extension provides a mechanism to antialias all GL primitives: points, lines, polygons, bitmaps, and images.  The technique is to sample all primitives multiple times at each pixel.  The color sample values are resolved to a single, displayable color each time a pixel is updated, so the antialiasing appears to be automatic at the application level.  Because each sample includes depth and stencil information, the depth and stencil functions perform equivalently to the single-sample mode. An additional buffer, called the multisample buffer, is added to the framebuffer.  Pixel sample values, including color, depth, and stencil values, are stored in this buffer.  When the framebuffer includes a multisample buffer, it does not also include separate depth or stencil buffers, even if the multisample buffer does not store depth or stencil values.  Color buffers (left/right, front/ back, and aux) do coexist with the multisample buffer, however. Multisample antialiasing is most valuable for...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SampleMask.</para>
        /// <para>Fullname: SampleMaskEXT</para>
        /// <para>Aliases: SampleMaskSGIS, </para>
        /// <para>Extensions: EXT_multisample SGIS_multisample</para>
        /// </summary>
        public static void SampleMask(float value, bool invert)
        {
            if (gl._SampleMask != null) gl._SampleMask(value, invert); else { }
        }
        /// <summary>
        /// <para>Fullname: SamplePatternEXT</para>
        /// </summary>
        [GLEntry("SamplePatternEXT", Category = "EXT", Alias = "SamplePatternSGIS ")]
        public static GLDelegate.SamplePattern _SamplePattern = null;
        public static GLDelegate.SamplePattern SamplePatternSGIS = SamplePattern;
        /// <summary>
        /// <para>This extension provides a mechanism to antialias all GL primitives: points, lines, polygons, bitmaps, and images.  The technique is to sample all primitives multiple times at each pixel.  The color sample values are resolved to a single, displayable color each time a pixel is updated, so the antialiasing appears to be automatic at the application level.  Because each sample includes depth and stencil information, the depth and stencil functions perform equivalently to the single-sample mode. An additional buffer, called the multisample buffer, is added to the framebuffer.  Pixel sample values, including color, depth, and stencil values, are stored in this buffer.  When the framebuffer includes a multisample buffer, it does not also include separate depth or stencil buffers, even if the multisample buffer does not store depth or stencil values.  Color buffers (left/right, front/ back, and aux) do coexist with the multisample buffer, however. Multisample antialiasing is most valuable for...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SamplePattern.</para>
        /// <para>Fullname: SamplePatternEXT</para>
        /// <para>Aliases: SamplePatternSGIS, </para>
        /// <para>Extensions: EXT_multisample SGIS_multisample</para>
        /// </summary>
        public static void SamplePattern(int pattern)
        {
            if (gl._SamplePattern != null) gl._SamplePattern(pattern); else { }
        }
        /// <summary>
        /// <para>Fullname: SetInvariantEXT</para>
        /// </summary>
        [GLEntry("SetInvariantEXT", Category = "EXT")]
        public static GLDelegate.SetInvariant _SetInvariant = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SetInvariant.</para>
        /// <para>Fullname: SetInvariantEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void SetInvariant(uint id, int type, IntPtr addr)
        {
            if (gl._SetInvariant != null) gl._SetInvariant(id, type, addr); else { }
        }
        /// <summary>
        /// <para>Fullname: SetLocalConstantEXT</para>
        /// </summary>
        [GLEntry("SetLocalConstantEXT", Category = "EXT")]
        public static GLDelegate.SetLocalConstant _SetLocalConstant = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SetLocalConstant.</para>
        /// <para>Fullname: SetLocalConstantEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void SetLocalConstant(uint id, int type, IntPtr addr)
        {
            if (gl._SetLocalConstant != null) gl._SetLocalConstant(id, type, addr); else { }
        }
        /// <summary>
        /// <para>Fullname: ShaderOp1EXT</para>
        /// </summary>
        [GLEntry("ShaderOp1EXT", Category = "EXT")]
        public static GLDelegate.ShaderOp1 _ShaderOp1 = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ShaderOp1.</para>
        /// <para>Fullname: ShaderOp1EXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void ShaderOp1(int op, uint res, uint arg1)
        {
            if (gl._ShaderOp1 != null) gl._ShaderOp1(op, res, arg1); else { }
        }
        /// <summary>
        /// <para>Fullname: ShaderOp2EXT</para>
        /// </summary>
        [GLEntry("ShaderOp2EXT", Category = "EXT")]
        public static GLDelegate.ShaderOp2 _ShaderOp2 = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ShaderOp2.</para>
        /// <para>Fullname: ShaderOp2EXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void ShaderOp2(int op, uint res, uint arg1, uint arg2)
        {
            if (gl._ShaderOp2 != null) gl._ShaderOp2(op, res, arg1, arg2); else { }
        }
        /// <summary>
        /// <para>Fullname: ShaderOp3EXT</para>
        /// </summary>
        [GLEntry("ShaderOp3EXT", Category = "EXT")]
        public static GLDelegate.ShaderOp3 _ShaderOp3 = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ShaderOp3.</para>
        /// <para>Fullname: ShaderOp3EXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void ShaderOp3(int op, uint res, uint arg1, uint arg2, uint arg3)
        {
            if (gl._ShaderOp3 != null) gl._ShaderOp3(op, res, arg1, arg2, arg3); else { }
        }
        /// <summary>
        /// <para>Fullname: StencilClearTagEXT</para>
        /// </summary>
        [GLEntry("StencilClearTagEXT", Category = "EXT")]
        public static GLDelegate.StencilClearTag _StencilClearTag = null;
        /// <summary>
        /// <para>Stencil-only framebuffer clears are increasingly common as 3D applications are now using rendering algorithms such as stenciled shadow volume rendering for multiple light sources in a single frame, recent "soft" stenciled shadow volume techniques, and stencil-based constructive solid geometry techniques.  In such algorithms there are multiple stencil buffer clears for each depth buffer clear. Additionally in most cases, these algorithms do not require all of the 8 typical stencil bitplanes for their stencil requirements. In such cases, there is the potential for unused stencil bitplanes to encode a "stencil clear tag" in such a way to reduce the number of actual stencil clears.  The idea is that switching to an unused stencil clear tag logically corresponds to when an application would otherwise perform a framebuffer-wide stencil clear. This extension exposes an inexpensive hardware mechanism for amortizing the cost of multiple stencil-only clears by using a client-specified number of ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _StencilClearTag.</para>
        /// <para>Fullname: StencilClearTagEXT</para>
        /// <para>Extensions: EXT_stencil_clear_tag</para>
        /// </summary>
        public static void StencilClearTag(int stencilTagBits, uint stencilClearTag)
        {
            if (gl._StencilClearTag != null) gl._StencilClearTag(stencilTagBits, stencilClearTag); else { }
        }
        /// <summary>
        /// <para>Fullname: SwizzleEXT</para>
        /// </summary>
        [GLEntry("SwizzleEXT", Category = "EXT")]
        public static GLDelegate.Swizzle _Swizzle = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Swizzle.</para>
        /// <para>Fullname: SwizzleEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void Swizzle(uint res, uint input, int outX, int outY, int outZ, int outW)
        {
            if (gl._Swizzle != null) gl._Swizzle(res, input, outX, outY, outZ, outW); else { }
        }
        /// <summary>
        /// <para>Fullname: Tangent3bEXT</para>
        /// </summary>
        [GLEntry("Tangent3bEXT", Category = "EXT")]
        public static GLDelegate.Tangent3b _Tangent3b = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Tangent3b.</para>
        /// <para>Fullname: Tangent3bEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Tangent3b(byte tx, byte ty, byte tz)
        {
            if (gl._Tangent3b != null) gl._Tangent3b(tx, ty, tz); else { }
        }
        /// <summary>
        /// <para>Fullname: Tangent3bvEXT</para>
        /// </summary>
        [GLEntry("Tangent3bvEXT", Category = "EXT")]
        public static GLDelegate.Tangent3bv _Tangent3bv = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Tangent3bv.</para>
        /// <para>Fullname: Tangent3bvEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Tangent3bv(byte[] v)
        {
            if (gl._Tangent3bv != null) gl._Tangent3bv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Tangent3dEXT</para>
        /// </summary>
        [GLEntry("Tangent3dEXT", Category = "EXT")]
        public static GLDelegate.Tangent3d _Tangent3d = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Tangent3d.</para>
        /// <para>Fullname: Tangent3dEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Tangent3d(double tx, double ty, double tz)
        {
            if (gl._Tangent3d != null) gl._Tangent3d(tx, ty, tz); else { }
        }
        /// <summary>
        /// <para>Fullname: Tangent3dvEXT</para>
        /// </summary>
        [GLEntry("Tangent3dvEXT", Category = "EXT")]
        public static GLDelegate.Tangent3dv _Tangent3dv = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Tangent3dv.</para>
        /// <para>Fullname: Tangent3dvEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Tangent3dv(double[] v)
        {
            if (gl._Tangent3dv != null) gl._Tangent3dv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Tangent3fEXT</para>
        /// </summary>
        [GLEntry("Tangent3fEXT", Category = "EXT")]
        public static GLDelegate.Tangent3f _Tangent3f = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Tangent3f.</para>
        /// <para>Fullname: Tangent3fEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Tangent3f(float tx, float ty, float tz)
        {
            if (gl._Tangent3f != null) gl._Tangent3f(tx, ty, tz); else { }
        }
        /// <summary>
        /// <para>Fullname: Tangent3fvEXT</para>
        /// </summary>
        [GLEntry("Tangent3fvEXT", Category = "EXT")]
        public static GLDelegate.Tangent3fv _Tangent3fv = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Tangent3fv.</para>
        /// <para>Fullname: Tangent3fvEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Tangent3fv(float[] v)
        {
            if (gl._Tangent3fv != null) gl._Tangent3fv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Tangent3iEXT</para>
        /// </summary>
        [GLEntry("Tangent3iEXT", Category = "EXT")]
        public static GLDelegate.Tangent3i _Tangent3i = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Tangent3i.</para>
        /// <para>Fullname: Tangent3iEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Tangent3i(int tx, int ty, int tz)
        {
            if (gl._Tangent3i != null) gl._Tangent3i(tx, ty, tz); else { }
        }
        /// <summary>
        /// <para>Fullname: Tangent3ivEXT</para>
        /// </summary>
        [GLEntry("Tangent3ivEXT", Category = "EXT")]
        public static GLDelegate.Tangent3iv _Tangent3iv = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Tangent3iv.</para>
        /// <para>Fullname: Tangent3ivEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Tangent3iv(int[] v)
        {
            if (gl._Tangent3iv != null) gl._Tangent3iv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Tangent3sEXT</para>
        /// </summary>
        [GLEntry("Tangent3sEXT", Category = "EXT")]
        public static GLDelegate.Tangent3s _Tangent3s = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Tangent3s.</para>
        /// <para>Fullname: Tangent3sEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Tangent3s(short tx, short ty, short tz)
        {
            if (gl._Tangent3s != null) gl._Tangent3s(tx, ty, tz); else { }
        }
        /// <summary>
        /// <para>Fullname: Tangent3svEXT</para>
        /// </summary>
        [GLEntry("Tangent3svEXT", Category = "EXT")]
        public static GLDelegate.Tangent3sv _Tangent3sv = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Tangent3sv.</para>
        /// <para>Fullname: Tangent3svEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void Tangent3sv(short[] v)
        {
            if (gl._Tangent3sv != null) gl._Tangent3sv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TangentPointerEXT</para>
        /// </summary>
        [GLEntry("TangentPointerEXT", Category = "EXT")]
        public static GLDelegate.TangentPointer _TangentPointer = null;
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TangentPointer.</para>
        /// <para>Fullname: TangentPointerEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void TangentPointer(int type, int stride, IntPtr pointer)
        {
            if (gl._TangentPointer != null) gl._TangentPointer(type, stride, pointer); else { }
        }
        /// <summary>
        /// <para>This extension allows specifying a per-vertex tangent and binormal vector in addition to the normal vector, defining a coordinate frame. The coordinate frame is used in additional extensions which also build on fragment lighting to achieve bump mapping. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TangentPointer.</para>
        /// <para>Fullname: TangentPointerEXT</para>
        /// <para>Extensions: EXT_coordinate_frame</para>
        /// </summary>
        public static void TangentPointer(int type, int stride, Array pointer)
        {
            GCHandle h = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try { if (gl._TangentPointer != null) gl._TangentPointer(type, stride, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: TexCoordPointerEXT</para>
        /// </summary>
        [GLEntry("TexCoordPointerEXT", Category = "EXT")]
        public static GLDelegate.TexCoordPointerEXT _TexCoordPointerEXT = null;
        /// <summary>
        /// <para>This extension adds the ability to specify multiple geometric primitives with very few subroutine calls.  Instead of calling an OpenGL procedure to pass each individual vertex, normal, or color, separate arrays of vertexes, normals, and colors are prespecified, and are used to define a sequence of primitives (all of the same type) when a single call is made to DrawArraysEXT.  A stride mechanism is provided so that an application can choose to keep all vertex data staggered in a single array, or sparsely in separate arrays.  Single-array storage may optimize performance on some implementations. This extension also supports the rendering of individual array elements, each specified as an index into the enabled arrays. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoordPointerEXT.</para>
        /// <para>Fullname: TexCoordPointerEXT</para>
        /// <para>Extensions: EXT_vertex_array</para>
        /// </summary>
        public static void TexCoordPointerEXT(int size, int type, int stride, int count, IntPtr pointer)
        {
            if (gl._TexCoordPointerEXT != null) gl._TexCoordPointerEXT(size, type, stride, count, pointer); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureBufferEXT</para>
        /// </summary>
        [GLEntry("TextureBufferEXT", Category = "EXT")]
        public static GLDelegate.TextureBuffer _TextureBuffer = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureBuffer.</para>
        /// <para>Fullname: TextureBufferEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureBuffer(uint texture, int target, int internalformat, uint buffer)
        {
            if (gl._TextureBuffer != null) gl._TextureBuffer(texture, target, internalformat, buffer); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureImage1DEXT</para>
        /// </summary>
        [GLEntry("TextureImage1DEXT", Category = "EXT")]
        public static GLDelegate.TextureImage1D _TextureImage1D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureImage1D.</para>
        /// <para>Fullname: TextureImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureImage1D(uint texture, int target, int level, int internalformat, int width, int border, int format, int type, IntPtr pixels)
        {
            if (gl._TextureImage1D != null) gl._TextureImage1D(texture, target, level, internalformat, width, border, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureImage1D.</para>
        /// <para>Fullname: TextureImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureImage1D(uint texture, int target, int level, int internalformat, int width, int border, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._TextureImage1D != null) gl._TextureImage1D(texture, target, level, internalformat, width, border, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: TextureImage2DEXT</para>
        /// </summary>
        [GLEntry("TextureImage2DEXT", Category = "EXT")]
        public static GLDelegate.TextureImage2D _TextureImage2D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureImage2D.</para>
        /// <para>Fullname: TextureImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureImage2D(uint texture, int target, int level, int internalformat, int width, int height, int border, int format, int type, IntPtr pixels)
        {
            if (gl._TextureImage2D != null) gl._TextureImage2D(texture, target, level, internalformat, width, height, border, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureImage2D.</para>
        /// <para>Fullname: TextureImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureImage2D(uint texture, int target, int level, int internalformat, int width, int height, int border, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._TextureImage2D != null) gl._TextureImage2D(texture, target, level, internalformat, width, height, border, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: TextureImage3DEXT</para>
        /// </summary>
        [GLEntry("TextureImage3DEXT", Category = "EXT")]
        public static GLDelegate.TextureImage3D _TextureImage3D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureImage3D.</para>
        /// <para>Fullname: TextureImage3DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureImage3D(uint texture, int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, IntPtr pixels)
        {
            if (gl._TextureImage3D != null) gl._TextureImage3D(texture, target, level, internalformat, width, height, depth, border, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureImage3D.</para>
        /// <para>Fullname: TextureImage3DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureImage3D(uint texture, int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._TextureImage3D != null) gl._TextureImage3D(texture, target, level, internalformat, width, height, depth, border, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: TextureLightEXT</para>
        /// </summary>
        [GLEntry("TextureLightEXT", Category = "EXT")]
        public static GLDelegate.TextureLight _TextureLight = null;
        /// <summary>
        /// <para>This extension defines a general mechanism for substituting the fragment color computed during texture environment processing in place of other fragment attributes such as the fragment normal, or as sources for some of the computations in the fragment processing pipeline, for example as material or light parameters in the fragment lighting computations. Cf ----------------------+ |                 +-> to lighting parameters v                 | +------------+        +--------+     +-------------+ |            |        |        |     |             | | texel      |------->| texenv |-----| texture     |---> Cf' (to Light Environment | generation |        |        |     | application |          or Fog) |            |        |        |     |             | +------------+        +--------+     +-------------+ </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureLight.</para>
        /// <para>Fullname: TextureLightEXT</para>
        /// <para>Extensions: EXT_light_texture</para>
        /// </summary>
        public static void TextureLight(int pname)
        {
            if (gl._TextureLight != null) gl._TextureLight(pname); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureMaterialEXT</para>
        /// </summary>
        [GLEntry("TextureMaterialEXT", Category = "EXT")]
        public static GLDelegate.TextureMaterial _TextureMaterial = null;
        /// <summary>
        /// <para>This extension defines a general mechanism for substituting the fragment color computed during texture environment processing in place of other fragment attributes such as the fragment normal, or as sources for some of the computations in the fragment processing pipeline, for example as material or light parameters in the fragment lighting computations. Cf ----------------------+ |                 +-> to lighting parameters v                 | +------------+        +--------+     +-------------+ |            |        |        |     |             | | texel      |------->| texenv |-----| texture     |---> Cf' (to Light Environment | generation |        |        |     | application |          or Fog) |            |        |        |     |             | +------------+        +--------+     +-------------+ </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureMaterial.</para>
        /// <para>Fullname: TextureMaterialEXT</para>
        /// <para>Extensions: EXT_light_texture</para>
        /// </summary>
        public static void TextureMaterial(int face, int mode)
        {
            if (gl._TextureMaterial != null) gl._TextureMaterial(face, mode); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureNormalEXT</para>
        /// </summary>
        [GLEntry("TextureNormalEXT", Category = "EXT")]
        public static GLDelegate.TextureNormal _TextureNormal = null;
        /// <summary>
        /// <para>This extension defines a mechanism for using texture values to perturb the fragment normal vector prior to fragment lighting.  It enables a direct implementation of the original formulation of bump mapping by Blinn. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureNormal.</para>
        /// <para>Fullname: TextureNormalEXT</para>
        /// <para>Extensions: EXT_texture_perturb_normal</para>
        /// </summary>
        public static void TextureNormal(int mode)
        {
            if (gl._TextureNormal != null) gl._TextureNormal(mode); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureParameterfEXT</para>
        /// </summary>
        [GLEntry("TextureParameterfEXT", Category = "EXT")]
        public static GLDelegate.TextureParameterf _TextureParameterf = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureParameterf.</para>
        /// <para>Fullname: TextureParameterfEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureParameterf(uint texture, int target, int pname, float param)
        {
            if (gl._TextureParameterf != null) gl._TextureParameterf(texture, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureParameterfvEXT</para>
        /// </summary>
        [GLEntry("TextureParameterfvEXT", Category = "EXT")]
        public static GLDelegate.TextureParameterfv _TextureParameterfv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureParameterfv.</para>
        /// <para>Fullname: TextureParameterfvEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureParameterfv(uint texture, int target, int pname, float[] param)
        {
            if (gl._TextureParameterfv != null) gl._TextureParameterfv(texture, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureParameteriEXT</para>
        /// </summary>
        [GLEntry("TextureParameteriEXT", Category = "EXT")]
        public static GLDelegate.TextureParameteri _TextureParameteri = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureParameteri.</para>
        /// <para>Fullname: TextureParameteriEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureParameteri(uint texture, int target, int pname, int param)
        {
            if (gl._TextureParameteri != null) gl._TextureParameteri(texture, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureParameterIivEXT</para>
        /// </summary>
        [GLEntry("TextureParameterIivEXT", Category = "EXT")]
        public static GLDelegate.TextureParameterIiv _TextureParameterIiv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureParameterIiv.</para>
        /// <para>Fullname: TextureParameterIivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureParameterIiv(uint texture, int target, int pname, int[] param)
        {
            if (gl._TextureParameterIiv != null) gl._TextureParameterIiv(texture, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureParameterIuivEXT</para>
        /// </summary>
        [GLEntry("TextureParameterIuivEXT", Category = "EXT")]
        public static GLDelegate.TextureParameterIuiv _TextureParameterIuiv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureParameterIuiv.</para>
        /// <para>Fullname: TextureParameterIuivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureParameterIuiv(uint texture, int target, int pname, uint[] param)
        {
            if (gl._TextureParameterIuiv != null) gl._TextureParameterIuiv(texture, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureParameterivEXT</para>
        /// </summary>
        [GLEntry("TextureParameterivEXT", Category = "EXT")]
        public static GLDelegate.TextureParameteriv _TextureParameteriv = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureParameteriv.</para>
        /// <para>Fullname: TextureParameterivEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureParameteriv(uint texture, int target, int pname, int[] param)
        {
            if (gl._TextureParameteriv != null) gl._TextureParameteriv(texture, target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureRenderbufferEXT</para>
        /// </summary>
        [GLEntry("TextureRenderbufferEXT", Category = "EXT")]
        public static GLDelegate.TextureRenderbuffer _TextureRenderbuffer = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureRenderbuffer.</para>
        /// <para>Fullname: TextureRenderbufferEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureRenderbuffer(uint texture, int target, uint renderbuffer)
        {
            if (gl._TextureRenderbuffer != null) gl._TextureRenderbuffer(texture, target, renderbuffer); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureSubImage1DEXT</para>
        /// </summary>
        [GLEntry("TextureSubImage1DEXT", Category = "EXT")]
        public static GLDelegate.TextureSubImage1D _TextureSubImage1D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureSubImage1D.</para>
        /// <para>Fullname: TextureSubImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureSubImage1D(uint texture, int target, int level, int xoffset, int width, int format, int type, IntPtr pixels)
        {
            if (gl._TextureSubImage1D != null) gl._TextureSubImage1D(texture, target, level, xoffset, width, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureSubImage1D.</para>
        /// <para>Fullname: TextureSubImage1DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureSubImage1D(uint texture, int target, int level, int xoffset, int width, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._TextureSubImage1D != null) gl._TextureSubImage1D(texture, target, level, xoffset, width, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: TextureSubImage2DEXT</para>
        /// </summary>
        [GLEntry("TextureSubImage2DEXT", Category = "EXT")]
        public static GLDelegate.TextureSubImage2D _TextureSubImage2D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureSubImage2D.</para>
        /// <para>Fullname: TextureSubImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureSubImage2D(uint texture, int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, IntPtr pixels)
        {
            if (gl._TextureSubImage2D != null) gl._TextureSubImage2D(texture, target, level, xoffset, yoffset, width, height, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureSubImage2D.</para>
        /// <para>Fullname: TextureSubImage2DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureSubImage2D(uint texture, int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._TextureSubImage2D != null) gl._TextureSubImage2D(texture, target, level, xoffset, yoffset, width, height, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: TextureSubImage3DEXT</para>
        /// </summary>
        [GLEntry("TextureSubImage3DEXT", Category = "EXT")]
        public static GLDelegate.TextureSubImage3D _TextureSubImage3D = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureSubImage3D.</para>
        /// <para>Fullname: TextureSubImage3DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureSubImage3D(uint texture, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, IntPtr pixels)
        {
            if (gl._TextureSubImage3D != null) gl._TextureSubImage3D(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureSubImage3D.</para>
        /// <para>Fullname: TextureSubImage3DEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static void TextureSubImage3D(uint texture, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._TextureSubImage3D != null) gl._TextureSubImage3D(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: UniformBufferEXT</para>
        /// </summary>
        [GLEntry("UniformBufferEXT", Category = "EXT")]
        public static GLDelegate.UniformBuffer _UniformBuffer = null;
        /// <summary>
        /// <para>This extension introduces the concept of bindable uniforms to the OpenGL Shading Language.  A uniform variable can be declared bindable, which means that the storage for the uniform is not allocated by the compiler/linker anymore, but is backed by a buffer object.  This buffer object is bound to the bindable uniform through the new command UniformBufferEXT().  Binding needs to happen after linking a program object. Binding different buffer objects to a bindable uniform allows an application to easily use different "uniform data sets", without having to re-specify the data every time. A buffer object can be bound to bindable uniforms in different program objects. If those bindable uniforms are all of the same type, accessing a bindable uniform in program object A will result in the same data if the same access is made in program object B.  This provides a mechanism for 'environment uniforms', uniform values that can be shared among multiple program objects. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformBuffer.</para>
        /// <para>Fullname: UniformBufferEXT</para>
        /// <para>Extensions: EXT_bindable_uniform</para>
        /// </summary>
        public static void UniformBuffer(uint program, int location, uint buffer)
        {
            if (gl._UniformBuffer != null) gl._UniformBuffer(program, location, buffer); else { }
        }
        /// <summary>
        /// <para>Fullname: UnlockArraysEXT</para>
        /// </summary>
        [GLEntry("UnlockArraysEXT", Category = "EXT")]
        public static GLDelegate.UnlockArrays _UnlockArrays = null;
        /// <summary>
        /// <para>This extension defines an interface which allows static vertex array data to be cached or pre-compiled for more efficient rendering.  This is useful for implementations which can cache the transformed results of array data for reuse by several DrawArrays, ArrayElement, or DrawElements commands.  It is also useful for implementations which can transfer array data to fast memory for more efficient processing. For example, rendering an M by N mesh of quadrilaterals can be accomplished by setting up vertex arrays containing all of the vertexes in the mesh and issuing M DrawElements commands each of which operate on 2 * N vertexes.  Each DrawElements command after the first will share N vertexes with the preceding DrawElements command.  If the vertex array data is locked while the DrawElements commands are executed, then OpenGL may be able to transform each of these shared vertexes just once. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UnlockArrays.</para>
        /// <para>Fullname: UnlockArraysEXT</para>
        /// <para>Extensions: EXT_compiled_vertex_array</para>
        /// </summary>
        public static void UnlockArrays()
        {
            if (gl._UnlockArrays != null) gl._UnlockArrays(); else { }
        }
        /// <summary>
        /// <para>Fullname: UnmapNamedBufferEXT</para>
        /// </summary>
        [GLEntry("UnmapNamedBufferEXT", Category = "EXT")]
        public static GLDelegate.UnmapNamedBuffer _UnmapNamedBuffer = null;
        /// <summary>
        /// <para>This extension introduces a set of new "direct state access" commands (meaning no selector is involved) to access (update and query) OpenGL state that previously depended on the OpenGL state selectors for access.  These new commands supplement the existing selector-based OpenGL commands to access the same state. The intent of this extension is to make it more efficient for libraries to avoid disturbing selector and latched state.  The extension also allows more efficient command usage by eliminating the need for selector update commands. Two derivative advantages of this extension are 1) display lists can be executed using these commands that avoid disturbing selectors that subsequent commands may depend on, and 2) drivers implemented with a dual-thread partitioning with OpenGL command buffering from an application thread and then OpenGL command dispatching in a concurrent driver thread can avoid thread synchronization created by selector saving, setting, command execution, and selecto...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UnmapNamedBuffer.</para>
        /// <para>Fullname: UnmapNamedBufferEXT</para>
        /// <para>Extensions: EXT_direct_state_access</para>
        /// </summary>
        public static bool UnmapNamedBuffer(uint buffer)
        {
            if (gl._UnmapNamedBuffer != null) return gl._UnmapNamedBuffer(buffer);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: UseShaderProgramEXT</para>
        /// </summary>
        [GLEntry("UseShaderProgramEXT", Category = "EXT")]
        public static GLDelegate.UseShaderProgram _UseShaderProgram = null;
        /// <summary>
        /// <para>Prior to this extension, GLSL requires multiple shader domains (vertex, fragment, geometry) to be linked into a single monolithic program object to specify a GLSL shader for each domain. While GLSL's monolithic approach has some advantages for optimizing shaders as a unit that span multiple domains, all existing GPU hardware supports the more flexible mix-and-match approach. HLSL9, Cg, the prior OpenGL assembly program extensions, and game console programmers favor a more flexible "mix-and-match" approach to specifying shaders independently for these different shader domains. Many developers build their shader content around the mix-and-match approach where they can use a single vertex shader with multiple fragment shaders (or vice versa). This keep-it-simple extension adapts the "mix-and-match" shader domain model for GLSL so different GLSL program objects can be bound to different shader domains. This extension redefines the operation of glUseProgram(GLenum program) to be equivalent ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UseShaderProgram.</para>
        /// <para>Fullname: UseShaderProgramEXT</para>
        /// <para>Extensions: EXT_separate_shader_objects</para>
        /// </summary>
        public static void UseShaderProgram(int type, uint program)
        {
            if (gl._UseShaderProgram != null) gl._UseShaderProgram(type, program); else { }
        }
        /// <summary>
        /// <para>Fullname: VariantbvEXT</para>
        /// </summary>
        [GLEntry("VariantbvEXT", Category = "EXT")]
        public static GLDelegate.Variantbv _Variantbv = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Variantbv.</para>
        /// <para>Fullname: VariantbvEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void Variantbv(uint id, byte[] addr)
        {
            if (gl._Variantbv != null) gl._Variantbv(id, addr); else { }
        }
        /// <summary>
        /// <para>Fullname: VariantdvEXT</para>
        /// </summary>
        [GLEntry("VariantdvEXT", Category = "EXT")]
        public static GLDelegate.Variantdv _Variantdv = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Variantdv.</para>
        /// <para>Fullname: VariantdvEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void Variantdv(uint id, double[] addr)
        {
            if (gl._Variantdv != null) gl._Variantdv(id, addr); else { }
        }
        /// <summary>
        /// <para>Fullname: VariantfvEXT</para>
        /// </summary>
        [GLEntry("VariantfvEXT", Category = "EXT")]
        public static GLDelegate.Variantfv _Variantfv = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Variantfv.</para>
        /// <para>Fullname: VariantfvEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void Variantfv(uint id, float[] addr)
        {
            if (gl._Variantfv != null) gl._Variantfv(id, addr); else { }
        }
        /// <summary>
        /// <para>Fullname: VariantivEXT</para>
        /// </summary>
        [GLEntry("VariantivEXT", Category = "EXT")]
        public static GLDelegate.Variantiv _Variantiv = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Variantiv.</para>
        /// <para>Fullname: VariantivEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void Variantiv(uint id, int[] addr)
        {
            if (gl._Variantiv != null) gl._Variantiv(id, addr); else { }
        }
        /// <summary>
        /// <para>Fullname: VariantPointerEXT</para>
        /// </summary>
        [GLEntry("VariantPointerEXT", Category = "EXT")]
        public static GLDelegate.VariantPointer _VariantPointer = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VariantPointer.</para>
        /// <para>Fullname: VariantPointerEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void VariantPointer(uint id, int type, uint stride, IntPtr addr)
        {
            if (gl._VariantPointer != null) gl._VariantPointer(id, type, stride, addr); else { }
        }
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VariantPointer.</para>
        /// <para>Fullname: VariantPointerEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void VariantPointer(uint id, int type, uint stride, Array addr)
        {
            GCHandle h = GCHandle.Alloc(addr, GCHandleType.Pinned);
            try { if (gl._VariantPointer != null) gl._VariantPointer(id, type, stride, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: VariantsvEXT</para>
        /// </summary>
        [GLEntry("VariantsvEXT", Category = "EXT")]
        public static GLDelegate.Variantsv _Variantsv = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Variantsv.</para>
        /// <para>Fullname: VariantsvEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void Variantsv(uint id, short[] addr)
        {
            if (gl._Variantsv != null) gl._Variantsv(id, addr); else { }
        }
        /// <summary>
        /// <para>Fullname: VariantubvEXT</para>
        /// </summary>
        [GLEntry("VariantubvEXT", Category = "EXT")]
        public static GLDelegate.Variantubv _Variantubv = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Variantubv.</para>
        /// <para>Fullname: VariantubvEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void Variantubv(uint id, byte[] addr)
        {
            if (gl._Variantubv != null) gl._Variantubv(id, addr); else { }
        }
        /// <summary>
        /// <para>Fullname: VariantuivEXT</para>
        /// </summary>
        [GLEntry("VariantuivEXT", Category = "EXT")]
        public static GLDelegate.Variantuiv _Variantuiv = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Variantuiv.</para>
        /// <para>Fullname: VariantuivEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void Variantuiv(uint id, uint[] addr)
        {
            if (gl._Variantuiv != null) gl._Variantuiv(id, addr); else { }
        }
        /// <summary>
        /// <para>Fullname: VariantusvEXT</para>
        /// </summary>
        [GLEntry("VariantusvEXT", Category = "EXT")]
        public static GLDelegate.Variantusv _Variantusv = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Variantusv.</para>
        /// <para>Fullname: VariantusvEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void Variantusv(uint id, ushort[] addr)
        {
            if (gl._Variantusv != null) gl._Variantusv(id, addr); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexArrayVertexAttribLOffsetEXT</para>
        /// </summary>
        [GLEntry("VertexArrayVertexAttribLOffsetEXT", Category = "EXT")]
        public static GLDelegate.VertexArrayVertexAttribLOffset _VertexArrayVertexAttribLOffset = null;
        /// <summary>
        /// <para>This extension provides OpenGL shading language support for vertex shader inputs with 64-bit floating-point components and OpenGL API support for specifying the value of those inputs using vertex array or immediate mode entry points.  This builds on the support for general-purpose support for 64-bit floating-point values in the ARB_gpu_shader_fp64 extension. This extension provides a new class of vertex attribute functions, beginning with "VertexAttribL" ("L" for "long"), that can be used to specify attributes with 64-bit floating-point components.  This extension provides no automatic type conversion between attribute and shader variables; single-precision attributes are not automatically converted to double-precision or vice versa.  For shader variables with 64-bit component types, the "VertexAttribL" functions must be used to specify attribute values.  For other shader variables, the "VertexAttribL" functions must not be used.  If a vertex attribute is specified using the wrong attr...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexArrayVertexAttribLOffset.</para>
        /// <para>Fullname: VertexArrayVertexAttribLOffsetEXT</para>
        /// <para>Extensions: EXT_vertex_attrib_64bit</para>
        /// </summary>
        public static void VertexArrayVertexAttribLOffset(uint vaobj, uint buffer, uint index, int size, int type, int stride, int offset)
        {
            if (gl._VertexArrayVertexAttribLOffset != null) gl._VertexArrayVertexAttribLOffset(vaobj, buffer, index, size, type, stride, offset); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexPointerEXT</para>
        /// </summary>
        [GLEntry("VertexPointerEXT", Category = "EXT")]
        public static GLDelegate.VertexPointerEXT _VertexPointerEXT = null;
        /// <summary>
        /// <para>This extension adds the ability to specify multiple geometric primitives with very few subroutine calls.  Instead of calling an OpenGL procedure to pass each individual vertex, normal, or color, separate arrays of vertexes, normals, and colors are prespecified, and are used to define a sequence of primitives (all of the same type) when a single call is made to DrawArraysEXT.  A stride mechanism is provided so that an application can choose to keep all vertex data staggered in a single array, or sparsely in separate arrays.  Single-array storage may optimize performance on some implementations. This extension also supports the rendering of individual array elements, each specified as an index into the enabled arrays. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexPointerEXT.</para>
        /// <para>Fullname: VertexPointerEXT</para>
        /// <para>Extensions: EXT_vertex_array</para>
        /// </summary>
        public static void VertexPointerEXT(int size, int type, int stride, int count, IntPtr pointer)
        {
            if (gl._VertexPointerEXT != null) gl._VertexPointerEXT(size, type, stride, count, pointer); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexWeightfEXT</para>
        /// </summary>
        [GLEntry("VertexWeightfEXT", Category = "EXT")]
        public static GLDelegate.VertexWeightf _VertexWeightf = null;
        /// <summary>
        /// <para>The intent of this extension is to provide a means for blending geometry based on two slightly differing modelview matrices. The blending is based on a vertex weighting that can change on a per-vertex basis.  This provides a primitive form of skinning. A second modelview matrix transform is introduced.  When vertex weighting is enabled, the incoming vertex object coordinates are transformed by both the primary and secondary modelview matrices; likewise, the incoming normal coordinates are transformed by the inverses of both the primary and secondary modelview matrices. The resulting two position coordinates and two normal coordinates are blended based on the per-vertex vertex weight and then combined by addition.  The transformed, weighted, and combined vertex position and normal are then used by OpenGL as the eye-space position and normal for lighting, texture coordinate, generation, clipping, and further vertex transformation. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexWeightf.</para>
        /// <para>Fullname: VertexWeightfEXT</para>
        /// <para>Extensions: EXT_vertex_weighting</para>
        /// </summary>
        public static void VertexWeightf(float weight)
        {
            if (gl._VertexWeightf != null) gl._VertexWeightf(weight); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexWeightfvEXT</para>
        /// </summary>
        [GLEntry("VertexWeightfvEXT", Category = "EXT")]
        public static GLDelegate.VertexWeightfv _VertexWeightfv = null;
        /// <summary>
        /// <para>The intent of this extension is to provide a means for blending geometry based on two slightly differing modelview matrices. The blending is based on a vertex weighting that can change on a per-vertex basis.  This provides a primitive form of skinning. A second modelview matrix transform is introduced.  When vertex weighting is enabled, the incoming vertex object coordinates are transformed by both the primary and secondary modelview matrices; likewise, the incoming normal coordinates are transformed by the inverses of both the primary and secondary modelview matrices. The resulting two position coordinates and two normal coordinates are blended based on the per-vertex vertex weight and then combined by addition.  The transformed, weighted, and combined vertex position and normal are then used by OpenGL as the eye-space position and normal for lighting, texture coordinate, generation, clipping, and further vertex transformation. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexWeightfv.</para>
        /// <para>Fullname: VertexWeightfvEXT</para>
        /// <para>Extensions: EXT_vertex_weighting</para>
        /// </summary>
        public static void VertexWeightfv(float[] weight)
        {
            if (gl._VertexWeightfv != null) gl._VertexWeightfv(weight); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexWeightfvEXT</para>
        /// </summary>
        [GLEntry("VertexWeightfvEXT", Category = "EXT")]
        public static GLDelegate.VertexWeightfv_float _VertexWeightfv_float = null;
        /// <summary>
        /// <para>The intent of this extension is to provide a means for blending geometry based on two slightly differing modelview matrices. The blending is based on a vertex weighting that can change on a per-vertex basis.  This provides a primitive form of skinning. A second modelview matrix transform is introduced.  When vertex weighting is enabled, the incoming vertex object coordinates are transformed by both the primary and secondary modelview matrices; likewise, the incoming normal coordinates are transformed by the inverses of both the primary and secondary modelview matrices. The resulting two position coordinates and two normal coordinates are blended based on the per-vertex vertex weight and then combined by addition.  The transformed, weighted, and combined vertex position and normal are then used by OpenGL as the eye-space position and normal for lighting, texture coordinate, generation, clipping, and further vertex transformation. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexWeightfv_float.</para>
        /// <para>Fullname: VertexWeightfvEXT</para>
        /// <para>Extensions: EXT_vertex_weighting</para>
        /// </summary>
        public static void VertexWeightfv(ref float weight)
        {
            if (gl._VertexWeightfv_float != null) gl._VertexWeightfv_float(ref weight); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexWeightPointerEXT</para>
        /// </summary>
        [GLEntry("VertexWeightPointerEXT", Category = "EXT")]
        public static GLDelegate.VertexWeightPointer _VertexWeightPointer = null;
        /// <summary>
        /// <para>The intent of this extension is to provide a means for blending geometry based on two slightly differing modelview matrices. The blending is based on a vertex weighting that can change on a per-vertex basis.  This provides a primitive form of skinning. A second modelview matrix transform is introduced.  When vertex weighting is enabled, the incoming vertex object coordinates are transformed by both the primary and secondary modelview matrices; likewise, the incoming normal coordinates are transformed by the inverses of both the primary and secondary modelview matrices. The resulting two position coordinates and two normal coordinates are blended based on the per-vertex vertex weight and then combined by addition.  The transformed, weighted, and combined vertex position and normal are then used by OpenGL as the eye-space position and normal for lighting, texture coordinate, generation, clipping, and further vertex transformation. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexWeightPointer.</para>
        /// <para>Fullname: VertexWeightPointerEXT</para>
        /// <para>Extensions: EXT_vertex_weighting</para>
        /// </summary>
        public static void VertexWeightPointer(int size, int type, int stride, IntPtr pointer)
        {
            if (gl._VertexWeightPointer != null) gl._VertexWeightPointer(size, type, stride, pointer); else { }
        }
        /// <summary>
        /// <para>The intent of this extension is to provide a means for blending geometry based on two slightly differing modelview matrices. The blending is based on a vertex weighting that can change on a per-vertex basis.  This provides a primitive form of skinning. A second modelview matrix transform is introduced.  When vertex weighting is enabled, the incoming vertex object coordinates are transformed by both the primary and secondary modelview matrices; likewise, the incoming normal coordinates are transformed by the inverses of both the primary and secondary modelview matrices. The resulting two position coordinates and two normal coordinates are blended based on the per-vertex vertex weight and then combined by addition.  The transformed, weighted, and combined vertex position and normal are then used by OpenGL as the eye-space position and normal for lighting, texture coordinate, generation, clipping, and further vertex transformation. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexWeightPointer.</para>
        /// <para>Fullname: VertexWeightPointerEXT</para>
        /// <para>Extensions: EXT_vertex_weighting</para>
        /// </summary>
        public static void VertexWeightPointer(int size, int type, int stride, Array pointer)
        {
            GCHandle h = GCHandle.Alloc(pointer, GCHandleType.Pinned);
            try { if (gl._VertexWeightPointer != null) gl._VertexWeightPointer(size, type, stride, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: WriteMaskEXT</para>
        /// </summary>
        [GLEntry("WriteMaskEXT", Category = "EXT")]
        public static GLDelegate.WriteMask _WriteMask = null;
        /// <summary>
        /// <para>EXT_vertex_shader adds a flexible way to change the per-vertex processing in the GL pipeline. It provides a method to replace the fixed vertex/normal transform and lighting with a user specified means of generating processed vertices, texture coordinates, color, and secondary color, along with a primitive's associated state. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WriteMask.</para>
        /// <para>Fullname: WriteMaskEXT</para>
        /// <para>Extensions: EXT_vertex_shader</para>
        /// </summary>
        public static void WriteMask(uint res, uint input, int outX, int outY, int outZ, int outW)
        {
            if (gl._WriteMask != null) gl._WriteMask(res, input, outX, outY, outZ, outW); else { }
        }
        /// <summary>
        /// <para>Fullname: DetailTexFuncSGIS</para>
        /// </summary>
        [GLEntry("DetailTexFuncSGIS", Category = "SGIS")]
        public static GLDelegate.DetailTexFunc _DetailTexFunc = null;
        /// <summary>
        /// <para>This extension introduces texture magnification filters that blend between the level 0 image and a separately defined "detail" image. The detail image represents the characteristics of the high frequency subband image above the band-limited level 0 image.  The detail image is typically a rectangular portion of the subband image which is modified so that it can be repeated without discontinuities along its edges. Detail blending can be enabled for all color channels, for the alpha channel only, or for the red, green, and blue channels only.  It is available only for 2D textures. WARNING - Silicon Graphics has filed for patent protection for some </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DetailTexFunc.</para>
        /// <para>Fullname: DetailTexFuncSGIS</para>
        /// <para>Extensions: SGIS_detail_texture</para>
        /// </summary>
        public static void DetailTexFunc(int target, int n, float[] points)
        {
            if (gl._DetailTexFunc != null) gl._DetailTexFunc(target, n, points); else { }
        }
        /// <summary>
        /// <para>Fullname: FogFuncSGIS</para>
        /// </summary>
        [GLEntry("FogFuncSGIS", Category = "SGIS")]
        public static GLDelegate.FogFunc _FogFunc = null;
        /// <summary>
        /// <para>This extension allows to define application-specific fog blend-factor function.  Function is defined by the set of the "control" points and should be monotonic. Each control point represented as a pair of the eye-space distance value and corresponding value of the fog blending factor. The minimum number of control points is one. The maximum number is implementation dependent.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FogFunc.</para>
        /// <para>Fullname: FogFuncSGIS</para>
        /// <para>Extensions: SGIS_fog_function</para>
        /// </summary>
        public static void FogFunc(int n, float[] points)
        {
            if (gl._FogFunc != null) gl._FogFunc(n, points); else { }
        }
        /// <summary>
        /// <para>Fullname: GetDetailTexFuncSGIS</para>
        /// </summary>
        [GLEntry("GetDetailTexFuncSGIS", Category = "SGIS")]
        public static GLDelegate.GetDetailTexFunc _GetDetailTexFunc = null;
        /// <summary>
        /// <para>This extension introduces texture magnification filters that blend between the level 0 image and a separately defined "detail" image. The detail image represents the characteristics of the high frequency subband image above the band-limited level 0 image.  The detail image is typically a rectangular portion of the subband image which is modified so that it can be repeated without discontinuities along its edges. Detail blending can be enabled for all color channels, for the alpha channel only, or for the red, green, and blue channels only.  It is available only for 2D textures. WARNING - Silicon Graphics has filed for patent protection for some </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetDetailTexFunc.</para>
        /// <para>Fullname: GetDetailTexFuncSGIS</para>
        /// <para>Extensions: SGIS_detail_texture</para>
        /// </summary>
        public static void GetDetailTexFunc(int target, float[] points)
        {
            if (gl._GetDetailTexFunc != null) gl._GetDetailTexFunc(target, points); else { }
        }
        /// <summary>
        /// <para>Fullname: GetFogFuncSGIS</para>
        /// </summary>
        [GLEntry("GetFogFuncSGIS", Category = "SGIS")]
        public static GLDelegate.GetFogFunc _GetFogFunc = null;
        /// <summary>
        /// <para>This extension allows to define application-specific fog blend-factor function.  Function is defined by the set of the "control" points and should be monotonic. Each control point represented as a pair of the eye-space distance value and corresponding value of the fog blending factor. The minimum number of control points is one. The maximum number is implementation dependent.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetFogFunc.</para>
        /// <para>Fullname: GetFogFuncSGIS</para>
        /// <para>Extensions: SGIS_fog_function</para>
        /// </summary>
        public static void GetFogFunc(float[] points)
        {
            if (gl._GetFogFunc != null) gl._GetFogFunc(points); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPixelTexGenParameterfvSGIS</para>
        /// </summary>
        [GLEntry("GetPixelTexGenParameterfvSGIS", Category = "SGIS")]
        public static GLDelegate.GetPixelTexGenParameterfv _GetPixelTexGenParameterfv = null;
        /// <summary>
        /// <para>The geometry rasterization and pixel pipeline "convert to fragment" stages each produce fragments.  The fragments are processed by a unified per fragment pipeline that begins with the application of the texture to the fragment color.  Because the pixel pipeline shares the per fragment processing with the geometry pipeline, the fragments produced by the pixel pipeline must have the same fields as the ones produced by the geometry pipeline.  When pixel groups are being converted to fragments, the parts of the fragment that aren't derived from the pixel groups are taken from the associated values in the current raster position. A fragment consists of x and y window coordinates and their associated color value, depth value, and texture coordinates. In the 1.1 OpenGL specification, when the pixel group is RGBA the fragment color is always derived from the pixel group, and the depth value and texture coordinates always come from the raster position. This extension provides a way to specify h...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPixelTexGenParameterfv.</para>
        /// <para>Fullname: GetPixelTexGenParameterfvSGIS</para>
        /// <para>Extensions: SGIS_pixel_texture</para>
        /// </summary>
        public static void GetPixelTexGenParameterfv(int pname, float[] param)
        {
            if (gl._GetPixelTexGenParameterfv != null) gl._GetPixelTexGenParameterfv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPixelTexGenParameterivSGIS</para>
        /// </summary>
        [GLEntry("GetPixelTexGenParameterivSGIS", Category = "SGIS")]
        public static GLDelegate.GetPixelTexGenParameteriv _GetPixelTexGenParameteriv = null;
        /// <summary>
        /// <para>The geometry rasterization and pixel pipeline "convert to fragment" stages each produce fragments.  The fragments are processed by a unified per fragment pipeline that begins with the application of the texture to the fragment color.  Because the pixel pipeline shares the per fragment processing with the geometry pipeline, the fragments produced by the pixel pipeline must have the same fields as the ones produced by the geometry pipeline.  When pixel groups are being converted to fragments, the parts of the fragment that aren't derived from the pixel groups are taken from the associated values in the current raster position. A fragment consists of x and y window coordinates and their associated color value, depth value, and texture coordinates. In the 1.1 OpenGL specification, when the pixel group is RGBA the fragment color is always derived from the pixel group, and the depth value and texture coordinates always come from the raster position. This extension provides a way to specify h...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPixelTexGenParameteriv.</para>
        /// <para>Fullname: GetPixelTexGenParameterivSGIS</para>
        /// <para>Extensions: SGIS_pixel_texture</para>
        /// </summary>
        public static void GetPixelTexGenParameteriv(int pname, int[] param)
        {
            if (gl._GetPixelTexGenParameteriv != null) gl._GetPixelTexGenParameteriv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetSharpenTexFuncSGIS</para>
        /// </summary>
        [GLEntry("GetSharpenTexFuncSGIS", Category = "SGIS")]
        public static GLDelegate.GetSharpenTexFunc _GetSharpenTexFunc = null;
        /// <summary>
        /// <para>This extension introduces texture magnification filters that sharpen the resulting image by extrapolating from the level 1 image to the level 0 image.  Sharpening can be enabled for all color channels, for the alpha channel only, or for the red, green, and blue channels only. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetSharpenTexFunc.</para>
        /// <para>Fullname: GetSharpenTexFuncSGIS</para>
        /// <para>Extensions: SGIS_sharpen_texture</para>
        /// </summary>
        public static void GetSharpenTexFunc(int target, float[] points)
        {
            if (gl._GetSharpenTexFunc != null) gl._GetSharpenTexFunc(target, points); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTexFilterFuncSGIS</para>
        /// </summary>
        [GLEntry("GetTexFilterFuncSGIS", Category = "SGIS")]
        public static GLDelegate.GetTexFilterFunc _GetTexFilterFunc = null;
        /// <summary>
        /// <para>This extension allows 1D and 2D textures to be filtered using an application-defined, four sample per dimension filter.  (In addition to the NEAREST and LINEAR filters defined in the original GL Specification.) Such filtering results in higher image quality.  It is defined only for non-mipmapped filters.  The filter that is specified must be symmetric and separable (in the 2D case). </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTexFilterFunc.</para>
        /// <para>Fullname: GetTexFilterFuncSGIS</para>
        /// <para>Extensions: SGIS_texture_filter4</para>
        /// </summary>
        public static void GetTexFilterFunc(int target, int filter, float[] weights)
        {
            if (gl._GetTexFilterFunc != null) gl._GetTexFilterFunc(target, filter, weights); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelTexGenParameterfSGIS</para>
        /// </summary>
        [GLEntry("PixelTexGenParameterfSGIS", Category = "SGIS")]
        public static GLDelegate.PixelTexGenParameterf _PixelTexGenParameterf = null;
        /// <summary>
        /// <para>The geometry rasterization and pixel pipeline "convert to fragment" stages each produce fragments.  The fragments are processed by a unified per fragment pipeline that begins with the application of the texture to the fragment color.  Because the pixel pipeline shares the per fragment processing with the geometry pipeline, the fragments produced by the pixel pipeline must have the same fields as the ones produced by the geometry pipeline.  When pixel groups are being converted to fragments, the parts of the fragment that aren't derived from the pixel groups are taken from the associated values in the current raster position. A fragment consists of x and y window coordinates and their associated color value, depth value, and texture coordinates. In the 1.1 OpenGL specification, when the pixel group is RGBA the fragment color is always derived from the pixel group, and the depth value and texture coordinates always come from the raster position. This extension provides a way to specify h...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelTexGenParameterf.</para>
        /// <para>Fullname: PixelTexGenParameterfSGIS</para>
        /// <para>Extensions: SGIS_pixel_texture</para>
        /// </summary>
        public static void PixelTexGenParameterf(int pname, float param)
        {
            if (gl._PixelTexGenParameterf != null) gl._PixelTexGenParameterf(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelTexGenParameterfvSGIS</para>
        /// </summary>
        [GLEntry("PixelTexGenParameterfvSGIS", Category = "SGIS")]
        public static GLDelegate.PixelTexGenParameterfv _PixelTexGenParameterfv = null;
        /// <summary>
        /// <para>The geometry rasterization and pixel pipeline "convert to fragment" stages each produce fragments.  The fragments are processed by a unified per fragment pipeline that begins with the application of the texture to the fragment color.  Because the pixel pipeline shares the per fragment processing with the geometry pipeline, the fragments produced by the pixel pipeline must have the same fields as the ones produced by the geometry pipeline.  When pixel groups are being converted to fragments, the parts of the fragment that aren't derived from the pixel groups are taken from the associated values in the current raster position. A fragment consists of x and y window coordinates and their associated color value, depth value, and texture coordinates. In the 1.1 OpenGL specification, when the pixel group is RGBA the fragment color is always derived from the pixel group, and the depth value and texture coordinates always come from the raster position. This extension provides a way to specify h...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelTexGenParameterfv.</para>
        /// <para>Fullname: PixelTexGenParameterfvSGIS</para>
        /// <para>Extensions: SGIS_pixel_texture</para>
        /// </summary>
        public static void PixelTexGenParameterfv(int pname, float[] param)
        {
            if (gl._PixelTexGenParameterfv != null) gl._PixelTexGenParameterfv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelTexGenParameteriSGIS</para>
        /// </summary>
        [GLEntry("PixelTexGenParameteriSGIS", Category = "SGIS")]
        public static GLDelegate.PixelTexGenParameteri _PixelTexGenParameteri = null;
        /// <summary>
        /// <para>The geometry rasterization and pixel pipeline "convert to fragment" stages each produce fragments.  The fragments are processed by a unified per fragment pipeline that begins with the application of the texture to the fragment color.  Because the pixel pipeline shares the per fragment processing with the geometry pipeline, the fragments produced by the pixel pipeline must have the same fields as the ones produced by the geometry pipeline.  When pixel groups are being converted to fragments, the parts of the fragment that aren't derived from the pixel groups are taken from the associated values in the current raster position. A fragment consists of x and y window coordinates and their associated color value, depth value, and texture coordinates. In the 1.1 OpenGL specification, when the pixel group is RGBA the fragment color is always derived from the pixel group, and the depth value and texture coordinates always come from the raster position. This extension provides a way to specify h...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelTexGenParameteri.</para>
        /// <para>Fullname: PixelTexGenParameteriSGIS</para>
        /// <para>Extensions: SGIS_pixel_texture</para>
        /// </summary>
        public static void PixelTexGenParameteri(int pname, int param)
        {
            if (gl._PixelTexGenParameteri != null) gl._PixelTexGenParameteri(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelTexGenParameterivSGIS</para>
        /// </summary>
        [GLEntry("PixelTexGenParameterivSGIS", Category = "SGIS")]
        public static GLDelegate.PixelTexGenParameteriv _PixelTexGenParameteriv = null;
        /// <summary>
        /// <para>The geometry rasterization and pixel pipeline "convert to fragment" stages each produce fragments.  The fragments are processed by a unified per fragment pipeline that begins with the application of the texture to the fragment color.  Because the pixel pipeline shares the per fragment processing with the geometry pipeline, the fragments produced by the pixel pipeline must have the same fields as the ones produced by the geometry pipeline.  When pixel groups are being converted to fragments, the parts of the fragment that aren't derived from the pixel groups are taken from the associated values in the current raster position. A fragment consists of x and y window coordinates and their associated color value, depth value, and texture coordinates. In the 1.1 OpenGL specification, when the pixel group is RGBA the fragment color is always derived from the pixel group, and the depth value and texture coordinates always come from the raster position. This extension provides a way to specify h...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelTexGenParameteriv.</para>
        /// <para>Fullname: PixelTexGenParameterivSGIS</para>
        /// <para>Extensions: SGIS_pixel_texture</para>
        /// </summary>
        public static void PixelTexGenParameteriv(int pname, int[] param)
        {
            if (gl._PixelTexGenParameteriv != null) gl._PixelTexGenParameteriv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: SharpenTexFuncSGIS</para>
        /// </summary>
        [GLEntry("SharpenTexFuncSGIS", Category = "SGIS")]
        public static GLDelegate.SharpenTexFunc _SharpenTexFunc = null;
        /// <summary>
        /// <para>This extension introduces texture magnification filters that sharpen the resulting image by extrapolating from the level 1 image to the level 0 image.  Sharpening can be enabled for all color channels, for the alpha channel only, or for the red, green, and blue channels only. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SharpenTexFunc.</para>
        /// <para>Fullname: SharpenTexFuncSGIS</para>
        /// <para>Extensions: SGIS_sharpen_texture</para>
        /// </summary>
        public static void SharpenTexFunc(int target, int n, float[] points)
        {
            if (gl._SharpenTexFunc != null) gl._SharpenTexFunc(target, n, points); else { }
        }
        /// <summary>
        /// <para>Fullname: TexFilterFuncSGIS</para>
        /// </summary>
        [GLEntry("TexFilterFuncSGIS", Category = "SGIS")]
        public static GLDelegate.TexFilterFunc _TexFilterFunc = null;
        /// <summary>
        /// <para>This extension allows 1D and 2D textures to be filtered using an application-defined, four sample per dimension filter.  (In addition to the NEAREST and LINEAR filters defined in the original GL Specification.) Such filtering results in higher image quality.  It is defined only for non-mipmapped filters.  The filter that is specified must be symmetric and separable (in the 2D case). </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexFilterFunc.</para>
        /// <para>Fullname: TexFilterFuncSGIS</para>
        /// <para>Extensions: SGIS_texture_filter4</para>
        /// </summary>
        public static void TexFilterFunc(int target, int filter, int n, float[] weights)
        {
            if (gl._TexFilterFunc != null) gl._TexFilterFunc(target, filter, n, weights); else { }
        }
        /// <summary>
        /// <para>Fullname: TexFilterFuncSGIS</para>
        /// </summary>
        [GLEntry("TexFilterFuncSGIS", Category = "SGIS")]
        public static GLDelegate.TexFilterFunc_float _TexFilterFunc_float = null;
        /// <summary>
        /// <para>This extension allows 1D and 2D textures to be filtered using an application-defined, four sample per dimension filter.  (In addition to the NEAREST and LINEAR filters defined in the original GL Specification.) Such filtering results in higher image quality.  It is defined only for non-mipmapped filters.  The filter that is specified must be symmetric and separable (in the 2D case). </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexFilterFunc_float.</para>
        /// <para>Fullname: TexFilterFuncSGIS</para>
        /// <para>Extensions: SGIS_texture_filter4</para>
        /// </summary>
        public static void TexFilterFunc(int target, int filter, int n, ref float weights)
        {
            if (gl._TexFilterFunc_float != null) gl._TexFilterFunc_float(target, filter, n, ref weights); else { }
        }
        /// <summary>
        /// <para>Fullname: TexImage4DSGIS</para>
        /// </summary>
        [GLEntry("TexImage4DSGIS", Category = "SGIS")]
        public static GLDelegate.TexImage4D _TexImage4D = null;
        /// <summary>
        /// <para>This extension defines 4-dimensional texture mapping.  If EXT_subtexture is supported, this extension also defines a mechanism to redefine a portion of an existing 4-dimensional texture image.  Because EXT_texture3D is required, this extension utilizes the 3-dimensional image support defined in by EXT_texture3D as a base for 4-dimensional image manipulation.  The 4th dimension has an abstract, rather than physical, reference and will be called "extent", since the definition of extent is "that which specifies the range or magnitude of an area or volume." Four-dimensional texture mapping is more constrained than its one, two, and three-dimensional counterparts.  Mipmapping is not supported, so only the level-zero 4-dimensional texture image can be defined.  Cubic filtering is not supported, so the border width must be either zero or one. Four-dimensional textures are used primarily as color lookup tables for color conversion. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexImage4D.</para>
        /// <para>Fullname: TexImage4DSGIS</para>
        /// <para>Extensions: SGIS_texture4D</para>
        /// </summary>
        public static void TexImage4D(int target, int level, int internalformat, int width, int height, int depth, int size4d, int border, int format, int type, IntPtr pixels)
        {
            if (gl._TexImage4D != null) gl._TexImage4D(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>This extension defines 4-dimensional texture mapping.  If EXT_subtexture is supported, this extension also defines a mechanism to redefine a portion of an existing 4-dimensional texture image.  Because EXT_texture3D is required, this extension utilizes the 3-dimensional image support defined in by EXT_texture3D as a base for 4-dimensional image manipulation.  The 4th dimension has an abstract, rather than physical, reference and will be called "extent", since the definition of extent is "that which specifies the range or magnitude of an area or volume." Four-dimensional texture mapping is more constrained than its one, two, and three-dimensional counterparts.  Mipmapping is not supported, so only the level-zero 4-dimensional texture image can be defined.  Cubic filtering is not supported, so the border width must be either zero or one. Four-dimensional textures are used primarily as color lookup tables for color conversion. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexImage4D.</para>
        /// <para>Fullname: TexImage4DSGIS</para>
        /// <para>Extensions: SGIS_texture4D</para>
        /// </summary>
        public static void TexImage4D(int target, int level, int internalformat, int width, int height, int depth, int size4d, int border, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._TexImage4D != null) gl._TexImage4D(target, level, internalformat, width, height, depth, size4d, border, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: TexSubImage4DSGIS</para>
        /// </summary>
        [GLEntry("TexSubImage4DSGIS", Category = "SGIS")]
        public static GLDelegate.TexSubImage4D _TexSubImage4D = null;
        /// <summary>
        /// <para>This extension defines 4-dimensional texture mapping.  If EXT_subtexture is supported, this extension also defines a mechanism to redefine a portion of an existing 4-dimensional texture image.  Because EXT_texture3D is required, this extension utilizes the 3-dimensional image support defined in by EXT_texture3D as a base for 4-dimensional image manipulation.  The 4th dimension has an abstract, rather than physical, reference and will be called "extent", since the definition of extent is "that which specifies the range or magnitude of an area or volume." Four-dimensional texture mapping is more constrained than its one, two, and three-dimensional counterparts.  Mipmapping is not supported, so only the level-zero 4-dimensional texture image can be defined.  Cubic filtering is not supported, so the border width must be either zero or one. Four-dimensional textures are used primarily as color lookup tables for color conversion. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexSubImage4D.</para>
        /// <para>Fullname: TexSubImage4DSGIS</para>
        /// <para>Extensions: SGIS_texture4D</para>
        /// </summary>
        public static void TexSubImage4D(int target, int level, int xoffset, int yoffset, int zoffset, int woffset, int width, int height, int depth, int size4d, int format, int type, IntPtr pixels)
        {
            if (gl._TexSubImage4D != null) gl._TexSubImage4D(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels); else { }
        }
        /// <summary>
        /// <para>This extension defines 4-dimensional texture mapping.  If EXT_subtexture is supported, this extension also defines a mechanism to redefine a portion of an existing 4-dimensional texture image.  Because EXT_texture3D is required, this extension utilizes the 3-dimensional image support defined in by EXT_texture3D as a base for 4-dimensional image manipulation.  The 4th dimension has an abstract, rather than physical, reference and will be called "extent", since the definition of extent is "that which specifies the range or magnitude of an area or volume." Four-dimensional texture mapping is more constrained than its one, two, and three-dimensional counterparts.  Mipmapping is not supported, so only the level-zero 4-dimensional texture image can be defined.  Cubic filtering is not supported, so the border width must be either zero or one. Four-dimensional textures are used primarily as color lookup tables for color conversion. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexSubImage4D.</para>
        /// <para>Fullname: TexSubImage4DSGIS</para>
        /// <para>Extensions: SGIS_texture4D</para>
        /// </summary>
        public static void TexSubImage4D(int target, int level, int xoffset, int yoffset, int zoffset, int woffset, int width, int height, int depth, int size4d, int format, int type, Array pixels)
        {
            GCHandle h = GCHandle.Alloc(pixels, GCHandleType.Pinned);
            try { if (gl._TexSubImage4D != null) gl._TexSubImage4D(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, h.AddrOfPinnedObject()); }
            finally { h.Free(); }
        }
        /// <summary>
        /// <para>Fullname: TextureColorMaskSGIS</para>
        /// </summary>
        [GLEntry("TextureColorMaskSGIS", Category = "SGIS")]
        public static GLDelegate.TextureColorMask _TextureColorMask = null;
        /// <summary>
        /// <para>This extension implements the same functionality for texture updates that glColorMask implements for color buffer updates. Masks for updating textures with indexed internal formats (the analog for glIndexMask) should be supported by a separate extension. The extension allows an application to update a subset of components in an existing texture.	The masks are applied after all pixel transfer operations have been performed, immediately prior to writing the texel value into texture memory.  They apply to all texture updates. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureColorMask.</para>
        /// <para>Fullname: TextureColorMaskSGIS</para>
        /// <para>Extensions: SGIS_texture_color_mask</para>
        /// </summary>
        public static void TextureColorMask(bool red, bool green, bool blue, bool alpha)
        {
            if (gl._TextureColorMask != null) gl._TextureColorMask(red, green, blue, alpha); else { }
        }
        /// <summary>
        /// <para>Fullname: AsyncMarkerSGIX</para>
        /// </summary>
        [GLEntry("AsyncMarkerSGIX", Category = "SGIX")]
        public static GLDelegate.AsyncMarker _AsyncMarker = null;
        /// <summary>
        /// <para>This extension provides a framework for asynchronous OpenGL commands.  It also provides commands allowing a program to wait for the completion of asynchronous commands.  Asynchronous commands have two properties:  1) Asynchronous commands are non-blocking.  For example, an asynchronous ReadPixels command returns control to the program immediately rather than blocking until the command completes. This property allows the program to issue other OpenGL commands in parallel with the execution of commands that normally block.  2) Asynchronous commands may complete out-of-order with respect to other OpenGL commands.  For example, an asynchronous TexImage command may complete after subsequent OpenGL commands issued by the program rather than maintaining the normal serial order of the OpenGL command stream.  This property allows the graphics accelerator to execute asynchronous commands in parallel with the normal command stream, for instance using a secondary path to transfer data from or to t...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _AsyncMarker.</para>
        /// <para>Fullname: AsyncMarkerSGIX</para>
        /// <para>Extensions: SGIX_async</para>
        /// </summary>
        public static void AsyncMarker(uint marker)
        {
            if (gl._AsyncMarker != null) gl._AsyncMarker(marker); else { }
        }
        /// <summary>
        /// <para>Fullname: DeformSGIX</para>
        /// </summary>
        [GLEntry("DeformSGIX", Category = "SGIX")]
        public static GLDelegate.Deform _Deform = null;
        /// <summary>Documentation not found...</summary>
        public static void Deform(int mask)
        {
            if (gl._Deform != null) gl._Deform(mask); else { }
        }
        /// <summary>
        /// <para>Fullname: DeformationMap3dSGIX</para>
        /// </summary>
        [GLEntry("DeformationMap3dSGIX", Category = "SGIX")]
        public static GLDelegate.DeformationMap3d _DeformationMap3d = null;
        /// <summary>Documentation not found...</summary>
        public static void DeformationMap3d(int target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double w1, double w2, int wstride, int worder, double[] points)
        {
            if (gl._DeformationMap3d != null) gl._DeformationMap3d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points); else { }
        }
        /// <summary>
        /// <para>Fullname: DeformationMap3fSGIX</para>
        /// </summary>
        [GLEntry("DeformationMap3fSGIX", Category = "SGIX")]
        public static GLDelegate.DeformationMap3f _DeformationMap3f = null;
        /// <summary>Documentation not found...</summary>
        public static void DeformationMap3f(int target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float w1, float w2, int wstride, int worder, float[] points)
        {
            if (gl._DeformationMap3f != null) gl._DeformationMap3f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteAsyncMarkersSGIX</para>
        /// </summary>
        [GLEntry("DeleteAsyncMarkersSGIX", Category = "SGIX")]
        public static GLDelegate.DeleteAsyncMarkers _DeleteAsyncMarkers = null;
        /// <summary>
        /// <para>This extension provides a framework for asynchronous OpenGL commands.  It also provides commands allowing a program to wait for the completion of asynchronous commands.  Asynchronous commands have two properties:  1) Asynchronous commands are non-blocking.  For example, an asynchronous ReadPixels command returns control to the program immediately rather than blocking until the command completes. This property allows the program to issue other OpenGL commands in parallel with the execution of commands that normally block.  2) Asynchronous commands may complete out-of-order with respect to other OpenGL commands.  For example, an asynchronous TexImage command may complete after subsequent OpenGL commands issued by the program rather than maintaining the normal serial order of the OpenGL command stream.  This property allows the graphics accelerator to execute asynchronous commands in parallel with the normal command stream, for instance using a secondary path to transfer data from or to t...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteAsyncMarkers.</para>
        /// <para>Fullname: DeleteAsyncMarkersSGIX</para>
        /// <para>Extensions: SGIX_async</para>
        /// </summary>
        public static void DeleteAsyncMarkers(uint marker, int range)
        {
            if (gl._DeleteAsyncMarkers != null) gl._DeleteAsyncMarkers(marker, range); else { }
        }
        /// <summary>
        /// <para>Fullname: FinishAsyncSGIX</para>
        /// </summary>
        [GLEntry("FinishAsyncSGIX", Category = "SGIX")]
        public static GLDelegate.FinishAsync_uint _FinishAsync_uint = null;
        /// <summary>
        /// <para>This extension provides a framework for asynchronous OpenGL commands.  It also provides commands allowing a program to wait for the completion of asynchronous commands.  Asynchronous commands have two properties:  1) Asynchronous commands are non-blocking.  For example, an asynchronous ReadPixels command returns control to the program immediately rather than blocking until the command completes. This property allows the program to issue other OpenGL commands in parallel with the execution of commands that normally block.  2) Asynchronous commands may complete out-of-order with respect to other OpenGL commands.  For example, an asynchronous TexImage command may complete after subsequent OpenGL commands issued by the program rather than maintaining the normal serial order of the OpenGL command stream.  This property allows the graphics accelerator to execute asynchronous commands in parallel with the normal command stream, for instance using a secondary path to transfer data from or to t...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FinishAsync_uint.</para>
        /// <para>Fullname: FinishAsyncSGIX</para>
        /// <para>Extensions: SGIX_async</para>
        /// </summary>
        public static int FinishAsync(out uint markerp)
        {
            if (gl._FinishAsync_uint != null) return gl._FinishAsync_uint(out markerp);
            else { markerp = new uint(); return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: FinishAsyncSGIX</para>
        /// </summary>
        [GLEntry("FinishAsyncSGIX", Category = "SGIX")]
        public static GLDelegate.FinishAsync _FinishAsync = null;
        /// <summary>
        /// <para>This extension provides a framework for asynchronous OpenGL commands.  It also provides commands allowing a program to wait for the completion of asynchronous commands.  Asynchronous commands have two properties:  1) Asynchronous commands are non-blocking.  For example, an asynchronous ReadPixels command returns control to the program immediately rather than blocking until the command completes. This property allows the program to issue other OpenGL commands in parallel with the execution of commands that normally block.  2) Asynchronous commands may complete out-of-order with respect to other OpenGL commands.  For example, an asynchronous TexImage command may complete after subsequent OpenGL commands issued by the program rather than maintaining the normal serial order of the OpenGL command stream.  This property allows the graphics accelerator to execute asynchronous commands in parallel with the normal command stream, for instance using a secondary path to transfer data from or to t...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FinishAsync.</para>
        /// <para>Fullname: FinishAsyncSGIX</para>
        /// <para>Extensions: SGIX_async</para>
        /// </summary>
        public static int FinishAsync(uint[] markerp)
        {
            if (gl._FinishAsync != null) return gl._FinishAsync(markerp);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: FlushRasterSGIX</para>
        /// </summary>
        [GLEntry("FlushRasterSGIX", Category = "SGIX")]
        public static GLDelegate.FlushRaster _FlushRaster = null;
        /// <summary>
        /// <para>This extensions provides a way to ensure that all raster operations currently in the pipeline will be completed before the next raster operation begins. We define a raster operation as an operation that involves the rasterization stage of the OpenGL pipeline. The implementation is free to decide what consitutes flushing the raster subsystem. The motivation is to allow accurate instrumentation by including this call before stopping rasterization measurements. There are cases where Finish() is used, but a FlushRaster() would suffice, so this extension is deliberately kept independent of the instruments extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FlushRaster.</para>
        /// <para>Fullname: FlushRasterSGIX</para>
        /// <para>Extensions: SGIX_flush_raster</para>
        /// </summary>
        public static void FlushRaster()
        {
            if (gl._FlushRaster != null) gl._FlushRaster(); else { }
        }
        /// <summary>
        /// <para>Fullname: FragmentColorMaterialSGIX</para>
        /// </summary>
        [GLEntry("FragmentColorMaterialSGIX", Category = "SGIX")]
        public static GLDelegate.FragmentColorMaterial _FragmentColorMaterial = null;
        /// <summary>
        /// <para>This extension adds a new lighting stage to the OpenGL pipeline.  This stage occurs during fragment processing after the texture environment has been applied and before fog has been applied.  The extension provides a mechanism for computing 'per-pixel lighting'.  Fragment lighting applies to fragments generated by all primitives including pixel images. This extension doesn't eliminate vertex lighting, but can be used to complement it.  For example, the diffuse contribution can be evaluated at each vertex, and the specular contribution can be evaluated at each fragment with the results being summed together to generate the final result. Ct  Cf |   |-------------------------------+ |   |                               | ----------                            | |        |                            | | TexEnv |                            | |        |                            | ----------                            | |                                 | ----------                           ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FragmentColorMaterial.</para>
        /// <para>Fullname: FragmentColorMaterialSGIX</para>
        /// <para>Extensions: SGIX_fragment_lighting</para>
        /// </summary>
        public static void FragmentColorMaterial(int face, int mode)
        {
            if (gl._FragmentColorMaterial != null) gl._FragmentColorMaterial(face, mode); else { }
        }
        /// <summary>
        /// <para>Fullname: FragmentLightfSGIX</para>
        /// </summary>
        [GLEntry("FragmentLightfSGIX", Category = "SGIX")]
        public static GLDelegate.FragmentLightf _FragmentLightf = null;
        /// <summary>
        /// <para>This extension adds a new lighting stage to the OpenGL pipeline.  This stage occurs during fragment processing after the texture environment has been applied and before fog has been applied.  The extension provides a mechanism for computing 'per-pixel lighting'.  Fragment lighting applies to fragments generated by all primitives including pixel images. This extension doesn't eliminate vertex lighting, but can be used to complement it.  For example, the diffuse contribution can be evaluated at each vertex, and the specular contribution can be evaluated at each fragment with the results being summed together to generate the final result. Ct  Cf |   |-------------------------------+ |   |                               | ----------                            | |        |                            | | TexEnv |                            | |        |                            | ----------                            | |                                 | ----------                           ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FragmentLightf.</para>
        /// <para>Fullname: FragmentLightfSGIX</para>
        /// <para>Extensions: SGIX_fragment_lighting</para>
        /// </summary>
        public static void FragmentLightf(int light, int pname, float param)
        {
            if (gl._FragmentLightf != null) gl._FragmentLightf(light, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: FragmentLightfvSGIX</para>
        /// </summary>
        [GLEntry("FragmentLightfvSGIX", Category = "SGIX")]
        public static GLDelegate.FragmentLightfv _FragmentLightfv = null;
        /// <summary>
        /// <para>This extension adds a new lighting stage to the OpenGL pipeline.  This stage occurs during fragment processing after the texture environment has been applied and before fog has been applied.  The extension provides a mechanism for computing 'per-pixel lighting'.  Fragment lighting applies to fragments generated by all primitives including pixel images. This extension doesn't eliminate vertex lighting, but can be used to complement it.  For example, the diffuse contribution can be evaluated at each vertex, and the specular contribution can be evaluated at each fragment with the results being summed together to generate the final result. Ct  Cf |   |-------------------------------+ |   |                               | ----------                            | |        |                            | | TexEnv |                            | |        |                            | ----------                            | |                                 | ----------                           ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FragmentLightfv.</para>
        /// <para>Fullname: FragmentLightfvSGIX</para>
        /// <para>Extensions: SGIX_fragment_lighting</para>
        /// </summary>
        public static void FragmentLightfv(int light, int pname, float[] param)
        {
            if (gl._FragmentLightfv != null) gl._FragmentLightfv(light, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: FragmentLightiSGIX</para>
        /// </summary>
        [GLEntry("FragmentLightiSGIX", Category = "SGIX")]
        public static GLDelegate.FragmentLighti _FragmentLighti = null;
        /// <summary>
        /// <para>This extension adds a new lighting stage to the OpenGL pipeline.  This stage occurs during fragment processing after the texture environment has been applied and before fog has been applied.  The extension provides a mechanism for computing 'per-pixel lighting'.  Fragment lighting applies to fragments generated by all primitives including pixel images. This extension doesn't eliminate vertex lighting, but can be used to complement it.  For example, the diffuse contribution can be evaluated at each vertex, and the specular contribution can be evaluated at each fragment with the results being summed together to generate the final result. Ct  Cf |   |-------------------------------+ |   |                               | ----------                            | |        |                            | | TexEnv |                            | |        |                            | ----------                            | |                                 | ----------                           ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FragmentLighti.</para>
        /// <para>Fullname: FragmentLightiSGIX</para>
        /// <para>Extensions: SGIX_fragment_lighting</para>
        /// </summary>
        public static void FragmentLighti(int light, int pname, int param)
        {
            if (gl._FragmentLighti != null) gl._FragmentLighti(light, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: FragmentLightivSGIX</para>
        /// </summary>
        [GLEntry("FragmentLightivSGIX", Category = "SGIX")]
        public static GLDelegate.FragmentLightiv _FragmentLightiv = null;
        /// <summary>
        /// <para>This extension adds a new lighting stage to the OpenGL pipeline.  This stage occurs during fragment processing after the texture environment has been applied and before fog has been applied.  The extension provides a mechanism for computing 'per-pixel lighting'.  Fragment lighting applies to fragments generated by all primitives including pixel images. This extension doesn't eliminate vertex lighting, but can be used to complement it.  For example, the diffuse contribution can be evaluated at each vertex, and the specular contribution can be evaluated at each fragment with the results being summed together to generate the final result. Ct  Cf |   |-------------------------------+ |   |                               | ----------                            | |        |                            | | TexEnv |                            | |        |                            | ----------                            | |                                 | ----------                           ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FragmentLightiv.</para>
        /// <para>Fullname: FragmentLightivSGIX</para>
        /// <para>Extensions: SGIX_fragment_lighting</para>
        /// </summary>
        public static void FragmentLightiv(int light, int pname, int[] param)
        {
            if (gl._FragmentLightiv != null) gl._FragmentLightiv(light, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: FragmentLightModelfSGIX</para>
        /// </summary>
        [GLEntry("FragmentLightModelfSGIX", Category = "SGIX")]
        public static GLDelegate.FragmentLightModelf _FragmentLightModelf = null;
        /// <summary>
        /// <para>This extension adds a new lighting stage to the OpenGL pipeline.  This stage occurs during fragment processing after the texture environment has been applied and before fog has been applied.  The extension provides a mechanism for computing 'per-pixel lighting'.  Fragment lighting applies to fragments generated by all primitives including pixel images. This extension doesn't eliminate vertex lighting, but can be used to complement it.  For example, the diffuse contribution can be evaluated at each vertex, and the specular contribution can be evaluated at each fragment with the results being summed together to generate the final result. Ct  Cf |   |-------------------------------+ |   |                               | ----------                            | |        |                            | | TexEnv |                            | |        |                            | ----------                            | |                                 | ----------                           ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FragmentLightModelf.</para>
        /// <para>Fullname: FragmentLightModelfSGIX</para>
        /// <para>Extensions: SGIX_fragment_lighting</para>
        /// </summary>
        public static void FragmentLightModelf(int pname, float param)
        {
            if (gl._FragmentLightModelf != null) gl._FragmentLightModelf(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: FragmentLightModelfvSGIX</para>
        /// </summary>
        [GLEntry("FragmentLightModelfvSGIX", Category = "SGIX")]
        public static GLDelegate.FragmentLightModelfv _FragmentLightModelfv = null;
        /// <summary>
        /// <para>This extension adds a new lighting stage to the OpenGL pipeline.  This stage occurs during fragment processing after the texture environment has been applied and before fog has been applied.  The extension provides a mechanism for computing 'per-pixel lighting'.  Fragment lighting applies to fragments generated by all primitives including pixel images. This extension doesn't eliminate vertex lighting, but can be used to complement it.  For example, the diffuse contribution can be evaluated at each vertex, and the specular contribution can be evaluated at each fragment with the results being summed together to generate the final result. Ct  Cf |   |-------------------------------+ |   |                               | ----------                            | |        |                            | | TexEnv |                            | |        |                            | ----------                            | |                                 | ----------                           ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FragmentLightModelfv.</para>
        /// <para>Fullname: FragmentLightModelfvSGIX</para>
        /// <para>Extensions: SGIX_fragment_lighting</para>
        /// </summary>
        public static void FragmentLightModelfv(int pname, float[] param)
        {
            if (gl._FragmentLightModelfv != null) gl._FragmentLightModelfv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: FragmentLightModeliSGIX</para>
        /// </summary>
        [GLEntry("FragmentLightModeliSGIX", Category = "SGIX")]
        public static GLDelegate.FragmentLightModeli _FragmentLightModeli = null;
        /// <summary>
        /// <para>This extension adds a new lighting stage to the OpenGL pipeline.  This stage occurs during fragment processing after the texture environment has been applied and before fog has been applied.  The extension provides a mechanism for computing 'per-pixel lighting'.  Fragment lighting applies to fragments generated by all primitives including pixel images. This extension doesn't eliminate vertex lighting, but can be used to complement it.  For example, the diffuse contribution can be evaluated at each vertex, and the specular contribution can be evaluated at each fragment with the results being summed together to generate the final result. Ct  Cf |   |-------------------------------+ |   |                               | ----------                            | |        |                            | | TexEnv |                            | |        |                            | ----------                            | |                                 | ----------                           ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FragmentLightModeli.</para>
        /// <para>Fullname: FragmentLightModeliSGIX</para>
        /// <para>Extensions: SGIX_fragment_lighting</para>
        /// </summary>
        public static void FragmentLightModeli(int pname, int param)
        {
            if (gl._FragmentLightModeli != null) gl._FragmentLightModeli(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: FragmentLightModelivSGIX</para>
        /// </summary>
        [GLEntry("FragmentLightModelivSGIX", Category = "SGIX")]
        public static GLDelegate.FragmentLightModeliv _FragmentLightModeliv = null;
        /// <summary>
        /// <para>This extension adds a new lighting stage to the OpenGL pipeline.  This stage occurs during fragment processing after the texture environment has been applied and before fog has been applied.  The extension provides a mechanism for computing 'per-pixel lighting'.  Fragment lighting applies to fragments generated by all primitives including pixel images. This extension doesn't eliminate vertex lighting, but can be used to complement it.  For example, the diffuse contribution can be evaluated at each vertex, and the specular contribution can be evaluated at each fragment with the results being summed together to generate the final result. Ct  Cf |   |-------------------------------+ |   |                               | ----------                            | |        |                            | | TexEnv |                            | |        |                            | ----------                            | |                                 | ----------                           ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FragmentLightModeliv.</para>
        /// <para>Fullname: FragmentLightModelivSGIX</para>
        /// <para>Extensions: SGIX_fragment_lighting</para>
        /// </summary>
        public static void FragmentLightModeliv(int pname, int[] param)
        {
            if (gl._FragmentLightModeliv != null) gl._FragmentLightModeliv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: FragmentMaterialfSGIX</para>
        /// </summary>
        [GLEntry("FragmentMaterialfSGIX", Category = "SGIX")]
        public static GLDelegate.FragmentMaterialf _FragmentMaterialf = null;
        /// <summary>
        /// <para>This extension adds a new lighting stage to the OpenGL pipeline.  This stage occurs during fragment processing after the texture environment has been applied and before fog has been applied.  The extension provides a mechanism for computing 'per-pixel lighting'.  Fragment lighting applies to fragments generated by all primitives including pixel images. This extension doesn't eliminate vertex lighting, but can be used to complement it.  For example, the diffuse contribution can be evaluated at each vertex, and the specular contribution can be evaluated at each fragment with the results being summed together to generate the final result. Ct  Cf |   |-------------------------------+ |   |                               | ----------                            | |        |                            | | TexEnv |                            | |        |                            | ----------                            | |                                 | ----------                           ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FragmentMaterialf.</para>
        /// <para>Fullname: FragmentMaterialfSGIX</para>
        /// <para>Extensions: SGIX_fragment_lighting</para>
        /// </summary>
        public static void FragmentMaterialf(int face, int pname, float param)
        {
            if (gl._FragmentMaterialf != null) gl._FragmentMaterialf(face, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: FragmentMaterialfvSGIX</para>
        /// </summary>
        [GLEntry("FragmentMaterialfvSGIX", Category = "SGIX")]
        public static GLDelegate.FragmentMaterialfv _FragmentMaterialfv = null;
        /// <summary>
        /// <para>This extension adds a new lighting stage to the OpenGL pipeline.  This stage occurs during fragment processing after the texture environment has been applied and before fog has been applied.  The extension provides a mechanism for computing 'per-pixel lighting'.  Fragment lighting applies to fragments generated by all primitives including pixel images. This extension doesn't eliminate vertex lighting, but can be used to complement it.  For example, the diffuse contribution can be evaluated at each vertex, and the specular contribution can be evaluated at each fragment with the results being summed together to generate the final result. Ct  Cf |   |-------------------------------+ |   |                               | ----------                            | |        |                            | | TexEnv |                            | |        |                            | ----------                            | |                                 | ----------                           ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FragmentMaterialfv.</para>
        /// <para>Fullname: FragmentMaterialfvSGIX</para>
        /// <para>Extensions: SGIX_fragment_lighting</para>
        /// </summary>
        public static void FragmentMaterialfv(int face, int pname, float[] param)
        {
            if (gl._FragmentMaterialfv != null) gl._FragmentMaterialfv(face, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: FragmentMaterialiSGIX</para>
        /// </summary>
        [GLEntry("FragmentMaterialiSGIX", Category = "SGIX")]
        public static GLDelegate.FragmentMateriali _FragmentMateriali = null;
        /// <summary>
        /// <para>This extension adds a new lighting stage to the OpenGL pipeline.  This stage occurs during fragment processing after the texture environment has been applied and before fog has been applied.  The extension provides a mechanism for computing 'per-pixel lighting'.  Fragment lighting applies to fragments generated by all primitives including pixel images. This extension doesn't eliminate vertex lighting, but can be used to complement it.  For example, the diffuse contribution can be evaluated at each vertex, and the specular contribution can be evaluated at each fragment with the results being summed together to generate the final result. Ct  Cf |   |-------------------------------+ |   |                               | ----------                            | |        |                            | | TexEnv |                            | |        |                            | ----------                            | |                                 | ----------                           ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FragmentMateriali.</para>
        /// <para>Fullname: FragmentMaterialiSGIX</para>
        /// <para>Extensions: SGIX_fragment_lighting</para>
        /// </summary>
        public static void FragmentMateriali(int face, int pname, int param)
        {
            if (gl._FragmentMateriali != null) gl._FragmentMateriali(face, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: FragmentMaterialivSGIX</para>
        /// </summary>
        [GLEntry("FragmentMaterialivSGIX", Category = "SGIX")]
        public static GLDelegate.FragmentMaterialiv _FragmentMaterialiv = null;
        /// <summary>
        /// <para>This extension adds a new lighting stage to the OpenGL pipeline.  This stage occurs during fragment processing after the texture environment has been applied and before fog has been applied.  The extension provides a mechanism for computing 'per-pixel lighting'.  Fragment lighting applies to fragments generated by all primitives including pixel images. This extension doesn't eliminate vertex lighting, but can be used to complement it.  For example, the diffuse contribution can be evaluated at each vertex, and the specular contribution can be evaluated at each fragment with the results being summed together to generate the final result. Ct  Cf |   |-------------------------------+ |   |                               | ----------                            | |        |                            | | TexEnv |                            | |        |                            | ----------                            | |                                 | ----------                           ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FragmentMaterialiv.</para>
        /// <para>Fullname: FragmentMaterialivSGIX</para>
        /// <para>Extensions: SGIX_fragment_lighting</para>
        /// </summary>
        public static void FragmentMaterialiv(int face, int pname, int[] param)
        {
            if (gl._FragmentMaterialiv != null) gl._FragmentMaterialiv(face, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: FrameZoomSGIX</para>
        /// </summary>
        [GLEntry("FrameZoomSGIX", Category = "SGIX")]
        public static GLDelegate.FrameZoom _FrameZoom = null;
        /// <summary>
        /// <para>This extension provides a additional way to rasterize geometric primitives and pixel rectangles.  The techique is to reduce the number of pixels rasterized  and (possibly) the number of depth and stencil operations performed per primitive.  Each pixel is zoomed up and used to render an N x N block of screen pixels.  The implementation is free to choose the number of stencil and z pixels that will correspond to each N x N block. This extension provides an opportunity to the implementation to perform expensive raster operations at a reduced resolution, increasing performance.  Such operations may include texture-mapping, depth & stencil tests, etc.  The hardware should be allowed to perform operations that it accelerates at full hardware speed. The visual result will be the same as if a scene were rendered into a small window, and then that buffer was copied and zoomed up into a large window. All OpenGL parameters that effect rasterization size will implicitly be multipled by N (this inc...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FrameZoom.</para>
        /// <para>Fullname: FrameZoomSGIX</para>
        /// <para>Extensions: SGIX_framezoom</para>
        /// </summary>
        public static void FrameZoom(int factor)
        {
            if (gl._FrameZoom != null) gl._FrameZoom(factor); else { }
        }
        /// <summary>
        /// <para>Fullname: GenAsyncMarkersSGIX</para>
        /// </summary>
        [GLEntry("GenAsyncMarkersSGIX", Category = "SGIX")]
        public static GLDelegate.GenAsyncMarkers _GenAsyncMarkers = null;
        /// <summary>
        /// <para>This extension provides a framework for asynchronous OpenGL commands.  It also provides commands allowing a program to wait for the completion of asynchronous commands.  Asynchronous commands have two properties:  1) Asynchronous commands are non-blocking.  For example, an asynchronous ReadPixels command returns control to the program immediately rather than blocking until the command completes. This property allows the program to issue other OpenGL commands in parallel with the execution of commands that normally block.  2) Asynchronous commands may complete out-of-order with respect to other OpenGL commands.  For example, an asynchronous TexImage command may complete after subsequent OpenGL commands issued by the program rather than maintaining the normal serial order of the OpenGL command stream.  This property allows the graphics accelerator to execute asynchronous commands in parallel with the normal command stream, for instance using a secondary path to transfer data from or to t...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenAsyncMarkers.</para>
        /// <para>Fullname: GenAsyncMarkersSGIX</para>
        /// <para>Extensions: SGIX_async</para>
        /// </summary>
        public static uint GenAsyncMarkers(int range)
        {
            if (gl._GenAsyncMarkers != null) return gl._GenAsyncMarkers(range);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: GetFragmentLightfvSGIX</para>
        /// </summary>
        [GLEntry("GetFragmentLightfvSGIX", Category = "SGIX")]
        public static GLDelegate.GetFragmentLightfv _GetFragmentLightfv = null;
        /// <summary>
        /// <para>This extension adds a new lighting stage to the OpenGL pipeline.  This stage occurs during fragment processing after the texture environment has been applied and before fog has been applied.  The extension provides a mechanism for computing 'per-pixel lighting'.  Fragment lighting applies to fragments generated by all primitives including pixel images. This extension doesn't eliminate vertex lighting, but can be used to complement it.  For example, the diffuse contribution can be evaluated at each vertex, and the specular contribution can be evaluated at each fragment with the results being summed together to generate the final result. Ct  Cf |   |-------------------------------+ |   |                               | ----------                            | |        |                            | | TexEnv |                            | |        |                            | ----------                            | |                                 | ----------                           ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetFragmentLightfv.</para>
        /// <para>Fullname: GetFragmentLightfvSGIX</para>
        /// <para>Extensions: SGIX_fragment_lighting</para>
        /// </summary>
        public static void GetFragmentLightfv(int light, int pname, float[] param)
        {
            if (gl._GetFragmentLightfv != null) gl._GetFragmentLightfv(light, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetFragmentLightivSGIX</para>
        /// </summary>
        [GLEntry("GetFragmentLightivSGIX", Category = "SGIX")]
        public static GLDelegate.GetFragmentLightiv _GetFragmentLightiv = null;
        /// <summary>
        /// <para>This extension adds a new lighting stage to the OpenGL pipeline.  This stage occurs during fragment processing after the texture environment has been applied and before fog has been applied.  The extension provides a mechanism for computing 'per-pixel lighting'.  Fragment lighting applies to fragments generated by all primitives including pixel images. This extension doesn't eliminate vertex lighting, but can be used to complement it.  For example, the diffuse contribution can be evaluated at each vertex, and the specular contribution can be evaluated at each fragment with the results being summed together to generate the final result. Ct  Cf |   |-------------------------------+ |   |                               | ----------                            | |        |                            | | TexEnv |                            | |        |                            | ----------                            | |                                 | ----------                           ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetFragmentLightiv.</para>
        /// <para>Fullname: GetFragmentLightivSGIX</para>
        /// <para>Extensions: SGIX_fragment_lighting</para>
        /// </summary>
        public static void GetFragmentLightiv(int light, int pname, int[] param)
        {
            if (gl._GetFragmentLightiv != null) gl._GetFragmentLightiv(light, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetFragmentMaterialfvSGIX</para>
        /// </summary>
        [GLEntry("GetFragmentMaterialfvSGIX", Category = "SGIX")]
        public static GLDelegate.GetFragmentMaterialfv _GetFragmentMaterialfv = null;
        /// <summary>
        /// <para>This extension adds a new lighting stage to the OpenGL pipeline.  This stage occurs during fragment processing after the texture environment has been applied and before fog has been applied.  The extension provides a mechanism for computing 'per-pixel lighting'.  Fragment lighting applies to fragments generated by all primitives including pixel images. This extension doesn't eliminate vertex lighting, but can be used to complement it.  For example, the diffuse contribution can be evaluated at each vertex, and the specular contribution can be evaluated at each fragment with the results being summed together to generate the final result. Ct  Cf |   |-------------------------------+ |   |                               | ----------                            | |        |                            | | TexEnv |                            | |        |                            | ----------                            | |                                 | ----------                           ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetFragmentMaterialfv.</para>
        /// <para>Fullname: GetFragmentMaterialfvSGIX</para>
        /// <para>Extensions: SGIX_fragment_lighting</para>
        /// </summary>
        public static void GetFragmentMaterialfv(int face, int pname, float[] param)
        {
            if (gl._GetFragmentMaterialfv != null) gl._GetFragmentMaterialfv(face, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetFragmentMaterialivSGIX</para>
        /// </summary>
        [GLEntry("GetFragmentMaterialivSGIX", Category = "SGIX")]
        public static GLDelegate.GetFragmentMaterialiv _GetFragmentMaterialiv = null;
        /// <summary>
        /// <para>This extension adds a new lighting stage to the OpenGL pipeline.  This stage occurs during fragment processing after the texture environment has been applied and before fog has been applied.  The extension provides a mechanism for computing 'per-pixel lighting'.  Fragment lighting applies to fragments generated by all primitives including pixel images. This extension doesn't eliminate vertex lighting, but can be used to complement it.  For example, the diffuse contribution can be evaluated at each vertex, and the specular contribution can be evaluated at each fragment with the results being summed together to generate the final result. Ct  Cf |   |-------------------------------+ |   |                               | ----------                            | |        |                            | | TexEnv |                            | |        |                            | ----------                            | |                                 | ----------                           ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetFragmentMaterialiv.</para>
        /// <para>Fullname: GetFragmentMaterialivSGIX</para>
        /// <para>Extensions: SGIX_fragment_lighting</para>
        /// </summary>
        public static void GetFragmentMaterialiv(int face, int pname, int[] param)
        {
            if (gl._GetFragmentMaterialiv != null) gl._GetFragmentMaterialiv(face, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetInstrumentsSGIX</para>
        /// </summary>
        [GLEntry("GetInstrumentsSGIX", Category = "SGIX")]
        public static GLDelegate.GetInstruments _GetInstruments = null;
        /// <summary>
        /// <para>This extension allows the gathering and return of performance measurements from within the graphics pipeline by adding instrumentation. There are two reasons to do this.  The first is as a part of some type of fixed-frame-rate load management scheme.  If we know that the pipeline is stalled or struggling to process the amount of data we have given it so far, we can reduce the level of detail of the remaining objects in the current frame or the next frame, or adjust the framebuffer resolution for the next frame if we have a video-zoom capability available.  We can call this type of instrumentation Load Monitoring. The second is for performance tuning and debugging of an application. It might tell us how many triangles were culled or clipped before being rasterized.  We can call this simply Tuning. Load Monitoring requires that the instrumentation and the access of the measurements be efficient, otherwise the instrumentation itself will reduce performance more than any load-management sc...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetInstruments.</para>
        /// <para>Fullname: GetInstrumentsSGIX</para>
        /// <para>Extensions: SGIX_instruments</para>
        /// </summary>
        public static int GetInstruments()
        {
            if (gl._GetInstruments != null) return gl._GetInstruments();
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: GetListParameterfvSGIX</para>
        /// </summary>
        [GLEntry("GetListParameterfvSGIX", Category = "SGIX")]
        public static GLDelegate.GetListParameterfv _GetListParameterfv = null;
        /// <summary>
        /// <para>This extension provides a mechanism for specifying the relative importance of display lists.  This information can be used by an OpenGL implementation to guide the placement of display list data in a storage hierarchy. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetListParameterfv.</para>
        /// <para>Fullname: GetListParameterfvSGIX</para>
        /// <para>Extensions: SGIX_list_priority</para>
        /// </summary>
        public static void GetListParameterfv(uint list, int pname, float[] param)
        {
            if (gl._GetListParameterfv != null) gl._GetListParameterfv(list, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetListParameterivSGIX</para>
        /// </summary>
        [GLEntry("GetListParameterivSGIX", Category = "SGIX")]
        public static GLDelegate.GetListParameteriv _GetListParameteriv = null;
        /// <summary>
        /// <para>This extension provides a mechanism for specifying the relative importance of display lists.  This information can be used by an OpenGL implementation to guide the placement of display list data in a storage hierarchy. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetListParameteriv.</para>
        /// <para>Fullname: GetListParameterivSGIX</para>
        /// <para>Extensions: SGIX_list_priority</para>
        /// </summary>
        public static void GetListParameteriv(uint list, int pname, int[] param)
        {
            if (gl._GetListParameteriv != null) gl._GetListParameteriv(list, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: IglooInterfaceSGIX</para>
        /// </summary>
        [GLEntry("IglooInterfaceSGIX", Category = "SGIX")]
        public static GLDelegate.IglooInterface _IglooInterface = null;
        /// <summary>Documentation not found...</summary>
        public static void IglooInterface(int pname, IntPtr param)
        {
            if (gl._IglooInterface != null) gl._IglooInterface(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: InstrumentsBufferSGIX</para>
        /// </summary>
        [GLEntry("InstrumentsBufferSGIX", Category = "SGIX")]
        public static GLDelegate.InstrumentsBuffer _InstrumentsBuffer = null;
        /// <summary>
        /// <para>This extension allows the gathering and return of performance measurements from within the graphics pipeline by adding instrumentation. There are two reasons to do this.  The first is as a part of some type of fixed-frame-rate load management scheme.  If we know that the pipeline is stalled or struggling to process the amount of data we have given it so far, we can reduce the level of detail of the remaining objects in the current frame or the next frame, or adjust the framebuffer resolution for the next frame if we have a video-zoom capability available.  We can call this type of instrumentation Load Monitoring. The second is for performance tuning and debugging of an application. It might tell us how many triangles were culled or clipped before being rasterized.  We can call this simply Tuning. Load Monitoring requires that the instrumentation and the access of the measurements be efficient, otherwise the instrumentation itself will reduce performance more than any load-management sc...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _InstrumentsBuffer.</para>
        /// <para>Fullname: InstrumentsBufferSGIX</para>
        /// <para>Extensions: SGIX_instruments</para>
        /// </summary>
        public static void InstrumentsBuffer(int size, IntPtr buffer)
        {
            if (gl._InstrumentsBuffer != null) gl._InstrumentsBuffer(size, buffer); else { }
        }
        /// <summary>
        /// <para>Fullname: IsAsyncMarkerSGIX</para>
        /// </summary>
        [GLEntry("IsAsyncMarkerSGIX", Category = "SGIX")]
        public static GLDelegate.IsAsyncMarker _IsAsyncMarker = null;
        /// <summary>
        /// <para>This extension provides a framework for asynchronous OpenGL commands.  It also provides commands allowing a program to wait for the completion of asynchronous commands.  Asynchronous commands have two properties:  1) Asynchronous commands are non-blocking.  For example, an asynchronous ReadPixels command returns control to the program immediately rather than blocking until the command completes. This property allows the program to issue other OpenGL commands in parallel with the execution of commands that normally block.  2) Asynchronous commands may complete out-of-order with respect to other OpenGL commands.  For example, an asynchronous TexImage command may complete after subsequent OpenGL commands issued by the program rather than maintaining the normal serial order of the OpenGL command stream.  This property allows the graphics accelerator to execute asynchronous commands in parallel with the normal command stream, for instance using a secondary path to transfer data from or to t...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsAsyncMarker.</para>
        /// <para>Fullname: IsAsyncMarkerSGIX</para>
        /// <para>Extensions: SGIX_async</para>
        /// </summary>
        public static bool IsAsyncMarker(uint marker)
        {
            if (gl._IsAsyncMarker != null) return gl._IsAsyncMarker(marker);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: LightEnviSGIX</para>
        /// </summary>
        [GLEntry("LightEnviSGIX", Category = "SGIX")]
        public static GLDelegate.LightEnvi _LightEnvi = null;
        /// <summary>
        /// <para>This extension adds a new lighting stage to the OpenGL pipeline.  This stage occurs during fragment processing after the texture environment has been applied and before fog has been applied.  The extension provides a mechanism for computing 'per-pixel lighting'.  Fragment lighting applies to fragments generated by all primitives including pixel images. This extension doesn't eliminate vertex lighting, but can be used to complement it.  For example, the diffuse contribution can be evaluated at each vertex, and the specular contribution can be evaluated at each fragment with the results being summed together to generate the final result. Ct  Cf |   |-------------------------------+ |   |                               | ----------                            | |        |                            | | TexEnv |                            | |        |                            | ----------                            | |                                 | ----------                           ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _LightEnvi.</para>
        /// <para>Fullname: LightEnviSGIX</para>
        /// <para>Extensions: SGIX_fragment_lighting</para>
        /// </summary>
        public static void LightEnvi(int pname, int param)
        {
            if (gl._LightEnvi != null) gl._LightEnvi(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ListParameterfSGIX</para>
        /// </summary>
        [GLEntry("ListParameterfSGIX", Category = "SGIX")]
        public static GLDelegate.ListParameterf _ListParameterf = null;
        /// <summary>
        /// <para>This extension provides a mechanism for specifying the relative importance of display lists.  This information can be used by an OpenGL implementation to guide the placement of display list data in a storage hierarchy. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ListParameterf.</para>
        /// <para>Fullname: ListParameterfSGIX</para>
        /// <para>Extensions: SGIX_list_priority</para>
        /// </summary>
        public static void ListParameterf(uint list, int pname, float param)
        {
            if (gl._ListParameterf != null) gl._ListParameterf(list, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ListParameterfvSGIX</para>
        /// </summary>
        [GLEntry("ListParameterfvSGIX", Category = "SGIX")]
        public static GLDelegate.ListParameterfv _ListParameterfv = null;
        /// <summary>
        /// <para>This extension provides a mechanism for specifying the relative importance of display lists.  This information can be used by an OpenGL implementation to guide the placement of display list data in a storage hierarchy. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ListParameterfv.</para>
        /// <para>Fullname: ListParameterfvSGIX</para>
        /// <para>Extensions: SGIX_list_priority</para>
        /// </summary>
        public static void ListParameterfv(uint list, int pname, float[] param)
        {
            if (gl._ListParameterfv != null) gl._ListParameterfv(list, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ListParameteriSGIX</para>
        /// </summary>
        [GLEntry("ListParameteriSGIX", Category = "SGIX")]
        public static GLDelegate.ListParameteri _ListParameteri = null;
        /// <summary>
        /// <para>This extension provides a mechanism for specifying the relative importance of display lists.  This information can be used by an OpenGL implementation to guide the placement of display list data in a storage hierarchy. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ListParameteri.</para>
        /// <para>Fullname: ListParameteriSGIX</para>
        /// <para>Extensions: SGIX_list_priority</para>
        /// </summary>
        public static void ListParameteri(uint list, int pname, int param)
        {
            if (gl._ListParameteri != null) gl._ListParameteri(list, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ListParameterivSGIX</para>
        /// </summary>
        [GLEntry("ListParameterivSGIX", Category = "SGIX")]
        public static GLDelegate.ListParameteriv _ListParameteriv = null;
        /// <summary>
        /// <para>This extension provides a mechanism for specifying the relative importance of display lists.  This information can be used by an OpenGL implementation to guide the placement of display list data in a storage hierarchy. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ListParameteriv.</para>
        /// <para>Fullname: ListParameterivSGIX</para>
        /// <para>Extensions: SGIX_list_priority</para>
        /// </summary>
        public static void ListParameteriv(uint list, int pname, int[] param)
        {
            if (gl._ListParameteriv != null) gl._ListParameteriv(list, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: LoadIdentityDeformationMapSGIX</para>
        /// </summary>
        [GLEntry("LoadIdentityDeformationMapSGIX", Category = "SGIX")]
        public static GLDelegate.LoadIdentityDeformationMap _LoadIdentityDeformationMap = null;
        /// <summary>Documentation not found...</summary>
        public static void LoadIdentityDeformationMap(int mask)
        {
            if (gl._LoadIdentityDeformationMap != null) gl._LoadIdentityDeformationMap(mask); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelTexGenSGIX</para>
        /// </summary>
        [GLEntry("PixelTexGenSGIX", Category = "SGIX")]
        public static GLDelegate.PixelTexGen _PixelTexGen = null;
        /// <summary>
        /// <para>This extension allows the color components of pixel groups to be used as texture coordinates, effectively converting a color image into a texture coordinate image.  Because texture mapping is essentially a multidimensional table lookup, this conversion supports multidimensional color lookups for images.  Such multidimensional lookups can be used to implement very accurate color space conversions. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelTexGen.</para>
        /// <para>Fullname: PixelTexGenSGIX</para>
        /// <para>Extensions: SGIX_pixel_texture</para>
        /// </summary>
        public static void PixelTexGen(int mode)
        {
            if (gl._PixelTexGen != null) gl._PixelTexGen(mode); else { }
        }
        /// <summary>
        /// <para>Fullname: PollAsyncSGIX</para>
        /// </summary>
        [GLEntry("PollAsyncSGIX", Category = "SGIX")]
        public static GLDelegate.PollAsync _PollAsync = null;
        /// <summary>
        /// <para>This extension provides a framework for asynchronous OpenGL commands.  It also provides commands allowing a program to wait for the completion of asynchronous commands.  Asynchronous commands have two properties:  1) Asynchronous commands are non-blocking.  For example, an asynchronous ReadPixels command returns control to the program immediately rather than blocking until the command completes. This property allows the program to issue other OpenGL commands in parallel with the execution of commands that normally block.  2) Asynchronous commands may complete out-of-order with respect to other OpenGL commands.  For example, an asynchronous TexImage command may complete after subsequent OpenGL commands issued by the program rather than maintaining the normal serial order of the OpenGL command stream.  This property allows the graphics accelerator to execute asynchronous commands in parallel with the normal command stream, for instance using a secondary path to transfer data from or to t...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PollAsync.</para>
        /// <para>Fullname: PollAsyncSGIX</para>
        /// <para>Extensions: SGIX_async</para>
        /// </summary>
        public static int PollAsync(uint[] markerp)
        {
            if (gl._PollAsync != null) return gl._PollAsync(markerp);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: PollAsyncSGIX</para>
        /// </summary>
        [GLEntry("PollAsyncSGIX", Category = "SGIX")]
        public static GLDelegate.PollAsync_uint _PollAsync_uint = null;
        /// <summary>
        /// <para>This extension provides a framework for asynchronous OpenGL commands.  It also provides commands allowing a program to wait for the completion of asynchronous commands.  Asynchronous commands have two properties:  1) Asynchronous commands are non-blocking.  For example, an asynchronous ReadPixels command returns control to the program immediately rather than blocking until the command completes. This property allows the program to issue other OpenGL commands in parallel with the execution of commands that normally block.  2) Asynchronous commands may complete out-of-order with respect to other OpenGL commands.  For example, an asynchronous TexImage command may complete after subsequent OpenGL commands issued by the program rather than maintaining the normal serial order of the OpenGL command stream.  This property allows the graphics accelerator to execute asynchronous commands in parallel with the normal command stream, for instance using a secondary path to transfer data from or to t...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PollAsync_uint.</para>
        /// <para>Fullname: PollAsyncSGIX</para>
        /// <para>Extensions: SGIX_async</para>
        /// </summary>
        public static int PollAsync(out uint markerp)
        {
            if (gl._PollAsync_uint != null) return gl._PollAsync_uint(out markerp);
            else { markerp = new uint(); return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: PollInstrumentsSGIX</para>
        /// </summary>
        [GLEntry("PollInstrumentsSGIX", Category = "SGIX")]
        public static GLDelegate.PollInstruments _PollInstruments = null;
        /// <summary>
        /// <para>This extension allows the gathering and return of performance measurements from within the graphics pipeline by adding instrumentation. There are two reasons to do this.  The first is as a part of some type of fixed-frame-rate load management scheme.  If we know that the pipeline is stalled or struggling to process the amount of data we have given it so far, we can reduce the level of detail of the remaining objects in the current frame or the next frame, or adjust the framebuffer resolution for the next frame if we have a video-zoom capability available.  We can call this type of instrumentation Load Monitoring. The second is for performance tuning and debugging of an application. It might tell us how many triangles were culled or clipped before being rasterized.  We can call this simply Tuning. Load Monitoring requires that the instrumentation and the access of the measurements be efficient, otherwise the instrumentation itself will reduce performance more than any load-management sc...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PollInstruments.</para>
        /// <para>Fullname: PollInstrumentsSGIX</para>
        /// <para>Extensions: SGIX_instruments</para>
        /// </summary>
        public static int PollInstruments(int[] marker_p)
        {
            if (gl._PollInstruments != null) return gl._PollInstruments(marker_p);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: PollInstrumentsSGIX</para>
        /// </summary>
        [GLEntry("PollInstrumentsSGIX", Category = "SGIX")]
        public static GLDelegate.PollInstruments_int _PollInstruments_int = null;
        /// <summary>
        /// <para>This extension allows the gathering and return of performance measurements from within the graphics pipeline by adding instrumentation. There are two reasons to do this.  The first is as a part of some type of fixed-frame-rate load management scheme.  If we know that the pipeline is stalled or struggling to process the amount of data we have given it so far, we can reduce the level of detail of the remaining objects in the current frame or the next frame, or adjust the framebuffer resolution for the next frame if we have a video-zoom capability available.  We can call this type of instrumentation Load Monitoring. The second is for performance tuning and debugging of an application. It might tell us how many triangles were culled or clipped before being rasterized.  We can call this simply Tuning. Load Monitoring requires that the instrumentation and the access of the measurements be efficient, otherwise the instrumentation itself will reduce performance more than any load-management sc...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PollInstruments_int.</para>
        /// <para>Fullname: PollInstrumentsSGIX</para>
        /// <para>Extensions: SGIX_instruments</para>
        /// </summary>
        public static int PollInstruments(out int marker_p)
        {
            if (gl._PollInstruments_int != null) return gl._PollInstruments_int(out marker_p);
            else { marker_p = new int(); return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: ReadInstrumentsSGIX</para>
        /// </summary>
        [GLEntry("ReadInstrumentsSGIX", Category = "SGIX")]
        public static GLDelegate.ReadInstruments _ReadInstruments = null;
        /// <summary>
        /// <para>This extension allows the gathering and return of performance measurements from within the graphics pipeline by adding instrumentation. There are two reasons to do this.  The first is as a part of some type of fixed-frame-rate load management scheme.  If we know that the pipeline is stalled or struggling to process the amount of data we have given it so far, we can reduce the level of detail of the remaining objects in the current frame or the next frame, or adjust the framebuffer resolution for the next frame if we have a video-zoom capability available.  We can call this type of instrumentation Load Monitoring. The second is for performance tuning and debugging of an application. It might tell us how many triangles were culled or clipped before being rasterized.  We can call this simply Tuning. Load Monitoring requires that the instrumentation and the access of the measurements be efficient, otherwise the instrumentation itself will reduce performance more than any load-management sc...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReadInstruments.</para>
        /// <para>Fullname: ReadInstrumentsSGIX</para>
        /// <para>Extensions: SGIX_instruments</para>
        /// </summary>
        public static void ReadInstruments(int marker)
        {
            if (gl._ReadInstruments != null) gl._ReadInstruments(marker); else { }
        }
        /// <summary>
        /// <para>Fullname: ReferencePlaneSGIX</para>
        /// </summary>
        [GLEntry("ReferencePlaneSGIX", Category = "SGIX")]
        public static GLDelegate.ReferencePlane _ReferencePlane = null;
        /// <summary>
        /// <para>This extension allows a group of coplanar primitives to be rendered without depth-buffering artifacts.  This is accomplished by generating the depth values for all the primitives from a single ``reference plane'' rather than from the primitives themselves.  This ensures that all the primitives in the group have exactly the same depth value at any given sample point, no matter what imprecision may exist in the original specifications of the primitives or in the GL's coordinate transformation process. The reference plane is defined by a four-component plane equation. When glReferencePlaneSGIX is called, equation is transformed by the transpose-adjoint of a matrix that is the complete object-coordinate to clip-coordinate transformation.  The resulting clip-coordinate coefficients are transformed by the current viewport when the reference plane is enabled. The reference plane is enabled and disabled with glEnable and glDisable. If the reference plane is enabled, a fragment (xf,yf,zf) will ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReferencePlane.</para>
        /// <para>Fullname: ReferencePlaneSGIX</para>
        /// <para>Extensions: SGIX_reference_plane</para>
        /// </summary>
        public static void ReferencePlane(double[] equation)
        {
            if (gl._ReferencePlane != null) gl._ReferencePlane(equation); else { }
        }
        /// <summary>
        /// <para>Fullname: SpriteParameterfSGIX</para>
        /// </summary>
        [GLEntry("SpriteParameterfSGIX", Category = "SGIX")]
        public static GLDelegate.SpriteParameterf _SpriteParameterf = null;
        /// <summary>
        /// <para>This extension provides support for viewpoint dependent alignment of geometry, in particular geometry that rotates about a point or a specified axis to face the eye point.  The primary use is for quickly rendering roughly cylindrically or spherically symmetric objects, e.g. trees, smoke, clouds, etc. using geometry textured with a partially transparent texture map. Rendering sprite geometry requires applying a transformation to primitives before the current model view. This matrix includes a rotation which is computed based on the current model view matrix and a translation which is specified explicitly (SPRITE_TRANSLATION_SGIX). The current model view matrix itself is not modified. Primitives are first transformed by a rotation, depending on the sprite mode: </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SpriteParameterf.</para>
        /// <para>Fullname: SpriteParameterfSGIX</para>
        /// <para>Extensions: SGIX_sprite</para>
        /// </summary>
        public static void SpriteParameterf(int pname, float param)
        {
            if (gl._SpriteParameterf != null) gl._SpriteParameterf(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: SpriteParameterfvSGIX</para>
        /// </summary>
        [GLEntry("SpriteParameterfvSGIX", Category = "SGIX")]
        public static GLDelegate.SpriteParameterfv _SpriteParameterfv = null;
        /// <summary>
        /// <para>This extension provides support for viewpoint dependent alignment of geometry, in particular geometry that rotates about a point or a specified axis to face the eye point.  The primary use is for quickly rendering roughly cylindrically or spherically symmetric objects, e.g. trees, smoke, clouds, etc. using geometry textured with a partially transparent texture map. Rendering sprite geometry requires applying a transformation to primitives before the current model view. This matrix includes a rotation which is computed based on the current model view matrix and a translation which is specified explicitly (SPRITE_TRANSLATION_SGIX). The current model view matrix itself is not modified. Primitives are first transformed by a rotation, depending on the sprite mode: </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SpriteParameterfv.</para>
        /// <para>Fullname: SpriteParameterfvSGIX</para>
        /// <para>Extensions: SGIX_sprite</para>
        /// </summary>
        public static void SpriteParameterfv(int pname, float[] param)
        {
            if (gl._SpriteParameterfv != null) gl._SpriteParameterfv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: SpriteParameteriSGIX</para>
        /// </summary>
        [GLEntry("SpriteParameteriSGIX", Category = "SGIX")]
        public static GLDelegate.SpriteParameteri _SpriteParameteri = null;
        /// <summary>
        /// <para>This extension provides support for viewpoint dependent alignment of geometry, in particular geometry that rotates about a point or a specified axis to face the eye point.  The primary use is for quickly rendering roughly cylindrically or spherically symmetric objects, e.g. trees, smoke, clouds, etc. using geometry textured with a partially transparent texture map. Rendering sprite geometry requires applying a transformation to primitives before the current model view. This matrix includes a rotation which is computed based on the current model view matrix and a translation which is specified explicitly (SPRITE_TRANSLATION_SGIX). The current model view matrix itself is not modified. Primitives are first transformed by a rotation, depending on the sprite mode: </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SpriteParameteri.</para>
        /// <para>Fullname: SpriteParameteriSGIX</para>
        /// <para>Extensions: SGIX_sprite</para>
        /// </summary>
        public static void SpriteParameteri(int pname, int param)
        {
            if (gl._SpriteParameteri != null) gl._SpriteParameteri(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: SpriteParameterivSGIX</para>
        /// </summary>
        [GLEntry("SpriteParameterivSGIX", Category = "SGIX")]
        public static GLDelegate.SpriteParameteriv _SpriteParameteriv = null;
        /// <summary>
        /// <para>This extension provides support for viewpoint dependent alignment of geometry, in particular geometry that rotates about a point or a specified axis to face the eye point.  The primary use is for quickly rendering roughly cylindrically or spherically symmetric objects, e.g. trees, smoke, clouds, etc. using geometry textured with a partially transparent texture map. Rendering sprite geometry requires applying a transformation to primitives before the current model view. This matrix includes a rotation which is computed based on the current model view matrix and a translation which is specified explicitly (SPRITE_TRANSLATION_SGIX). The current model view matrix itself is not modified. Primitives are first transformed by a rotation, depending on the sprite mode: </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SpriteParameteriv.</para>
        /// <para>Fullname: SpriteParameterivSGIX</para>
        /// <para>Extensions: SGIX_sprite</para>
        /// </summary>
        public static void SpriteParameteriv(int pname, int[] param)
        {
            if (gl._SpriteParameteriv != null) gl._SpriteParameteriv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: StartInstrumentsSGIX</para>
        /// </summary>
        [GLEntry("StartInstrumentsSGIX", Category = "SGIX")]
        public static GLDelegate.StartInstruments _StartInstruments = null;
        /// <summary>
        /// <para>This extension allows the gathering and return of performance measurements from within the graphics pipeline by adding instrumentation. There are two reasons to do this.  The first is as a part of some type of fixed-frame-rate load management scheme.  If we know that the pipeline is stalled or struggling to process the amount of data we have given it so far, we can reduce the level of detail of the remaining objects in the current frame or the next frame, or adjust the framebuffer resolution for the next frame if we have a video-zoom capability available.  We can call this type of instrumentation Load Monitoring. The second is for performance tuning and debugging of an application. It might tell us how many triangles were culled or clipped before being rasterized.  We can call this simply Tuning. Load Monitoring requires that the instrumentation and the access of the measurements be efficient, otherwise the instrumentation itself will reduce performance more than any load-management sc...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _StartInstruments.</para>
        /// <para>Fullname: StartInstrumentsSGIX</para>
        /// <para>Extensions: SGIX_instruments</para>
        /// </summary>
        public static void StartInstruments()
        {
            if (gl._StartInstruments != null) gl._StartInstruments(); else { }
        }
        /// <summary>
        /// <para>Fullname: StopInstrumentsSGIX</para>
        /// </summary>
        [GLEntry("StopInstrumentsSGIX", Category = "SGIX")]
        public static GLDelegate.StopInstruments _StopInstruments = null;
        /// <summary>
        /// <para>This extension allows the gathering and return of performance measurements from within the graphics pipeline by adding instrumentation. There are two reasons to do this.  The first is as a part of some type of fixed-frame-rate load management scheme.  If we know that the pipeline is stalled or struggling to process the amount of data we have given it so far, we can reduce the level of detail of the remaining objects in the current frame or the next frame, or adjust the framebuffer resolution for the next frame if we have a video-zoom capability available.  We can call this type of instrumentation Load Monitoring. The second is for performance tuning and debugging of an application. It might tell us how many triangles were culled or clipped before being rasterized.  We can call this simply Tuning. Load Monitoring requires that the instrumentation and the access of the measurements be efficient, otherwise the instrumentation itself will reduce performance more than any load-management sc...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _StopInstruments.</para>
        /// <para>Fullname: StopInstrumentsSGIX</para>
        /// <para>Extensions: SGIX_instruments</para>
        /// </summary>
        public static void StopInstruments(int marker)
        {
            if (gl._StopInstruments != null) gl._StopInstruments(marker); else { }
        }
        /// <summary>
        /// <para>Fullname: TagSampleBufferSGIX</para>
        /// </summary>
        [GLEntry("TagSampleBufferSGIX", Category = "SGIX")]
        public static GLDelegate.TagSampleBuffer _TagSampleBuffer = null;
        /// <summary>
        /// <para>The extensions defines a special purpose fast multisample clear. This clear can be used with some restrictions as a significantly faster alternative to Clear(DEPTH_BUFFER_BIT).  The extension is based on the RealityEngine architecture and will probably never be supported by any other architecture. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TagSampleBuffer.</para>
        /// <para>Fullname: TagSampleBufferSGIX</para>
        /// <para>Extensions: SGIX_tag_sample_buffer</para>
        /// </summary>
        public static void TagSampleBuffer()
        {
            if (gl._TagSampleBuffer != null) gl._TagSampleBuffer(); else { }
        }
        /// <summary>
        /// <para>Fullname: GetImageTransformParameterfvHP</para>
        /// </summary>
        [GLEntry("GetImageTransformParameterfvHP", Category = "HP")]
        public static GLDelegate.GetImageTransformParameterfv _GetImageTransformParameterfv = null;
        /// <summary>
        /// <para>This extension provides support for scaling, rotation, and translation of two-dimensional pixel rectangles at a fixed location in the pixel transfer process.  The 2D image transformation attributes are specified as individual values so that that implementations may easily detect scaling and rotation values that lend themselves to optimization.  2D image transformation occurs immediately after the post-convolution color table stage of the pixel pipeline.  This extension also defines a color table that is applied immediately after the image transformation operation. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetImageTransformParameterfv.</para>
        /// <para>Fullname: GetImageTransformParameterfvHP</para>
        /// <para>Extensions: HP_image_transform</para>
        /// </summary>
        public static void GetImageTransformParameterfv(int target, int pname, float[] param)
        {
            if (gl._GetImageTransformParameterfv != null) gl._GetImageTransformParameterfv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetImageTransformParameterivHP</para>
        /// </summary>
        [GLEntry("GetImageTransformParameterivHP", Category = "HP")]
        public static GLDelegate.GetImageTransformParameteriv _GetImageTransformParameteriv = null;
        /// <summary>
        /// <para>This extension provides support for scaling, rotation, and translation of two-dimensional pixel rectangles at a fixed location in the pixel transfer process.  The 2D image transformation attributes are specified as individual values so that that implementations may easily detect scaling and rotation values that lend themselves to optimization.  2D image transformation occurs immediately after the post-convolution color table stage of the pixel pipeline.  This extension also defines a color table that is applied immediately after the image transformation operation. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetImageTransformParameteriv.</para>
        /// <para>Fullname: GetImageTransformParameterivHP</para>
        /// <para>Extensions: HP_image_transform</para>
        /// </summary>
        public static void GetImageTransformParameteriv(int target, int pname, int[] param)
        {
            if (gl._GetImageTransformParameteriv != null) gl._GetImageTransformParameteriv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ImageTransformParameterfHP</para>
        /// </summary>
        [GLEntry("ImageTransformParameterfHP", Category = "HP")]
        public static GLDelegate.ImageTransformParameterf _ImageTransformParameterf = null;
        /// <summary>
        /// <para>This extension provides support for scaling, rotation, and translation of two-dimensional pixel rectangles at a fixed location in the pixel transfer process.  The 2D image transformation attributes are specified as individual values so that that implementations may easily detect scaling and rotation values that lend themselves to optimization.  2D image transformation occurs immediately after the post-convolution color table stage of the pixel pipeline.  This extension also defines a color table that is applied immediately after the image transformation operation. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ImageTransformParameterf.</para>
        /// <para>Fullname: ImageTransformParameterfHP</para>
        /// <para>Extensions: HP_image_transform</para>
        /// </summary>
        public static void ImageTransformParameterf(int target, int pname, float param)
        {
            if (gl._ImageTransformParameterf != null) gl._ImageTransformParameterf(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ImageTransformParameterfvHP</para>
        /// </summary>
        [GLEntry("ImageTransformParameterfvHP", Category = "HP")]
        public static GLDelegate.ImageTransformParameterfv _ImageTransformParameterfv = null;
        /// <summary>
        /// <para>This extension provides support for scaling, rotation, and translation of two-dimensional pixel rectangles at a fixed location in the pixel transfer process.  The 2D image transformation attributes are specified as individual values so that that implementations may easily detect scaling and rotation values that lend themselves to optimization.  2D image transformation occurs immediately after the post-convolution color table stage of the pixel pipeline.  This extension also defines a color table that is applied immediately after the image transformation operation. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ImageTransformParameterfv.</para>
        /// <para>Fullname: ImageTransformParameterfvHP</para>
        /// <para>Extensions: HP_image_transform</para>
        /// </summary>
        public static void ImageTransformParameterfv(int target, int pname, float[] param)
        {
            if (gl._ImageTransformParameterfv != null) gl._ImageTransformParameterfv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ImageTransformParameteriHP</para>
        /// </summary>
        [GLEntry("ImageTransformParameteriHP", Category = "HP")]
        public static GLDelegate.ImageTransformParameteri _ImageTransformParameteri = null;
        /// <summary>
        /// <para>This extension provides support for scaling, rotation, and translation of two-dimensional pixel rectangles at a fixed location in the pixel transfer process.  The 2D image transformation attributes are specified as individual values so that that implementations may easily detect scaling and rotation values that lend themselves to optimization.  2D image transformation occurs immediately after the post-convolution color table stage of the pixel pipeline.  This extension also defines a color table that is applied immediately after the image transformation operation. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ImageTransformParameteri.</para>
        /// <para>Fullname: ImageTransformParameteriHP</para>
        /// <para>Extensions: HP_image_transform</para>
        /// </summary>
        public static void ImageTransformParameteri(int target, int pname, int param)
        {
            if (gl._ImageTransformParameteri != null) gl._ImageTransformParameteri(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ImageTransformParameterivHP</para>
        /// </summary>
        [GLEntry("ImageTransformParameterivHP", Category = "HP")]
        public static GLDelegate.ImageTransformParameteriv _ImageTransformParameteriv = null;
        /// <summary>
        /// <para>This extension provides support for scaling, rotation, and translation of two-dimensional pixel rectangles at a fixed location in the pixel transfer process.  The 2D image transformation attributes are specified as individual values so that that implementations may easily detect scaling and rotation values that lend themselves to optimization.  2D image transformation occurs immediately after the post-convolution color table stage of the pixel pipeline.  This extension also defines a color table that is applied immediately after the image transformation operation. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ImageTransformParameteriv.</para>
        /// <para>Fullname: ImageTransformParameterivHP</para>
        /// <para>Extensions: HP_image_transform</para>
        /// </summary>
        public static void ImageTransformParameteriv(int target, int pname, int[] param)
        {
            if (gl._ImageTransformParameteriv != null) gl._ImageTransformParameteriv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ColorPointervINTEL</para>
        /// </summary>
        [GLEntry("ColorPointervINTEL", Category = "INTEL")]
        public static GLDelegate.ColorPointerv _ColorPointerv = null;
        /// <summary>
        /// <para>This extension adds the ability to format vertex arrays in a way that's </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorPointerv.</para>
        /// <para>Fullname: ColorPointervINTEL</para>
        /// <para>Extensions: INTEL_parallel_arrays</para>
        /// </summary>
        public static void ColorPointerv(int size, int type, IntPtr pointer)
        {
            if (gl._ColorPointerv != null) gl._ColorPointerv(size, type, pointer); else { }
        }
        /// <summary>
        /// <para>Fullname: NormalPointervINTEL</para>
        /// </summary>
        [GLEntry("NormalPointervINTEL", Category = "INTEL")]
        public static GLDelegate.NormalPointerv _NormalPointerv = null;
        /// <summary>
        /// <para>This extension adds the ability to format vertex arrays in a way that's </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NormalPointerv.</para>
        /// <para>Fullname: NormalPointervINTEL</para>
        /// <para>Extensions: INTEL_parallel_arrays</para>
        /// </summary>
        public static void NormalPointerv(int type, IntPtr pointer)
        {
            if (gl._NormalPointerv != null) gl._NormalPointerv(type, pointer); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoordPointervINTEL</para>
        /// </summary>
        [GLEntry("TexCoordPointervINTEL", Category = "INTEL")]
        public static GLDelegate.TexCoordPointerv _TexCoordPointerv = null;
        /// <summary>
        /// <para>This extension adds the ability to format vertex arrays in a way that's </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoordPointerv.</para>
        /// <para>Fullname: TexCoordPointervINTEL</para>
        /// <para>Extensions: INTEL_parallel_arrays</para>
        /// </summary>
        public static void TexCoordPointerv(int size, int type, IntPtr pointer)
        {
            if (gl._TexCoordPointerv != null) gl._TexCoordPointerv(size, type, pointer); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexPointervINTEL</para>
        /// </summary>
        [GLEntry("VertexPointervINTEL", Category = "INTEL")]
        public static GLDelegate.VertexPointerv _VertexPointerv = null;
        /// <summary>
        /// <para>This extension adds the ability to format vertex arrays in a way that's </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexPointerv.</para>
        /// <para>Fullname: VertexPointervINTEL</para>
        /// <para>Extensions: INTEL_parallel_arrays</para>
        /// </summary>
        public static void VertexPointerv(int size, int type, IntPtr pointer)
        {
            if (gl._VertexPointerv != null) gl._VertexPointerv(size, type, pointer); else { }
        }
        /// <summary>
        /// <para>Fullname: FinishTextureSUNX</para>
        /// </summary>
        [GLEntry("FinishTextureSUNX", Category = "SUNX")]
        public static GLDelegate.FinishTexture _FinishTexture = null;
        /// <summary>
        /// <para>This extension allows the pixel data specified by the application to be used internally without making a second copy. This extension affects how the pixel data in client memory is interpreted and therefore affects DrawPixels, Bitmap, PolygonStipple, TexImage1D, TexImage2D, TexImage3DEXT, ColorTableSGI. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FinishTexture.</para>
        /// <para>Fullname: FinishTextureSUNX</para>
        /// <para>Extensions: SUNX_constant_data</para>
        /// </summary>
        public static void FinishTexture()
        {
            if (gl._FinishTexture != null) gl._FinishTexture(); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3fVertex3fSUN</para>
        /// </summary>
        [GLEntry("Color3fVertex3fSUN", Category = "SUN")]
        public static GLDelegate.Color3fVertex3f _Color3fVertex3f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3fVertex3f.</para>
        /// <para>Fullname: Color3fVertex3fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void Color3fVertex3f(float r, float g, float b, float x, float y, float z)
        {
            if (gl._Color3fVertex3f != null) gl._Color3fVertex3f(r, g, b, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3fVertex3fvSUN</para>
        /// </summary>
        [GLEntry("Color3fVertex3fvSUN", Category = "SUN")]
        public static GLDelegate.Color3fVertex3fv _Color3fVertex3fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3fVertex3fv.</para>
        /// <para>Fullname: Color3fVertex3fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void Color3fVertex3fv(float[] c, float[] v)
        {
            if (gl._Color3fVertex3fv != null) gl._Color3fVertex3fv(c, v); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4fNormal3fVertex3fSUN</para>
        /// </summary>
        [GLEntry("Color4fNormal3fVertex3fSUN", Category = "SUN")]
        public static GLDelegate.Color4fNormal3fVertex3f _Color4fNormal3fVertex3f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4fNormal3fVertex3f.</para>
        /// <para>Fullname: Color4fNormal3fVertex3fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void Color4fNormal3fVertex3f(float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z)
        {
            if (gl._Color4fNormal3fVertex3f != null) gl._Color4fNormal3fVertex3f(r, g, b, a, nx, ny, nz, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4fNormal3fVertex3fvSUN</para>
        /// </summary>
        [GLEntry("Color4fNormal3fVertex3fvSUN", Category = "SUN")]
        public static GLDelegate.Color4fNormal3fVertex3fv _Color4fNormal3fVertex3fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4fNormal3fVertex3fv.</para>
        /// <para>Fullname: Color4fNormal3fVertex3fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void Color4fNormal3fVertex3fv(float[] c, float[] n, float[] v)
        {
            if (gl._Color4fNormal3fVertex3fv != null) gl._Color4fNormal3fVertex3fv(c, n, v); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4ubVertex2fSUN</para>
        /// </summary>
        [GLEntry("Color4ubVertex2fSUN", Category = "SUN")]
        public static GLDelegate.Color4ubVertex2f _Color4ubVertex2f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4ubVertex2f.</para>
        /// <para>Fullname: Color4ubVertex2fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void Color4ubVertex2f(byte r, byte g, byte b, byte a, float x, float y)
        {
            if (gl._Color4ubVertex2f != null) gl._Color4ubVertex2f(r, g, b, a, x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4ubVertex2fvSUN</para>
        /// </summary>
        [GLEntry("Color4ubVertex2fvSUN", Category = "SUN")]
        public static GLDelegate.Color4ubVertex2fv _Color4ubVertex2fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4ubVertex2fv.</para>
        /// <para>Fullname: Color4ubVertex2fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void Color4ubVertex2fv(byte[] c, float[] v)
        {
            if (gl._Color4ubVertex2fv != null) gl._Color4ubVertex2fv(c, v); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4ubVertex3fSUN</para>
        /// </summary>
        [GLEntry("Color4ubVertex3fSUN", Category = "SUN")]
        public static GLDelegate.Color4ubVertex3f _Color4ubVertex3f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4ubVertex3f.</para>
        /// <para>Fullname: Color4ubVertex3fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void Color4ubVertex3f(byte r, byte g, byte b, byte a, float x, float y, float z)
        {
            if (gl._Color4ubVertex3f != null) gl._Color4ubVertex3f(r, g, b, a, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4ubVertex3fvSUN</para>
        /// </summary>
        [GLEntry("Color4ubVertex3fvSUN", Category = "SUN")]
        public static GLDelegate.Color4ubVertex3fv _Color4ubVertex3fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4ubVertex3fv.</para>
        /// <para>Fullname: Color4ubVertex3fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void Color4ubVertex3fv(byte[] c, float[] v)
        {
            if (gl._Color4ubVertex3fv != null) gl._Color4ubVertex3fv(c, v); else { }
        }
        /// <summary>
        /// <para>Fullname: DrawMeshArraysSUN</para>
        /// </summary>
        [GLEntry("DrawMeshArraysSUN", Category = "SUN")]
        public static GLDelegate.DrawMeshArrays _DrawMeshArrays = null;
        /// <summary>
        /// <para>This extension defines a new mesh primitive. The primitive can only be used with vertex arrays and cannot be used in immediate mode. The application must arrange the vertices in row major format. For example if a quad mesh is 4 vertices wide the, vertices in the first row are the first 4 vertices and vertices in the second row are vertices 5 through 8. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawMeshArrays.</para>
        /// <para>Fullname: DrawMeshArraysSUN</para>
        /// <para>Extensions: SUN_mesh_array</para>
        /// </summary>
        public static void DrawMeshArrays(int mode, int first, int count, int width)
        {
            if (gl._DrawMeshArrays != null) gl._DrawMeshArrays(mode, first, count, width); else { }
        }
        /// <summary>
        /// <para>Fullname: GlobalAlphaFactorbSUN</para>
        /// </summary>
        [GLEntry("GlobalAlphaFactorbSUN", Category = "SUN")]
        public static GLDelegate.GlobalAlphaFactorb _GlobalAlphaFactorb = null;
        /// <summary>
        /// <para>Transparency is done in OpenGL using alpha blending. An alpha value of 0.0 is used for fully transparent objects, while an alpha value of 1.0 is used for fully opaque objects.  A value of 0.25 is 75% transparent, and so on. OpenGL defines alpha as a component of the vertex color state. Whenever a color is set, the alpha component is set along with the red, green, and blue components.  This means that transparency can't be changed for primitives with per-vertex colors without modifying the color of each vertex, replacing the old alpha component with the new alpha component.  This can be very expensive for objects that are drawn using vertex arrays; it all but precludes the use of display lists. This extension defines a new global alpha attribute that can be used to specify an alpha factor that is independent from the alpha component of the color value.  The global alpha factor is multiplied by the fragment's alpha value after primitive rasterization and prior to texture mapping, replaci...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GlobalAlphaFactorb.</para>
        /// <para>Fullname: GlobalAlphaFactorbSUN</para>
        /// <para>Extensions: SUN_global_alpha</para>
        /// </summary>
        public static void GlobalAlphaFactorb(byte factor)
        {
            if (gl._GlobalAlphaFactorb != null) gl._GlobalAlphaFactorb(factor); else { }
        }
        /// <summary>
        /// <para>Fullname: GlobalAlphaFactordSUN</para>
        /// </summary>
        [GLEntry("GlobalAlphaFactordSUN", Category = "SUN")]
        public static GLDelegate.GlobalAlphaFactord _GlobalAlphaFactord = null;
        /// <summary>
        /// <para>Transparency is done in OpenGL using alpha blending. An alpha value of 0.0 is used for fully transparent objects, while an alpha value of 1.0 is used for fully opaque objects.  A value of 0.25 is 75% transparent, and so on. OpenGL defines alpha as a component of the vertex color state. Whenever a color is set, the alpha component is set along with the red, green, and blue components.  This means that transparency can't be changed for primitives with per-vertex colors without modifying the color of each vertex, replacing the old alpha component with the new alpha component.  This can be very expensive for objects that are drawn using vertex arrays; it all but precludes the use of display lists. This extension defines a new global alpha attribute that can be used to specify an alpha factor that is independent from the alpha component of the color value.  The global alpha factor is multiplied by the fragment's alpha value after primitive rasterization and prior to texture mapping, replaci...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GlobalAlphaFactord.</para>
        /// <para>Fullname: GlobalAlphaFactordSUN</para>
        /// <para>Extensions: SUN_global_alpha</para>
        /// </summary>
        public static void GlobalAlphaFactord(double factor)
        {
            if (gl._GlobalAlphaFactord != null) gl._GlobalAlphaFactord(factor); else { }
        }
        /// <summary>
        /// <para>Fullname: GlobalAlphaFactorfSUN</para>
        /// </summary>
        [GLEntry("GlobalAlphaFactorfSUN", Category = "SUN")]
        public static GLDelegate.GlobalAlphaFactorf _GlobalAlphaFactorf = null;
        /// <summary>
        /// <para>Transparency is done in OpenGL using alpha blending. An alpha value of 0.0 is used for fully transparent objects, while an alpha value of 1.0 is used for fully opaque objects.  A value of 0.25 is 75% transparent, and so on. OpenGL defines alpha as a component of the vertex color state. Whenever a color is set, the alpha component is set along with the red, green, and blue components.  This means that transparency can't be changed for primitives with per-vertex colors without modifying the color of each vertex, replacing the old alpha component with the new alpha component.  This can be very expensive for objects that are drawn using vertex arrays; it all but precludes the use of display lists. This extension defines a new global alpha attribute that can be used to specify an alpha factor that is independent from the alpha component of the color value.  The global alpha factor is multiplied by the fragment's alpha value after primitive rasterization and prior to texture mapping, replaci...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GlobalAlphaFactorf.</para>
        /// <para>Fullname: GlobalAlphaFactorfSUN</para>
        /// <para>Extensions: SUN_global_alpha</para>
        /// </summary>
        public static void GlobalAlphaFactorf(float factor)
        {
            if (gl._GlobalAlphaFactorf != null) gl._GlobalAlphaFactorf(factor); else { }
        }
        /// <summary>
        /// <para>Fullname: GlobalAlphaFactoriSUN</para>
        /// </summary>
        [GLEntry("GlobalAlphaFactoriSUN", Category = "SUN")]
        public static GLDelegate.GlobalAlphaFactori _GlobalAlphaFactori = null;
        /// <summary>
        /// <para>Transparency is done in OpenGL using alpha blending. An alpha value of 0.0 is used for fully transparent objects, while an alpha value of 1.0 is used for fully opaque objects.  A value of 0.25 is 75% transparent, and so on. OpenGL defines alpha as a component of the vertex color state. Whenever a color is set, the alpha component is set along with the red, green, and blue components.  This means that transparency can't be changed for primitives with per-vertex colors without modifying the color of each vertex, replacing the old alpha component with the new alpha component.  This can be very expensive for objects that are drawn using vertex arrays; it all but precludes the use of display lists. This extension defines a new global alpha attribute that can be used to specify an alpha factor that is independent from the alpha component of the color value.  The global alpha factor is multiplied by the fragment's alpha value after primitive rasterization and prior to texture mapping, replaci...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GlobalAlphaFactori.</para>
        /// <para>Fullname: GlobalAlphaFactoriSUN</para>
        /// <para>Extensions: SUN_global_alpha</para>
        /// </summary>
        public static void GlobalAlphaFactori(int factor)
        {
            if (gl._GlobalAlphaFactori != null) gl._GlobalAlphaFactori(factor); else { }
        }
        /// <summary>
        /// <para>Fullname: GlobalAlphaFactorsSUN</para>
        /// </summary>
        [GLEntry("GlobalAlphaFactorsSUN", Category = "SUN")]
        public static GLDelegate.GlobalAlphaFactors _GlobalAlphaFactors = null;
        /// <summary>
        /// <para>Transparency is done in OpenGL using alpha blending. An alpha value of 0.0 is used for fully transparent objects, while an alpha value of 1.0 is used for fully opaque objects.  A value of 0.25 is 75% transparent, and so on. OpenGL defines alpha as a component of the vertex color state. Whenever a color is set, the alpha component is set along with the red, green, and blue components.  This means that transparency can't be changed for primitives with per-vertex colors without modifying the color of each vertex, replacing the old alpha component with the new alpha component.  This can be very expensive for objects that are drawn using vertex arrays; it all but precludes the use of display lists. This extension defines a new global alpha attribute that can be used to specify an alpha factor that is independent from the alpha component of the color value.  The global alpha factor is multiplied by the fragment's alpha value after primitive rasterization and prior to texture mapping, replaci...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GlobalAlphaFactors.</para>
        /// <para>Fullname: GlobalAlphaFactorsSUN</para>
        /// <para>Extensions: SUN_global_alpha</para>
        /// </summary>
        public static void GlobalAlphaFactors(short factor)
        {
            if (gl._GlobalAlphaFactors != null) gl._GlobalAlphaFactors(factor); else { }
        }
        /// <summary>
        /// <para>Fullname: GlobalAlphaFactorubSUN</para>
        /// </summary>
        [GLEntry("GlobalAlphaFactorubSUN", Category = "SUN")]
        public static GLDelegate.GlobalAlphaFactorub _GlobalAlphaFactorub = null;
        /// <summary>
        /// <para>Transparency is done in OpenGL using alpha blending. An alpha value of 0.0 is used for fully transparent objects, while an alpha value of 1.0 is used for fully opaque objects.  A value of 0.25 is 75% transparent, and so on. OpenGL defines alpha as a component of the vertex color state. Whenever a color is set, the alpha component is set along with the red, green, and blue components.  This means that transparency can't be changed for primitives with per-vertex colors without modifying the color of each vertex, replacing the old alpha component with the new alpha component.  This can be very expensive for objects that are drawn using vertex arrays; it all but precludes the use of display lists. This extension defines a new global alpha attribute that can be used to specify an alpha factor that is independent from the alpha component of the color value.  The global alpha factor is multiplied by the fragment's alpha value after primitive rasterization and prior to texture mapping, replaci...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GlobalAlphaFactorub.</para>
        /// <para>Fullname: GlobalAlphaFactorubSUN</para>
        /// <para>Extensions: SUN_global_alpha</para>
        /// </summary>
        public static void GlobalAlphaFactorub(byte factor)
        {
            if (gl._GlobalAlphaFactorub != null) gl._GlobalAlphaFactorub(factor); else { }
        }
        /// <summary>
        /// <para>Fullname: GlobalAlphaFactoruiSUN</para>
        /// </summary>
        [GLEntry("GlobalAlphaFactoruiSUN", Category = "SUN")]
        public static GLDelegate.GlobalAlphaFactorui _GlobalAlphaFactorui = null;
        /// <summary>
        /// <para>Transparency is done in OpenGL using alpha blending. An alpha value of 0.0 is used for fully transparent objects, while an alpha value of 1.0 is used for fully opaque objects.  A value of 0.25 is 75% transparent, and so on. OpenGL defines alpha as a component of the vertex color state. Whenever a color is set, the alpha component is set along with the red, green, and blue components.  This means that transparency can't be changed for primitives with per-vertex colors without modifying the color of each vertex, replacing the old alpha component with the new alpha component.  This can be very expensive for objects that are drawn using vertex arrays; it all but precludes the use of display lists. This extension defines a new global alpha attribute that can be used to specify an alpha factor that is independent from the alpha component of the color value.  The global alpha factor is multiplied by the fragment's alpha value after primitive rasterization and prior to texture mapping, replaci...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GlobalAlphaFactorui.</para>
        /// <para>Fullname: GlobalAlphaFactoruiSUN</para>
        /// <para>Extensions: SUN_global_alpha</para>
        /// </summary>
        public static void GlobalAlphaFactorui(uint factor)
        {
            if (gl._GlobalAlphaFactorui != null) gl._GlobalAlphaFactorui(factor); else { }
        }
        /// <summary>
        /// <para>Fullname: GlobalAlphaFactorusSUN</para>
        /// </summary>
        [GLEntry("GlobalAlphaFactorusSUN", Category = "SUN")]
        public static GLDelegate.GlobalAlphaFactorus _GlobalAlphaFactorus = null;
        /// <summary>
        /// <para>Transparency is done in OpenGL using alpha blending. An alpha value of 0.0 is used for fully transparent objects, while an alpha value of 1.0 is used for fully opaque objects.  A value of 0.25 is 75% transparent, and so on. OpenGL defines alpha as a component of the vertex color state. Whenever a color is set, the alpha component is set along with the red, green, and blue components.  This means that transparency can't be changed for primitives with per-vertex colors without modifying the color of each vertex, replacing the old alpha component with the new alpha component.  This can be very expensive for objects that are drawn using vertex arrays; it all but precludes the use of display lists. This extension defines a new global alpha attribute that can be used to specify an alpha factor that is independent from the alpha component of the color value.  The global alpha factor is multiplied by the fragment's alpha value after primitive rasterization and prior to texture mapping, replaci...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GlobalAlphaFactorus.</para>
        /// <para>Fullname: GlobalAlphaFactorusSUN</para>
        /// <para>Extensions: SUN_global_alpha</para>
        /// </summary>
        public static void GlobalAlphaFactorus(ushort factor)
        {
            if (gl._GlobalAlphaFactorus != null) gl._GlobalAlphaFactorus(factor); else { }
        }
        /// <summary>
        /// <para>Fullname: Normal3fVertex3fSUN</para>
        /// </summary>
        [GLEntry("Normal3fVertex3fSUN", Category = "SUN")]
        public static GLDelegate.Normal3fVertex3f _Normal3fVertex3f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Normal3fVertex3f.</para>
        /// <para>Fullname: Normal3fVertex3fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void Normal3fVertex3f(float nx, float ny, float nz, float x, float y, float z)
        {
            if (gl._Normal3fVertex3f != null) gl._Normal3fVertex3f(nx, ny, nz, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: Normal3fVertex3fvSUN</para>
        /// </summary>
        [GLEntry("Normal3fVertex3fvSUN", Category = "SUN")]
        public static GLDelegate.Normal3fVertex3fv _Normal3fVertex3fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Normal3fVertex3fv.</para>
        /// <para>Fullname: Normal3fVertex3fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void Normal3fVertex3fv(float[] n, float[] v)
        {
            if (gl._Normal3fVertex3fv != null) gl._Normal3fVertex3fv(n, v); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodePointerSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodePointerSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodePointer _ReplacementCodePointer = null;
        /// <summary>
        /// <para>OpenGL has two chained triangle primitives, TRIANGLE_STRIP and TRIANGLE_FAN.  For multiple, consecutive triangle strips or triangle fans, the overhead of Begin and End, or separate calls to DrawArrays, can be significant depending on the number of triangles per strip or fan. Many surface tessellators produce triangle strips with very few triangles per strip before needing to restart a new strip.  Even sophisticated tessellators typically need to restart a new strip, or switch from a triangle strip to a triangle fan, many times within a single object.  Such tessellators can often produce a more efficient tessellation--one with fewer vertices--by mixing strips and fans within the same object.  The ability to switch from one to the other without restarting the strip or fan yields even more savings.  Unfortunately, the overhead of switching from a triangle strip to a triangle fan, or vice versa, can reduce, or even eliminate the benefit gained from reducing the number of vertices. A new tr...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodePointer.</para>
        /// <para>Fullname: ReplacementCodePointerSUN</para>
        /// <para>Extensions: SUN_triangle_list</para>
        /// </summary>
        public static void ReplacementCodePointer(int type, int stride, IntPtr pointer)
        {
            if (gl._ReplacementCodePointer != null) gl._ReplacementCodePointer(type, stride, pointer); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeubSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeubSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeub _ReplacementCodeub = null;
        /// <summary>
        /// <para>OpenGL has two chained triangle primitives, TRIANGLE_STRIP and TRIANGLE_FAN.  For multiple, consecutive triangle strips or triangle fans, the overhead of Begin and End, or separate calls to DrawArrays, can be significant depending on the number of triangles per strip or fan. Many surface tessellators produce triangle strips with very few triangles per strip before needing to restart a new strip.  Even sophisticated tessellators typically need to restart a new strip, or switch from a triangle strip to a triangle fan, many times within a single object.  Such tessellators can often produce a more efficient tessellation--one with fewer vertices--by mixing strips and fans within the same object.  The ability to switch from one to the other without restarting the strip or fan yields even more savings.  Unfortunately, the overhead of switching from a triangle strip to a triangle fan, or vice versa, can reduce, or even eliminate the benefit gained from reducing the number of vertices. A new tr...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeub.</para>
        /// <para>Fullname: ReplacementCodeubSUN</para>
        /// <para>Extensions: SUN_triangle_list</para>
        /// </summary>
        public static void ReplacementCodeub(byte code)
        {
            if (gl._ReplacementCodeub != null) gl._ReplacementCodeub(code); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeubvSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeubvSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeubv _ReplacementCodeubv = null;
        /// <summary>
        /// <para>OpenGL has two chained triangle primitives, TRIANGLE_STRIP and TRIANGLE_FAN.  For multiple, consecutive triangle strips or triangle fans, the overhead of Begin and End, or separate calls to DrawArrays, can be significant depending on the number of triangles per strip or fan. Many surface tessellators produce triangle strips with very few triangles per strip before needing to restart a new strip.  Even sophisticated tessellators typically need to restart a new strip, or switch from a triangle strip to a triangle fan, many times within a single object.  Such tessellators can often produce a more efficient tessellation--one with fewer vertices--by mixing strips and fans within the same object.  The ability to switch from one to the other without restarting the strip or fan yields even more savings.  Unfortunately, the overhead of switching from a triangle strip to a triangle fan, or vice versa, can reduce, or even eliminate the benefit gained from reducing the number of vertices. A new tr...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeubv.</para>
        /// <para>Fullname: ReplacementCodeubvSUN</para>
        /// <para>Extensions: SUN_triangle_list</para>
        /// </summary>
        public static void ReplacementCodeubv(byte[] code)
        {
            if (gl._ReplacementCodeubv != null) gl._ReplacementCodeubv(code); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeuiSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeuiSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeui _ReplacementCodeui = null;
        /// <summary>
        /// <para>OpenGL has two chained triangle primitives, TRIANGLE_STRIP and TRIANGLE_FAN.  For multiple, consecutive triangle strips or triangle fans, the overhead of Begin and End, or separate calls to DrawArrays, can be significant depending on the number of triangles per strip or fan. Many surface tessellators produce triangle strips with very few triangles per strip before needing to restart a new strip.  Even sophisticated tessellators typically need to restart a new strip, or switch from a triangle strip to a triangle fan, many times within a single object.  Such tessellators can often produce a more efficient tessellation--one with fewer vertices--by mixing strips and fans within the same object.  The ability to switch from one to the other without restarting the strip or fan yields even more savings.  Unfortunately, the overhead of switching from a triangle strip to a triangle fan, or vice versa, can reduce, or even eliminate the benefit gained from reducing the number of vertices. A new tr...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeui.</para>
        /// <para>Fullname: ReplacementCodeuiSUN</para>
        /// <para>Extensions: SUN_triangle_list</para>
        /// </summary>
        public static void ReplacementCodeui(uint code)
        {
            if (gl._ReplacementCodeui != null) gl._ReplacementCodeui(code); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeuiColor3fVertex3fSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeuiColor3fVertex3fSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeuiColor3fVertex3f _ReplacementCodeuiColor3fVertex3f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeuiColor3fVertex3f.</para>
        /// <para>Fullname: ReplacementCodeuiColor3fVertex3fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void ReplacementCodeuiColor3fVertex3f(uint rc, float r, float g, float b, float x, float y, float z)
        {
            if (gl._ReplacementCodeuiColor3fVertex3f != null) gl._ReplacementCodeuiColor3fVertex3f(rc, r, g, b, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeuiColor3fVertex3fvSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeuiColor3fVertex3fvSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeuiColor3fVertex3fv _ReplacementCodeuiColor3fVertex3fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeuiColor3fVertex3fv.</para>
        /// <para>Fullname: ReplacementCodeuiColor3fVertex3fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void ReplacementCodeuiColor3fVertex3fv(uint[] rc, float[] c, float[] v)
        {
            if (gl._ReplacementCodeuiColor3fVertex3fv != null) gl._ReplacementCodeuiColor3fVertex3fv(rc, c, v); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeuiColor4fNormal3fVertex3fSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeuiColor4fNormal3fVertex3fSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeuiColor4fNormal3fVertex3f _ReplacementCodeuiColor4fNormal3fVertex3f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeuiColor4fNormal3fVertex3f.</para>
        /// <para>Fullname: ReplacementCodeuiColor4fNormal3fVertex3fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void ReplacementCodeuiColor4fNormal3fVertex3f(uint rc, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z)
        {
            if (gl._ReplacementCodeuiColor4fNormal3fVertex3f != null) gl._ReplacementCodeuiColor4fNormal3fVertex3f(rc, r, g, b, a, nx, ny, nz, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeuiColor4fNormal3fVertex3fvSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeuiColor4fNormal3fVertex3fvSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeuiColor4fNormal3fVertex3fv _ReplacementCodeuiColor4fNormal3fVertex3fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeuiColor4fNormal3fVertex3fv.</para>
        /// <para>Fullname: ReplacementCodeuiColor4fNormal3fVertex3fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void ReplacementCodeuiColor4fNormal3fVertex3fv(uint[] rc, float[] c, float[] n, float[] v)
        {
            if (gl._ReplacementCodeuiColor4fNormal3fVertex3fv != null) gl._ReplacementCodeuiColor4fNormal3fVertex3fv(rc, c, n, v); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeuiColor4ubVertex3fSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeuiColor4ubVertex3fSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeuiColor4ubVertex3f _ReplacementCodeuiColor4ubVertex3f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeuiColor4ubVertex3f.</para>
        /// <para>Fullname: ReplacementCodeuiColor4ubVertex3fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void ReplacementCodeuiColor4ubVertex3f(uint rc, byte r, byte g, byte b, byte a, float x, float y, float z)
        {
            if (gl._ReplacementCodeuiColor4ubVertex3f != null) gl._ReplacementCodeuiColor4ubVertex3f(rc, r, g, b, a, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeuiColor4ubVertex3fvSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeuiColor4ubVertex3fvSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeuiColor4ubVertex3fv _ReplacementCodeuiColor4ubVertex3fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeuiColor4ubVertex3fv.</para>
        /// <para>Fullname: ReplacementCodeuiColor4ubVertex3fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void ReplacementCodeuiColor4ubVertex3fv(uint[] rc, byte[] c, float[] v)
        {
            if (gl._ReplacementCodeuiColor4ubVertex3fv != null) gl._ReplacementCodeuiColor4ubVertex3fv(rc, c, v); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeuiNormal3fVertex3fSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeuiNormal3fVertex3fSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeuiNormal3fVertex3f _ReplacementCodeuiNormal3fVertex3f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeuiNormal3fVertex3f.</para>
        /// <para>Fullname: ReplacementCodeuiNormal3fVertex3fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void ReplacementCodeuiNormal3fVertex3f(uint rc, float nx, float ny, float nz, float x, float y, float z)
        {
            if (gl._ReplacementCodeuiNormal3fVertex3f != null) gl._ReplacementCodeuiNormal3fVertex3f(rc, nx, ny, nz, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeuiNormal3fVertex3fvSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeuiNormal3fVertex3fvSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeuiNormal3fVertex3fv _ReplacementCodeuiNormal3fVertex3fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeuiNormal3fVertex3fv.</para>
        /// <para>Fullname: ReplacementCodeuiNormal3fVertex3fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void ReplacementCodeuiNormal3fVertex3fv(uint[] rc, float[] n, float[] v)
        {
            if (gl._ReplacementCodeuiNormal3fVertex3fv != null) gl._ReplacementCodeuiNormal3fVertex3fv(rc, n, v); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3f _ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3f.</para>
        /// <para>Fullname: ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3f(uint rc, float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z)
        {
            if (gl._ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3f != null) gl._ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3f(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fv _ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fv.</para>
        /// <para>Fullname: ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fv(uint[] rc, float[] tc, float[] c, float[] n, float[] v)
        {
            if (gl._ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fv != null) gl._ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fv(rc, tc, c, n, v); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeuiTexCoord2fNormal3fVertex3f _ReplacementCodeuiTexCoord2fNormal3fVertex3f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeuiTexCoord2fNormal3fVertex3f.</para>
        /// <para>Fullname: ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void ReplacementCodeuiTexCoord2fNormal3fVertex3f(uint rc, float s, float t, float nx, float ny, float nz, float x, float y, float z)
        {
            if (gl._ReplacementCodeuiTexCoord2fNormal3fVertex3f != null) gl._ReplacementCodeuiTexCoord2fNormal3fVertex3f(rc, s, t, nx, ny, nz, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeuiTexCoord2fNormal3fVertex3fv _ReplacementCodeuiTexCoord2fNormal3fVertex3fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeuiTexCoord2fNormal3fVertex3fv.</para>
        /// <para>Fullname: ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void ReplacementCodeuiTexCoord2fNormal3fVertex3fv(uint[] rc, float[] tc, float[] n, float[] v)
        {
            if (gl._ReplacementCodeuiTexCoord2fNormal3fVertex3fv != null) gl._ReplacementCodeuiTexCoord2fNormal3fVertex3fv(rc, tc, n, v); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeuiTexCoord2fVertex3fSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeuiTexCoord2fVertex3fSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeuiTexCoord2fVertex3f _ReplacementCodeuiTexCoord2fVertex3f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeuiTexCoord2fVertex3f.</para>
        /// <para>Fullname: ReplacementCodeuiTexCoord2fVertex3fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void ReplacementCodeuiTexCoord2fVertex3f(uint rc, float s, float t, float x, float y, float z)
        {
            if (gl._ReplacementCodeuiTexCoord2fVertex3f != null) gl._ReplacementCodeuiTexCoord2fVertex3f(rc, s, t, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeuiTexCoord2fVertex3fvSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeuiTexCoord2fVertex3fvSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeuiTexCoord2fVertex3fv _ReplacementCodeuiTexCoord2fVertex3fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeuiTexCoord2fVertex3fv.</para>
        /// <para>Fullname: ReplacementCodeuiTexCoord2fVertex3fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void ReplacementCodeuiTexCoord2fVertex3fv(uint[] rc, float[] tc, float[] v)
        {
            if (gl._ReplacementCodeuiTexCoord2fVertex3fv != null) gl._ReplacementCodeuiTexCoord2fVertex3fv(rc, tc, v); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeuivSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeuivSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeuiv _ReplacementCodeuiv = null;
        /// <summary>
        /// <para>OpenGL has two chained triangle primitives, TRIANGLE_STRIP and TRIANGLE_FAN.  For multiple, consecutive triangle strips or triangle fans, the overhead of Begin and End, or separate calls to DrawArrays, can be significant depending on the number of triangles per strip or fan. Many surface tessellators produce triangle strips with very few triangles per strip before needing to restart a new strip.  Even sophisticated tessellators typically need to restart a new strip, or switch from a triangle strip to a triangle fan, many times within a single object.  Such tessellators can often produce a more efficient tessellation--one with fewer vertices--by mixing strips and fans within the same object.  The ability to switch from one to the other without restarting the strip or fan yields even more savings.  Unfortunately, the overhead of switching from a triangle strip to a triangle fan, or vice versa, can reduce, or even eliminate the benefit gained from reducing the number of vertices. A new tr...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeuiv.</para>
        /// <para>Fullname: ReplacementCodeuivSUN</para>
        /// <para>Extensions: SUN_triangle_list</para>
        /// </summary>
        public static void ReplacementCodeuiv(uint[] code)
        {
            if (gl._ReplacementCodeuiv != null) gl._ReplacementCodeuiv(code); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeuiVertex3fSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeuiVertex3fSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeuiVertex3f _ReplacementCodeuiVertex3f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeuiVertex3f.</para>
        /// <para>Fullname: ReplacementCodeuiVertex3fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void ReplacementCodeuiVertex3f(uint rc, float x, float y, float z)
        {
            if (gl._ReplacementCodeuiVertex3f != null) gl._ReplacementCodeuiVertex3f(rc, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeuiVertex3fvSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeuiVertex3fvSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeuiVertex3fv _ReplacementCodeuiVertex3fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeuiVertex3fv.</para>
        /// <para>Fullname: ReplacementCodeuiVertex3fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void ReplacementCodeuiVertex3fv(uint[] rc, float[] v)
        {
            if (gl._ReplacementCodeuiVertex3fv != null) gl._ReplacementCodeuiVertex3fv(rc, v); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeusSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeusSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeus _ReplacementCodeus = null;
        /// <summary>
        /// <para>OpenGL has two chained triangle primitives, TRIANGLE_STRIP and TRIANGLE_FAN.  For multiple, consecutive triangle strips or triangle fans, the overhead of Begin and End, or separate calls to DrawArrays, can be significant depending on the number of triangles per strip or fan. Many surface tessellators produce triangle strips with very few triangles per strip before needing to restart a new strip.  Even sophisticated tessellators typically need to restart a new strip, or switch from a triangle strip to a triangle fan, many times within a single object.  Such tessellators can often produce a more efficient tessellation--one with fewer vertices--by mixing strips and fans within the same object.  The ability to switch from one to the other without restarting the strip or fan yields even more savings.  Unfortunately, the overhead of switching from a triangle strip to a triangle fan, or vice versa, can reduce, or even eliminate the benefit gained from reducing the number of vertices. A new tr...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeus.</para>
        /// <para>Fullname: ReplacementCodeusSUN</para>
        /// <para>Extensions: SUN_triangle_list</para>
        /// </summary>
        public static void ReplacementCodeus(ushort code)
        {
            if (gl._ReplacementCodeus != null) gl._ReplacementCodeus(code); else { }
        }
        /// <summary>
        /// <para>Fullname: ReplacementCodeusvSUN</para>
        /// </summary>
        [GLEntry("ReplacementCodeusvSUN", Category = "SUN")]
        public static GLDelegate.ReplacementCodeusv _ReplacementCodeusv = null;
        /// <summary>
        /// <para>OpenGL has two chained triangle primitives, TRIANGLE_STRIP and TRIANGLE_FAN.  For multiple, consecutive triangle strips or triangle fans, the overhead of Begin and End, or separate calls to DrawArrays, can be significant depending on the number of triangles per strip or fan. Many surface tessellators produce triangle strips with very few triangles per strip before needing to restart a new strip.  Even sophisticated tessellators typically need to restart a new strip, or switch from a triangle strip to a triangle fan, many times within a single object.  Such tessellators can often produce a more efficient tessellation--one with fewer vertices--by mixing strips and fans within the same object.  The ability to switch from one to the other without restarting the strip or fan yields even more savings.  Unfortunately, the overhead of switching from a triangle strip to a triangle fan, or vice versa, can reduce, or even eliminate the benefit gained from reducing the number of vertices. A new tr...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ReplacementCodeusv.</para>
        /// <para>Fullname: ReplacementCodeusvSUN</para>
        /// <para>Extensions: SUN_triangle_list</para>
        /// </summary>
        public static void ReplacementCodeusv(ushort[] code)
        {
            if (gl._ReplacementCodeusv != null) gl._ReplacementCodeusv(code); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2fColor3fVertex3fSUN</para>
        /// </summary>
        [GLEntry("TexCoord2fColor3fVertex3fSUN", Category = "SUN")]
        public static GLDelegate.TexCoord2fColor3fVertex3f _TexCoord2fColor3fVertex3f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2fColor3fVertex3f.</para>
        /// <para>Fullname: TexCoord2fColor3fVertex3fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void TexCoord2fColor3fVertex3f(float s, float t, float r, float g, float b, float x, float y, float z)
        {
            if (gl._TexCoord2fColor3fVertex3f != null) gl._TexCoord2fColor3fVertex3f(s, t, r, g, b, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2fColor3fVertex3fvSUN</para>
        /// </summary>
        [GLEntry("TexCoord2fColor3fVertex3fvSUN", Category = "SUN")]
        public static GLDelegate.TexCoord2fColor3fVertex3fv _TexCoord2fColor3fVertex3fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2fColor3fVertex3fv.</para>
        /// <para>Fullname: TexCoord2fColor3fVertex3fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void TexCoord2fColor3fVertex3fv(float[] tc, float[] c, float[] v)
        {
            if (gl._TexCoord2fColor3fVertex3fv != null) gl._TexCoord2fColor3fVertex3fv(tc, c, v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2fColor4fNormal3fVertex3fSUN</para>
        /// </summary>
        [GLEntry("TexCoord2fColor4fNormal3fVertex3fSUN", Category = "SUN")]
        public static GLDelegate.TexCoord2fColor4fNormal3fVertex3f _TexCoord2fColor4fNormal3fVertex3f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2fColor4fNormal3fVertex3f.</para>
        /// <para>Fullname: TexCoord2fColor4fNormal3fVertex3fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void TexCoord2fColor4fNormal3fVertex3f(float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z)
        {
            if (gl._TexCoord2fColor4fNormal3fVertex3f != null) gl._TexCoord2fColor4fNormal3fVertex3f(s, t, r, g, b, a, nx, ny, nz, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2fColor4fNormal3fVertex3fvSUN</para>
        /// </summary>
        [GLEntry("TexCoord2fColor4fNormal3fVertex3fvSUN", Category = "SUN")]
        public static GLDelegate.TexCoord2fColor4fNormal3fVertex3fv _TexCoord2fColor4fNormal3fVertex3fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2fColor4fNormal3fVertex3fv.</para>
        /// <para>Fullname: TexCoord2fColor4fNormal3fVertex3fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void TexCoord2fColor4fNormal3fVertex3fv(float[] tc, float[] c, float[] n, float[] v)
        {
            if (gl._TexCoord2fColor4fNormal3fVertex3fv != null) gl._TexCoord2fColor4fNormal3fVertex3fv(tc, c, n, v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2fColor4ubVertex3fSUN</para>
        /// </summary>
        [GLEntry("TexCoord2fColor4ubVertex3fSUN", Category = "SUN")]
        public static GLDelegate.TexCoord2fColor4ubVertex3f _TexCoord2fColor4ubVertex3f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2fColor4ubVertex3f.</para>
        /// <para>Fullname: TexCoord2fColor4ubVertex3fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void TexCoord2fColor4ubVertex3f(float s, float t, byte r, byte g, byte b, byte a, float x, float y, float z)
        {
            if (gl._TexCoord2fColor4ubVertex3f != null) gl._TexCoord2fColor4ubVertex3f(s, t, r, g, b, a, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2fColor4ubVertex3fvSUN</para>
        /// </summary>
        [GLEntry("TexCoord2fColor4ubVertex3fvSUN", Category = "SUN")]
        public static GLDelegate.TexCoord2fColor4ubVertex3fv _TexCoord2fColor4ubVertex3fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2fColor4ubVertex3fv.</para>
        /// <para>Fullname: TexCoord2fColor4ubVertex3fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void TexCoord2fColor4ubVertex3fv(float[] tc, byte[] c, float[] v)
        {
            if (gl._TexCoord2fColor4ubVertex3fv != null) gl._TexCoord2fColor4ubVertex3fv(tc, c, v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2fNormal3fVertex3fSUN</para>
        /// </summary>
        [GLEntry("TexCoord2fNormal3fVertex3fSUN", Category = "SUN")]
        public static GLDelegate.TexCoord2fNormal3fVertex3f _TexCoord2fNormal3fVertex3f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2fNormal3fVertex3f.</para>
        /// <para>Fullname: TexCoord2fNormal3fVertex3fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void TexCoord2fNormal3fVertex3f(float s, float t, float nx, float ny, float nz, float x, float y, float z)
        {
            if (gl._TexCoord2fNormal3fVertex3f != null) gl._TexCoord2fNormal3fVertex3f(s, t, nx, ny, nz, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2fNormal3fVertex3fvSUN</para>
        /// </summary>
        [GLEntry("TexCoord2fNormal3fVertex3fvSUN", Category = "SUN")]
        public static GLDelegate.TexCoord2fNormal3fVertex3fv _TexCoord2fNormal3fVertex3fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2fNormal3fVertex3fv.</para>
        /// <para>Fullname: TexCoord2fNormal3fVertex3fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void TexCoord2fNormal3fVertex3fv(float[] tc, float[] n, float[] v)
        {
            if (gl._TexCoord2fNormal3fVertex3fv != null) gl._TexCoord2fNormal3fVertex3fv(tc, n, v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2fVertex3fSUN</para>
        /// </summary>
        [GLEntry("TexCoord2fVertex3fSUN", Category = "SUN")]
        public static GLDelegate.TexCoord2fVertex3f _TexCoord2fVertex3f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2fVertex3f.</para>
        /// <para>Fullname: TexCoord2fVertex3fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void TexCoord2fVertex3f(float s, float t, float x, float y, float z)
        {
            if (gl._TexCoord2fVertex3f != null) gl._TexCoord2fVertex3f(s, t, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2fVertex3fvSUN</para>
        /// </summary>
        [GLEntry("TexCoord2fVertex3fvSUN", Category = "SUN")]
        public static GLDelegate.TexCoord2fVertex3fv _TexCoord2fVertex3fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2fVertex3fv.</para>
        /// <para>Fullname: TexCoord2fVertex3fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void TexCoord2fVertex3fv(float[] tc, float[] v)
        {
            if (gl._TexCoord2fVertex3fv != null) gl._TexCoord2fVertex3fv(tc, v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord4fColor4fNormal3fVertex4fSUN</para>
        /// </summary>
        [GLEntry("TexCoord4fColor4fNormal3fVertex4fSUN", Category = "SUN")]
        public static GLDelegate.TexCoord4fColor4fNormal3fVertex4f _TexCoord4fColor4fNormal3fVertex4f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord4fColor4fNormal3fVertex4f.</para>
        /// <para>Fullname: TexCoord4fColor4fNormal3fVertex4fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void TexCoord4fColor4fNormal3fVertex4f(float s, float t, float p, float q, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z, float w)
        {
            if (gl._TexCoord4fColor4fNormal3fVertex4f != null) gl._TexCoord4fColor4fNormal3fVertex4f(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord4fColor4fNormal3fVertex4fvSUN</para>
        /// </summary>
        [GLEntry("TexCoord4fColor4fNormal3fVertex4fvSUN", Category = "SUN")]
        public static GLDelegate.TexCoord4fColor4fNormal3fVertex4fv _TexCoord4fColor4fNormal3fVertex4fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord4fColor4fNormal3fVertex4fv.</para>
        /// <para>Fullname: TexCoord4fColor4fNormal3fVertex4fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void TexCoord4fColor4fNormal3fVertex4fv(float[] tc, float[] c, float[] n, float[] v)
        {
            if (gl._TexCoord4fColor4fNormal3fVertex4fv != null) gl._TexCoord4fColor4fNormal3fVertex4fv(tc, c, n, v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord4fVertex4fSUN</para>
        /// </summary>
        [GLEntry("TexCoord4fVertex4fSUN", Category = "SUN")]
        public static GLDelegate.TexCoord4fVertex4f _TexCoord4fVertex4f = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord4fVertex4f.</para>
        /// <para>Fullname: TexCoord4fVertex4fSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void TexCoord4fVertex4f(float s, float t, float p, float q, float x, float y, float z, float w)
        {
            if (gl._TexCoord4fVertex4f != null) gl._TexCoord4fVertex4f(s, t, p, q, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord4fVertex4fvSUN</para>
        /// </summary>
        [GLEntry("TexCoord4fVertex4fvSUN", Category = "SUN")]
        public static GLDelegate.TexCoord4fVertex4fv _TexCoord4fVertex4fv = null;
        /// <summary>
        /// <para>This extension provides new GL commands to specify vertex data such as color and normal along with the vertex in one single GL command in order to minimize the overhead in making GL commands for each set of vertex data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord4fVertex4fv.</para>
        /// <para>Fullname: TexCoord4fVertex4fvSUN</para>
        /// <para>Extensions: SUN_vertex</para>
        /// </summary>
        public static void TexCoord4fVertex4fv(float[] tc, float[] v)
        {
            if (gl._TexCoord4fVertex4fv != null) gl._TexCoord4fVertex4fv(tc, v); else { }
        }
        /// <summary>
        /// <para>Fullname: ActiveVaryingNV</para>
        /// </summary>
        [GLEntry("ActiveVaryingNV", Category = "NV")]
        public static GLDelegate.ActiveVarying _ActiveVarying = null;
        /// <summary>
        /// <para>This extension provides a new mode to the GL, called transform feedback, which records vertex attributes of the primitives processed by the GL. The selected attributes are written into buffer objects, and can be written with each attribute in a separate buffer object or with all attributes interleaved into a single buffer object.  If a geometry program or shader is active, the primitives recorded are those emitted by the geometry program.  Otherwise, transform feedback captures primitives whose vertex are transformed by a vertex program or shader, or by fixed-function vertex processing.  In either case, the primitives captured are those generated prior to clipping.  Transform feedback mode is capable of capturing transformed vertex data generated by fixed-function vertex processing, outputs from assembly vertex or geometry programs, or varying variables emitted from GLSL vertex or geometry shaders. The vertex data recorded in transform feedback mode is stored into buffer objects as an ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ActiveVarying.</para>
        /// <para>Fullname: ActiveVaryingNV</para>
        /// <para>Extensions: NV_transform_feedback</para>
        /// </summary>
        public static void ActiveVarying(uint program, StringBuilder name)
        {
            if (gl._ActiveVarying != null) gl._ActiveVarying(program, name); else { }
        }
        /// <summary>
        /// <para>Fullname: AreProgramsResidentNV</para>
        /// </summary>
        [GLEntry("AreProgramsResidentNV", Category = "NV")]
        public static GLDelegate.AreProgramsResident _AreProgramsResident = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _AreProgramsResident.</para>
        /// <para>Fullname: AreProgramsResidentNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static bool AreProgramsResident(int n, uint[] programs, bool[] residences)
        {
            if (gl._AreProgramsResident != null) return gl._AreProgramsResident(n, programs, residences);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: AreProgramsResidentNV</para>
        /// </summary>
        [GLEntry("AreProgramsResidentNV", Category = "NV")]
        public static GLDelegate.AreProgramsResident_uint_bool _AreProgramsResident_uint_bool = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _AreProgramsResident_uint_bool.</para>
        /// <para>Fullname: AreProgramsResidentNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static bool AreProgramsResident(int n, ref uint programs, out bool residences)
        {
            if (gl._AreProgramsResident_uint_bool != null) return gl._AreProgramsResident_uint_bool(n, ref programs, out residences);
            else { residences = new bool(); return false; }
        }
        /// <summary>
        /// <para>Fullname: BeginOcclusionQueryNV</para>
        /// </summary>
        [GLEntry("BeginOcclusionQueryNV", Category = "NV")]
        public static GLDelegate.BeginOcclusionQuery _BeginOcclusionQuery = null;
        /// <summary>
        /// <para>The HP_occlusion_test extension defines a mechanism whereby an application can query the visibility of an object, where "visible" means that at least one pixel passes the depth and stencil tests. The HP extension has two major shortcomings. - It returns the result as a simple GL_TRUE/GL_FALSE result, when in fact it is often useful to know exactly how many pixels passed. - It provides only a simple "stop-and-wait" model for using multiple queries.  The application begins an occlusion test and ends it; then, at some later point, it asks for the result, at which point the driver must stop and wait until the result from the previous test is back before the application can even begin the next one. This is a very simple model, but its performance is mediocre when an application wishes to perform many queries, and it eliminates most of the opportunites for parallelism between the CPU and GPU. This extension solves both of those problems.  It returns as its result the number of pixels that pa...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BeginOcclusionQuery.</para>
        /// <para>Fullname: BeginOcclusionQueryNV</para>
        /// <para>Extensions: NV_occlusion_query</para>
        /// </summary>
        public static void BeginOcclusionQuery(uint id)
        {
            if (gl._BeginOcclusionQuery != null) gl._BeginOcclusionQuery(id); else { }
        }
        /// <summary>
        /// <para>Fullname: BeginVideoCaptureNV</para>
        /// </summary>
        [GLEntry("BeginVideoCaptureNV", Category = "NV")]
        public static GLDelegate.BeginVideoCapture _BeginVideoCapture = null;
        /// <summary>
        /// <para>This extension provides a mechanism for streaming video data directly into texture objects and buffer objects.  Applications can then display video streams in interactive 3D scenes and/or manipulate the video data using the GL's image processing capabilities. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BeginVideoCapture.</para>
        /// <para>Fullname: BeginVideoCaptureNV</para>
        /// <para>Extensions: NV_video_capture</para>
        /// </summary>
        public static void BeginVideoCapture(uint video_capture_slot)
        {
            if (gl._BeginVideoCapture != null) gl._BeginVideoCapture(video_capture_slot); else { }
        }
        /// <summary>
        /// <para>Fullname: BindVideoCaptureStreamBufferNV</para>
        /// </summary>
        [GLEntry("BindVideoCaptureStreamBufferNV", Category = "NV")]
        public static GLDelegate.BindVideoCaptureStreamBuffer _BindVideoCaptureStreamBuffer = null;
        /// <summary>
        /// <para>This extension provides a mechanism for streaming video data directly into texture objects and buffer objects.  Applications can then display video streams in interactive 3D scenes and/or manipulate the video data using the GL's image processing capabilities. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindVideoCaptureStreamBuffer.</para>
        /// <para>Fullname: BindVideoCaptureStreamBufferNV</para>
        /// <para>Extensions: NV_video_capture</para>
        /// </summary>
        public static void BindVideoCaptureStreamBuffer(uint video_capture_slot, uint stream, int frame_region, int offset)
        {
            if (gl._BindVideoCaptureStreamBuffer != null) gl._BindVideoCaptureStreamBuffer(video_capture_slot, stream, frame_region, offset); else { }
        }
        /// <summary>
        /// <para>Fullname: BindVideoCaptureStreamTextureNV</para>
        /// </summary>
        [GLEntry("BindVideoCaptureStreamTextureNV", Category = "NV")]
        public static GLDelegate.BindVideoCaptureStreamTexture _BindVideoCaptureStreamTexture = null;
        /// <summary>
        /// <para>This extension provides a mechanism for streaming video data directly into texture objects and buffer objects.  Applications can then display video streams in interactive 3D scenes and/or manipulate the video data using the GL's image processing capabilities. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindVideoCaptureStreamTexture.</para>
        /// <para>Fullname: BindVideoCaptureStreamTextureNV</para>
        /// <para>Extensions: NV_video_capture</para>
        /// </summary>
        public static void BindVideoCaptureStreamTexture(uint video_capture_slot, uint stream, int frame_region, int target, uint texture)
        {
            if (gl._BindVideoCaptureStreamTexture != null) gl._BindVideoCaptureStreamTexture(video_capture_slot, stream, frame_region, target, texture); else { }
        }
        /// <summary>
        /// <para>Fullname: BufferAddressRangeNV</para>
        /// </summary>
        [GLEntry("BufferAddressRangeNV", Category = "NV")]
        public static GLDelegate.BufferAddressRange _BufferAddressRange = null;
        /// <summary>
        /// <para>This extension provides a mechanism to specify vertex attrib and element array locations using GPU addresses. Binding vertex buffers is one of the most frequent and expensive operations in many GL applications, due to the cost of chasing pointers and binding objects described in the Overview of NV_shader_buffer_load. The intent of this extension is to enable a way for the application to specify vertex attrib state that alleviates the overhead of object binds and driver memory management. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BufferAddressRange.</para>
        /// <para>Fullname: BufferAddressRangeNV</para>
        /// <para>Extensions: NV_vertex_buffer_unified_memory</para>
        /// </summary>
        public static void BufferAddressRange(int pname, uint index, ulong address, int length)
        {
            if (gl._BufferAddressRange != null) gl._BufferAddressRange(pname, index, address, length); else { }
        }
        /// <summary>
        /// <para>Fullname: ClearDepthdNV</para>
        /// </summary>
        [GLEntry("ClearDepthdNV", Category = "NV")]
        public static GLDelegate.ClearDepthd _ClearDepthd = null;
        /// <summary>
        /// <para>This extension provides new texture internal formats whose depth components are stored as 32-bit floating-point values, rather than the normalized unsigned integers used in existing depth formats. Floating-point depth textures support all the functionality supported for fixed-point depth textures, including shadow mapping and rendering support via EXT_framebuffer_object.  Floating-point depth textures can store values outside the range [0,1]. By default, OpenGL entry points taking depth values implicitly clamp the values to the range [0,1].  This extension provides new DepthClear, DepthRange, and DepthBoundsEXT entry points that allow applications to specify depth values that are not clamped. Additionally, this extension provides new packed depth/stencil pixel formats (see EXT_packed_depth_stencil) that have 64-bit pixels consisting of a 32-bit floating-point depth value, 8 bits of stencil, and 24 unused bites.  A packed depth/stencil texture internal format is also provided. This exte...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClearDepthd.</para>
        /// <para>Fullname: ClearDepthdNV</para>
        /// <para>Extensions: NV_depth_buffer_float</para>
        /// </summary>
        public static void ClearDepthd(double depth)
        {
            if (gl._ClearDepthd != null) gl._ClearDepthd(depth); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3hNV</para>
        /// </summary>
        [GLEntry("Color3hNV", Category = "NV")]
        public static GLDelegate.Color3h _Color3h = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3h.</para>
        /// <para>Fullname: Color3hNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void Color3h(ushort red, ushort green, ushort blue)
        {
            if (gl._Color3h != null) gl._Color3h(red, green, blue); else { }
        }
        /// <summary>
        /// <para>Fullname: Color3hvNV</para>
        /// </summary>
        [GLEntry("Color3hvNV", Category = "NV")]
        public static GLDelegate.Color3hv _Color3hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color3hv.</para>
        /// <para>Fullname: Color3hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void Color3hv(ushort[] v)
        {
            if (gl._Color3hv != null) gl._Color3hv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4hNV</para>
        /// </summary>
        [GLEntry("Color4hNV", Category = "NV")]
        public static GLDelegate.Color4h _Color4h = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4h.</para>
        /// <para>Fullname: Color4hNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void Color4h(ushort red, ushort green, ushort blue, ushort alpha)
        {
            if (gl._Color4h != null) gl._Color4h(red, green, blue, alpha); else { }
        }
        /// <summary>
        /// <para>Fullname: Color4hvNV</para>
        /// </summary>
        [GLEntry("Color4hvNV", Category = "NV")]
        public static GLDelegate.Color4hv _Color4hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Color4hv.</para>
        /// <para>Fullname: Color4hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void Color4hv(ushort[] v)
        {
            if (gl._Color4hv != null) gl._Color4hv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: ColorFormatNV</para>
        /// </summary>
        [GLEntry("ColorFormatNV", Category = "NV")]
        public static GLDelegate.ColorFormat _ColorFormat = null;
        /// <summary>
        /// <para>This extension provides a mechanism to specify vertex attrib and element array locations using GPU addresses. Binding vertex buffers is one of the most frequent and expensive operations in many GL applications, due to the cost of chasing pointers and binding objects described in the Overview of NV_shader_buffer_load. The intent of this extension is to enable a way for the application to specify vertex attrib state that alleviates the overhead of object binds and driver memory management. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorFormat.</para>
        /// <para>Fullname: ColorFormatNV</para>
        /// <para>Extensions: NV_vertex_buffer_unified_memory</para>
        /// </summary>
        public static void ColorFormat(int size, int type, int stride)
        {
            if (gl._ColorFormat != null) gl._ColorFormat(size, type, stride); else { }
        }
        /// <summary>
        /// <para>Fullname: CombinerInputNV</para>
        /// </summary>
        [GLEntry("CombinerInputNV", Category = "NV")]
        public static GLDelegate.CombinerInput _CombinerInput = null;
        /// <summary>
        /// <para>NVIDIA's next-generation graphics processor and its derivative designs support an extremely configurable mechanism know as "register combiners" for computing fragment colors. The register combiner mechanism is a significant redesign of NVIDIA's original TNT combiner mechanism as introduced by NVIDIA's RIVA TNT graphics processor.  Familiarity with the TNT combiners will help the reader appreciate the greatly enhanced register combiners functionality (see the NV_texture_env_combine4 OpenGL extension specification for this background).  The register combiner mechanism has the following enhanced functionality: The numeric range of combiner computations is from [-1,1] (instead of TNT's [0,1] numeric range), The set of available combiner inputs is expanded to include the secondary color, fog color, fog factor, and a second combiner constant color (TNT's available combiner inputs consist of only zero, a single combiner constant color, the primary color, texture 0, texture 1, and, in the case...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CombinerInput.</para>
        /// <para>Fullname: CombinerInputNV</para>
        /// <para>Extensions: NV_register_combiners</para>
        /// </summary>
        public static void CombinerInput(int stage, int portion, int variable, int input, int mapping, int componentUsage)
        {
            if (gl._CombinerInput != null) gl._CombinerInput(stage, portion, variable, input, mapping, componentUsage); else { }
        }
        /// <summary>
        /// <para>Fullname: CombinerOutputNV</para>
        /// </summary>
        [GLEntry("CombinerOutputNV", Category = "NV")]
        public static GLDelegate.CombinerOutput _CombinerOutput = null;
        /// <summary>
        /// <para>NVIDIA's next-generation graphics processor and its derivative designs support an extremely configurable mechanism know as "register combiners" for computing fragment colors. The register combiner mechanism is a significant redesign of NVIDIA's original TNT combiner mechanism as introduced by NVIDIA's RIVA TNT graphics processor.  Familiarity with the TNT combiners will help the reader appreciate the greatly enhanced register combiners functionality (see the NV_texture_env_combine4 OpenGL extension specification for this background).  The register combiner mechanism has the following enhanced functionality: The numeric range of combiner computations is from [-1,1] (instead of TNT's [0,1] numeric range), The set of available combiner inputs is expanded to include the secondary color, fog color, fog factor, and a second combiner constant color (TNT's available combiner inputs consist of only zero, a single combiner constant color, the primary color, texture 0, texture 1, and, in the case...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CombinerOutput.</para>
        /// <para>Fullname: CombinerOutputNV</para>
        /// <para>Extensions: NV_register_combiners</para>
        /// </summary>
        public static void CombinerOutput(int stage, int portion, int abOutput, int cdOutput, int sumOutput, int scale, int bias, bool abDotProduct, bool cdDotProduct, bool muxSum)
        {
            if (gl._CombinerOutput != null) gl._CombinerOutput(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum); else { }
        }
        /// <summary>
        /// <para>Fullname: CombinerParameterfNV</para>
        /// </summary>
        [GLEntry("CombinerParameterfNV", Category = "NV")]
        public static GLDelegate.CombinerParameterf _CombinerParameterf = null;
        /// <summary>
        /// <para>NVIDIA's next-generation graphics processor and its derivative designs support an extremely configurable mechanism know as "register combiners" for computing fragment colors. The register combiner mechanism is a significant redesign of NVIDIA's original TNT combiner mechanism as introduced by NVIDIA's RIVA TNT graphics processor.  Familiarity with the TNT combiners will help the reader appreciate the greatly enhanced register combiners functionality (see the NV_texture_env_combine4 OpenGL extension specification for this background).  The register combiner mechanism has the following enhanced functionality: The numeric range of combiner computations is from [-1,1] (instead of TNT's [0,1] numeric range), The set of available combiner inputs is expanded to include the secondary color, fog color, fog factor, and a second combiner constant color (TNT's available combiner inputs consist of only zero, a single combiner constant color, the primary color, texture 0, texture 1, and, in the case...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CombinerParameterf.</para>
        /// <para>Fullname: CombinerParameterfNV</para>
        /// <para>Extensions: NV_register_combiners</para>
        /// </summary>
        public static void CombinerParameterf(int pname, float param)
        {
            if (gl._CombinerParameterf != null) gl._CombinerParameterf(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: CombinerParameterfvNV</para>
        /// </summary>
        [GLEntry("CombinerParameterfvNV", Category = "NV")]
        public static GLDelegate.CombinerParameterfv _CombinerParameterfv = null;
        /// <summary>
        /// <para>NVIDIA's next-generation graphics processor and its derivative designs support an extremely configurable mechanism know as "register combiners" for computing fragment colors. The register combiner mechanism is a significant redesign of NVIDIA's original TNT combiner mechanism as introduced by NVIDIA's RIVA TNT graphics processor.  Familiarity with the TNT combiners will help the reader appreciate the greatly enhanced register combiners functionality (see the NV_texture_env_combine4 OpenGL extension specification for this background).  The register combiner mechanism has the following enhanced functionality: The numeric range of combiner computations is from [-1,1] (instead of TNT's [0,1] numeric range), The set of available combiner inputs is expanded to include the secondary color, fog color, fog factor, and a second combiner constant color (TNT's available combiner inputs consist of only zero, a single combiner constant color, the primary color, texture 0, texture 1, and, in the case...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CombinerParameterfv.</para>
        /// <para>Fullname: CombinerParameterfvNV</para>
        /// <para>Extensions: NV_register_combiners</para>
        /// </summary>
        public static void CombinerParameterfv(int pname, float[] param)
        {
            if (gl._CombinerParameterfv != null) gl._CombinerParameterfv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: CombinerParameteriNV</para>
        /// </summary>
        [GLEntry("CombinerParameteriNV", Category = "NV")]
        public static GLDelegate.CombinerParameteri _CombinerParameteri = null;
        /// <summary>
        /// <para>NVIDIA's next-generation graphics processor and its derivative designs support an extremely configurable mechanism know as "register combiners" for computing fragment colors. The register combiner mechanism is a significant redesign of NVIDIA's original TNT combiner mechanism as introduced by NVIDIA's RIVA TNT graphics processor.  Familiarity with the TNT combiners will help the reader appreciate the greatly enhanced register combiners functionality (see the NV_texture_env_combine4 OpenGL extension specification for this background).  The register combiner mechanism has the following enhanced functionality: The numeric range of combiner computations is from [-1,1] (instead of TNT's [0,1] numeric range), The set of available combiner inputs is expanded to include the secondary color, fog color, fog factor, and a second combiner constant color (TNT's available combiner inputs consist of only zero, a single combiner constant color, the primary color, texture 0, texture 1, and, in the case...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CombinerParameteri.</para>
        /// <para>Fullname: CombinerParameteriNV</para>
        /// <para>Extensions: NV_register_combiners</para>
        /// </summary>
        public static void CombinerParameteri(int pname, int param)
        {
            if (gl._CombinerParameteri != null) gl._CombinerParameteri(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: CombinerParameterivNV</para>
        /// </summary>
        [GLEntry("CombinerParameterivNV", Category = "NV")]
        public static GLDelegate.CombinerParameteriv _CombinerParameteriv = null;
        /// <summary>
        /// <para>NVIDIA's next-generation graphics processor and its derivative designs support an extremely configurable mechanism know as "register combiners" for computing fragment colors. The register combiner mechanism is a significant redesign of NVIDIA's original TNT combiner mechanism as introduced by NVIDIA's RIVA TNT graphics processor.  Familiarity with the TNT combiners will help the reader appreciate the greatly enhanced register combiners functionality (see the NV_texture_env_combine4 OpenGL extension specification for this background).  The register combiner mechanism has the following enhanced functionality: The numeric range of combiner computations is from [-1,1] (instead of TNT's [0,1] numeric range), The set of available combiner inputs is expanded to include the secondary color, fog color, fog factor, and a second combiner constant color (TNT's available combiner inputs consist of only zero, a single combiner constant color, the primary color, texture 0, texture 1, and, in the case...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CombinerParameteriv.</para>
        /// <para>Fullname: CombinerParameterivNV</para>
        /// <para>Extensions: NV_register_combiners</para>
        /// </summary>
        public static void CombinerParameteriv(int pname, int[] param)
        {
            if (gl._CombinerParameteriv != null) gl._CombinerParameteriv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: CombinerStageParameterfvNV</para>
        /// </summary>
        [GLEntry("CombinerStageParameterfvNV", Category = "NV")]
        public static GLDelegate.CombinerStageParameterfv _CombinerStageParameterfv = null;
        /// <summary>
        /// <para>The NV_register_combiners extension provides a powerful fragment coloring mechanism.  This specification extends the register combiners functionality to support more color constant values that are unique for each general combiner stage. The base register combiners functionality supports only two color constants.  These two constants are available in every general combiner stage and in the final combiner. When many general combiner stages are supported, more than two unique color constants is often required.  The obvious way to extend the register combiners is to add several more color constant registers.  But adding new unique color constant registers is expensive for hardware implementation because every color constant register must be available as an input to any stage. In practice however, it is the total set of general combiner stages that requires more color constants, not each and every individual general combiner stage.  Each individual general combiner stage typically requires ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CombinerStageParameterfv.</para>
        /// <para>Fullname: CombinerStageParameterfvNV</para>
        /// <para>Extensions: NV_register_combiners2</para>
        /// </summary>
        public static void CombinerStageParameterfv(int stage, int pname, float[] param)
        {
            if (gl._CombinerStageParameterfv != null) gl._CombinerStageParameterfv(stage, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: CopyPathNV</para>
        /// </summary>
        [GLEntry("CopyPathNV", Category = "NV")]
        public static GLDelegate.CopyPath _CopyPath = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CopyPath.</para>
        /// <para>Fullname: CopyPathNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void CopyPath(uint resultPath, uint srcPath)
        {
            if (gl._CopyPath != null) gl._CopyPath(resultPath, srcPath); else { }
        }
        /// <summary>
        /// <para>Fullname: CoverFillPathNV</para>
        /// </summary>
        [GLEntry("CoverFillPathNV", Category = "NV")]
        public static GLDelegate.CoverFillPath _CoverFillPath = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CoverFillPath.</para>
        /// <para>Fullname: CoverFillPathNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void CoverFillPath(uint path, int coverMode)
        {
            if (gl._CoverFillPath != null) gl._CoverFillPath(path, coverMode); else { }
        }
        /// <summary>
        /// <para>Fullname: CoverFillPathInstancedNV</para>
        /// </summary>
        [GLEntry("CoverFillPathInstancedNV", Category = "NV")]
        public static GLDelegate.CoverFillPathInstanced _CoverFillPathInstanced = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CoverFillPathInstanced.</para>
        /// <para>Fullname: CoverFillPathInstancedNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void CoverFillPathInstanced(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int coverMode, int transformType, float[] transformValues)
        {
            if (gl._CoverFillPathInstanced != null) gl._CoverFillPathInstanced(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues); else { }
        }
        /// <summary>
        /// <para>Fullname: CoverStrokePathNV</para>
        /// </summary>
        [GLEntry("CoverStrokePathNV", Category = "NV")]
        public static GLDelegate.CoverStrokePath _CoverStrokePath = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CoverStrokePath.</para>
        /// <para>Fullname: CoverStrokePathNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void CoverStrokePath(uint path, int coverMode)
        {
            if (gl._CoverStrokePath != null) gl._CoverStrokePath(path, coverMode); else { }
        }
        /// <summary>
        /// <para>Fullname: CoverStrokePathInstancedNV</para>
        /// </summary>
        [GLEntry("CoverStrokePathInstancedNV", Category = "NV")]
        public static GLDelegate.CoverStrokePathInstanced _CoverStrokePathInstanced = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _CoverStrokePathInstanced.</para>
        /// <para>Fullname: CoverStrokePathInstancedNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void CoverStrokePathInstanced(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int coverMode, int transformType, float[] transformValues)
        {
            if (gl._CoverStrokePathInstanced != null) gl._CoverStrokePathInstanced(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteFencesNV</para>
        /// </summary>
        [GLEntry("DeleteFencesNV", Category = "NV", Alias = "DeleteFencesAPPLE ")]
        public static GLDelegate.DeleteFences _DeleteFences = null;
        public static GLDelegate.DeleteFences DeleteFencesAPPLE = DeleteFences;
        /// <summary>
        /// <para>The goal of this extension is provide a finer granularity of synchronizing GL command completion than offered by standard OpenGL, which offers only two mechanisms for synchronization: Flush and Finish. Since Flush merely assures the user that the commands complete in a finite (though undetermined) amount of time, it is, thus, of only modest utility.  Finish, on the other hand, stalls CPU execution until all pending GL commands have completed.  This extension offers a middle ground - the ability to "finish" a subset of the command stream, and the ability to determine whether a given command has completed or not. This extension introduces the concept of a "fence" to the OpenGL command stream.  Once the fence is inserted into the command stream, it can be queried for a given condition - typically, its completion. Moreover, the application may also request a partial Finish -- that is, all commands prior to the fence will be forced to complete until control is returned to the calling proces...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteFences.</para>
        /// <para>Fullname: DeleteFencesNV</para>
        /// <para>Aliases: DeleteFencesAPPLE, </para>
        /// <para>Extensions: NV_fence APPLE_fence</para>
        /// </summary>
        public static void DeleteFences(int n, uint[] fences)
        {
            if (gl._DeleteFences != null) gl._DeleteFences(n, fences); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteFencesNV</para>
        /// </summary>
        [GLEntry("DeleteFencesNV", Category = "NV", Alias = "DeleteFencesAPPLE ")]
        public static GLDelegate.DeleteFences_uint _DeleteFences_uint = null;
        /// <summary>
        /// <para>The goal of this extension is provide a finer granularity of synchronizing GL command completion than offered by standard OpenGL, which offers only two mechanisms for synchronization: Flush and Finish. Since Flush merely assures the user that the commands complete in a finite (though undetermined) amount of time, it is, thus, of only modest utility.  Finish, on the other hand, stalls CPU execution until all pending GL commands have completed.  This extension offers a middle ground - the ability to "finish" a subset of the command stream, and the ability to determine whether a given command has completed or not. This extension introduces the concept of a "fence" to the OpenGL command stream.  Once the fence is inserted into the command stream, it can be queried for a given condition - typically, its completion. Moreover, the application may also request a partial Finish -- that is, all commands prior to the fence will be forced to complete until control is returned to the calling proces...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteFences_uint.</para>
        /// <para>Fullname: DeleteFencesNV</para>
        /// <para>Aliases: DeleteFencesAPPLE, </para>
        /// <para>Extensions: NV_fence APPLE_fence</para>
        /// </summary>
        public static void DeleteFences(int n, ref uint fences)
        {
            if (gl._DeleteFences_uint != null) gl._DeleteFences_uint(n, ref fences); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteOcclusionQueriesNV</para>
        /// </summary>
        [GLEntry("DeleteOcclusionQueriesNV", Category = "NV")]
        public static GLDelegate.DeleteOcclusionQueries_uint _DeleteOcclusionQueries_uint = null;
        /// <summary>
        /// <para>The HP_occlusion_test extension defines a mechanism whereby an application can query the visibility of an object, where "visible" means that at least one pixel passes the depth and stencil tests. The HP extension has two major shortcomings. - It returns the result as a simple GL_TRUE/GL_FALSE result, when in fact it is often useful to know exactly how many pixels passed. - It provides only a simple "stop-and-wait" model for using multiple queries.  The application begins an occlusion test and ends it; then, at some later point, it asks for the result, at which point the driver must stop and wait until the result from the previous test is back before the application can even begin the next one. This is a very simple model, but its performance is mediocre when an application wishes to perform many queries, and it eliminates most of the opportunites for parallelism between the CPU and GPU. This extension solves both of those problems.  It returns as its result the number of pixels that pa...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteOcclusionQueries_uint.</para>
        /// <para>Fullname: DeleteOcclusionQueriesNV</para>
        /// <para>Extensions: NV_occlusion_query</para>
        /// </summary>
        public static void DeleteOcclusionQueries(int n, ref uint ids)
        {
            if (gl._DeleteOcclusionQueries_uint != null) gl._DeleteOcclusionQueries_uint(n, ref ids); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteOcclusionQueriesNV</para>
        /// </summary>
        [GLEntry("DeleteOcclusionQueriesNV", Category = "NV")]
        public static GLDelegate.DeleteOcclusionQueries _DeleteOcclusionQueries = null;
        /// <summary>
        /// <para>The HP_occlusion_test extension defines a mechanism whereby an application can query the visibility of an object, where "visible" means that at least one pixel passes the depth and stencil tests. The HP extension has two major shortcomings. - It returns the result as a simple GL_TRUE/GL_FALSE result, when in fact it is often useful to know exactly how many pixels passed. - It provides only a simple "stop-and-wait" model for using multiple queries.  The application begins an occlusion test and ends it; then, at some later point, it asks for the result, at which point the driver must stop and wait until the result from the previous test is back before the application can even begin the next one. This is a very simple model, but its performance is mediocre when an application wishes to perform many queries, and it eliminates most of the opportunites for parallelism between the CPU and GPU. This extension solves both of those problems.  It returns as its result the number of pixels that pa...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteOcclusionQueries.</para>
        /// <para>Fullname: DeleteOcclusionQueriesNV</para>
        /// <para>Extensions: NV_occlusion_query</para>
        /// </summary>
        public static void DeleteOcclusionQueries(int n, uint[] ids)
        {
            if (gl._DeleteOcclusionQueries != null) gl._DeleteOcclusionQueries(n, ids); else { }
        }
        /// <summary>
        /// <para>Fullname: DeletePathsNV</para>
        /// </summary>
        [GLEntry("DeletePathsNV", Category = "NV")]
        public static GLDelegate.DeletePaths _DeletePaths = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeletePaths.</para>
        /// <para>Fullname: DeletePathsNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void DeletePaths(uint path, int range)
        {
            if (gl._DeletePaths != null) gl._DeletePaths(path, range); else { }
        }
        /// <summary>
        /// <para>Fullname: DepthBoundsdNV</para>
        /// </summary>
        [GLEntry("DepthBoundsdNV", Category = "NV")]
        public static GLDelegate.DepthBoundsd _DepthBoundsd = null;
        /// <summary>
        /// <para>This extension provides new texture internal formats whose depth components are stored as 32-bit floating-point values, rather than the normalized unsigned integers used in existing depth formats. Floating-point depth textures support all the functionality supported for fixed-point depth textures, including shadow mapping and rendering support via EXT_framebuffer_object.  Floating-point depth textures can store values outside the range [0,1]. By default, OpenGL entry points taking depth values implicitly clamp the values to the range [0,1].  This extension provides new DepthClear, DepthRange, and DepthBoundsEXT entry points that allow applications to specify depth values that are not clamped. Additionally, this extension provides new packed depth/stencil pixel formats (see EXT_packed_depth_stencil) that have 64-bit pixels consisting of a 32-bit floating-point depth value, 8 bits of stencil, and 24 unused bites.  A packed depth/stencil texture internal format is also provided. This exte...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DepthBoundsd.</para>
        /// <para>Fullname: DepthBoundsdNV</para>
        /// <para>Extensions: NV_depth_buffer_float</para>
        /// </summary>
        public static void DepthBoundsd(double zmin, double zmax)
        {
            if (gl._DepthBoundsd != null) gl._DepthBoundsd(zmin, zmax); else { }
        }
        /// <summary>
        /// <para>Fullname: DepthRangedNV</para>
        /// </summary>
        [GLEntry("DepthRangedNV", Category = "NV")]
        public static GLDelegate.DepthRanged _DepthRanged = null;
        /// <summary>
        /// <para>This extension provides new texture internal formats whose depth components are stored as 32-bit floating-point values, rather than the normalized unsigned integers used in existing depth formats. Floating-point depth textures support all the functionality supported for fixed-point depth textures, including shadow mapping and rendering support via EXT_framebuffer_object.  Floating-point depth textures can store values outside the range [0,1]. By default, OpenGL entry points taking depth values implicitly clamp the values to the range [0,1].  This extension provides new DepthClear, DepthRange, and DepthBoundsEXT entry points that allow applications to specify depth values that are not clamped. Additionally, this extension provides new packed depth/stencil pixel formats (see EXT_packed_depth_stencil) that have 64-bit pixels consisting of a 32-bit floating-point depth value, 8 bits of stencil, and 24 unused bites.  A packed depth/stencil texture internal format is also provided. This exte...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DepthRanged.</para>
        /// <para>Fullname: DepthRangedNV</para>
        /// <para>Extensions: NV_depth_buffer_float</para>
        /// </summary>
        public static void DepthRanged(double zNear, double zFar)
        {
            if (gl._DepthRanged != null) gl._DepthRanged(zNear, zFar); else { }
        }
        /// <summary>
        /// <para>Fullname: EdgeFlagFormatNV</para>
        /// </summary>
        [GLEntry("EdgeFlagFormatNV", Category = "NV")]
        public static GLDelegate.EdgeFlagFormat _EdgeFlagFormat = null;
        /// <summary>
        /// <para>This extension provides a mechanism to specify vertex attrib and element array locations using GPU addresses. Binding vertex buffers is one of the most frequent and expensive operations in many GL applications, due to the cost of chasing pointers and binding objects described in the Overview of NV_shader_buffer_load. The intent of this extension is to enable a way for the application to specify vertex attrib state that alleviates the overhead of object binds and driver memory management. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EdgeFlagFormat.</para>
        /// <para>Fullname: EdgeFlagFormatNV</para>
        /// <para>Extensions: NV_vertex_buffer_unified_memory</para>
        /// </summary>
        public static void EdgeFlagFormat(int stride)
        {
            if (gl._EdgeFlagFormat != null) gl._EdgeFlagFormat(stride); else { }
        }
        /// <summary>
        /// <para>Fullname: EndOcclusionQueryNV</para>
        /// </summary>
        [GLEntry("EndOcclusionQueryNV", Category = "NV")]
        public static GLDelegate.EndOcclusionQuery _EndOcclusionQuery = null;
        /// <summary>
        /// <para>The HP_occlusion_test extension defines a mechanism whereby an application can query the visibility of an object, where "visible" means that at least one pixel passes the depth and stencil tests. The HP extension has two major shortcomings. - It returns the result as a simple GL_TRUE/GL_FALSE result, when in fact it is often useful to know exactly how many pixels passed. - It provides only a simple "stop-and-wait" model for using multiple queries.  The application begins an occlusion test and ends it; then, at some later point, it asks for the result, at which point the driver must stop and wait until the result from the previous test is back before the application can even begin the next one. This is a very simple model, but its performance is mediocre when an application wishes to perform many queries, and it eliminates most of the opportunites for parallelism between the CPU and GPU. This extension solves both of those problems.  It returns as its result the number of pixels that pa...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EndOcclusionQuery.</para>
        /// <para>Fullname: EndOcclusionQueryNV</para>
        /// <para>Extensions: NV_occlusion_query</para>
        /// </summary>
        public static void EndOcclusionQuery()
        {
            if (gl._EndOcclusionQuery != null) gl._EndOcclusionQuery(); else { }
        }
        /// <summary>
        /// <para>Fullname: EndVideoCaptureNV</para>
        /// </summary>
        [GLEntry("EndVideoCaptureNV", Category = "NV")]
        public static GLDelegate.EndVideoCapture _EndVideoCapture = null;
        /// <summary>
        /// <para>This extension provides a mechanism for streaming video data directly into texture objects and buffer objects.  Applications can then display video streams in interactive 3D scenes and/or manipulate the video data using the GL's image processing capabilities. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EndVideoCapture.</para>
        /// <para>Fullname: EndVideoCaptureNV</para>
        /// <para>Extensions: NV_video_capture</para>
        /// </summary>
        public static void EndVideoCapture(uint video_capture_slot)
        {
            if (gl._EndVideoCapture != null) gl._EndVideoCapture(video_capture_slot); else { }
        }
        /// <summary>
        /// <para>Fullname: EvalMapsNV</para>
        /// </summary>
        [GLEntry("EvalMapsNV", Category = "NV")]
        public static GLDelegate.EvalMaps _EvalMaps = null;
        /// <summary>
        /// <para>OpenGL evaluators provide applications with the capability to specify polynomial or rational curves and surfaces using control points relative to the Bezier basis.  The curves and surfaces are then drawn by evaluating the polynomials provided at various values for the u parameter of a curve or the (u,v) parameters of a surface. A tensor product formulation is used for the surfaces. For various historical reasons, evaluators have not been particularly popular as an interface for drawing curves and surfaces. This extension proposes a new interface for surfaces that provides a number of significant enhancements to the functionality provided by the original OpenGL evaluators. Many implementations never optimized evaluators, so applications often implemented their own algorithms instead.  This extension relaxes some restrictions that make it difficult to optimize evaluators. Also, new vertex attributes have been added to OpenGL through extensions, including multiple sets of texture coordina...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EvalMaps.</para>
        /// <para>Fullname: EvalMapsNV</para>
        /// <para>Extensions: NV_evaluators</para>
        /// </summary>
        public static void EvalMaps(int target, int mode)
        {
            if (gl._EvalMaps != null) gl._EvalMaps(target, mode); else { }
        }
        /// <summary>
        /// <para>Fullname: ExecuteProgramNV</para>
        /// </summary>
        [GLEntry("ExecuteProgramNV", Category = "NV")]
        public static GLDelegate.ExecuteProgram _ExecuteProgram = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ExecuteProgram.</para>
        /// <para>Fullname: ExecuteProgramNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void ExecuteProgram(int target, uint id, float[] param)
        {
            if (gl._ExecuteProgram != null) gl._ExecuteProgram(target, id, param); else { }
        }
        /// <summary>
        /// <para>Fullname: FinalCombinerInputNV</para>
        /// </summary>
        [GLEntry("FinalCombinerInputNV", Category = "NV")]
        public static GLDelegate.FinalCombinerInput _FinalCombinerInput = null;
        /// <summary>
        /// <para>NVIDIA's next-generation graphics processor and its derivative designs support an extremely configurable mechanism know as "register combiners" for computing fragment colors. The register combiner mechanism is a significant redesign of NVIDIA's original TNT combiner mechanism as introduced by NVIDIA's RIVA TNT graphics processor.  Familiarity with the TNT combiners will help the reader appreciate the greatly enhanced register combiners functionality (see the NV_texture_env_combine4 OpenGL extension specification for this background).  The register combiner mechanism has the following enhanced functionality: The numeric range of combiner computations is from [-1,1] (instead of TNT's [0,1] numeric range), The set of available combiner inputs is expanded to include the secondary color, fog color, fog factor, and a second combiner constant color (TNT's available combiner inputs consist of only zero, a single combiner constant color, the primary color, texture 0, texture 1, and, in the case...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FinalCombinerInput.</para>
        /// <para>Fullname: FinalCombinerInputNV</para>
        /// <para>Extensions: NV_register_combiners</para>
        /// </summary>
        public static void FinalCombinerInput(int variable, int input, int mapping, int componentUsage)
        {
            if (gl._FinalCombinerInput != null) gl._FinalCombinerInput(variable, input, mapping, componentUsage); else { }
        }
        /// <summary>
        /// <para>Fullname: FinishFenceNV</para>
        /// </summary>
        [GLEntry("FinishFenceNV", Category = "NV", Alias = "FinishFenceAPPLE ")]
        public static GLDelegate.FinishFence _FinishFence = null;
        public static GLDelegate.FinishFence FinishFenceAPPLE = FinishFence;
        /// <summary>
        /// <para>The goal of this extension is provide a finer granularity of synchronizing GL command completion than offered by standard OpenGL, which offers only two mechanisms for synchronization: Flush and Finish. Since Flush merely assures the user that the commands complete in a finite (though undetermined) amount of time, it is, thus, of only modest utility.  Finish, on the other hand, stalls CPU execution until all pending GL commands have completed.  This extension offers a middle ground - the ability to "finish" a subset of the command stream, and the ability to determine whether a given command has completed or not. This extension introduces the concept of a "fence" to the OpenGL command stream.  Once the fence is inserted into the command stream, it can be queried for a given condition - typically, its completion. Moreover, the application may also request a partial Finish -- that is, all commands prior to the fence will be forced to complete until control is returned to the calling proces...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FinishFence.</para>
        /// <para>Fullname: FinishFenceNV</para>
        /// <para>Aliases: FinishFenceAPPLE, </para>
        /// <para>Extensions: NV_fence APPLE_fence</para>
        /// </summary>
        public static void FinishFence(uint fence)
        {
            if (gl._FinishFence != null) gl._FinishFence(fence); else { }
        }
        /// <summary>
        /// <para>Fullname: FlushPixelDataRangeNV</para>
        /// </summary>
        [GLEntry("FlushPixelDataRangeNV", Category = "NV")]
        public static GLDelegate.FlushPixelDataRange _FlushPixelDataRange = null;
        /// <summary>
        /// <para>The vertex array range extension is intended to improve the efficiency of OpenGL vertex arrays.  OpenGL vertex arrays' coherency model and ability to access memory from arbitrary locations in memory prevented implementations from using DMA (Direct Memory Access) operations. Many image-intensive applications, such as those that use dynamically generated textures, face similar problems.  These applications would like to be able to sustain throughputs of hundreds of millions of pixels per second through DrawPixels and hundreds of millions of texels per second through TexSubImage. However, the same restrictions that limited vertex throughput also limit pixel throughput. By the time that any pixel operation that reads data from user memory returns, OpenGL requires that it must be safe for the application to start using that memory for a different purpose.  This coherency model prevents asynchronous DMA transfers directly out of the user's buffer. There are also no restrictions on the pointe...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FlushPixelDataRange.</para>
        /// <para>Fullname: FlushPixelDataRangeNV</para>
        /// <para>Extensions: NV_pixel_data_range</para>
        /// </summary>
        public static void FlushPixelDataRange(int target)
        {
            if (gl._FlushPixelDataRange != null) gl._FlushPixelDataRange(target); else { }
        }
        /// <summary>
        /// <para>Fullname: FlushVertexArrayRangeNV</para>
        /// </summary>
        [GLEntry("FlushVertexArrayRangeNV", Category = "NV")]
        public static GLDelegate.FlushVertexArrayRange _FlushVertexArrayRange = null;
        /// <summary>
        /// <para>The goal of this extension is to permit extremely high vertex processing rates via OpenGL vertex arrays even when the CPU lacks the necessary data movement bandwidth to keep up with the rate at which the vertex engine can consume vertices.  CPUs can keep up if they can just pass vertex indices to the hardware and let the hardware "pull" the actual vertex data via Direct Memory Access (DMA).  Unfortunately, the current OpenGL 1.1 vertex array functionality has semantic constraints that make such an approach hard.  Hence, the vertex array range extension. This extension provides a mechanism for deferring the pulling of vertex array elements to facilitate DMAed pulling of vertices for fast, efficient vertex array transfers.  The OpenGL client need only pass vertex indices to the hardware which can DMA the actual index's vertex data directly out of the client address space. The OpenGL 1.1 vertex array functionality specifies a fairly strict coherency model for when OpenGL extracts vertex d...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FlushVertexArrayRange.</para>
        /// <para>Fullname: FlushVertexArrayRangeNV</para>
        /// <para>Extensions: NV_vertex_array_range</para>
        /// </summary>
        public static void FlushVertexArrayRange()
        {
            if (gl._FlushVertexArrayRange != null) gl._FlushVertexArrayRange(); else { }
        }
        /// <summary>
        /// <para>Fullname: FogCoordFormatNV</para>
        /// </summary>
        [GLEntry("FogCoordFormatNV", Category = "NV")]
        public static GLDelegate.FogCoordFormat _FogCoordFormat = null;
        /// <summary>
        /// <para>This extension provides a mechanism to specify vertex attrib and element array locations using GPU addresses. Binding vertex buffers is one of the most frequent and expensive operations in many GL applications, due to the cost of chasing pointers and binding objects described in the Overview of NV_shader_buffer_load. The intent of this extension is to enable a way for the application to specify vertex attrib state that alleviates the overhead of object binds and driver memory management. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FogCoordFormat.</para>
        /// <para>Fullname: FogCoordFormatNV</para>
        /// <para>Extensions: NV_vertex_buffer_unified_memory</para>
        /// </summary>
        public static void FogCoordFormat(int type, int stride)
        {
            if (gl._FogCoordFormat != null) gl._FogCoordFormat(type, stride); else { }
        }
        /// <summary>
        /// <para>Fullname: FogCoordhNV</para>
        /// </summary>
        [GLEntry("FogCoordhNV", Category = "NV")]
        public static GLDelegate.FogCoordh _FogCoordh = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FogCoordh.</para>
        /// <para>Fullname: FogCoordhNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void FogCoordh(ushort fog)
        {
            if (gl._FogCoordh != null) gl._FogCoordh(fog); else { }
        }
        /// <summary>
        /// <para>Fullname: FogCoordhvNV</para>
        /// </summary>
        [GLEntry("FogCoordhvNV", Category = "NV")]
        public static GLDelegate.FogCoordhv _FogCoordhv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FogCoordhv.</para>
        /// <para>Fullname: FogCoordhvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void FogCoordhv(ushort[] fog)
        {
            if (gl._FogCoordhv != null) gl._FogCoordhv(fog); else { }
        }
        /// <summary>
        /// <para>Fullname: GenFencesNV</para>
        /// </summary>
        [GLEntry("GenFencesNV", Category = "NV", Alias = "GenFencesAPPLE ")]
        public static GLDelegate.GenFences _GenFences = null;
        public static GLDelegate.GenFences GenFencesAPPLE = GenFences;
        /// <summary>
        /// <para>The goal of this extension is provide a finer granularity of synchronizing GL command completion than offered by standard OpenGL, which offers only two mechanisms for synchronization: Flush and Finish. Since Flush merely assures the user that the commands complete in a finite (though undetermined) amount of time, it is, thus, of only modest utility.  Finish, on the other hand, stalls CPU execution until all pending GL commands have completed.  This extension offers a middle ground - the ability to "finish" a subset of the command stream, and the ability to determine whether a given command has completed or not. This extension introduces the concept of a "fence" to the OpenGL command stream.  Once the fence is inserted into the command stream, it can be queried for a given condition - typically, its completion. Moreover, the application may also request a partial Finish -- that is, all commands prior to the fence will be forced to complete until control is returned to the calling proces...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenFences.</para>
        /// <para>Fullname: GenFencesNV</para>
        /// <para>Aliases: GenFencesAPPLE, </para>
        /// <para>Extensions: NV_fence APPLE_fence</para>
        /// </summary>
        public static void GenFences(int n, uint[] fences)
        {
            if (gl._GenFences != null) gl._GenFences(n, fences); else { }
        }
        /// <summary>
        /// <para>Fullname: GenFencesNV</para>
        /// </summary>
        [GLEntry("GenFencesNV", Category = "NV", Alias = "GenFencesAPPLE ")]
        public static GLDelegate.GenFences_uint _GenFences_uint = null;
        /// <summary>
        /// <para>The goal of this extension is provide a finer granularity of synchronizing GL command completion than offered by standard OpenGL, which offers only two mechanisms for synchronization: Flush and Finish. Since Flush merely assures the user that the commands complete in a finite (though undetermined) amount of time, it is, thus, of only modest utility.  Finish, on the other hand, stalls CPU execution until all pending GL commands have completed.  This extension offers a middle ground - the ability to "finish" a subset of the command stream, and the ability to determine whether a given command has completed or not. This extension introduces the concept of a "fence" to the OpenGL command stream.  Once the fence is inserted into the command stream, it can be queried for a given condition - typically, its completion. Moreover, the application may also request a partial Finish -- that is, all commands prior to the fence will be forced to complete until control is returned to the calling proces...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenFences_uint.</para>
        /// <para>Fullname: GenFencesNV</para>
        /// <para>Aliases: GenFencesAPPLE, </para>
        /// <para>Extensions: NV_fence APPLE_fence</para>
        /// </summary>
        public static void GenFences(int n, out uint fences)
        {
            if (gl._GenFences_uint != null) gl._GenFences_uint(n, out fences); else { fences = new uint(); }
        }
        /// <summary>
        /// <para>Fullname: GenOcclusionQueriesNV</para>
        /// </summary>
        [GLEntry("GenOcclusionQueriesNV", Category = "NV")]
        public static GLDelegate.GenOcclusionQueries_uint _GenOcclusionQueries_uint = null;
        /// <summary>
        /// <para>The HP_occlusion_test extension defines a mechanism whereby an application can query the visibility of an object, where "visible" means that at least one pixel passes the depth and stencil tests. The HP extension has two major shortcomings. - It returns the result as a simple GL_TRUE/GL_FALSE result, when in fact it is often useful to know exactly how many pixels passed. - It provides only a simple "stop-and-wait" model for using multiple queries.  The application begins an occlusion test and ends it; then, at some later point, it asks for the result, at which point the driver must stop and wait until the result from the previous test is back before the application can even begin the next one. This is a very simple model, but its performance is mediocre when an application wishes to perform many queries, and it eliminates most of the opportunites for parallelism between the CPU and GPU. This extension solves both of those problems.  It returns as its result the number of pixels that pa...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenOcclusionQueries_uint.</para>
        /// <para>Fullname: GenOcclusionQueriesNV</para>
        /// <para>Extensions: NV_occlusion_query</para>
        /// </summary>
        public static void GenOcclusionQueries(int n, out uint ids)
        {
            if (gl._GenOcclusionQueries_uint != null) gl._GenOcclusionQueries_uint(n, out ids); else { ids = new uint(); }
        }
        /// <summary>
        /// <para>Fullname: GenOcclusionQueriesNV</para>
        /// </summary>
        [GLEntry("GenOcclusionQueriesNV", Category = "NV")]
        public static GLDelegate.GenOcclusionQueries _GenOcclusionQueries = null;
        /// <summary>
        /// <para>The HP_occlusion_test extension defines a mechanism whereby an application can query the visibility of an object, where "visible" means that at least one pixel passes the depth and stencil tests. The HP extension has two major shortcomings. - It returns the result as a simple GL_TRUE/GL_FALSE result, when in fact it is often useful to know exactly how many pixels passed. - It provides only a simple "stop-and-wait" model for using multiple queries.  The application begins an occlusion test and ends it; then, at some later point, it asks for the result, at which point the driver must stop and wait until the result from the previous test is back before the application can even begin the next one. This is a very simple model, but its performance is mediocre when an application wishes to perform many queries, and it eliminates most of the opportunites for parallelism between the CPU and GPU. This extension solves both of those problems.  It returns as its result the number of pixels that pa...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenOcclusionQueries.</para>
        /// <para>Fullname: GenOcclusionQueriesNV</para>
        /// <para>Extensions: NV_occlusion_query</para>
        /// </summary>
        public static void GenOcclusionQueries(int n, uint[] ids)
        {
            if (gl._GenOcclusionQueries != null) gl._GenOcclusionQueries(n, ids); else { }
        }
        /// <summary>
        /// <para>Fullname: GenPathsNV</para>
        /// </summary>
        [GLEntry("GenPathsNV", Category = "NV")]
        public static GLDelegate.GenPaths _GenPaths = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenPaths.</para>
        /// <para>Fullname: GenPathsNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static uint GenPaths(int range)
        {
            if (gl._GenPaths != null) return gl._GenPaths(range);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: GetActiveVaryingNV</para>
        /// </summary>
        [GLEntry("GetActiveVaryingNV", Category = "NV")]
        public static GLDelegate.GetActiveVarying_int_int_int _GetActiveVarying_int_int_int = null;
        /// <summary>
        /// <para>This extension provides a new mode to the GL, called transform feedback, which records vertex attributes of the primitives processed by the GL. The selected attributes are written into buffer objects, and can be written with each attribute in a separate buffer object or with all attributes interleaved into a single buffer object.  If a geometry program or shader is active, the primitives recorded are those emitted by the geometry program.  Otherwise, transform feedback captures primitives whose vertex are transformed by a vertex program or shader, or by fixed-function vertex processing.  In either case, the primitives captured are those generated prior to clipping.  Transform feedback mode is capable of capturing transformed vertex data generated by fixed-function vertex processing, outputs from assembly vertex or geometry programs, or varying variables emitted from GLSL vertex or geometry shaders. The vertex data recorded in transform feedback mode is stored into buffer objects as an ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetActiveVarying_int_int_int.</para>
        /// <para>Fullname: GetActiveVaryingNV</para>
        /// <para>Extensions: NV_transform_feedback</para>
        /// </summary>
        public static void GetActiveVarying(uint program, uint index, int bufSize, out int length, out int size, out int type, StringBuilder name)
        {
            if (gl._GetActiveVarying_int_int_int != null) gl._GetActiveVarying_int_int_int(program, index, bufSize, out length, out size, out type, name); else { length = new int(); size = new int(); type = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetActiveVaryingNV</para>
        /// </summary>
        [GLEntry("GetActiveVaryingNV", Category = "NV")]
        public static GLDelegate.GetActiveVarying _GetActiveVarying = null;
        /// <summary>
        /// <para>This extension provides a new mode to the GL, called transform feedback, which records vertex attributes of the primitives processed by the GL. The selected attributes are written into buffer objects, and can be written with each attribute in a separate buffer object or with all attributes interleaved into a single buffer object.  If a geometry program or shader is active, the primitives recorded are those emitted by the geometry program.  Otherwise, transform feedback captures primitives whose vertex are transformed by a vertex program or shader, or by fixed-function vertex processing.  In either case, the primitives captured are those generated prior to clipping.  Transform feedback mode is capable of capturing transformed vertex data generated by fixed-function vertex processing, outputs from assembly vertex or geometry programs, or varying variables emitted from GLSL vertex or geometry shaders. The vertex data recorded in transform feedback mode is stored into buffer objects as an ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetActiveVarying.</para>
        /// <para>Fullname: GetActiveVaryingNV</para>
        /// <para>Extensions: NV_transform_feedback</para>
        /// </summary>
        public static void GetActiveVarying(uint program, uint index, int bufSize, int[] length, int[] size, int[] type, StringBuilder name)
        {
            if (gl._GetActiveVarying != null) gl._GetActiveVarying(program, index, bufSize, length, size, type, name); else { }
        }
        /// <summary>
        /// <para>Fullname: GetBufferParameterui64vNV</para>
        /// </summary>
        [GLEntry("GetBufferParameterui64vNV", Category = "NV")]
        public static GLDelegate.GetBufferParameterui64v _GetBufferParameterui64v = null;
        /// <summary>
        /// <para>At a very coarse level, GL has evolved in a way that allows applications to replace many of the original state machine variables with blocks of user-defined data. For example, the current vertex state has been augmented by vertex buffer objects, fixed-function shading state and parameters have been replaced by shaders/programs and constant buffers, etc.. Applications switch between coarse sets of state by binding objects to the context or to other container objects (e.g. vertex array objects) instead of manipulating state variables of the context. In terms of the number of GL commands required to draw an object, modern applications are orders of magnitude more efficient than legacy applications, but this explosion of objects bound to other objects has led to a new bottleneck - pointer chasing and CPU L2 cache misses in the driver, and general L2 cache pollution. This extension provides a mechanism to read from a flat, 64-bit GPU address space from programs/shaders, to query GPU address...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetBufferParameterui64v.</para>
        /// <para>Fullname: GetBufferParameterui64vNV</para>
        /// <para>Extensions: NV_shader_buffer_load</para>
        /// </summary>
        public static void GetBufferParameterui64v(int target, int pname, ulong[] param)
        {
            if (gl._GetBufferParameterui64v != null) gl._GetBufferParameterui64v(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetCombinerInputParameterfvNV</para>
        /// </summary>
        [GLEntry("GetCombinerInputParameterfvNV", Category = "NV")]
        public static GLDelegate.GetCombinerInputParameterfv _GetCombinerInputParameterfv = null;
        /// <summary>
        /// <para>NVIDIA's next-generation graphics processor and its derivative designs support an extremely configurable mechanism know as "register combiners" for computing fragment colors. The register combiner mechanism is a significant redesign of NVIDIA's original TNT combiner mechanism as introduced by NVIDIA's RIVA TNT graphics processor.  Familiarity with the TNT combiners will help the reader appreciate the greatly enhanced register combiners functionality (see the NV_texture_env_combine4 OpenGL extension specification for this background).  The register combiner mechanism has the following enhanced functionality: The numeric range of combiner computations is from [-1,1] (instead of TNT's [0,1] numeric range), The set of available combiner inputs is expanded to include the secondary color, fog color, fog factor, and a second combiner constant color (TNT's available combiner inputs consist of only zero, a single combiner constant color, the primary color, texture 0, texture 1, and, in the case...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetCombinerInputParameterfv.</para>
        /// <para>Fullname: GetCombinerInputParameterfvNV</para>
        /// <para>Extensions: NV_register_combiners</para>
        /// </summary>
        public static void GetCombinerInputParameterfv(int stage, int portion, int variable, int pname, float[] param)
        {
            if (gl._GetCombinerInputParameterfv != null) gl._GetCombinerInputParameterfv(stage, portion, variable, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetCombinerInputParameterivNV</para>
        /// </summary>
        [GLEntry("GetCombinerInputParameterivNV", Category = "NV")]
        public static GLDelegate.GetCombinerInputParameteriv _GetCombinerInputParameteriv = null;
        /// <summary>
        /// <para>NVIDIA's next-generation graphics processor and its derivative designs support an extremely configurable mechanism know as "register combiners" for computing fragment colors. The register combiner mechanism is a significant redesign of NVIDIA's original TNT combiner mechanism as introduced by NVIDIA's RIVA TNT graphics processor.  Familiarity with the TNT combiners will help the reader appreciate the greatly enhanced register combiners functionality (see the NV_texture_env_combine4 OpenGL extension specification for this background).  The register combiner mechanism has the following enhanced functionality: The numeric range of combiner computations is from [-1,1] (instead of TNT's [0,1] numeric range), The set of available combiner inputs is expanded to include the secondary color, fog color, fog factor, and a second combiner constant color (TNT's available combiner inputs consist of only zero, a single combiner constant color, the primary color, texture 0, texture 1, and, in the case...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetCombinerInputParameteriv.</para>
        /// <para>Fullname: GetCombinerInputParameterivNV</para>
        /// <para>Extensions: NV_register_combiners</para>
        /// </summary>
        public static void GetCombinerInputParameteriv(int stage, int portion, int variable, int pname, int[] param)
        {
            if (gl._GetCombinerInputParameteriv != null) gl._GetCombinerInputParameteriv(stage, portion, variable, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetCombinerOutputParameterfvNV</para>
        /// </summary>
        [GLEntry("GetCombinerOutputParameterfvNV", Category = "NV")]
        public static GLDelegate.GetCombinerOutputParameterfv _GetCombinerOutputParameterfv = null;
        /// <summary>
        /// <para>NVIDIA's next-generation graphics processor and its derivative designs support an extremely configurable mechanism know as "register combiners" for computing fragment colors. The register combiner mechanism is a significant redesign of NVIDIA's original TNT combiner mechanism as introduced by NVIDIA's RIVA TNT graphics processor.  Familiarity with the TNT combiners will help the reader appreciate the greatly enhanced register combiners functionality (see the NV_texture_env_combine4 OpenGL extension specification for this background).  The register combiner mechanism has the following enhanced functionality: The numeric range of combiner computations is from [-1,1] (instead of TNT's [0,1] numeric range), The set of available combiner inputs is expanded to include the secondary color, fog color, fog factor, and a second combiner constant color (TNT's available combiner inputs consist of only zero, a single combiner constant color, the primary color, texture 0, texture 1, and, in the case...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetCombinerOutputParameterfv.</para>
        /// <para>Fullname: GetCombinerOutputParameterfvNV</para>
        /// <para>Extensions: NV_register_combiners</para>
        /// </summary>
        public static void GetCombinerOutputParameterfv(int stage, int portion, int pname, float[] param)
        {
            if (gl._GetCombinerOutputParameterfv != null) gl._GetCombinerOutputParameterfv(stage, portion, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetCombinerOutputParameterivNV</para>
        /// </summary>
        [GLEntry("GetCombinerOutputParameterivNV", Category = "NV")]
        public static GLDelegate.GetCombinerOutputParameteriv _GetCombinerOutputParameteriv = null;
        /// <summary>
        /// <para>NVIDIA's next-generation graphics processor and its derivative designs support an extremely configurable mechanism know as "register combiners" for computing fragment colors. The register combiner mechanism is a significant redesign of NVIDIA's original TNT combiner mechanism as introduced by NVIDIA's RIVA TNT graphics processor.  Familiarity with the TNT combiners will help the reader appreciate the greatly enhanced register combiners functionality (see the NV_texture_env_combine4 OpenGL extension specification for this background).  The register combiner mechanism has the following enhanced functionality: The numeric range of combiner computations is from [-1,1] (instead of TNT's [0,1] numeric range), The set of available combiner inputs is expanded to include the secondary color, fog color, fog factor, and a second combiner constant color (TNT's available combiner inputs consist of only zero, a single combiner constant color, the primary color, texture 0, texture 1, and, in the case...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetCombinerOutputParameteriv.</para>
        /// <para>Fullname: GetCombinerOutputParameterivNV</para>
        /// <para>Extensions: NV_register_combiners</para>
        /// </summary>
        public static void GetCombinerOutputParameteriv(int stage, int portion, int pname, int[] param)
        {
            if (gl._GetCombinerOutputParameteriv != null) gl._GetCombinerOutputParameteriv(stage, portion, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetCombinerStageParameterfvNV</para>
        /// </summary>
        [GLEntry("GetCombinerStageParameterfvNV", Category = "NV")]
        public static GLDelegate.GetCombinerStageParameterfv _GetCombinerStageParameterfv = null;
        /// <summary>
        /// <para>The NV_register_combiners extension provides a powerful fragment coloring mechanism.  This specification extends the register combiners functionality to support more color constant values that are unique for each general combiner stage. The base register combiners functionality supports only two color constants.  These two constants are available in every general combiner stage and in the final combiner. When many general combiner stages are supported, more than two unique color constants is often required.  The obvious way to extend the register combiners is to add several more color constant registers.  But adding new unique color constant registers is expensive for hardware implementation because every color constant register must be available as an input to any stage. In practice however, it is the total set of general combiner stages that requires more color constants, not each and every individual general combiner stage.  Each individual general combiner stage typically requires ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetCombinerStageParameterfv.</para>
        /// <para>Fullname: GetCombinerStageParameterfvNV</para>
        /// <para>Extensions: NV_register_combiners2</para>
        /// </summary>
        public static void GetCombinerStageParameterfv(int stage, int pname, float[] param)
        {
            if (gl._GetCombinerStageParameterfv != null) gl._GetCombinerStageParameterfv(stage, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetFenceivNV</para>
        /// </summary>
        [GLEntry("GetFenceivNV", Category = "NV")]
        public static GLDelegate.GetFenceiv _GetFenceiv = null;
        /// <summary>
        /// <para>The goal of this extension is provide a finer granularity of synchronizing GL command completion than offered by standard OpenGL, which offers only two mechanisms for synchronization: Flush and Finish. Since Flush merely assures the user that the commands complete in a finite (though undetermined) amount of time, it is, thus, of only modest utility.  Finish, on the other hand, stalls CPU execution until all pending GL commands have completed.  This extension offers a middle ground - the ability to "finish" a subset of the command stream, and the ability to determine whether a given command has completed or not. This extension introduces the concept of a "fence" to the OpenGL command stream.  Once the fence is inserted into the command stream, it can be queried for a given condition - typically, its completion. Moreover, the application may also request a partial Finish -- that is, all commands prior to the fence will be forced to complete until control is returned to the calling proces...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetFenceiv.</para>
        /// <para>Fullname: GetFenceivNV</para>
        /// <para>Extensions: NV_fence</para>
        /// </summary>
        public static void GetFenceiv(uint fence, int pname, int[] param)
        {
            if (gl._GetFenceiv != null) gl._GetFenceiv(fence, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetFinalCombinerInputParameterfvNV</para>
        /// </summary>
        [GLEntry("GetFinalCombinerInputParameterfvNV", Category = "NV")]
        public static GLDelegate.GetFinalCombinerInputParameterfv _GetFinalCombinerInputParameterfv = null;
        /// <summary>
        /// <para>NVIDIA's next-generation graphics processor and its derivative designs support an extremely configurable mechanism know as "register combiners" for computing fragment colors. The register combiner mechanism is a significant redesign of NVIDIA's original TNT combiner mechanism as introduced by NVIDIA's RIVA TNT graphics processor.  Familiarity with the TNT combiners will help the reader appreciate the greatly enhanced register combiners functionality (see the NV_texture_env_combine4 OpenGL extension specification for this background).  The register combiner mechanism has the following enhanced functionality: The numeric range of combiner computations is from [-1,1] (instead of TNT's [0,1] numeric range), The set of available combiner inputs is expanded to include the secondary color, fog color, fog factor, and a second combiner constant color (TNT's available combiner inputs consist of only zero, a single combiner constant color, the primary color, texture 0, texture 1, and, in the case...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetFinalCombinerInputParameterfv.</para>
        /// <para>Fullname: GetFinalCombinerInputParameterfvNV</para>
        /// <para>Extensions: NV_register_combiners</para>
        /// </summary>
        public static void GetFinalCombinerInputParameterfv(int variable, int pname, float[] param)
        {
            if (gl._GetFinalCombinerInputParameterfv != null) gl._GetFinalCombinerInputParameterfv(variable, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetFinalCombinerInputParameterivNV</para>
        /// </summary>
        [GLEntry("GetFinalCombinerInputParameterivNV", Category = "NV")]
        public static GLDelegate.GetFinalCombinerInputParameteriv _GetFinalCombinerInputParameteriv = null;
        /// <summary>
        /// <para>NVIDIA's next-generation graphics processor and its derivative designs support an extremely configurable mechanism know as "register combiners" for computing fragment colors. The register combiner mechanism is a significant redesign of NVIDIA's original TNT combiner mechanism as introduced by NVIDIA's RIVA TNT graphics processor.  Familiarity with the TNT combiners will help the reader appreciate the greatly enhanced register combiners functionality (see the NV_texture_env_combine4 OpenGL extension specification for this background).  The register combiner mechanism has the following enhanced functionality: The numeric range of combiner computations is from [-1,1] (instead of TNT's [0,1] numeric range), The set of available combiner inputs is expanded to include the secondary color, fog color, fog factor, and a second combiner constant color (TNT's available combiner inputs consist of only zero, a single combiner constant color, the primary color, texture 0, texture 1, and, in the case...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetFinalCombinerInputParameteriv.</para>
        /// <para>Fullname: GetFinalCombinerInputParameterivNV</para>
        /// <para>Extensions: NV_register_combiners</para>
        /// </summary>
        public static void GetFinalCombinerInputParameteriv(int variable, int pname, int[] param)
        {
            if (gl._GetFinalCombinerInputParameteriv != null) gl._GetFinalCombinerInputParameteriv(variable, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetImageHandleNV</para>
        /// </summary>
        [GLEntry("GetImageHandleNV", Category = "NV")]
        public static GLDelegate.GetImageHandle _GetImageHandle = null;
        /// <summary>
        /// <para>This extension allows OpenGL applications to access texture objects in shaders without first binding each texture to one of a limited number of texture image units.  Using this extension, an application can query an 64-bit unsigned integer texture handle for each texture that it wants to access and then use that handle directly in GLSL or assembly-based shaders.  The ability to access textures without having to bind and/or re-bind them is similar to the capability provided by the NV_shader_buffer_load extension that allows shaders to access buffer objects without binding them.  In both cases, these extensions significantly reduce the amount of API and internal GL driver overhead needed to manage resource bindings. This extension also provides similar capability for the image load, store, and atomic functionality provided by OpenGL 4.2 and the ARB_shader_image_load_store and EXT_shader_image_load_store extensions, where a texture can be accessed without first binding it to an image unit...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetImageHandle.</para>
        /// <para>Fullname: GetImageHandleNV</para>
        /// <para>Extensions: NV_bindless_texture</para>
        /// </summary>
        public static ulong GetImageHandle(uint texture, int level, bool layered, int layer, int format)
        {
            if (gl._GetImageHandle != null) return gl._GetImageHandle(texture, level, layered, layer, format);
            else { return (ulong)0; }
        }
        /// <summary>
        /// <para>Fullname: GetIntegerui64i_vNV</para>
        /// </summary>
        [GLEntry("GetIntegerui64i_vNV", Category = "NV")]
        public static GLDelegate.GetIntegerui64i_v _GetIntegerui64i_v = null;
        /// <summary>
        /// <para>This extension provides a mechanism to specify vertex attrib and element array locations using GPU addresses. Binding vertex buffers is one of the most frequent and expensive operations in many GL applications, due to the cost of chasing pointers and binding objects described in the Overview of NV_shader_buffer_load. The intent of this extension is to enable a way for the application to specify vertex attrib state that alleviates the overhead of object binds and driver memory management. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetIntegerui64i_v.</para>
        /// <para>Fullname: GetIntegerui64i_vNV</para>
        /// <para>Extensions: NV_vertex_buffer_unified_memory</para>
        /// </summary>
        public static void GetIntegerui64i_v(int value, uint index, ulong[] result)
        {
            if (gl._GetIntegerui64i_v != null) gl._GetIntegerui64i_v(value, index, result); else { }
        }
        /// <summary>
        /// <para>Fullname: GetIntegerui64vNV</para>
        /// </summary>
        [GLEntry("GetIntegerui64vNV", Category = "NV")]
        public static GLDelegate.GetIntegerui64v _GetIntegerui64v = null;
        /// <summary>
        /// <para>At a very coarse level, GL has evolved in a way that allows applications to replace many of the original state machine variables with blocks of user-defined data. For example, the current vertex state has been augmented by vertex buffer objects, fixed-function shading state and parameters have been replaced by shaders/programs and constant buffers, etc.. Applications switch between coarse sets of state by binding objects to the context or to other container objects (e.g. vertex array objects) instead of manipulating state variables of the context. In terms of the number of GL commands required to draw an object, modern applications are orders of magnitude more efficient than legacy applications, but this explosion of objects bound to other objects has led to a new bottleneck - pointer chasing and CPU L2 cache misses in the driver, and general L2 cache pollution. This extension provides a mechanism to read from a flat, 64-bit GPU address space from programs/shaders, to query GPU address...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetIntegerui64v.</para>
        /// <para>Fullname: GetIntegerui64vNV</para>
        /// <para>Extensions: NV_shader_buffer_load</para>
        /// </summary>
        public static void GetIntegerui64v(int value, ulong[] result)
        {
            if (gl._GetIntegerui64v != null) gl._GetIntegerui64v(value, result); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMapAttribParameterfvNV</para>
        /// </summary>
        [GLEntry("GetMapAttribParameterfvNV", Category = "NV")]
        public static GLDelegate.GetMapAttribParameterfv _GetMapAttribParameterfv = null;
        /// <summary>
        /// <para>OpenGL evaluators provide applications with the capability to specify polynomial or rational curves and surfaces using control points relative to the Bezier basis.  The curves and surfaces are then drawn by evaluating the polynomials provided at various values for the u parameter of a curve or the (u,v) parameters of a surface. A tensor product formulation is used for the surfaces. For various historical reasons, evaluators have not been particularly popular as an interface for drawing curves and surfaces. This extension proposes a new interface for surfaces that provides a number of significant enhancements to the functionality provided by the original OpenGL evaluators. Many implementations never optimized evaluators, so applications often implemented their own algorithms instead.  This extension relaxes some restrictions that make it difficult to optimize evaluators. Also, new vertex attributes have been added to OpenGL through extensions, including multiple sets of texture coordina...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMapAttribParameterfv.</para>
        /// <para>Fullname: GetMapAttribParameterfvNV</para>
        /// <para>Extensions: NV_evaluators</para>
        /// </summary>
        public static void GetMapAttribParameterfv(int target, uint index, int pname, float[] param)
        {
            if (gl._GetMapAttribParameterfv != null) gl._GetMapAttribParameterfv(target, index, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMapAttribParameterivNV</para>
        /// </summary>
        [GLEntry("GetMapAttribParameterivNV", Category = "NV")]
        public static GLDelegate.GetMapAttribParameteriv _GetMapAttribParameteriv = null;
        /// <summary>
        /// <para>OpenGL evaluators provide applications with the capability to specify polynomial or rational curves and surfaces using control points relative to the Bezier basis.  The curves and surfaces are then drawn by evaluating the polynomials provided at various values for the u parameter of a curve or the (u,v) parameters of a surface. A tensor product formulation is used for the surfaces. For various historical reasons, evaluators have not been particularly popular as an interface for drawing curves and surfaces. This extension proposes a new interface for surfaces that provides a number of significant enhancements to the functionality provided by the original OpenGL evaluators. Many implementations never optimized evaluators, so applications often implemented their own algorithms instead.  This extension relaxes some restrictions that make it difficult to optimize evaluators. Also, new vertex attributes have been added to OpenGL through extensions, including multiple sets of texture coordina...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMapAttribParameteriv.</para>
        /// <para>Fullname: GetMapAttribParameterivNV</para>
        /// <para>Extensions: NV_evaluators</para>
        /// </summary>
        public static void GetMapAttribParameteriv(int target, uint index, int pname, int[] param)
        {
            if (gl._GetMapAttribParameteriv != null) gl._GetMapAttribParameteriv(target, index, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMapControlPointsNV</para>
        /// </summary>
        [GLEntry("GetMapControlPointsNV", Category = "NV")]
        public static GLDelegate.GetMapControlPoints _GetMapControlPoints = null;
        /// <summary>
        /// <para>OpenGL evaluators provide applications with the capability to specify polynomial or rational curves and surfaces using control points relative to the Bezier basis.  The curves and surfaces are then drawn by evaluating the polynomials provided at various values for the u parameter of a curve or the (u,v) parameters of a surface. A tensor product formulation is used for the surfaces. For various historical reasons, evaluators have not been particularly popular as an interface for drawing curves and surfaces. This extension proposes a new interface for surfaces that provides a number of significant enhancements to the functionality provided by the original OpenGL evaluators. Many implementations never optimized evaluators, so applications often implemented their own algorithms instead.  This extension relaxes some restrictions that make it difficult to optimize evaluators. Also, new vertex attributes have been added to OpenGL through extensions, including multiple sets of texture coordina...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMapControlPoints.</para>
        /// <para>Fullname: GetMapControlPointsNV</para>
        /// <para>Extensions: NV_evaluators</para>
        /// </summary>
        public static void GetMapControlPoints(int target, uint index, int type, int ustride, int vstride, bool packed, IntPtr points)
        {
            if (gl._GetMapControlPoints != null) gl._GetMapControlPoints(target, index, type, ustride, vstride, packed, points); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMapParameterfvNV</para>
        /// </summary>
        [GLEntry("GetMapParameterfvNV", Category = "NV")]
        public static GLDelegate.GetMapParameterfv _GetMapParameterfv = null;
        /// <summary>
        /// <para>OpenGL evaluators provide applications with the capability to specify polynomial or rational curves and surfaces using control points relative to the Bezier basis.  The curves and surfaces are then drawn by evaluating the polynomials provided at various values for the u parameter of a curve or the (u,v) parameters of a surface. A tensor product formulation is used for the surfaces. For various historical reasons, evaluators have not been particularly popular as an interface for drawing curves and surfaces. This extension proposes a new interface for surfaces that provides a number of significant enhancements to the functionality provided by the original OpenGL evaluators. Many implementations never optimized evaluators, so applications often implemented their own algorithms instead.  This extension relaxes some restrictions that make it difficult to optimize evaluators. Also, new vertex attributes have been added to OpenGL through extensions, including multiple sets of texture coordina...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMapParameterfv.</para>
        /// <para>Fullname: GetMapParameterfvNV</para>
        /// <para>Extensions: NV_evaluators</para>
        /// </summary>
        public static void GetMapParameterfv(int target, int pname, float[] param)
        {
            if (gl._GetMapParameterfv != null) gl._GetMapParameterfv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetMapParameterivNV</para>
        /// </summary>
        [GLEntry("GetMapParameterivNV", Category = "NV")]
        public static GLDelegate.GetMapParameteriv _GetMapParameteriv = null;
        /// <summary>
        /// <para>OpenGL evaluators provide applications with the capability to specify polynomial or rational curves and surfaces using control points relative to the Bezier basis.  The curves and surfaces are then drawn by evaluating the polynomials provided at various values for the u parameter of a curve or the (u,v) parameters of a surface. A tensor product formulation is used for the surfaces. For various historical reasons, evaluators have not been particularly popular as an interface for drawing curves and surfaces. This extension proposes a new interface for surfaces that provides a number of significant enhancements to the functionality provided by the original OpenGL evaluators. Many implementations never optimized evaluators, so applications often implemented their own algorithms instead.  This extension relaxes some restrictions that make it difficult to optimize evaluators. Also, new vertex attributes have been added to OpenGL through extensions, including multiple sets of texture coordina...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetMapParameteriv.</para>
        /// <para>Fullname: GetMapParameterivNV</para>
        /// <para>Extensions: NV_evaluators</para>
        /// </summary>
        public static void GetMapParameteriv(int target, int pname, int[] param)
        {
            if (gl._GetMapParameteriv != null) gl._GetMapParameteriv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetNamedBufferParameterui64vNV</para>
        /// </summary>
        [GLEntry("GetNamedBufferParameterui64vNV", Category = "NV")]
        public static GLDelegate.GetNamedBufferParameterui64v _GetNamedBufferParameterui64v = null;
        /// <summary>
        /// <para>At a very coarse level, GL has evolved in a way that allows applications to replace many of the original state machine variables with blocks of user-defined data. For example, the current vertex state has been augmented by vertex buffer objects, fixed-function shading state and parameters have been replaced by shaders/programs and constant buffers, etc.. Applications switch between coarse sets of state by binding objects to the context or to other container objects (e.g. vertex array objects) instead of manipulating state variables of the context. In terms of the number of GL commands required to draw an object, modern applications are orders of magnitude more efficient than legacy applications, but this explosion of objects bound to other objects has led to a new bottleneck - pointer chasing and CPU L2 cache misses in the driver, and general L2 cache pollution. This extension provides a mechanism to read from a flat, 64-bit GPU address space from programs/shaders, to query GPU address...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetNamedBufferParameterui64v.</para>
        /// <para>Fullname: GetNamedBufferParameterui64vNV</para>
        /// <para>Extensions: NV_shader_buffer_load</para>
        /// </summary>
        public static void GetNamedBufferParameterui64v(uint buffer, int pname, ulong[] param)
        {
            if (gl._GetNamedBufferParameterui64v != null) gl._GetNamedBufferParameterui64v(buffer, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetOcclusionQueryivNV</para>
        /// </summary>
        [GLEntry("GetOcclusionQueryivNV", Category = "NV")]
        public static GLDelegate.GetOcclusionQueryiv _GetOcclusionQueryiv = null;
        /// <summary>
        /// <para>The HP_occlusion_test extension defines a mechanism whereby an application can query the visibility of an object, where "visible" means that at least one pixel passes the depth and stencil tests. The HP extension has two major shortcomings. - It returns the result as a simple GL_TRUE/GL_FALSE result, when in fact it is often useful to know exactly how many pixels passed. - It provides only a simple "stop-and-wait" model for using multiple queries.  The application begins an occlusion test and ends it; then, at some later point, it asks for the result, at which point the driver must stop and wait until the result from the previous test is back before the application can even begin the next one. This is a very simple model, but its performance is mediocre when an application wishes to perform many queries, and it eliminates most of the opportunites for parallelism between the CPU and GPU. This extension solves both of those problems.  It returns as its result the number of pixels that pa...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetOcclusionQueryiv.</para>
        /// <para>Fullname: GetOcclusionQueryivNV</para>
        /// <para>Extensions: NV_occlusion_query</para>
        /// </summary>
        public static void GetOcclusionQueryiv(uint id, int pname, int[] param)
        {
            if (gl._GetOcclusionQueryiv != null) gl._GetOcclusionQueryiv(id, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetOcclusionQueryuivNV</para>
        /// </summary>
        [GLEntry("GetOcclusionQueryuivNV", Category = "NV")]
        public static GLDelegate.GetOcclusionQueryuiv _GetOcclusionQueryuiv = null;
        /// <summary>
        /// <para>The HP_occlusion_test extension defines a mechanism whereby an application can query the visibility of an object, where "visible" means that at least one pixel passes the depth and stencil tests. The HP extension has two major shortcomings. - It returns the result as a simple GL_TRUE/GL_FALSE result, when in fact it is often useful to know exactly how many pixels passed. - It provides only a simple "stop-and-wait" model for using multiple queries.  The application begins an occlusion test and ends it; then, at some later point, it asks for the result, at which point the driver must stop and wait until the result from the previous test is back before the application can even begin the next one. This is a very simple model, but its performance is mediocre when an application wishes to perform many queries, and it eliminates most of the opportunites for parallelism between the CPU and GPU. This extension solves both of those problems.  It returns as its result the number of pixels that pa...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetOcclusionQueryuiv.</para>
        /// <para>Fullname: GetOcclusionQueryuivNV</para>
        /// <para>Extensions: NV_occlusion_query</para>
        /// </summary>
        public static void GetOcclusionQueryuiv(uint id, int pname, uint[] param)
        {
            if (gl._GetOcclusionQueryuiv != null) gl._GetOcclusionQueryuiv(id, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPathColorGenfvNV</para>
        /// </summary>
        [GLEntry("GetPathColorGenfvNV", Category = "NV")]
        public static GLDelegate.GetPathColorGenfv _GetPathColorGenfv = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPathColorGenfv.</para>
        /// <para>Fullname: GetPathColorGenfvNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void GetPathColorGenfv(int color, int pname, float[] value)
        {
            if (gl._GetPathColorGenfv != null) gl._GetPathColorGenfv(color, pname, value); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPathColorGenivNV</para>
        /// </summary>
        [GLEntry("GetPathColorGenivNV", Category = "NV")]
        public static GLDelegate.GetPathColorGeniv _GetPathColorGeniv = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPathColorGeniv.</para>
        /// <para>Fullname: GetPathColorGenivNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void GetPathColorGeniv(int color, int pname, int[] value)
        {
            if (gl._GetPathColorGeniv != null) gl._GetPathColorGeniv(color, pname, value); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPathCommandsNV</para>
        /// </summary>
        [GLEntry("GetPathCommandsNV", Category = "NV")]
        public static GLDelegate.GetPathCommands _GetPathCommands = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPathCommands.</para>
        /// <para>Fullname: GetPathCommandsNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void GetPathCommands(uint path, byte[] commands)
        {
            if (gl._GetPathCommands != null) gl._GetPathCommands(path, commands); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPathCoordsNV</para>
        /// </summary>
        [GLEntry("GetPathCoordsNV", Category = "NV")]
        public static GLDelegate.GetPathCoords _GetPathCoords = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPathCoords.</para>
        /// <para>Fullname: GetPathCoordsNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void GetPathCoords(uint path, float[] coords)
        {
            if (gl._GetPathCoords != null) gl._GetPathCoords(path, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPathDashArrayNV</para>
        /// </summary>
        [GLEntry("GetPathDashArrayNV", Category = "NV")]
        public static GLDelegate.GetPathDashArray _GetPathDashArray = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPathDashArray.</para>
        /// <para>Fullname: GetPathDashArrayNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void GetPathDashArray(uint path, float[] dashArray)
        {
            if (gl._GetPathDashArray != null) gl._GetPathDashArray(path, dashArray); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPathLengthNV</para>
        /// </summary>
        [GLEntry("GetPathLengthNV", Category = "NV")]
        public static GLDelegate.GetPathLength _GetPathLength = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPathLength.</para>
        /// <para>Fullname: GetPathLengthNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static float GetPathLength(uint path, int startSegment, int numSegments)
        {
            if (gl._GetPathLength != null) return gl._GetPathLength(path, startSegment, numSegments);
            else { return (float)0; }
        }
        /// <summary>
        /// <para>Fullname: GetPathMetricRangeNV</para>
        /// </summary>
        [GLEntry("GetPathMetricRangeNV", Category = "NV")]
        public static GLDelegate.GetPathMetricRange _GetPathMetricRange = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPathMetricRange.</para>
        /// <para>Fullname: GetPathMetricRangeNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void GetPathMetricRange(int metricQueryMask, uint firstPathName, int numPaths, int stride, float[] metrics)
        {
            if (gl._GetPathMetricRange != null) gl._GetPathMetricRange(metricQueryMask, firstPathName, numPaths, stride, metrics); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPathMetricsNV</para>
        /// </summary>
        [GLEntry("GetPathMetricsNV", Category = "NV")]
        public static GLDelegate.GetPathMetrics _GetPathMetrics = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPathMetrics.</para>
        /// <para>Fullname: GetPathMetricsNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void GetPathMetrics(int metricQueryMask, int numPaths, int pathNameType, IntPtr paths, uint pathBase, int stride, float[] metrics)
        {
            if (gl._GetPathMetrics != null) gl._GetPathMetrics(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPathParameterfvNV</para>
        /// </summary>
        [GLEntry("GetPathParameterfvNV", Category = "NV")]
        public static GLDelegate.GetPathParameterfv _GetPathParameterfv = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPathParameterfv.</para>
        /// <para>Fullname: GetPathParameterfvNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void GetPathParameterfv(uint path, int pname, float[] value)
        {
            if (gl._GetPathParameterfv != null) gl._GetPathParameterfv(path, pname, value); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPathParameterivNV</para>
        /// </summary>
        [GLEntry("GetPathParameterivNV", Category = "NV")]
        public static GLDelegate.GetPathParameteriv _GetPathParameteriv = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPathParameteriv.</para>
        /// <para>Fullname: GetPathParameterivNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void GetPathParameteriv(uint path, int pname, int[] value)
        {
            if (gl._GetPathParameteriv != null) gl._GetPathParameteriv(path, pname, value); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPathSpacingNV</para>
        /// </summary>
        [GLEntry("GetPathSpacingNV", Category = "NV")]
        public static GLDelegate.GetPathSpacing _GetPathSpacing = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPathSpacing.</para>
        /// <para>Fullname: GetPathSpacingNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void GetPathSpacing(int pathListMode, int numPaths, int pathNameType, IntPtr paths, uint pathBase, float advanceScale, float kerningScale, int transformType, float[] returnedSpacing)
        {
            if (gl._GetPathSpacing != null) gl._GetPathSpacing(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPathTexGenfvNV</para>
        /// </summary>
        [GLEntry("GetPathTexGenfvNV", Category = "NV")]
        public static GLDelegate.GetPathTexGenfv _GetPathTexGenfv = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPathTexGenfv.</para>
        /// <para>Fullname: GetPathTexGenfvNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void GetPathTexGenfv(int texCoordSet, int pname, float[] value)
        {
            if (gl._GetPathTexGenfv != null) gl._GetPathTexGenfv(texCoordSet, pname, value); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPathTexGenivNV</para>
        /// </summary>
        [GLEntry("GetPathTexGenivNV", Category = "NV")]
        public static GLDelegate.GetPathTexGeniv _GetPathTexGeniv = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPathTexGeniv.</para>
        /// <para>Fullname: GetPathTexGenivNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void GetPathTexGeniv(int texCoordSet, int pname, int[] value)
        {
            if (gl._GetPathTexGeniv != null) gl._GetPathTexGeniv(texCoordSet, pname, value); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramEnvParameterIivNV</para>
        /// </summary>
        [GLEntry("GetProgramEnvParameterIivNV", Category = "NV")]
        public static GLDelegate.GetProgramEnvParameterIiv _GetProgramEnvParameterIiv = null;
        /// <summary>
        /// <para>This specification documents the common instruction set and basic functionality provided by NVIDIA's 4th generation of assembly instruction sets supporting programmable graphics pipeline stages. The instruction set builds upon the basic framework provided by the ARB_vertex_program and ARB_fragment_program extensions to expose considerably more capable hardware.  In addition to new capabilities for vertex and fragment programs, this extension provides a new program type (geometry programs) further described in the NV_geometry_program4 specification. NV_gpu_program4 provides a unified instruction set -- all instruction set features are available for all program types, except for a small number of features that make sense only for a specific program type.  It provides fully capable signed and unsigned integer data types, along with a set of arithmetic, logical, and data type conversion instructions capable of operating on integers.  It also provides a uniform set of structured branching c...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramEnvParameterIiv.</para>
        /// <para>Fullname: GetProgramEnvParameterIivNV</para>
        /// <para>Extensions: NV_gpu_program4</para>
        /// </summary>
        public static void GetProgramEnvParameterIiv(int target, uint index, int[] param)
        {
            if (gl._GetProgramEnvParameterIiv != null) gl._GetProgramEnvParameterIiv(target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramEnvParameterIuivNV</para>
        /// </summary>
        [GLEntry("GetProgramEnvParameterIuivNV", Category = "NV")]
        public static GLDelegate.GetProgramEnvParameterIuiv _GetProgramEnvParameterIuiv = null;
        /// <summary>
        /// <para>This specification documents the common instruction set and basic functionality provided by NVIDIA's 4th generation of assembly instruction sets supporting programmable graphics pipeline stages. The instruction set builds upon the basic framework provided by the ARB_vertex_program and ARB_fragment_program extensions to expose considerably more capable hardware.  In addition to new capabilities for vertex and fragment programs, this extension provides a new program type (geometry programs) further described in the NV_geometry_program4 specification. NV_gpu_program4 provides a unified instruction set -- all instruction set features are available for all program types, except for a small number of features that make sense only for a specific program type.  It provides fully capable signed and unsigned integer data types, along with a set of arithmetic, logical, and data type conversion instructions capable of operating on integers.  It also provides a uniform set of structured branching c...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramEnvParameterIuiv.</para>
        /// <para>Fullname: GetProgramEnvParameterIuivNV</para>
        /// <para>Extensions: NV_gpu_program4</para>
        /// </summary>
        public static void GetProgramEnvParameterIuiv(int target, uint index, uint[] param)
        {
            if (gl._GetProgramEnvParameterIuiv != null) gl._GetProgramEnvParameterIuiv(target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramLocalParameterIivNV</para>
        /// </summary>
        [GLEntry("GetProgramLocalParameterIivNV", Category = "NV")]
        public static GLDelegate.GetProgramLocalParameterIiv _GetProgramLocalParameterIiv = null;
        /// <summary>
        /// <para>This specification documents the common instruction set and basic functionality provided by NVIDIA's 4th generation of assembly instruction sets supporting programmable graphics pipeline stages. The instruction set builds upon the basic framework provided by the ARB_vertex_program and ARB_fragment_program extensions to expose considerably more capable hardware.  In addition to new capabilities for vertex and fragment programs, this extension provides a new program type (geometry programs) further described in the NV_geometry_program4 specification. NV_gpu_program4 provides a unified instruction set -- all instruction set features are available for all program types, except for a small number of features that make sense only for a specific program type.  It provides fully capable signed and unsigned integer data types, along with a set of arithmetic, logical, and data type conversion instructions capable of operating on integers.  It also provides a uniform set of structured branching c...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramLocalParameterIiv.</para>
        /// <para>Fullname: GetProgramLocalParameterIivNV</para>
        /// <para>Extensions: NV_gpu_program4</para>
        /// </summary>
        public static void GetProgramLocalParameterIiv(int target, uint index, int[] param)
        {
            if (gl._GetProgramLocalParameterIiv != null) gl._GetProgramLocalParameterIiv(target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramLocalParameterIuivNV</para>
        /// </summary>
        [GLEntry("GetProgramLocalParameterIuivNV", Category = "NV")]
        public static GLDelegate.GetProgramLocalParameterIuiv _GetProgramLocalParameterIuiv = null;
        /// <summary>
        /// <para>This specification documents the common instruction set and basic functionality provided by NVIDIA's 4th generation of assembly instruction sets supporting programmable graphics pipeline stages. The instruction set builds upon the basic framework provided by the ARB_vertex_program and ARB_fragment_program extensions to expose considerably more capable hardware.  In addition to new capabilities for vertex and fragment programs, this extension provides a new program type (geometry programs) further described in the NV_geometry_program4 specification. NV_gpu_program4 provides a unified instruction set -- all instruction set features are available for all program types, except for a small number of features that make sense only for a specific program type.  It provides fully capable signed and unsigned integer data types, along with a set of arithmetic, logical, and data type conversion instructions capable of operating on integers.  It also provides a uniform set of structured branching c...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramLocalParameterIuiv.</para>
        /// <para>Fullname: GetProgramLocalParameterIuivNV</para>
        /// <para>Extensions: NV_gpu_program4</para>
        /// </summary>
        public static void GetProgramLocalParameterIuiv(int target, uint index, uint[] param)
        {
            if (gl._GetProgramLocalParameterIuiv != null) gl._GetProgramLocalParameterIuiv(target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramNamedParameterdvNV</para>
        /// </summary>
        [GLEntry("GetProgramNamedParameterdvNV", Category = "NV")]
        public static GLDelegate.GetProgramNamedParameterdv _GetProgramNamedParameterdv = null;
        /// <summary>
        /// <para>OpenGL mandates a certain set of configurable per-fragment computations defining texture lookup, texture environment, color sum, and fog operations.  Each of these areas provide a useful but limited set of fixed operations.  For example, unextended OpenGL 1.2.1 provides only four texture environment modes, color sum, and three fog modes.  Many OpenGL extensions have either improved existing functionality or introduced new configurable fragment operations.  While these extensions have enabled new and interesting rendering effects, the set of effects is limited by the set of special modes introduced by the extension.  This lack of flexibility is in contrast to the high-level of programmability of general-purpose CPUs and other (frequently software-based) shading languages.  The purpose of this extension is to expose to the OpenGL application writer an unprecedented degree of programmability in the computation of final fragment colors and depth values. This extension provides a mechanism ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramNamedParameterdv.</para>
        /// <para>Fullname: GetProgramNamedParameterdvNV</para>
        /// <para>Extensions: NV_fragment_program</para>
        /// </summary>
        public static void GetProgramNamedParameterdv(uint id, int len, byte[] name, double[] param)
        {
            if (gl._GetProgramNamedParameterdv != null) gl._GetProgramNamedParameterdv(id, len, name, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramNamedParameterfvNV</para>
        /// </summary>
        [GLEntry("GetProgramNamedParameterfvNV", Category = "NV")]
        public static GLDelegate.GetProgramNamedParameterfv _GetProgramNamedParameterfv = null;
        /// <summary>
        /// <para>OpenGL mandates a certain set of configurable per-fragment computations defining texture lookup, texture environment, color sum, and fog operations.  Each of these areas provide a useful but limited set of fixed operations.  For example, unextended OpenGL 1.2.1 provides only four texture environment modes, color sum, and three fog modes.  Many OpenGL extensions have either improved existing functionality or introduced new configurable fragment operations.  While these extensions have enabled new and interesting rendering effects, the set of effects is limited by the set of special modes introduced by the extension.  This lack of flexibility is in contrast to the high-level of programmability of general-purpose CPUs and other (frequently software-based) shading languages.  The purpose of this extension is to expose to the OpenGL application writer an unprecedented degree of programmability in the computation of final fragment colors and depth values. This extension provides a mechanism ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramNamedParameterfv.</para>
        /// <para>Fullname: GetProgramNamedParameterfvNV</para>
        /// <para>Extensions: NV_fragment_program</para>
        /// </summary>
        public static void GetProgramNamedParameterfv(uint id, int len, byte[] name, float[] param)
        {
            if (gl._GetProgramNamedParameterfv != null) gl._GetProgramNamedParameterfv(id, len, name, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramParameterdvNV</para>
        /// </summary>
        [GLEntry("GetProgramParameterdvNV", Category = "NV")]
        public static GLDelegate.GetProgramParameterdv _GetProgramParameterdv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramParameterdv.</para>
        /// <para>Fullname: GetProgramParameterdvNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void GetProgramParameterdv(int target, uint index, int pname, double[] param)
        {
            if (gl._GetProgramParameterdv != null) gl._GetProgramParameterdv(target, index, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramParameterfvNV</para>
        /// </summary>
        [GLEntry("GetProgramParameterfvNV", Category = "NV")]
        public static GLDelegate.GetProgramParameterfv _GetProgramParameterfv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramParameterfv.</para>
        /// <para>Fullname: GetProgramParameterfvNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void GetProgramParameterfv(int target, uint index, int pname, float[] param)
        {
            if (gl._GetProgramParameterfv != null) gl._GetProgramParameterfv(target, index, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramStringNV</para>
        /// </summary>
        [GLEntry("GetProgramStringNV", Category = "NV")]
        public static GLDelegate.GetProgramStringNV _GetProgramStringNV = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramStringNV.</para>
        /// <para>Fullname: GetProgramStringNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void GetProgramStringNV(uint id, int pname, byte[] program)
        {
            if (gl._GetProgramStringNV != null) gl._GetProgramStringNV(id, pname, program); else { }
        }
        /// <summary>
        /// <para>Fullname: GetProgramSubroutineParameteruivNV</para>
        /// </summary>
        [GLEntry("GetProgramSubroutineParameteruivNV", Category = "NV")]
        public static GLDelegate.GetProgramSubroutineParameteruiv _GetProgramSubroutineParameteruiv = null;
        /// <summary>
        /// <para>This specification documents the common instruction set and basic functionality provided by NVIDIA's 5th generation of assembly instruction sets supporting programmable graphics pipeline stages. The instruction set builds upon the basic framework provided by the ARB_vertex_program and ARB_fragment_program extensions to expose considerably more capable hardware.  In addition to new capabilities for vertex and fragment programs, this extension provides new functionality for geometry programs as originally described in the NV_geometry_program4 specification, and serves as the basis for the new tessellation control and evaluation programs described in the NV_tessellation_program5 extension. Programs using the functionality provided by this extension should begin with the program headers "!!NVvp5.0" (vertex programs), "!!NVtcp5.0" (tessellation control programs), "!!NVtep5.0" (tessellation evaluation programs), "!!NVgp5.0" (geometry programs), and "!!NVfp5.0" (fragment programs). This exten...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetProgramSubroutineParameteruiv.</para>
        /// <para>Fullname: GetProgramSubroutineParameteruivNV</para>
        /// <para>Extensions: NV_gpu_program5</para>
        /// </summary>
        public static void GetProgramSubroutineParameteruiv(int target, uint index, uint[] param)
        {
            if (gl._GetProgramSubroutineParameteruiv != null) gl._GetProgramSubroutineParameteruiv(target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTextureHandleNV</para>
        /// </summary>
        [GLEntry("GetTextureHandleNV", Category = "NV")]
        public static GLDelegate.GetTextureHandle _GetTextureHandle = null;
        /// <summary>
        /// <para>This extension allows OpenGL applications to access texture objects in shaders without first binding each texture to one of a limited number of texture image units.  Using this extension, an application can query an 64-bit unsigned integer texture handle for each texture that it wants to access and then use that handle directly in GLSL or assembly-based shaders.  The ability to access textures without having to bind and/or re-bind them is similar to the capability provided by the NV_shader_buffer_load extension that allows shaders to access buffer objects without binding them.  In both cases, these extensions significantly reduce the amount of API and internal GL driver overhead needed to manage resource bindings. This extension also provides similar capability for the image load, store, and atomic functionality provided by OpenGL 4.2 and the ARB_shader_image_load_store and EXT_shader_image_load_store extensions, where a texture can be accessed without first binding it to an image unit...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTextureHandle.</para>
        /// <para>Fullname: GetTextureHandleNV</para>
        /// <para>Extensions: NV_bindless_texture</para>
        /// </summary>
        public static ulong GetTextureHandle(uint texture)
        {
            if (gl._GetTextureHandle != null) return gl._GetTextureHandle(texture);
            else { return (ulong)0; }
        }
        /// <summary>
        /// <para>Fullname: GetTextureSamplerHandleNV</para>
        /// </summary>
        [GLEntry("GetTextureSamplerHandleNV", Category = "NV")]
        public static GLDelegate.GetTextureSamplerHandle _GetTextureSamplerHandle = null;
        /// <summary>
        /// <para>This extension allows OpenGL applications to access texture objects in shaders without first binding each texture to one of a limited number of texture image units.  Using this extension, an application can query an 64-bit unsigned integer texture handle for each texture that it wants to access and then use that handle directly in GLSL or assembly-based shaders.  The ability to access textures without having to bind and/or re-bind them is similar to the capability provided by the NV_shader_buffer_load extension that allows shaders to access buffer objects without binding them.  In both cases, these extensions significantly reduce the amount of API and internal GL driver overhead needed to manage resource bindings. This extension also provides similar capability for the image load, store, and atomic functionality provided by OpenGL 4.2 and the ARB_shader_image_load_store and EXT_shader_image_load_store extensions, where a texture can be accessed without first binding it to an image unit...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTextureSamplerHandle.</para>
        /// <para>Fullname: GetTextureSamplerHandleNV</para>
        /// <para>Extensions: NV_bindless_texture</para>
        /// </summary>
        public static ulong GetTextureSamplerHandle(uint texture, uint sampler)
        {
            if (gl._GetTextureSamplerHandle != null) return gl._GetTextureSamplerHandle(texture, sampler);
            else { return (ulong)0; }
        }
        /// <summary>
        /// <para>Fullname: GetTrackMatrixivNV</para>
        /// </summary>
        [GLEntry("GetTrackMatrixivNV", Category = "NV")]
        public static GLDelegate.GetTrackMatrixiv _GetTrackMatrixiv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTrackMatrixiv.</para>
        /// <para>Fullname: GetTrackMatrixivNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void GetTrackMatrixiv(int target, uint address, int pname, int[] param)
        {
            if (gl._GetTrackMatrixiv != null) gl._GetTrackMatrixiv(target, address, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTrackMatrixivNV</para>
        /// </summary>
        [GLEntry("GetTrackMatrixivNV", Category = "NV")]
        public static GLDelegate.GetTrackMatrixiv_int _GetTrackMatrixiv_int = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTrackMatrixiv_int.</para>
        /// <para>Fullname: GetTrackMatrixivNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void GetTrackMatrixiv(int target, uint address, int pname, out int param)
        {
            if (gl._GetTrackMatrixiv_int != null) gl._GetTrackMatrixiv_int(target, address, pname, out param); else { param = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetTransformFeedbackVaryingNV</para>
        /// </summary>
        [GLEntry("GetTransformFeedbackVaryingNV", Category = "NV")]
        public static GLDelegate.GetTransformFeedbackVaryingNV_int _GetTransformFeedbackVaryingNV_int = null;
        /// <summary>
        /// <para>This extension provides a new mode to the GL, called transform feedback, which records vertex attributes of the primitives processed by the GL. The selected attributes are written into buffer objects, and can be written with each attribute in a separate buffer object or with all attributes interleaved into a single buffer object.  If a geometry program or shader is active, the primitives recorded are those emitted by the geometry program.  Otherwise, transform feedback captures primitives whose vertex are transformed by a vertex program or shader, or by fixed-function vertex processing.  In either case, the primitives captured are those generated prior to clipping.  Transform feedback mode is capable of capturing transformed vertex data generated by fixed-function vertex processing, outputs from assembly vertex or geometry programs, or varying variables emitted from GLSL vertex or geometry shaders. The vertex data recorded in transform feedback mode is stored into buffer objects as an ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTransformFeedbackVaryingNV_int.</para>
        /// <para>Fullname: GetTransformFeedbackVaryingNV</para>
        /// <para>Extensions: NV_transform_feedback</para>
        /// </summary>
        public static void GetTransformFeedbackVaryingNV(uint program, uint index, out int location)
        {
            if (gl._GetTransformFeedbackVaryingNV_int != null) gl._GetTransformFeedbackVaryingNV_int(program, index, out location); else { location = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetTransformFeedbackVaryingNV</para>
        /// </summary>
        [GLEntry("GetTransformFeedbackVaryingNV", Category = "NV")]
        public static GLDelegate.GetTransformFeedbackVaryingNV _GetTransformFeedbackVaryingNV = null;
        /// <summary>
        /// <para>This extension provides a new mode to the GL, called transform feedback, which records vertex attributes of the primitives processed by the GL. The selected attributes are written into buffer objects, and can be written with each attribute in a separate buffer object or with all attributes interleaved into a single buffer object.  If a geometry program or shader is active, the primitives recorded are those emitted by the geometry program.  Otherwise, transform feedback captures primitives whose vertex are transformed by a vertex program or shader, or by fixed-function vertex processing.  In either case, the primitives captured are those generated prior to clipping.  Transform feedback mode is capable of capturing transformed vertex data generated by fixed-function vertex processing, outputs from assembly vertex or geometry programs, or varying variables emitted from GLSL vertex or geometry shaders. The vertex data recorded in transform feedback mode is stored into buffer objects as an ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTransformFeedbackVaryingNV.</para>
        /// <para>Fullname: GetTransformFeedbackVaryingNV</para>
        /// <para>Extensions: NV_transform_feedback</para>
        /// </summary>
        public static void GetTransformFeedbackVaryingNV(uint program, uint index, int[] location)
        {
            if (gl._GetTransformFeedbackVaryingNV != null) gl._GetTransformFeedbackVaryingNV(program, index, location); else { }
        }
        /// <summary>
        /// <para>Fullname: GetUniformi64vNV</para>
        /// </summary>
        [GLEntry("GetUniformi64vNV", Category = "NV")]
        public static GLDelegate.GetUniformi64v _GetUniformi64v = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetUniformi64v.</para>
        /// <para>Fullname: GetUniformi64vNV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void GetUniformi64v(uint program, int location, long[] param)
        {
            if (gl._GetUniformi64v != null) gl._GetUniformi64v(program, location, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetUniformui64vNV</para>
        /// </summary>
        [GLEntry("GetUniformui64vNV", Category = "NV")]
        public static GLDelegate.GetUniformui64v _GetUniformui64v = null;
        /// <summary>
        /// <para>At a very coarse level, GL has evolved in a way that allows applications to replace many of the original state machine variables with blocks of user-defined data. For example, the current vertex state has been augmented by vertex buffer objects, fixed-function shading state and parameters have been replaced by shaders/programs and constant buffers, etc.. Applications switch between coarse sets of state by binding objects to the context or to other container objects (e.g. vertex array objects) instead of manipulating state variables of the context. In terms of the number of GL commands required to draw an object, modern applications are orders of magnitude more efficient than legacy applications, but this explosion of objects bound to other objects has led to a new bottleneck - pointer chasing and CPU L2 cache misses in the driver, and general L2 cache pollution. This extension provides a mechanism to read from a flat, 64-bit GPU address space from programs/shaders, to query GPU address...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetUniformui64v.</para>
        /// <para>Fullname: GetUniformui64vNV</para>
        /// <para>Extensions: NV_shader_buffer_load</para>
        /// </summary>
        public static void GetUniformui64v(uint program, int location, ulong[] param)
        {
            if (gl._GetUniformui64v != null) gl._GetUniformui64v(program, location, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVaryingLocationNV</para>
        /// </summary>
        [GLEntry("GetVaryingLocationNV", Category = "NV")]
        public static GLDelegate.GetVaryingLocation _GetVaryingLocation = null;
        /// <summary>
        /// <para>This extension provides a new mode to the GL, called transform feedback, which records vertex attributes of the primitives processed by the GL. The selected attributes are written into buffer objects, and can be written with each attribute in a separate buffer object or with all attributes interleaved into a single buffer object.  If a geometry program or shader is active, the primitives recorded are those emitted by the geometry program.  Otherwise, transform feedback captures primitives whose vertex are transformed by a vertex program or shader, or by fixed-function vertex processing.  In either case, the primitives captured are those generated prior to clipping.  Transform feedback mode is capable of capturing transformed vertex data generated by fixed-function vertex processing, outputs from assembly vertex or geometry programs, or varying variables emitted from GLSL vertex or geometry shaders. The vertex data recorded in transform feedback mode is stored into buffer objects as an ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVaryingLocation.</para>
        /// <para>Fullname: GetVaryingLocationNV</para>
        /// <para>Extensions: NV_transform_feedback</para>
        /// </summary>
        public static int GetVaryingLocation(uint program, StringBuilder name)
        {
            if (gl._GetVaryingLocation != null) return gl._GetVaryingLocation(program, name);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: GetVertexAttribLi64vNV</para>
        /// </summary>
        [GLEntry("GetVertexAttribLi64vNV", Category = "NV")]
        public static GLDelegate.GetVertexAttribLi64v _GetVertexAttribLi64v = null;
        /// <summary>
        /// <para>This extension provides support for specifying vertex attributes with 64-bit integer components, analagous to the 64-bit floating point support added in EXT_vertex_attrib_64bit. Additionally, it provides the VertexAttribLFormatNV entry point to specify bindless vertex attribute arrays with 64-bit integer or floating-point components in conjunction with the NV_vertex_buffer_unified_memory extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVertexAttribLi64v.</para>
        /// <para>Fullname: GetVertexAttribLi64vNV</para>
        /// <para>Extensions: NV_vertex_attrib_integer_64bit</para>
        /// </summary>
        public static void GetVertexAttribLi64v(uint index, int pname, long[] param)
        {
            if (gl._GetVertexAttribLi64v != null) gl._GetVertexAttribLi64v(index, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVertexAttribLui64vNV</para>
        /// </summary>
        [GLEntry("GetVertexAttribLui64vNV", Category = "NV")]
        public static GLDelegate.GetVertexAttribLui64v _GetVertexAttribLui64v = null;
        /// <summary>
        /// <para>This extension provides support for specifying vertex attributes with 64-bit integer components, analagous to the 64-bit floating point support added in EXT_vertex_attrib_64bit. Additionally, it provides the VertexAttribLFormatNV entry point to specify bindless vertex attribute arrays with 64-bit integer or floating-point components in conjunction with the NV_vertex_buffer_unified_memory extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVertexAttribLui64v.</para>
        /// <para>Fullname: GetVertexAttribLui64vNV</para>
        /// <para>Extensions: NV_vertex_attrib_integer_64bit</para>
        /// </summary>
        public static void GetVertexAttribLui64v(uint index, int pname, ulong[] param)
        {
            if (gl._GetVertexAttribLui64v != null) gl._GetVertexAttribLui64v(index, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVideoCaptureivNV</para>
        /// </summary>
        [GLEntry("GetVideoCaptureivNV", Category = "NV")]
        public static GLDelegate.GetVideoCaptureiv _GetVideoCaptureiv = null;
        /// <summary>
        /// <para>This extension provides a mechanism for streaming video data directly into texture objects and buffer objects.  Applications can then display video streams in interactive 3D scenes and/or manipulate the video data using the GL's image processing capabilities. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVideoCaptureiv.</para>
        /// <para>Fullname: GetVideoCaptureivNV</para>
        /// <para>Extensions: NV_video_capture</para>
        /// </summary>
        public static void GetVideoCaptureiv(uint video_capture_slot, int pname, int[] param)
        {
            if (gl._GetVideoCaptureiv != null) gl._GetVideoCaptureiv(video_capture_slot, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVideoCaptureStreamdvNV</para>
        /// </summary>
        [GLEntry("GetVideoCaptureStreamdvNV", Category = "NV")]
        public static GLDelegate.GetVideoCaptureStreamdv _GetVideoCaptureStreamdv = null;
        /// <summary>
        /// <para>This extension provides a mechanism for streaming video data directly into texture objects and buffer objects.  Applications can then display video streams in interactive 3D scenes and/or manipulate the video data using the GL's image processing capabilities. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVideoCaptureStreamdv.</para>
        /// <para>Fullname: GetVideoCaptureStreamdvNV</para>
        /// <para>Extensions: NV_video_capture</para>
        /// </summary>
        public static void GetVideoCaptureStreamdv(uint video_capture_slot, uint stream, int pname, double[] param)
        {
            if (gl._GetVideoCaptureStreamdv != null) gl._GetVideoCaptureStreamdv(video_capture_slot, stream, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVideoCaptureStreamfvNV</para>
        /// </summary>
        [GLEntry("GetVideoCaptureStreamfvNV", Category = "NV")]
        public static GLDelegate.GetVideoCaptureStreamfv _GetVideoCaptureStreamfv = null;
        /// <summary>
        /// <para>This extension provides a mechanism for streaming video data directly into texture objects and buffer objects.  Applications can then display video streams in interactive 3D scenes and/or manipulate the video data using the GL's image processing capabilities. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVideoCaptureStreamfv.</para>
        /// <para>Fullname: GetVideoCaptureStreamfvNV</para>
        /// <para>Extensions: NV_video_capture</para>
        /// </summary>
        public static void GetVideoCaptureStreamfv(uint video_capture_slot, uint stream, int pname, float[] param)
        {
            if (gl._GetVideoCaptureStreamfv != null) gl._GetVideoCaptureStreamfv(video_capture_slot, stream, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVideoCaptureStreamivNV</para>
        /// </summary>
        [GLEntry("GetVideoCaptureStreamivNV", Category = "NV")]
        public static GLDelegate.GetVideoCaptureStreamiv _GetVideoCaptureStreamiv = null;
        /// <summary>
        /// <para>This extension provides a mechanism for streaming video data directly into texture objects and buffer objects.  Applications can then display video streams in interactive 3D scenes and/or manipulate the video data using the GL's image processing capabilities. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVideoCaptureStreamiv.</para>
        /// <para>Fullname: GetVideoCaptureStreamivNV</para>
        /// <para>Extensions: NV_video_capture</para>
        /// </summary>
        public static void GetVideoCaptureStreamiv(uint video_capture_slot, uint stream, int pname, int[] param)
        {
            if (gl._GetVideoCaptureStreamiv != null) gl._GetVideoCaptureStreamiv(video_capture_slot, stream, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVideoi64vNV</para>
        /// </summary>
        [GLEntry("GetVideoi64vNV", Category = "NV")]
        public static GLDelegate.GetVideoi64v _GetVideoi64v = null;
        /// <summary>
        /// <para>This extension provides a mechanism for displaying textures and renderbuffers on auxiliary video output devices.  It allows an application to specify separate buffers for the individual fields used with interlaced output.  It also provides a way to present frames or field pairs simultaneously in two separate video streams.  It also allows an application to request when images should be displayed, and to obtain feedback on exactly when images are actually first displayed. This specification attempts to avoid language that would tie it to any particular hardware or vendor.  However, it should be noted that it has been designed specifically for use with NVIDIA SDI products and the features and limitations of the spec compliment those of NVIDIA's line of SDI video output devices. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVideoi64v.</para>
        /// <para>Fullname: GetVideoi64vNV</para>
        /// <para>Extensions: NV_present_video</para>
        /// </summary>
        public static void GetVideoi64v(uint video_slot, int pname, long[] param)
        {
            if (gl._GetVideoi64v != null) gl._GetVideoi64v(video_slot, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVideoivNV</para>
        /// </summary>
        [GLEntry("GetVideoivNV", Category = "NV")]
        public static GLDelegate.GetVideoiv _GetVideoiv = null;
        /// <summary>
        /// <para>This extension provides a mechanism for displaying textures and renderbuffers on auxiliary video output devices.  It allows an application to specify separate buffers for the individual fields used with interlaced output.  It also provides a way to present frames or field pairs simultaneously in two separate video streams.  It also allows an application to request when images should be displayed, and to obtain feedback on exactly when images are actually first displayed. This specification attempts to avoid language that would tie it to any particular hardware or vendor.  However, it should be noted that it has been designed specifically for use with NVIDIA SDI products and the features and limitations of the spec compliment those of NVIDIA's line of SDI video output devices. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVideoiv.</para>
        /// <para>Fullname: GetVideoivNV</para>
        /// <para>Extensions: NV_present_video</para>
        /// </summary>
        public static void GetVideoiv(uint video_slot, int pname, int[] param)
        {
            if (gl._GetVideoiv != null) gl._GetVideoiv(video_slot, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVideoui64vNV</para>
        /// </summary>
        [GLEntry("GetVideoui64vNV", Category = "NV")]
        public static GLDelegate.GetVideoui64v _GetVideoui64v = null;
        /// <summary>
        /// <para>This extension provides a mechanism for displaying textures and renderbuffers on auxiliary video output devices.  It allows an application to specify separate buffers for the individual fields used with interlaced output.  It also provides a way to present frames or field pairs simultaneously in two separate video streams.  It also allows an application to request when images should be displayed, and to obtain feedback on exactly when images are actually first displayed. This specification attempts to avoid language that would tie it to any particular hardware or vendor.  However, it should be noted that it has been designed specifically for use with NVIDIA SDI products and the features and limitations of the spec compliment those of NVIDIA's line of SDI video output devices. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVideoui64v.</para>
        /// <para>Fullname: GetVideoui64vNV</para>
        /// <para>Extensions: NV_present_video</para>
        /// </summary>
        public static void GetVideoui64v(uint video_slot, int pname, ulong[] param)
        {
            if (gl._GetVideoui64v != null) gl._GetVideoui64v(video_slot, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVideouivNV</para>
        /// </summary>
        [GLEntry("GetVideouivNV", Category = "NV")]
        public static GLDelegate.GetVideouiv _GetVideouiv = null;
        /// <summary>
        /// <para>This extension provides a mechanism for displaying textures and renderbuffers on auxiliary video output devices.  It allows an application to specify separate buffers for the individual fields used with interlaced output.  It also provides a way to present frames or field pairs simultaneously in two separate video streams.  It also allows an application to request when images should be displayed, and to obtain feedback on exactly when images are actually first displayed. This specification attempts to avoid language that would tie it to any particular hardware or vendor.  However, it should be noted that it has been designed specifically for use with NVIDIA SDI products and the features and limitations of the spec compliment those of NVIDIA's line of SDI video output devices. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVideouiv.</para>
        /// <para>Fullname: GetVideouivNV</para>
        /// <para>Extensions: NV_present_video</para>
        /// </summary>
        public static void GetVideouiv(uint video_slot, int pname, uint[] param)
        {
            if (gl._GetVideouiv != null) gl._GetVideouiv(video_slot, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: IndexFormatNV</para>
        /// </summary>
        [GLEntry("IndexFormatNV", Category = "NV")]
        public static GLDelegate.IndexFormat _IndexFormat = null;
        /// <summary>
        /// <para>This extension provides a mechanism to specify vertex attrib and element array locations using GPU addresses. Binding vertex buffers is one of the most frequent and expensive operations in many GL applications, due to the cost of chasing pointers and binding objects described in the Overview of NV_shader_buffer_load. The intent of this extension is to enable a way for the application to specify vertex attrib state that alleviates the overhead of object binds and driver memory management. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IndexFormat.</para>
        /// <para>Fullname: IndexFormatNV</para>
        /// <para>Extensions: NV_vertex_buffer_unified_memory</para>
        /// </summary>
        public static void IndexFormat(int type, int stride)
        {
            if (gl._IndexFormat != null) gl._IndexFormat(type, stride); else { }
        }
        /// <summary>
        /// <para>Fullname: InterpolatePathsNV</para>
        /// </summary>
        [GLEntry("InterpolatePathsNV", Category = "NV")]
        public static GLDelegate.InterpolatePaths _InterpolatePaths = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _InterpolatePaths.</para>
        /// <para>Fullname: InterpolatePathsNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void InterpolatePaths(uint resultPath, uint pathA, uint pathB, float weight)
        {
            if (gl._InterpolatePaths != null) gl._InterpolatePaths(resultPath, pathA, pathB, weight); else { }
        }
        /// <summary>
        /// <para>Fullname: IsBufferResidentNV</para>
        /// </summary>
        [GLEntry("IsBufferResidentNV", Category = "NV")]
        public static GLDelegate.IsBufferResident _IsBufferResident = null;
        /// <summary>
        /// <para>At a very coarse level, GL has evolved in a way that allows applications to replace many of the original state machine variables with blocks of user-defined data. For example, the current vertex state has been augmented by vertex buffer objects, fixed-function shading state and parameters have been replaced by shaders/programs and constant buffers, etc.. Applications switch between coarse sets of state by binding objects to the context or to other container objects (e.g. vertex array objects) instead of manipulating state variables of the context. In terms of the number of GL commands required to draw an object, modern applications are orders of magnitude more efficient than legacy applications, but this explosion of objects bound to other objects has led to a new bottleneck - pointer chasing and CPU L2 cache misses in the driver, and general L2 cache pollution. This extension provides a mechanism to read from a flat, 64-bit GPU address space from programs/shaders, to query GPU address...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsBufferResident.</para>
        /// <para>Fullname: IsBufferResidentNV</para>
        /// <para>Extensions: NV_shader_buffer_load</para>
        /// </summary>
        public static bool IsBufferResident(int target)
        {
            if (gl._IsBufferResident != null) return gl._IsBufferResident(target);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: IsFenceNV</para>
        /// </summary>
        [GLEntry("IsFenceNV", Category = "NV", Alias = "IsFenceAPPLE ")]
        public static GLDelegate.IsFence _IsFence = null;
        public static GLDelegate.IsFence IsFenceAPPLE = IsFence;
        /// <summary>
        /// <para>The goal of this extension is provide a finer granularity of synchronizing GL command completion than offered by standard OpenGL, which offers only two mechanisms for synchronization: Flush and Finish. Since Flush merely assures the user that the commands complete in a finite (though undetermined) amount of time, it is, thus, of only modest utility.  Finish, on the other hand, stalls CPU execution until all pending GL commands have completed.  This extension offers a middle ground - the ability to "finish" a subset of the command stream, and the ability to determine whether a given command has completed or not. This extension introduces the concept of a "fence" to the OpenGL command stream.  Once the fence is inserted into the command stream, it can be queried for a given condition - typically, its completion. Moreover, the application may also request a partial Finish -- that is, all commands prior to the fence will be forced to complete until control is returned to the calling proces...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsFence.</para>
        /// <para>Fullname: IsFenceNV</para>
        /// <para>Aliases: IsFenceAPPLE, </para>
        /// <para>Extensions: NV_fence APPLE_fence</para>
        /// </summary>
        public static bool IsFence(uint fence)
        {
            if (gl._IsFence != null) return gl._IsFence(fence);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: IsImageHandleResidentNV</para>
        /// </summary>
        [GLEntry("IsImageHandleResidentNV", Category = "NV")]
        public static GLDelegate.IsImageHandleResident _IsImageHandleResident = null;
        /// <summary>
        /// <para>This extension allows OpenGL applications to access texture objects in shaders without first binding each texture to one of a limited number of texture image units.  Using this extension, an application can query an 64-bit unsigned integer texture handle for each texture that it wants to access and then use that handle directly in GLSL or assembly-based shaders.  The ability to access textures without having to bind and/or re-bind them is similar to the capability provided by the NV_shader_buffer_load extension that allows shaders to access buffer objects without binding them.  In both cases, these extensions significantly reduce the amount of API and internal GL driver overhead needed to manage resource bindings. This extension also provides similar capability for the image load, store, and atomic functionality provided by OpenGL 4.2 and the ARB_shader_image_load_store and EXT_shader_image_load_store extensions, where a texture can be accessed without first binding it to an image unit...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsImageHandleResident.</para>
        /// <para>Fullname: IsImageHandleResidentNV</para>
        /// <para>Extensions: NV_bindless_texture</para>
        /// </summary>
        public static bool IsImageHandleResident(ulong handle)
        {
            if (gl._IsImageHandleResident != null) return gl._IsImageHandleResident(handle);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: IsNamedBufferResidentNV</para>
        /// </summary>
        [GLEntry("IsNamedBufferResidentNV", Category = "NV")]
        public static GLDelegate.IsNamedBufferResident _IsNamedBufferResident = null;
        /// <summary>
        /// <para>At a very coarse level, GL has evolved in a way that allows applications to replace many of the original state machine variables with blocks of user-defined data. For example, the current vertex state has been augmented by vertex buffer objects, fixed-function shading state and parameters have been replaced by shaders/programs and constant buffers, etc.. Applications switch between coarse sets of state by binding objects to the context or to other container objects (e.g. vertex array objects) instead of manipulating state variables of the context. In terms of the number of GL commands required to draw an object, modern applications are orders of magnitude more efficient than legacy applications, but this explosion of objects bound to other objects has led to a new bottleneck - pointer chasing and CPU L2 cache misses in the driver, and general L2 cache pollution. This extension provides a mechanism to read from a flat, 64-bit GPU address space from programs/shaders, to query GPU address...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsNamedBufferResident.</para>
        /// <para>Fullname: IsNamedBufferResidentNV</para>
        /// <para>Extensions: NV_shader_buffer_load</para>
        /// </summary>
        public static bool IsNamedBufferResident(uint buffer)
        {
            if (gl._IsNamedBufferResident != null) return gl._IsNamedBufferResident(buffer);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: IsOcclusionQueryNV</para>
        /// </summary>
        [GLEntry("IsOcclusionQueryNV", Category = "NV")]
        public static GLDelegate.IsOcclusionQuery _IsOcclusionQuery = null;
        /// <summary>
        /// <para>The HP_occlusion_test extension defines a mechanism whereby an application can query the visibility of an object, where "visible" means that at least one pixel passes the depth and stencil tests. The HP extension has two major shortcomings. - It returns the result as a simple GL_TRUE/GL_FALSE result, when in fact it is often useful to know exactly how many pixels passed. - It provides only a simple "stop-and-wait" model for using multiple queries.  The application begins an occlusion test and ends it; then, at some later point, it asks for the result, at which point the driver must stop and wait until the result from the previous test is back before the application can even begin the next one. This is a very simple model, but its performance is mediocre when an application wishes to perform many queries, and it eliminates most of the opportunites for parallelism between the CPU and GPU. This extension solves both of those problems.  It returns as its result the number of pixels that pa...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsOcclusionQuery.</para>
        /// <para>Fullname: IsOcclusionQueryNV</para>
        /// <para>Extensions: NV_occlusion_query</para>
        /// </summary>
        public static bool IsOcclusionQuery(uint id)
        {
            if (gl._IsOcclusionQuery != null) return gl._IsOcclusionQuery(id);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: IsPathNV</para>
        /// </summary>
        [GLEntry("IsPathNV", Category = "NV")]
        public static GLDelegate.IsPath _IsPath = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsPath.</para>
        /// <para>Fullname: IsPathNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static bool IsPath(uint path)
        {
            if (gl._IsPath != null) return gl._IsPath(path);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: IsPointInFillPathNV</para>
        /// </summary>
        [GLEntry("IsPointInFillPathNV", Category = "NV")]
        public static GLDelegate.IsPointInFillPath _IsPointInFillPath = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsPointInFillPath.</para>
        /// <para>Fullname: IsPointInFillPathNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static bool IsPointInFillPath(uint path, uint mask, float x, float y)
        {
            if (gl._IsPointInFillPath != null) return gl._IsPointInFillPath(path, mask, x, y);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: IsPointInStrokePathNV</para>
        /// </summary>
        [GLEntry("IsPointInStrokePathNV", Category = "NV")]
        public static GLDelegate.IsPointInStrokePath _IsPointInStrokePath = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsPointInStrokePath.</para>
        /// <para>Fullname: IsPointInStrokePathNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static bool IsPointInStrokePath(uint path, float x, float y)
        {
            if (gl._IsPointInStrokePath != null) return gl._IsPointInStrokePath(path, x, y);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: IsTextureHandleResidentNV</para>
        /// </summary>
        [GLEntry("IsTextureHandleResidentNV", Category = "NV")]
        public static GLDelegate.IsTextureHandleResident _IsTextureHandleResident = null;
        /// <summary>
        /// <para>This extension allows OpenGL applications to access texture objects in shaders without first binding each texture to one of a limited number of texture image units.  Using this extension, an application can query an 64-bit unsigned integer texture handle for each texture that it wants to access and then use that handle directly in GLSL or assembly-based shaders.  The ability to access textures without having to bind and/or re-bind them is similar to the capability provided by the NV_shader_buffer_load extension that allows shaders to access buffer objects without binding them.  In both cases, these extensions significantly reduce the amount of API and internal GL driver overhead needed to manage resource bindings. This extension also provides similar capability for the image load, store, and atomic functionality provided by OpenGL 4.2 and the ARB_shader_image_load_store and EXT_shader_image_load_store extensions, where a texture can be accessed without first binding it to an image unit...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsTextureHandleResident.</para>
        /// <para>Fullname: IsTextureHandleResidentNV</para>
        /// <para>Extensions: NV_bindless_texture</para>
        /// </summary>
        public static bool IsTextureHandleResident(ulong handle)
        {
            if (gl._IsTextureHandleResident != null) return gl._IsTextureHandleResident(handle);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: LoadProgramNV</para>
        /// </summary>
        [GLEntry("LoadProgramNV", Category = "NV")]
        public static GLDelegate.LoadProgram _LoadProgram = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _LoadProgram.</para>
        /// <para>Fullname: LoadProgramNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void LoadProgram(int target, uint id, int len, byte[] program)
        {
            if (gl._LoadProgram != null) gl._LoadProgram(target, id, len, program); else { }
        }
        /// <summary>
        /// <para>Fullname: MakeBufferNonResidentNV</para>
        /// </summary>
        [GLEntry("MakeBufferNonResidentNV", Category = "NV")]
        public static GLDelegate.MakeBufferNonResident _MakeBufferNonResident = null;
        /// <summary>
        /// <para>At a very coarse level, GL has evolved in a way that allows applications to replace many of the original state machine variables with blocks of user-defined data. For example, the current vertex state has been augmented by vertex buffer objects, fixed-function shading state and parameters have been replaced by shaders/programs and constant buffers, etc.. Applications switch between coarse sets of state by binding objects to the context or to other container objects (e.g. vertex array objects) instead of manipulating state variables of the context. In terms of the number of GL commands required to draw an object, modern applications are orders of magnitude more efficient than legacy applications, but this explosion of objects bound to other objects has led to a new bottleneck - pointer chasing and CPU L2 cache misses in the driver, and general L2 cache pollution. This extension provides a mechanism to read from a flat, 64-bit GPU address space from programs/shaders, to query GPU address...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MakeBufferNonResident.</para>
        /// <para>Fullname: MakeBufferNonResidentNV</para>
        /// <para>Extensions: NV_shader_buffer_load</para>
        /// </summary>
        public static void MakeBufferNonResident(int target)
        {
            if (gl._MakeBufferNonResident != null) gl._MakeBufferNonResident(target); else { }
        }
        /// <summary>
        /// <para>Fullname: MakeBufferResidentNV</para>
        /// </summary>
        [GLEntry("MakeBufferResidentNV", Category = "NV")]
        public static GLDelegate.MakeBufferResident _MakeBufferResident = null;
        /// <summary>
        /// <para>At a very coarse level, GL has evolved in a way that allows applications to replace many of the original state machine variables with blocks of user-defined data. For example, the current vertex state has been augmented by vertex buffer objects, fixed-function shading state and parameters have been replaced by shaders/programs and constant buffers, etc.. Applications switch between coarse sets of state by binding objects to the context or to other container objects (e.g. vertex array objects) instead of manipulating state variables of the context. In terms of the number of GL commands required to draw an object, modern applications are orders of magnitude more efficient than legacy applications, but this explosion of objects bound to other objects has led to a new bottleneck - pointer chasing and CPU L2 cache misses in the driver, and general L2 cache pollution. This extension provides a mechanism to read from a flat, 64-bit GPU address space from programs/shaders, to query GPU address...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MakeBufferResident.</para>
        /// <para>Fullname: MakeBufferResidentNV</para>
        /// <para>Extensions: NV_shader_buffer_load</para>
        /// </summary>
        public static void MakeBufferResident(int target, int access)
        {
            if (gl._MakeBufferResident != null) gl._MakeBufferResident(target, access); else { }
        }
        /// <summary>
        /// <para>Fullname: MakeImageHandleNonResidentNV</para>
        /// </summary>
        [GLEntry("MakeImageHandleNonResidentNV", Category = "NV")]
        public static GLDelegate.MakeImageHandleNonResident _MakeImageHandleNonResident = null;
        /// <summary>
        /// <para>This extension allows OpenGL applications to access texture objects in shaders without first binding each texture to one of a limited number of texture image units.  Using this extension, an application can query an 64-bit unsigned integer texture handle for each texture that it wants to access and then use that handle directly in GLSL or assembly-based shaders.  The ability to access textures without having to bind and/or re-bind them is similar to the capability provided by the NV_shader_buffer_load extension that allows shaders to access buffer objects without binding them.  In both cases, these extensions significantly reduce the amount of API and internal GL driver overhead needed to manage resource bindings. This extension also provides similar capability for the image load, store, and atomic functionality provided by OpenGL 4.2 and the ARB_shader_image_load_store and EXT_shader_image_load_store extensions, where a texture can be accessed without first binding it to an image unit...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MakeImageHandleNonResident.</para>
        /// <para>Fullname: MakeImageHandleNonResidentNV</para>
        /// <para>Extensions: NV_bindless_texture</para>
        /// </summary>
        public static void MakeImageHandleNonResident(ulong handle)
        {
            if (gl._MakeImageHandleNonResident != null) gl._MakeImageHandleNonResident(handle); else { }
        }
        /// <summary>
        /// <para>Fullname: MakeImageHandleResidentNV</para>
        /// </summary>
        [GLEntry("MakeImageHandleResidentNV", Category = "NV")]
        public static GLDelegate.MakeImageHandleResident _MakeImageHandleResident = null;
        /// <summary>
        /// <para>This extension allows OpenGL applications to access texture objects in shaders without first binding each texture to one of a limited number of texture image units.  Using this extension, an application can query an 64-bit unsigned integer texture handle for each texture that it wants to access and then use that handle directly in GLSL or assembly-based shaders.  The ability to access textures without having to bind and/or re-bind them is similar to the capability provided by the NV_shader_buffer_load extension that allows shaders to access buffer objects without binding them.  In both cases, these extensions significantly reduce the amount of API and internal GL driver overhead needed to manage resource bindings. This extension also provides similar capability for the image load, store, and atomic functionality provided by OpenGL 4.2 and the ARB_shader_image_load_store and EXT_shader_image_load_store extensions, where a texture can be accessed without first binding it to an image unit...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MakeImageHandleResident.</para>
        /// <para>Fullname: MakeImageHandleResidentNV</para>
        /// <para>Extensions: NV_bindless_texture</para>
        /// </summary>
        public static void MakeImageHandleResident(ulong handle, int access)
        {
            if (gl._MakeImageHandleResident != null) gl._MakeImageHandleResident(handle, access); else { }
        }
        /// <summary>
        /// <para>Fullname: MakeNamedBufferNonResidentNV</para>
        /// </summary>
        [GLEntry("MakeNamedBufferNonResidentNV", Category = "NV")]
        public static GLDelegate.MakeNamedBufferNonResident _MakeNamedBufferNonResident = null;
        /// <summary>
        /// <para>At a very coarse level, GL has evolved in a way that allows applications to replace many of the original state machine variables with blocks of user-defined data. For example, the current vertex state has been augmented by vertex buffer objects, fixed-function shading state and parameters have been replaced by shaders/programs and constant buffers, etc.. Applications switch between coarse sets of state by binding objects to the context or to other container objects (e.g. vertex array objects) instead of manipulating state variables of the context. In terms of the number of GL commands required to draw an object, modern applications are orders of magnitude more efficient than legacy applications, but this explosion of objects bound to other objects has led to a new bottleneck - pointer chasing and CPU L2 cache misses in the driver, and general L2 cache pollution. This extension provides a mechanism to read from a flat, 64-bit GPU address space from programs/shaders, to query GPU address...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MakeNamedBufferNonResident.</para>
        /// <para>Fullname: MakeNamedBufferNonResidentNV</para>
        /// <para>Extensions: NV_shader_buffer_load</para>
        /// </summary>
        public static void MakeNamedBufferNonResident(uint buffer)
        {
            if (gl._MakeNamedBufferNonResident != null) gl._MakeNamedBufferNonResident(buffer); else { }
        }
        /// <summary>
        /// <para>Fullname: MakeNamedBufferResidentNV</para>
        /// </summary>
        [GLEntry("MakeNamedBufferResidentNV", Category = "NV")]
        public static GLDelegate.MakeNamedBufferResident _MakeNamedBufferResident = null;
        /// <summary>
        /// <para>At a very coarse level, GL has evolved in a way that allows applications to replace many of the original state machine variables with blocks of user-defined data. For example, the current vertex state has been augmented by vertex buffer objects, fixed-function shading state and parameters have been replaced by shaders/programs and constant buffers, etc.. Applications switch between coarse sets of state by binding objects to the context or to other container objects (e.g. vertex array objects) instead of manipulating state variables of the context. In terms of the number of GL commands required to draw an object, modern applications are orders of magnitude more efficient than legacy applications, but this explosion of objects bound to other objects has led to a new bottleneck - pointer chasing and CPU L2 cache misses in the driver, and general L2 cache pollution. This extension provides a mechanism to read from a flat, 64-bit GPU address space from programs/shaders, to query GPU address...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MakeNamedBufferResident.</para>
        /// <para>Fullname: MakeNamedBufferResidentNV</para>
        /// <para>Extensions: NV_shader_buffer_load</para>
        /// </summary>
        public static void MakeNamedBufferResident(uint buffer, int access)
        {
            if (gl._MakeNamedBufferResident != null) gl._MakeNamedBufferResident(buffer, access); else { }
        }
        /// <summary>
        /// <para>Fullname: MakeTextureHandleNonResidentNV</para>
        /// </summary>
        [GLEntry("MakeTextureHandleNonResidentNV", Category = "NV")]
        public static GLDelegate.MakeTextureHandleNonResident _MakeTextureHandleNonResident = null;
        /// <summary>
        /// <para>This extension allows OpenGL applications to access texture objects in shaders without first binding each texture to one of a limited number of texture image units.  Using this extension, an application can query an 64-bit unsigned integer texture handle for each texture that it wants to access and then use that handle directly in GLSL or assembly-based shaders.  The ability to access textures without having to bind and/or re-bind them is similar to the capability provided by the NV_shader_buffer_load extension that allows shaders to access buffer objects without binding them.  In both cases, these extensions significantly reduce the amount of API and internal GL driver overhead needed to manage resource bindings. This extension also provides similar capability for the image load, store, and atomic functionality provided by OpenGL 4.2 and the ARB_shader_image_load_store and EXT_shader_image_load_store extensions, where a texture can be accessed without first binding it to an image unit...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MakeTextureHandleNonResident.</para>
        /// <para>Fullname: MakeTextureHandleNonResidentNV</para>
        /// <para>Extensions: NV_bindless_texture</para>
        /// </summary>
        public static void MakeTextureHandleNonResident(ulong handle)
        {
            if (gl._MakeTextureHandleNonResident != null) gl._MakeTextureHandleNonResident(handle); else { }
        }
        /// <summary>
        /// <para>Fullname: MakeTextureHandleResidentNV</para>
        /// </summary>
        [GLEntry("MakeTextureHandleResidentNV", Category = "NV")]
        public static GLDelegate.MakeTextureHandleResident _MakeTextureHandleResident = null;
        /// <summary>
        /// <para>This extension allows OpenGL applications to access texture objects in shaders without first binding each texture to one of a limited number of texture image units.  Using this extension, an application can query an 64-bit unsigned integer texture handle for each texture that it wants to access and then use that handle directly in GLSL or assembly-based shaders.  The ability to access textures without having to bind and/or re-bind them is similar to the capability provided by the NV_shader_buffer_load extension that allows shaders to access buffer objects without binding them.  In both cases, these extensions significantly reduce the amount of API and internal GL driver overhead needed to manage resource bindings. This extension also provides similar capability for the image load, store, and atomic functionality provided by OpenGL 4.2 and the ARB_shader_image_load_store and EXT_shader_image_load_store extensions, where a texture can be accessed without first binding it to an image unit...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MakeTextureHandleResident.</para>
        /// <para>Fullname: MakeTextureHandleResidentNV</para>
        /// <para>Extensions: NV_bindless_texture</para>
        /// </summary>
        public static void MakeTextureHandleResident(ulong handle)
        {
            if (gl._MakeTextureHandleResident != null) gl._MakeTextureHandleResident(handle); else { }
        }
        /// <summary>
        /// <para>Fullname: MapControlPointsNV</para>
        /// </summary>
        [GLEntry("MapControlPointsNV", Category = "NV")]
        public static GLDelegate.MapControlPoints _MapControlPoints = null;
        /// <summary>
        /// <para>OpenGL evaluators provide applications with the capability to specify polynomial or rational curves and surfaces using control points relative to the Bezier basis.  The curves and surfaces are then drawn by evaluating the polynomials provided at various values for the u parameter of a curve or the (u,v) parameters of a surface. A tensor product formulation is used for the surfaces. For various historical reasons, evaluators have not been particularly popular as an interface for drawing curves and surfaces. This extension proposes a new interface for surfaces that provides a number of significant enhancements to the functionality provided by the original OpenGL evaluators. Many implementations never optimized evaluators, so applications often implemented their own algorithms instead.  This extension relaxes some restrictions that make it difficult to optimize evaluators. Also, new vertex attributes have been added to OpenGL through extensions, including multiple sets of texture coordina...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MapControlPoints.</para>
        /// <para>Fullname: MapControlPointsNV</para>
        /// <para>Extensions: NV_evaluators</para>
        /// </summary>
        public static void MapControlPoints(int target, uint index, int type, int ustride, int vstride, int uorder, int vorder, bool packed, IntPtr points)
        {
            if (gl._MapControlPoints != null) gl._MapControlPoints(target, index, type, ustride, vstride, uorder, vorder, packed, points); else { }
        }
        /// <summary>
        /// <para>Fullname: MapParameterfvNV</para>
        /// </summary>
        [GLEntry("MapParameterfvNV", Category = "NV")]
        public static GLDelegate.MapParameterfv _MapParameterfv = null;
        /// <summary>
        /// <para>OpenGL evaluators provide applications with the capability to specify polynomial or rational curves and surfaces using control points relative to the Bezier basis.  The curves and surfaces are then drawn by evaluating the polynomials provided at various values for the u parameter of a curve or the (u,v) parameters of a surface. A tensor product formulation is used for the surfaces. For various historical reasons, evaluators have not been particularly popular as an interface for drawing curves and surfaces. This extension proposes a new interface for surfaces that provides a number of significant enhancements to the functionality provided by the original OpenGL evaluators. Many implementations never optimized evaluators, so applications often implemented their own algorithms instead.  This extension relaxes some restrictions that make it difficult to optimize evaluators. Also, new vertex attributes have been added to OpenGL through extensions, including multiple sets of texture coordina...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MapParameterfv.</para>
        /// <para>Fullname: MapParameterfvNV</para>
        /// <para>Extensions: NV_evaluators</para>
        /// </summary>
        public static void MapParameterfv(int target, int pname, float[] param)
        {
            if (gl._MapParameterfv != null) gl._MapParameterfv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: MapParameterivNV</para>
        /// </summary>
        [GLEntry("MapParameterivNV", Category = "NV")]
        public static GLDelegate.MapParameteriv _MapParameteriv = null;
        /// <summary>
        /// <para>OpenGL evaluators provide applications with the capability to specify polynomial or rational curves and surfaces using control points relative to the Bezier basis.  The curves and surfaces are then drawn by evaluating the polynomials provided at various values for the u parameter of a curve or the (u,v) parameters of a surface. A tensor product formulation is used for the surfaces. For various historical reasons, evaluators have not been particularly popular as an interface for drawing curves and surfaces. This extension proposes a new interface for surfaces that provides a number of significant enhancements to the functionality provided by the original OpenGL evaluators. Many implementations never optimized evaluators, so applications often implemented their own algorithms instead.  This extension relaxes some restrictions that make it difficult to optimize evaluators. Also, new vertex attributes have been added to OpenGL through extensions, including multiple sets of texture coordina...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MapParameteriv.</para>
        /// <para>Fullname: MapParameterivNV</para>
        /// <para>Extensions: NV_evaluators</para>
        /// </summary>
        public static void MapParameteriv(int target, int pname, int[] param)
        {
            if (gl._MapParameteriv != null) gl._MapParameteriv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord1hNV</para>
        /// </summary>
        [GLEntry("MultiTexCoord1hNV", Category = "NV")]
        public static GLDelegate.MultiTexCoord1h _MultiTexCoord1h = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord1h.</para>
        /// <para>Fullname: MultiTexCoord1hNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void MultiTexCoord1h(int target, ushort s)
        {
            if (gl._MultiTexCoord1h != null) gl._MultiTexCoord1h(target, s); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord1hvNV</para>
        /// </summary>
        [GLEntry("MultiTexCoord1hvNV", Category = "NV")]
        public static GLDelegate.MultiTexCoord1hv _MultiTexCoord1hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord1hv.</para>
        /// <para>Fullname: MultiTexCoord1hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void MultiTexCoord1hv(int target, ushort[] v)
        {
            if (gl._MultiTexCoord1hv != null) gl._MultiTexCoord1hv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord2hNV</para>
        /// </summary>
        [GLEntry("MultiTexCoord2hNV", Category = "NV")]
        public static GLDelegate.MultiTexCoord2h _MultiTexCoord2h = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord2h.</para>
        /// <para>Fullname: MultiTexCoord2hNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void MultiTexCoord2h(int target, ushort s, ushort t)
        {
            if (gl._MultiTexCoord2h != null) gl._MultiTexCoord2h(target, s, t); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord2hvNV</para>
        /// </summary>
        [GLEntry("MultiTexCoord2hvNV", Category = "NV")]
        public static GLDelegate.MultiTexCoord2hv _MultiTexCoord2hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord2hv.</para>
        /// <para>Fullname: MultiTexCoord2hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void MultiTexCoord2hv(int target, ushort[] v)
        {
            if (gl._MultiTexCoord2hv != null) gl._MultiTexCoord2hv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord3hNV</para>
        /// </summary>
        [GLEntry("MultiTexCoord3hNV", Category = "NV")]
        public static GLDelegate.MultiTexCoord3h _MultiTexCoord3h = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord3h.</para>
        /// <para>Fullname: MultiTexCoord3hNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void MultiTexCoord3h(int target, ushort s, ushort t, ushort r)
        {
            if (gl._MultiTexCoord3h != null) gl._MultiTexCoord3h(target, s, t, r); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord3hvNV</para>
        /// </summary>
        [GLEntry("MultiTexCoord3hvNV", Category = "NV")]
        public static GLDelegate.MultiTexCoord3hv _MultiTexCoord3hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord3hv.</para>
        /// <para>Fullname: MultiTexCoord3hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void MultiTexCoord3hv(int target, ushort[] v)
        {
            if (gl._MultiTexCoord3hv != null) gl._MultiTexCoord3hv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord4hNV</para>
        /// </summary>
        [GLEntry("MultiTexCoord4hNV", Category = "NV")]
        public static GLDelegate.MultiTexCoord4h _MultiTexCoord4h = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord4h.</para>
        /// <para>Fullname: MultiTexCoord4hNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void MultiTexCoord4h(int target, ushort s, ushort t, ushort r, ushort q)
        {
            if (gl._MultiTexCoord4h != null) gl._MultiTexCoord4h(target, s, t, r, q); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiTexCoord4hvNV</para>
        /// </summary>
        [GLEntry("MultiTexCoord4hvNV", Category = "NV")]
        public static GLDelegate.MultiTexCoord4hv _MultiTexCoord4hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiTexCoord4hv.</para>
        /// <para>Fullname: MultiTexCoord4hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void MultiTexCoord4hv(int target, ushort[] v)
        {
            if (gl._MultiTexCoord4hv != null) gl._MultiTexCoord4hv(target, v); else { }
        }
        /// <summary>
        /// <para>Fullname: Normal3hNV</para>
        /// </summary>
        [GLEntry("Normal3hNV", Category = "NV")]
        public static GLDelegate.Normal3h _Normal3h = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Normal3h.</para>
        /// <para>Fullname: Normal3hNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void Normal3h(ushort nx, ushort ny, ushort nz)
        {
            if (gl._Normal3h != null) gl._Normal3h(nx, ny, nz); else { }
        }
        /// <summary>
        /// <para>Fullname: Normal3hvNV</para>
        /// </summary>
        [GLEntry("Normal3hvNV", Category = "NV")]
        public static GLDelegate.Normal3hv _Normal3hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Normal3hv.</para>
        /// <para>Fullname: Normal3hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void Normal3hv(ushort[] v)
        {
            if (gl._Normal3hv != null) gl._Normal3hv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: NormalFormatNV</para>
        /// </summary>
        [GLEntry("NormalFormatNV", Category = "NV")]
        public static GLDelegate.NormalFormat _NormalFormat = null;
        /// <summary>
        /// <para>This extension provides a mechanism to specify vertex attrib and element array locations using GPU addresses. Binding vertex buffers is one of the most frequent and expensive operations in many GL applications, due to the cost of chasing pointers and binding objects described in the Overview of NV_shader_buffer_load. The intent of this extension is to enable a way for the application to specify vertex attrib state that alleviates the overhead of object binds and driver memory management. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NormalFormat.</para>
        /// <para>Fullname: NormalFormatNV</para>
        /// <para>Extensions: NV_vertex_buffer_unified_memory</para>
        /// </summary>
        public static void NormalFormat(int type, int stride)
        {
            if (gl._NormalFormat != null) gl._NormalFormat(type, stride); else { }
        }
        /// <summary>
        /// <para>Fullname: PathColorGenNV</para>
        /// </summary>
        [GLEntry("PathColorGenNV", Category = "NV")]
        public static GLDelegate.PathColorGen _PathColorGen = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PathColorGen.</para>
        /// <para>Fullname: PathColorGenNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void PathColorGen(int color, int genMode, int colorFormat, float[] coeffs)
        {
            if (gl._PathColorGen != null) gl._PathColorGen(color, genMode, colorFormat, coeffs); else { }
        }
        /// <summary>
        /// <para>Fullname: PathCommandsNV</para>
        /// </summary>
        [GLEntry("PathCommandsNV", Category = "NV")]
        public static GLDelegate.PathCommands _PathCommands = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PathCommands.</para>
        /// <para>Fullname: PathCommandsNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void PathCommands(uint path, int numCommands, byte[] commands, int numCoords, int coordType, IntPtr coords)
        {
            if (gl._PathCommands != null) gl._PathCommands(path, numCommands, commands, numCoords, coordType, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: PathCoordsNV</para>
        /// </summary>
        [GLEntry("PathCoordsNV", Category = "NV")]
        public static GLDelegate.PathCoords _PathCoords = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PathCoords.</para>
        /// <para>Fullname: PathCoordsNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void PathCoords(uint path, int numCoords, int coordType, IntPtr coords)
        {
            if (gl._PathCoords != null) gl._PathCoords(path, numCoords, coordType, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: PathCoverDepthFuncNV</para>
        /// </summary>
        [GLEntry("PathCoverDepthFuncNV", Category = "NV")]
        public static GLDelegate.PathCoverDepthFunc _PathCoverDepthFunc = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PathCoverDepthFunc.</para>
        /// <para>Fullname: PathCoverDepthFuncNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void PathCoverDepthFunc(int func)
        {
            if (gl._PathCoverDepthFunc != null) gl._PathCoverDepthFunc(func); else { }
        }
        /// <summary>
        /// <para>Fullname: PathDashArrayNV</para>
        /// </summary>
        [GLEntry("PathDashArrayNV", Category = "NV")]
        public static GLDelegate.PathDashArray _PathDashArray = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PathDashArray.</para>
        /// <para>Fullname: PathDashArrayNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void PathDashArray(uint path, int dashCount, float[] dashArray)
        {
            if (gl._PathDashArray != null) gl._PathDashArray(path, dashCount, dashArray); else { }
        }
        /// <summary>
        /// <para>Fullname: PathFogGenNV</para>
        /// </summary>
        [GLEntry("PathFogGenNV", Category = "NV")]
        public static GLDelegate.PathFogGen _PathFogGen = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PathFogGen.</para>
        /// <para>Fullname: PathFogGenNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void PathFogGen(int genMode)
        {
            if (gl._PathFogGen != null) gl._PathFogGen(genMode); else { }
        }
        /// <summary>
        /// <para>Fullname: PathGlyphRangeNV</para>
        /// </summary>
        [GLEntry("PathGlyphRangeNV", Category = "NV")]
        public static GLDelegate.PathGlyphRange _PathGlyphRange = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PathGlyphRange.</para>
        /// <para>Fullname: PathGlyphRangeNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void PathGlyphRange(uint firstPathName, int fontTarget, IntPtr fontName, int fontStyle, uint firstGlyph, int numGlyphs, int handleMissingGlyphs, uint pathParameterTemplate, float emScale)
        {
            if (gl._PathGlyphRange != null) gl._PathGlyphRange(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale); else { }
        }
        /// <summary>
        /// <para>Fullname: PathGlyphsNV</para>
        /// </summary>
        [GLEntry("PathGlyphsNV", Category = "NV")]
        public static GLDelegate.PathGlyphs _PathGlyphs = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PathGlyphs.</para>
        /// <para>Fullname: PathGlyphsNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void PathGlyphs(uint firstPathName, int fontTarget, IntPtr fontName, int fontStyle, int numGlyphs, int type, IntPtr charcodes, int handleMissingGlyphs, uint pathParameterTemplate, float emScale)
        {
            if (gl._PathGlyphs != null) gl._PathGlyphs(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale); else { }
        }
        /// <summary>
        /// <para>Fullname: PathParameterfNV</para>
        /// </summary>
        [GLEntry("PathParameterfNV", Category = "NV")]
        public static GLDelegate.PathParameterf _PathParameterf = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PathParameterf.</para>
        /// <para>Fullname: PathParameterfNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void PathParameterf(uint path, int pname, float value)
        {
            if (gl._PathParameterf != null) gl._PathParameterf(path, pname, value); else { }
        }
        /// <summary>
        /// <para>Fullname: PathParameterfvNV</para>
        /// </summary>
        [GLEntry("PathParameterfvNV", Category = "NV")]
        public static GLDelegate.PathParameterfv _PathParameterfv = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PathParameterfv.</para>
        /// <para>Fullname: PathParameterfvNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void PathParameterfv(uint path, int pname, float[] value)
        {
            if (gl._PathParameterfv != null) gl._PathParameterfv(path, pname, value); else { }
        }
        /// <summary>
        /// <para>Fullname: PathParameteriNV</para>
        /// </summary>
        [GLEntry("PathParameteriNV", Category = "NV")]
        public static GLDelegate.PathParameteri _PathParameteri = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PathParameteri.</para>
        /// <para>Fullname: PathParameteriNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void PathParameteri(uint path, int pname, int value)
        {
            if (gl._PathParameteri != null) gl._PathParameteri(path, pname, value); else { }
        }
        /// <summary>
        /// <para>Fullname: PathParameterivNV</para>
        /// </summary>
        [GLEntry("PathParameterivNV", Category = "NV")]
        public static GLDelegate.PathParameteriv _PathParameteriv = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PathParameteriv.</para>
        /// <para>Fullname: PathParameterivNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void PathParameteriv(uint path, int pname, int[] value)
        {
            if (gl._PathParameteriv != null) gl._PathParameteriv(path, pname, value); else { }
        }
        /// <summary>
        /// <para>Fullname: PathStencilDepthOffsetNV</para>
        /// </summary>
        [GLEntry("PathStencilDepthOffsetNV", Category = "NV")]
        public static GLDelegate.PathStencilDepthOffset _PathStencilDepthOffset = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PathStencilDepthOffset.</para>
        /// <para>Fullname: PathStencilDepthOffsetNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void PathStencilDepthOffset(float factor, float units)
        {
            if (gl._PathStencilDepthOffset != null) gl._PathStencilDepthOffset(factor, units); else { }
        }
        /// <summary>
        /// <para>Fullname: PathStencilFuncNV</para>
        /// </summary>
        [GLEntry("PathStencilFuncNV", Category = "NV")]
        public static GLDelegate.PathStencilFunc _PathStencilFunc = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PathStencilFunc.</para>
        /// <para>Fullname: PathStencilFuncNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void PathStencilFunc(int func, int reference, uint mask)
        {
            if (gl._PathStencilFunc != null) gl._PathStencilFunc(func, reference, mask); else { }
        }
        /// <summary>
        /// <para>Fullname: PathStringNV</para>
        /// </summary>
        [GLEntry("PathStringNV", Category = "NV")]
        public static GLDelegate.PathString _PathString = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PathString.</para>
        /// <para>Fullname: PathStringNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void PathString(uint path, int format, int length, IntPtr pathString)
        {
            if (gl._PathString != null) gl._PathString(path, format, length, pathString); else { }
        }
        /// <summary>
        /// <para>Fullname: PathSubCommandsNV</para>
        /// </summary>
        [GLEntry("PathSubCommandsNV", Category = "NV")]
        public static GLDelegate.PathSubCommands _PathSubCommands = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PathSubCommands.</para>
        /// <para>Fullname: PathSubCommandsNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void PathSubCommands(uint path, int commandStart, int commandsToDelete, int numCommands, byte[] commands, int numCoords, int coordType, IntPtr coords)
        {
            if (gl._PathSubCommands != null) gl._PathSubCommands(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: PathSubCoordsNV</para>
        /// </summary>
        [GLEntry("PathSubCoordsNV", Category = "NV")]
        public static GLDelegate.PathSubCoords _PathSubCoords = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PathSubCoords.</para>
        /// <para>Fullname: PathSubCoordsNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void PathSubCoords(uint path, int coordStart, int numCoords, int coordType, IntPtr coords)
        {
            if (gl._PathSubCoords != null) gl._PathSubCoords(path, coordStart, numCoords, coordType, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: PathTexGenNV</para>
        /// </summary>
        [GLEntry("PathTexGenNV", Category = "NV")]
        public static GLDelegate.PathTexGen _PathTexGen = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PathTexGen.</para>
        /// <para>Fullname: PathTexGenNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void PathTexGen(int texCoordSet, int genMode, int components, float[] coeffs)
        {
            if (gl._PathTexGen != null) gl._PathTexGen(texCoordSet, genMode, components, coeffs); else { }
        }
        /// <summary>
        /// <para>Fullname: PixelDataRangeNV</para>
        /// </summary>
        [GLEntry("PixelDataRangeNV", Category = "NV")]
        public static GLDelegate.PixelDataRange _PixelDataRange = null;
        /// <summary>
        /// <para>The vertex array range extension is intended to improve the efficiency of OpenGL vertex arrays.  OpenGL vertex arrays' coherency model and ability to access memory from arbitrary locations in memory prevented implementations from using DMA (Direct Memory Access) operations. Many image-intensive applications, such as those that use dynamically generated textures, face similar problems.  These applications would like to be able to sustain throughputs of hundreds of millions of pixels per second through DrawPixels and hundreds of millions of texels per second through TexSubImage. However, the same restrictions that limited vertex throughput also limit pixel throughput. By the time that any pixel operation that reads data from user memory returns, OpenGL requires that it must be safe for the application to start using that memory for a different purpose.  This coherency model prevents asynchronous DMA transfers directly out of the user's buffer. There are also no restrictions on the pointe...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PixelDataRange.</para>
        /// <para>Fullname: PixelDataRangeNV</para>
        /// <para>Extensions: NV_pixel_data_range</para>
        /// </summary>
        public static void PixelDataRange(int target, int length, IntPtr pointer)
        {
            if (gl._PixelDataRange != null) gl._PixelDataRange(target, length, pointer); else { }
        }
        /// <summary>
        /// <para>Fullname: PointAlongPathNV</para>
        /// </summary>
        [GLEntry("PointAlongPathNV", Category = "NV")]
        public static GLDelegate.PointAlongPath _PointAlongPath = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PointAlongPath.</para>
        /// <para>Fullname: PointAlongPathNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static bool PointAlongPath(uint path, int startSegment, int numSegments, float distance, float[] x, float[] y, float[] tangentX, float[] tangentY)
        {
            if (gl._PointAlongPath != null) return gl._PointAlongPath(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: PointAlongPathNV</para>
        /// </summary>
        [GLEntry("PointAlongPathNV", Category = "NV")]
        public static GLDelegate.PointAlongPath_float_float_float_float _PointAlongPath_float_float_float_float = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PointAlongPath_float_float_float_float.</para>
        /// <para>Fullname: PointAlongPathNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static bool PointAlongPath(uint path, int startSegment, int numSegments, float distance, out float x, out float y, out float tangentX, out float tangentY)
        {
            if (gl._PointAlongPath_float_float_float_float != null) return gl._PointAlongPath_float_float_float_float(path, startSegment, numSegments, distance, out x, out y, out tangentX, out tangentY);
            else { x = new float(); y = new float(); tangentX = new float(); tangentY = new float(); return false; }
        }
        /// <summary>
        /// <para>Fullname: PresentFrameDualFillNV</para>
        /// </summary>
        [GLEntry("PresentFrameDualFillNV", Category = "NV")]
        public static GLDelegate.PresentFrameDualFill _PresentFrameDualFill = null;
        /// <summary>
        /// <para>This extension provides a mechanism for displaying textures and renderbuffers on auxiliary video output devices.  It allows an application to specify separate buffers for the individual fields used with interlaced output.  It also provides a way to present frames or field pairs simultaneously in two separate video streams.  It also allows an application to request when images should be displayed, and to obtain feedback on exactly when images are actually first displayed. This specification attempts to avoid language that would tie it to any particular hardware or vendor.  However, it should be noted that it has been designed specifically for use with NVIDIA SDI products and the features and limitations of the spec compliment those of NVIDIA's line of SDI video output devices. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PresentFrameDualFill.</para>
        /// <para>Fullname: PresentFrameDualFillNV</para>
        /// <para>Extensions: NV_present_video</para>
        /// </summary>
        public static void PresentFrameDualFill(uint video_slot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, int type, int target0, uint fill0, int target1, uint fill1, int target2, uint fill2, int target3, uint fill3)
        {
            if (gl._PresentFrameDualFill != null) gl._PresentFrameDualFill(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3); else { }
        }
        /// <summary>
        /// <para>Fullname: PresentFrameKeyedNV</para>
        /// </summary>
        [GLEntry("PresentFrameKeyedNV", Category = "NV")]
        public static GLDelegate.PresentFrameKeyed _PresentFrameKeyed = null;
        /// <summary>
        /// <para>This extension provides a mechanism for displaying textures and renderbuffers on auxiliary video output devices.  It allows an application to specify separate buffers for the individual fields used with interlaced output.  It also provides a way to present frames or field pairs simultaneously in two separate video streams.  It also allows an application to request when images should be displayed, and to obtain feedback on exactly when images are actually first displayed. This specification attempts to avoid language that would tie it to any particular hardware or vendor.  However, it should be noted that it has been designed specifically for use with NVIDIA SDI products and the features and limitations of the spec compliment those of NVIDIA's line of SDI video output devices. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PresentFrameKeyed.</para>
        /// <para>Fullname: PresentFrameKeyedNV</para>
        /// <para>Extensions: NV_present_video</para>
        /// </summary>
        public static void PresentFrameKeyed(uint video_slot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, int type, int target0, uint fill0, uint key0, int target1, uint fill1, uint key1)
        {
            if (gl._PresentFrameKeyed != null) gl._PresentFrameKeyed(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1); else { }
        }
        /// <summary>
        /// <para>Fullname: PrimitiveRestartNV</para>
        /// </summary>
        [GLEntry("PrimitiveRestartNV", Category = "NV")]
        public static GLDelegate.PrimitiveRestart _PrimitiveRestart = null;
        /// <summary>
        /// <para>This extension allows applications to easily and inexpensively restart a primitive in its middle.  A "primitive restart" is simply the same as an End command, followed by another Begin command with the same mode as the original.  The typical expected use of this feature is to draw a mesh with many triangle strips, though primitive restarts are legal for all primitive types, even for points (where they are not useful). Although the EXT_multi_draw_arrays extension did reduce the overhead of such drawing techniques, they still remain more expensive than one would like. This extension provides an extremely lightweight primitive restart, which is accomplished by allowing the application to choose a special index number that signals that a primitive restart should occur, rather than a vertex being provoked.  This index can be an arbitrary 32-bit integer for maximum application convenience. In addition, for full orthogonality, a special OpenGL command is provided to restart primitives when in...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PrimitiveRestart.</para>
        /// <para>Fullname: PrimitiveRestartNV</para>
        /// <para>Extensions: NV_primitive_restart</para>
        /// </summary>
        public static void PrimitiveRestart()
        {
            if (gl._PrimitiveRestart != null) gl._PrimitiveRestart(); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramBufferParametersfvNV</para>
        /// </summary>
        [GLEntry("ProgramBufferParametersfvNV", Category = "NV")]
        public static GLDelegate.ProgramBufferParametersfv _ProgramBufferParametersfv = null;
        /// <summary>
        /// <para>This extension, in conjunction with NV_gpu_program4, provides a new type of program parameter than can be used as a constant during vertex, fragment, or geometry program execution.  Each program target has a set of parameter buffer binding points to which buffer objects can be attached. A vertex, fragment, or geometry program can read data from the attached buffer objects using a binding of the form "program.buffer[a][b]".  This binding reads data from the buffer object attached to binding point <a>. The buffer object attached is treated either as an array of 32-bit words or an array of four-component vectors, and the binding above reads the array element numbered <b>. The use of buffer objects allows applications to change large blocks of program parameters at once, simply by binding a new buffer object.  It also provides a number of new ways to load parameter values, including readback from the frame buffer (EXT_pixel_buffer_object), transform feedback (NV_transform_feedback), buffer...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramBufferParametersfv.</para>
        /// <para>Fullname: ProgramBufferParametersfvNV</para>
        /// <para>Extensions: NV_parameter_buffer_object</para>
        /// </summary>
        public static void ProgramBufferParametersfv(int target, uint buffer, uint index, int count, float[] param)
        {
            if (gl._ProgramBufferParametersfv != null) gl._ProgramBufferParametersfv(target, buffer, index, count, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramBufferParametersIivNV</para>
        /// </summary>
        [GLEntry("ProgramBufferParametersIivNV", Category = "NV")]
        public static GLDelegate.ProgramBufferParametersIiv _ProgramBufferParametersIiv = null;
        /// <summary>
        /// <para>This extension, in conjunction with NV_gpu_program4, provides a new type of program parameter than can be used as a constant during vertex, fragment, or geometry program execution.  Each program target has a set of parameter buffer binding points to which buffer objects can be attached. A vertex, fragment, or geometry program can read data from the attached buffer objects using a binding of the form "program.buffer[a][b]".  This binding reads data from the buffer object attached to binding point <a>. The buffer object attached is treated either as an array of 32-bit words or an array of four-component vectors, and the binding above reads the array element numbered <b>. The use of buffer objects allows applications to change large blocks of program parameters at once, simply by binding a new buffer object.  It also provides a number of new ways to load parameter values, including readback from the frame buffer (EXT_pixel_buffer_object), transform feedback (NV_transform_feedback), buffer...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramBufferParametersIiv.</para>
        /// <para>Fullname: ProgramBufferParametersIivNV</para>
        /// <para>Extensions: NV_parameter_buffer_object</para>
        /// </summary>
        public static void ProgramBufferParametersIiv(int target, uint buffer, uint index, int count, int[] param)
        {
            if (gl._ProgramBufferParametersIiv != null) gl._ProgramBufferParametersIiv(target, buffer, index, count, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramBufferParametersIuivNV</para>
        /// </summary>
        [GLEntry("ProgramBufferParametersIuivNV", Category = "NV")]
        public static GLDelegate.ProgramBufferParametersIuiv _ProgramBufferParametersIuiv = null;
        /// <summary>
        /// <para>This extension, in conjunction with NV_gpu_program4, provides a new type of program parameter than can be used as a constant during vertex, fragment, or geometry program execution.  Each program target has a set of parameter buffer binding points to which buffer objects can be attached. A vertex, fragment, or geometry program can read data from the attached buffer objects using a binding of the form "program.buffer[a][b]".  This binding reads data from the buffer object attached to binding point <a>. The buffer object attached is treated either as an array of 32-bit words or an array of four-component vectors, and the binding above reads the array element numbered <b>. The use of buffer objects allows applications to change large blocks of program parameters at once, simply by binding a new buffer object.  It also provides a number of new ways to load parameter values, including readback from the frame buffer (EXT_pixel_buffer_object), transform feedback (NV_transform_feedback), buffer...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramBufferParametersIuiv.</para>
        /// <para>Fullname: ProgramBufferParametersIuivNV</para>
        /// <para>Extensions: NV_parameter_buffer_object</para>
        /// </summary>
        public static void ProgramBufferParametersIuiv(int target, uint buffer, uint index, int count, uint[] param)
        {
            if (gl._ProgramBufferParametersIuiv != null) gl._ProgramBufferParametersIuiv(target, buffer, index, count, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramEnvParameterI4iNV</para>
        /// </summary>
        [GLEntry("ProgramEnvParameterI4iNV", Category = "NV")]
        public static GLDelegate.ProgramEnvParameterI4i _ProgramEnvParameterI4i = null;
        /// <summary>
        /// <para>This specification documents the common instruction set and basic functionality provided by NVIDIA's 4th generation of assembly instruction sets supporting programmable graphics pipeline stages. The instruction set builds upon the basic framework provided by the ARB_vertex_program and ARB_fragment_program extensions to expose considerably more capable hardware.  In addition to new capabilities for vertex and fragment programs, this extension provides a new program type (geometry programs) further described in the NV_geometry_program4 specification. NV_gpu_program4 provides a unified instruction set -- all instruction set features are available for all program types, except for a small number of features that make sense only for a specific program type.  It provides fully capable signed and unsigned integer data types, along with a set of arithmetic, logical, and data type conversion instructions capable of operating on integers.  It also provides a uniform set of structured branching c...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramEnvParameterI4i.</para>
        /// <para>Fullname: ProgramEnvParameterI4iNV</para>
        /// <para>Extensions: NV_gpu_program4</para>
        /// </summary>
        public static void ProgramEnvParameterI4i(int target, uint index, int x, int y, int z, int w)
        {
            if (gl._ProgramEnvParameterI4i != null) gl._ProgramEnvParameterI4i(target, index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramEnvParameterI4ivNV</para>
        /// </summary>
        [GLEntry("ProgramEnvParameterI4ivNV", Category = "NV")]
        public static GLDelegate.ProgramEnvParameterI4iv _ProgramEnvParameterI4iv = null;
        /// <summary>
        /// <para>This specification documents the common instruction set and basic functionality provided by NVIDIA's 4th generation of assembly instruction sets supporting programmable graphics pipeline stages. The instruction set builds upon the basic framework provided by the ARB_vertex_program and ARB_fragment_program extensions to expose considerably more capable hardware.  In addition to new capabilities for vertex and fragment programs, this extension provides a new program type (geometry programs) further described in the NV_geometry_program4 specification. NV_gpu_program4 provides a unified instruction set -- all instruction set features are available for all program types, except for a small number of features that make sense only for a specific program type.  It provides fully capable signed and unsigned integer data types, along with a set of arithmetic, logical, and data type conversion instructions capable of operating on integers.  It also provides a uniform set of structured branching c...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramEnvParameterI4iv.</para>
        /// <para>Fullname: ProgramEnvParameterI4ivNV</para>
        /// <para>Extensions: NV_gpu_program4</para>
        /// </summary>
        public static void ProgramEnvParameterI4iv(int target, uint index, int[] param)
        {
            if (gl._ProgramEnvParameterI4iv != null) gl._ProgramEnvParameterI4iv(target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramEnvParameterI4uiNV</para>
        /// </summary>
        [GLEntry("ProgramEnvParameterI4uiNV", Category = "NV")]
        public static GLDelegate.ProgramEnvParameterI4ui _ProgramEnvParameterI4ui = null;
        /// <summary>
        /// <para>This specification documents the common instruction set and basic functionality provided by NVIDIA's 4th generation of assembly instruction sets supporting programmable graphics pipeline stages. The instruction set builds upon the basic framework provided by the ARB_vertex_program and ARB_fragment_program extensions to expose considerably more capable hardware.  In addition to new capabilities for vertex and fragment programs, this extension provides a new program type (geometry programs) further described in the NV_geometry_program4 specification. NV_gpu_program4 provides a unified instruction set -- all instruction set features are available for all program types, except for a small number of features that make sense only for a specific program type.  It provides fully capable signed and unsigned integer data types, along with a set of arithmetic, logical, and data type conversion instructions capable of operating on integers.  It also provides a uniform set of structured branching c...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramEnvParameterI4ui.</para>
        /// <para>Fullname: ProgramEnvParameterI4uiNV</para>
        /// <para>Extensions: NV_gpu_program4</para>
        /// </summary>
        public static void ProgramEnvParameterI4ui(int target, uint index, uint x, uint y, uint z, uint w)
        {
            if (gl._ProgramEnvParameterI4ui != null) gl._ProgramEnvParameterI4ui(target, index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramEnvParameterI4uivNV</para>
        /// </summary>
        [GLEntry("ProgramEnvParameterI4uivNV", Category = "NV")]
        public static GLDelegate.ProgramEnvParameterI4uiv _ProgramEnvParameterI4uiv = null;
        /// <summary>
        /// <para>This specification documents the common instruction set and basic functionality provided by NVIDIA's 4th generation of assembly instruction sets supporting programmable graphics pipeline stages. The instruction set builds upon the basic framework provided by the ARB_vertex_program and ARB_fragment_program extensions to expose considerably more capable hardware.  In addition to new capabilities for vertex and fragment programs, this extension provides a new program type (geometry programs) further described in the NV_geometry_program4 specification. NV_gpu_program4 provides a unified instruction set -- all instruction set features are available for all program types, except for a small number of features that make sense only for a specific program type.  It provides fully capable signed and unsigned integer data types, along with a set of arithmetic, logical, and data type conversion instructions capable of operating on integers.  It also provides a uniform set of structured branching c...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramEnvParameterI4uiv.</para>
        /// <para>Fullname: ProgramEnvParameterI4uivNV</para>
        /// <para>Extensions: NV_gpu_program4</para>
        /// </summary>
        public static void ProgramEnvParameterI4uiv(int target, uint index, uint[] param)
        {
            if (gl._ProgramEnvParameterI4uiv != null) gl._ProgramEnvParameterI4uiv(target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramEnvParametersI4ivNV</para>
        /// </summary>
        [GLEntry("ProgramEnvParametersI4ivNV", Category = "NV")]
        public static GLDelegate.ProgramEnvParametersI4iv _ProgramEnvParametersI4iv = null;
        /// <summary>
        /// <para>This specification documents the common instruction set and basic functionality provided by NVIDIA's 4th generation of assembly instruction sets supporting programmable graphics pipeline stages. The instruction set builds upon the basic framework provided by the ARB_vertex_program and ARB_fragment_program extensions to expose considerably more capable hardware.  In addition to new capabilities for vertex and fragment programs, this extension provides a new program type (geometry programs) further described in the NV_geometry_program4 specification. NV_gpu_program4 provides a unified instruction set -- all instruction set features are available for all program types, except for a small number of features that make sense only for a specific program type.  It provides fully capable signed and unsigned integer data types, along with a set of arithmetic, logical, and data type conversion instructions capable of operating on integers.  It also provides a uniform set of structured branching c...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramEnvParametersI4iv.</para>
        /// <para>Fullname: ProgramEnvParametersI4ivNV</para>
        /// <para>Extensions: NV_gpu_program4</para>
        /// </summary>
        public static void ProgramEnvParametersI4iv(int target, uint index, int count, int[] param)
        {
            if (gl._ProgramEnvParametersI4iv != null) gl._ProgramEnvParametersI4iv(target, index, count, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramEnvParametersI4uivNV</para>
        /// </summary>
        [GLEntry("ProgramEnvParametersI4uivNV", Category = "NV")]
        public static GLDelegate.ProgramEnvParametersI4uiv _ProgramEnvParametersI4uiv = null;
        /// <summary>
        /// <para>This specification documents the common instruction set and basic functionality provided by NVIDIA's 4th generation of assembly instruction sets supporting programmable graphics pipeline stages. The instruction set builds upon the basic framework provided by the ARB_vertex_program and ARB_fragment_program extensions to expose considerably more capable hardware.  In addition to new capabilities for vertex and fragment programs, this extension provides a new program type (geometry programs) further described in the NV_geometry_program4 specification. NV_gpu_program4 provides a unified instruction set -- all instruction set features are available for all program types, except for a small number of features that make sense only for a specific program type.  It provides fully capable signed and unsigned integer data types, along with a set of arithmetic, logical, and data type conversion instructions capable of operating on integers.  It also provides a uniform set of structured branching c...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramEnvParametersI4uiv.</para>
        /// <para>Fullname: ProgramEnvParametersI4uivNV</para>
        /// <para>Extensions: NV_gpu_program4</para>
        /// </summary>
        public static void ProgramEnvParametersI4uiv(int target, uint index, int count, uint[] param)
        {
            if (gl._ProgramEnvParametersI4uiv != null) gl._ProgramEnvParametersI4uiv(target, index, count, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramLocalParameterI4iNV</para>
        /// </summary>
        [GLEntry("ProgramLocalParameterI4iNV", Category = "NV")]
        public static GLDelegate.ProgramLocalParameterI4i _ProgramLocalParameterI4i = null;
        /// <summary>
        /// <para>This specification documents the common instruction set and basic functionality provided by NVIDIA's 4th generation of assembly instruction sets supporting programmable graphics pipeline stages. The instruction set builds upon the basic framework provided by the ARB_vertex_program and ARB_fragment_program extensions to expose considerably more capable hardware.  In addition to new capabilities for vertex and fragment programs, this extension provides a new program type (geometry programs) further described in the NV_geometry_program4 specification. NV_gpu_program4 provides a unified instruction set -- all instruction set features are available for all program types, except for a small number of features that make sense only for a specific program type.  It provides fully capable signed and unsigned integer data types, along with a set of arithmetic, logical, and data type conversion instructions capable of operating on integers.  It also provides a uniform set of structured branching c...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramLocalParameterI4i.</para>
        /// <para>Fullname: ProgramLocalParameterI4iNV</para>
        /// <para>Extensions: NV_gpu_program4</para>
        /// </summary>
        public static void ProgramLocalParameterI4i(int target, uint index, int x, int y, int z, int w)
        {
            if (gl._ProgramLocalParameterI4i != null) gl._ProgramLocalParameterI4i(target, index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramLocalParameterI4ivNV</para>
        /// </summary>
        [GLEntry("ProgramLocalParameterI4ivNV", Category = "NV")]
        public static GLDelegate.ProgramLocalParameterI4iv _ProgramLocalParameterI4iv = null;
        /// <summary>
        /// <para>This specification documents the common instruction set and basic functionality provided by NVIDIA's 4th generation of assembly instruction sets supporting programmable graphics pipeline stages. The instruction set builds upon the basic framework provided by the ARB_vertex_program and ARB_fragment_program extensions to expose considerably more capable hardware.  In addition to new capabilities for vertex and fragment programs, this extension provides a new program type (geometry programs) further described in the NV_geometry_program4 specification. NV_gpu_program4 provides a unified instruction set -- all instruction set features are available for all program types, except for a small number of features that make sense only for a specific program type.  It provides fully capable signed and unsigned integer data types, along with a set of arithmetic, logical, and data type conversion instructions capable of operating on integers.  It also provides a uniform set of structured branching c...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramLocalParameterI4iv.</para>
        /// <para>Fullname: ProgramLocalParameterI4ivNV</para>
        /// <para>Extensions: NV_gpu_program4</para>
        /// </summary>
        public static void ProgramLocalParameterI4iv(int target, uint index, int[] param)
        {
            if (gl._ProgramLocalParameterI4iv != null) gl._ProgramLocalParameterI4iv(target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramLocalParameterI4uiNV</para>
        /// </summary>
        [GLEntry("ProgramLocalParameterI4uiNV", Category = "NV")]
        public static GLDelegate.ProgramLocalParameterI4ui _ProgramLocalParameterI4ui = null;
        /// <summary>
        /// <para>This specification documents the common instruction set and basic functionality provided by NVIDIA's 4th generation of assembly instruction sets supporting programmable graphics pipeline stages. The instruction set builds upon the basic framework provided by the ARB_vertex_program and ARB_fragment_program extensions to expose considerably more capable hardware.  In addition to new capabilities for vertex and fragment programs, this extension provides a new program type (geometry programs) further described in the NV_geometry_program4 specification. NV_gpu_program4 provides a unified instruction set -- all instruction set features are available for all program types, except for a small number of features that make sense only for a specific program type.  It provides fully capable signed and unsigned integer data types, along with a set of arithmetic, logical, and data type conversion instructions capable of operating on integers.  It also provides a uniform set of structured branching c...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramLocalParameterI4ui.</para>
        /// <para>Fullname: ProgramLocalParameterI4uiNV</para>
        /// <para>Extensions: NV_gpu_program4</para>
        /// </summary>
        public static void ProgramLocalParameterI4ui(int target, uint index, uint x, uint y, uint z, uint w)
        {
            if (gl._ProgramLocalParameterI4ui != null) gl._ProgramLocalParameterI4ui(target, index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramLocalParameterI4uivNV</para>
        /// </summary>
        [GLEntry("ProgramLocalParameterI4uivNV", Category = "NV")]
        public static GLDelegate.ProgramLocalParameterI4uiv _ProgramLocalParameterI4uiv = null;
        /// <summary>
        /// <para>This specification documents the common instruction set and basic functionality provided by NVIDIA's 4th generation of assembly instruction sets supporting programmable graphics pipeline stages. The instruction set builds upon the basic framework provided by the ARB_vertex_program and ARB_fragment_program extensions to expose considerably more capable hardware.  In addition to new capabilities for vertex and fragment programs, this extension provides a new program type (geometry programs) further described in the NV_geometry_program4 specification. NV_gpu_program4 provides a unified instruction set -- all instruction set features are available for all program types, except for a small number of features that make sense only for a specific program type.  It provides fully capable signed and unsigned integer data types, along with a set of arithmetic, logical, and data type conversion instructions capable of operating on integers.  It also provides a uniform set of structured branching c...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramLocalParameterI4uiv.</para>
        /// <para>Fullname: ProgramLocalParameterI4uivNV</para>
        /// <para>Extensions: NV_gpu_program4</para>
        /// </summary>
        public static void ProgramLocalParameterI4uiv(int target, uint index, uint[] param)
        {
            if (gl._ProgramLocalParameterI4uiv != null) gl._ProgramLocalParameterI4uiv(target, index, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramLocalParametersI4ivNV</para>
        /// </summary>
        [GLEntry("ProgramLocalParametersI4ivNV", Category = "NV")]
        public static GLDelegate.ProgramLocalParametersI4iv _ProgramLocalParametersI4iv = null;
        /// <summary>
        /// <para>This specification documents the common instruction set and basic functionality provided by NVIDIA's 4th generation of assembly instruction sets supporting programmable graphics pipeline stages. The instruction set builds upon the basic framework provided by the ARB_vertex_program and ARB_fragment_program extensions to expose considerably more capable hardware.  In addition to new capabilities for vertex and fragment programs, this extension provides a new program type (geometry programs) further described in the NV_geometry_program4 specification. NV_gpu_program4 provides a unified instruction set -- all instruction set features are available for all program types, except for a small number of features that make sense only for a specific program type.  It provides fully capable signed and unsigned integer data types, along with a set of arithmetic, logical, and data type conversion instructions capable of operating on integers.  It also provides a uniform set of structured branching c...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramLocalParametersI4iv.</para>
        /// <para>Fullname: ProgramLocalParametersI4ivNV</para>
        /// <para>Extensions: NV_gpu_program4</para>
        /// </summary>
        public static void ProgramLocalParametersI4iv(int target, uint index, int count, int[] param)
        {
            if (gl._ProgramLocalParametersI4iv != null) gl._ProgramLocalParametersI4iv(target, index, count, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramLocalParametersI4uivNV</para>
        /// </summary>
        [GLEntry("ProgramLocalParametersI4uivNV", Category = "NV")]
        public static GLDelegate.ProgramLocalParametersI4uiv _ProgramLocalParametersI4uiv = null;
        /// <summary>
        /// <para>This specification documents the common instruction set and basic functionality provided by NVIDIA's 4th generation of assembly instruction sets supporting programmable graphics pipeline stages. The instruction set builds upon the basic framework provided by the ARB_vertex_program and ARB_fragment_program extensions to expose considerably more capable hardware.  In addition to new capabilities for vertex and fragment programs, this extension provides a new program type (geometry programs) further described in the NV_geometry_program4 specification. NV_gpu_program4 provides a unified instruction set -- all instruction set features are available for all program types, except for a small number of features that make sense only for a specific program type.  It provides fully capable signed and unsigned integer data types, along with a set of arithmetic, logical, and data type conversion instructions capable of operating on integers.  It also provides a uniform set of structured branching c...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramLocalParametersI4uiv.</para>
        /// <para>Fullname: ProgramLocalParametersI4uivNV</para>
        /// <para>Extensions: NV_gpu_program4</para>
        /// </summary>
        public static void ProgramLocalParametersI4uiv(int target, uint index, int count, uint[] param)
        {
            if (gl._ProgramLocalParametersI4uiv != null) gl._ProgramLocalParametersI4uiv(target, index, count, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramNamedParameter4dNV</para>
        /// </summary>
        [GLEntry("ProgramNamedParameter4dNV", Category = "NV")]
        public static GLDelegate.ProgramNamedParameter4d _ProgramNamedParameter4d = null;
        /// <summary>
        /// <para>OpenGL mandates a certain set of configurable per-fragment computations defining texture lookup, texture environment, color sum, and fog operations.  Each of these areas provide a useful but limited set of fixed operations.  For example, unextended OpenGL 1.2.1 provides only four texture environment modes, color sum, and three fog modes.  Many OpenGL extensions have either improved existing functionality or introduced new configurable fragment operations.  While these extensions have enabled new and interesting rendering effects, the set of effects is limited by the set of special modes introduced by the extension.  This lack of flexibility is in contrast to the high-level of programmability of general-purpose CPUs and other (frequently software-based) shading languages.  The purpose of this extension is to expose to the OpenGL application writer an unprecedented degree of programmability in the computation of final fragment colors and depth values. This extension provides a mechanism ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramNamedParameter4d.</para>
        /// <para>Fullname: ProgramNamedParameter4dNV</para>
        /// <para>Extensions: NV_fragment_program</para>
        /// </summary>
        public static void ProgramNamedParameter4d(uint id, int len, byte[] name, double x, double y, double z, double w)
        {
            if (gl._ProgramNamedParameter4d != null) gl._ProgramNamedParameter4d(id, len, name, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramNamedParameter4dvNV</para>
        /// </summary>
        [GLEntry("ProgramNamedParameter4dvNV", Category = "NV")]
        public static GLDelegate.ProgramNamedParameter4dv _ProgramNamedParameter4dv = null;
        /// <summary>
        /// <para>OpenGL mandates a certain set of configurable per-fragment computations defining texture lookup, texture environment, color sum, and fog operations.  Each of these areas provide a useful but limited set of fixed operations.  For example, unextended OpenGL 1.2.1 provides only four texture environment modes, color sum, and three fog modes.  Many OpenGL extensions have either improved existing functionality or introduced new configurable fragment operations.  While these extensions have enabled new and interesting rendering effects, the set of effects is limited by the set of special modes introduced by the extension.  This lack of flexibility is in contrast to the high-level of programmability of general-purpose CPUs and other (frequently software-based) shading languages.  The purpose of this extension is to expose to the OpenGL application writer an unprecedented degree of programmability in the computation of final fragment colors and depth values. This extension provides a mechanism ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramNamedParameter4dv.</para>
        /// <para>Fullname: ProgramNamedParameter4dvNV</para>
        /// <para>Extensions: NV_fragment_program</para>
        /// </summary>
        public static void ProgramNamedParameter4dv(uint id, int len, byte[] name, double[] v)
        {
            if (gl._ProgramNamedParameter4dv != null) gl._ProgramNamedParameter4dv(id, len, name, v); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramNamedParameter4fNV</para>
        /// </summary>
        [GLEntry("ProgramNamedParameter4fNV", Category = "NV")]
        public static GLDelegate.ProgramNamedParameter4f _ProgramNamedParameter4f = null;
        /// <summary>
        /// <para>OpenGL mandates a certain set of configurable per-fragment computations defining texture lookup, texture environment, color sum, and fog operations.  Each of these areas provide a useful but limited set of fixed operations.  For example, unextended OpenGL 1.2.1 provides only four texture environment modes, color sum, and three fog modes.  Many OpenGL extensions have either improved existing functionality or introduced new configurable fragment operations.  While these extensions have enabled new and interesting rendering effects, the set of effects is limited by the set of special modes introduced by the extension.  This lack of flexibility is in contrast to the high-level of programmability of general-purpose CPUs and other (frequently software-based) shading languages.  The purpose of this extension is to expose to the OpenGL application writer an unprecedented degree of programmability in the computation of final fragment colors and depth values. This extension provides a mechanism ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramNamedParameter4f.</para>
        /// <para>Fullname: ProgramNamedParameter4fNV</para>
        /// <para>Extensions: NV_fragment_program</para>
        /// </summary>
        public static void ProgramNamedParameter4f(uint id, int len, byte[] name, float x, float y, float z, float w)
        {
            if (gl._ProgramNamedParameter4f != null) gl._ProgramNamedParameter4f(id, len, name, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramNamedParameter4fvNV</para>
        /// </summary>
        [GLEntry("ProgramNamedParameter4fvNV", Category = "NV")]
        public static GLDelegate.ProgramNamedParameter4fv _ProgramNamedParameter4fv = null;
        /// <summary>
        /// <para>OpenGL mandates a certain set of configurable per-fragment computations defining texture lookup, texture environment, color sum, and fog operations.  Each of these areas provide a useful but limited set of fixed operations.  For example, unextended OpenGL 1.2.1 provides only four texture environment modes, color sum, and three fog modes.  Many OpenGL extensions have either improved existing functionality or introduced new configurable fragment operations.  While these extensions have enabled new and interesting rendering effects, the set of effects is limited by the set of special modes introduced by the extension.  This lack of flexibility is in contrast to the high-level of programmability of general-purpose CPUs and other (frequently software-based) shading languages.  The purpose of this extension is to expose to the OpenGL application writer an unprecedented degree of programmability in the computation of final fragment colors and depth values. This extension provides a mechanism ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramNamedParameter4fv.</para>
        /// <para>Fullname: ProgramNamedParameter4fvNV</para>
        /// <para>Extensions: NV_fragment_program</para>
        /// </summary>
        public static void ProgramNamedParameter4fv(uint id, int len, byte[] name, float[] v)
        {
            if (gl._ProgramNamedParameter4fv != null) gl._ProgramNamedParameter4fv(id, len, name, v); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramParameter4dNV</para>
        /// </summary>
        [GLEntry("ProgramParameter4dNV", Category = "NV")]
        public static GLDelegate.ProgramParameter4d _ProgramParameter4d = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramParameter4d.</para>
        /// <para>Fullname: ProgramParameter4dNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void ProgramParameter4d(int target, uint index, double x, double y, double z, double w)
        {
            if (gl._ProgramParameter4d != null) gl._ProgramParameter4d(target, index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramParameter4dvNV</para>
        /// </summary>
        [GLEntry("ProgramParameter4dvNV", Category = "NV")]
        public static GLDelegate.ProgramParameter4dv _ProgramParameter4dv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramParameter4dv.</para>
        /// <para>Fullname: ProgramParameter4dvNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void ProgramParameter4dv(int target, uint index, double[] v)
        {
            if (gl._ProgramParameter4dv != null) gl._ProgramParameter4dv(target, index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramParameter4fNV</para>
        /// </summary>
        [GLEntry("ProgramParameter4fNV", Category = "NV")]
        public static GLDelegate.ProgramParameter4f _ProgramParameter4f = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramParameter4f.</para>
        /// <para>Fullname: ProgramParameter4fNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void ProgramParameter4f(int target, uint index, float x, float y, float z, float w)
        {
            if (gl._ProgramParameter4f != null) gl._ProgramParameter4f(target, index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramParameter4fvNV</para>
        /// </summary>
        [GLEntry("ProgramParameter4fvNV", Category = "NV")]
        public static GLDelegate.ProgramParameter4fv _ProgramParameter4fv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramParameter4fv.</para>
        /// <para>Fullname: ProgramParameter4fvNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void ProgramParameter4fv(int target, uint index, float[] v)
        {
            if (gl._ProgramParameter4fv != null) gl._ProgramParameter4fv(target, index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramParameters4dvNV</para>
        /// </summary>
        [GLEntry("ProgramParameters4dvNV", Category = "NV")]
        public static GLDelegate.ProgramParameters4dv _ProgramParameters4dv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramParameters4dv.</para>
        /// <para>Fullname: ProgramParameters4dvNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void ProgramParameters4dv(int target, uint index, int count, double[] v)
        {
            if (gl._ProgramParameters4dv != null) gl._ProgramParameters4dv(target, index, count, v); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramParameters4fvNV</para>
        /// </summary>
        [GLEntry("ProgramParameters4fvNV", Category = "NV")]
        public static GLDelegate.ProgramParameters4fv _ProgramParameters4fv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramParameters4fv.</para>
        /// <para>Fullname: ProgramParameters4fvNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void ProgramParameters4fv(int target, uint index, int count, float[] v)
        {
            if (gl._ProgramParameters4fv != null) gl._ProgramParameters4fv(target, index, count, v); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramSubroutineParametersuivNV</para>
        /// </summary>
        [GLEntry("ProgramSubroutineParametersuivNV", Category = "NV")]
        public static GLDelegate.ProgramSubroutineParametersuiv _ProgramSubroutineParametersuiv = null;
        /// <summary>
        /// <para>This specification documents the common instruction set and basic functionality provided by NVIDIA's 5th generation of assembly instruction sets supporting programmable graphics pipeline stages. The instruction set builds upon the basic framework provided by the ARB_vertex_program and ARB_fragment_program extensions to expose considerably more capable hardware.  In addition to new capabilities for vertex and fragment programs, this extension provides new functionality for geometry programs as originally described in the NV_geometry_program4 specification, and serves as the basis for the new tessellation control and evaluation programs described in the NV_tessellation_program5 extension. Programs using the functionality provided by this extension should begin with the program headers "!!NVvp5.0" (vertex programs), "!!NVtcp5.0" (tessellation control programs), "!!NVtep5.0" (tessellation evaluation programs), "!!NVgp5.0" (geometry programs), and "!!NVfp5.0" (fragment programs). This exten...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramSubroutineParametersuiv.</para>
        /// <para>Fullname: ProgramSubroutineParametersuivNV</para>
        /// <para>Extensions: NV_gpu_program5</para>
        /// </summary>
        public static void ProgramSubroutineParametersuiv(int target, int count, uint[] param)
        {
            if (gl._ProgramSubroutineParametersuiv != null) gl._ProgramSubroutineParametersuiv(target, count, param); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform1i64NV</para>
        /// </summary>
        [GLEntry("ProgramUniform1i64NV", Category = "NV")]
        public static GLDelegate.ProgramUniform1i64 _ProgramUniform1i64 = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform1i64.</para>
        /// <para>Fullname: ProgramUniform1i64NV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void ProgramUniform1i64(uint program, int location, long x)
        {
            if (gl._ProgramUniform1i64 != null) gl._ProgramUniform1i64(program, location, x); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform1i64vNV</para>
        /// </summary>
        [GLEntry("ProgramUniform1i64vNV", Category = "NV")]
        public static GLDelegate.ProgramUniform1i64v _ProgramUniform1i64v = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform1i64v.</para>
        /// <para>Fullname: ProgramUniform1i64vNV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void ProgramUniform1i64v(uint program, int location, int count, long[] value)
        {
            if (gl._ProgramUniform1i64v != null) gl._ProgramUniform1i64v(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform1ui64NV</para>
        /// </summary>
        [GLEntry("ProgramUniform1ui64NV", Category = "NV")]
        public static GLDelegate.ProgramUniform1ui64 _ProgramUniform1ui64 = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform1ui64.</para>
        /// <para>Fullname: ProgramUniform1ui64NV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void ProgramUniform1ui64(uint program, int location, ulong x)
        {
            if (gl._ProgramUniform1ui64 != null) gl._ProgramUniform1ui64(program, location, x); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform1ui64vNV</para>
        /// </summary>
        [GLEntry("ProgramUniform1ui64vNV", Category = "NV")]
        public static GLDelegate.ProgramUniform1ui64v _ProgramUniform1ui64v = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform1ui64v.</para>
        /// <para>Fullname: ProgramUniform1ui64vNV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void ProgramUniform1ui64v(uint program, int location, int count, ulong[] value)
        {
            if (gl._ProgramUniform1ui64v != null) gl._ProgramUniform1ui64v(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform2i64NV</para>
        /// </summary>
        [GLEntry("ProgramUniform2i64NV", Category = "NV")]
        public static GLDelegate.ProgramUniform2i64 _ProgramUniform2i64 = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform2i64.</para>
        /// <para>Fullname: ProgramUniform2i64NV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void ProgramUniform2i64(uint program, int location, long x, long y)
        {
            if (gl._ProgramUniform2i64 != null) gl._ProgramUniform2i64(program, location, x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform2i64vNV</para>
        /// </summary>
        [GLEntry("ProgramUniform2i64vNV", Category = "NV")]
        public static GLDelegate.ProgramUniform2i64v _ProgramUniform2i64v = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform2i64v.</para>
        /// <para>Fullname: ProgramUniform2i64vNV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void ProgramUniform2i64v(uint program, int location, int count, long[] value)
        {
            if (gl._ProgramUniform2i64v != null) gl._ProgramUniform2i64v(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform2ui64NV</para>
        /// </summary>
        [GLEntry("ProgramUniform2ui64NV", Category = "NV")]
        public static GLDelegate.ProgramUniform2ui64 _ProgramUniform2ui64 = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform2ui64.</para>
        /// <para>Fullname: ProgramUniform2ui64NV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void ProgramUniform2ui64(uint program, int location, ulong x, ulong y)
        {
            if (gl._ProgramUniform2ui64 != null) gl._ProgramUniform2ui64(program, location, x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform2ui64vNV</para>
        /// </summary>
        [GLEntry("ProgramUniform2ui64vNV", Category = "NV")]
        public static GLDelegate.ProgramUniform2ui64v _ProgramUniform2ui64v = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform2ui64v.</para>
        /// <para>Fullname: ProgramUniform2ui64vNV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void ProgramUniform2ui64v(uint program, int location, int count, ulong[] value)
        {
            if (gl._ProgramUniform2ui64v != null) gl._ProgramUniform2ui64v(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform3i64NV</para>
        /// </summary>
        [GLEntry("ProgramUniform3i64NV", Category = "NV")]
        public static GLDelegate.ProgramUniform3i64 _ProgramUniform3i64 = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform3i64.</para>
        /// <para>Fullname: ProgramUniform3i64NV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void ProgramUniform3i64(uint program, int location, long x, long y, long z)
        {
            if (gl._ProgramUniform3i64 != null) gl._ProgramUniform3i64(program, location, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform3i64vNV</para>
        /// </summary>
        [GLEntry("ProgramUniform3i64vNV", Category = "NV")]
        public static GLDelegate.ProgramUniform3i64v _ProgramUniform3i64v = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform3i64v.</para>
        /// <para>Fullname: ProgramUniform3i64vNV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void ProgramUniform3i64v(uint program, int location, int count, long[] value)
        {
            if (gl._ProgramUniform3i64v != null) gl._ProgramUniform3i64v(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform3ui64NV</para>
        /// </summary>
        [GLEntry("ProgramUniform3ui64NV", Category = "NV")]
        public static GLDelegate.ProgramUniform3ui64 _ProgramUniform3ui64 = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform3ui64.</para>
        /// <para>Fullname: ProgramUniform3ui64NV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void ProgramUniform3ui64(uint program, int location, ulong x, ulong y, ulong z)
        {
            if (gl._ProgramUniform3ui64 != null) gl._ProgramUniform3ui64(program, location, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform3ui64vNV</para>
        /// </summary>
        [GLEntry("ProgramUniform3ui64vNV", Category = "NV")]
        public static GLDelegate.ProgramUniform3ui64v _ProgramUniform3ui64v = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform3ui64v.</para>
        /// <para>Fullname: ProgramUniform3ui64vNV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void ProgramUniform3ui64v(uint program, int location, int count, ulong[] value)
        {
            if (gl._ProgramUniform3ui64v != null) gl._ProgramUniform3ui64v(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform4i64NV</para>
        /// </summary>
        [GLEntry("ProgramUniform4i64NV", Category = "NV")]
        public static GLDelegate.ProgramUniform4i64 _ProgramUniform4i64 = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform4i64.</para>
        /// <para>Fullname: ProgramUniform4i64NV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void ProgramUniform4i64(uint program, int location, long x, long y, long z, long w)
        {
            if (gl._ProgramUniform4i64 != null) gl._ProgramUniform4i64(program, location, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform4i64vNV</para>
        /// </summary>
        [GLEntry("ProgramUniform4i64vNV", Category = "NV")]
        public static GLDelegate.ProgramUniform4i64v _ProgramUniform4i64v = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform4i64v.</para>
        /// <para>Fullname: ProgramUniform4i64vNV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void ProgramUniform4i64v(uint program, int location, int count, long[] value)
        {
            if (gl._ProgramUniform4i64v != null) gl._ProgramUniform4i64v(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform4ui64NV</para>
        /// </summary>
        [GLEntry("ProgramUniform4ui64NV", Category = "NV")]
        public static GLDelegate.ProgramUniform4ui64 _ProgramUniform4ui64 = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform4ui64.</para>
        /// <para>Fullname: ProgramUniform4ui64NV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void ProgramUniform4ui64(uint program, int location, ulong x, ulong y, ulong z, ulong w)
        {
            if (gl._ProgramUniform4ui64 != null) gl._ProgramUniform4ui64(program, location, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniform4ui64vNV</para>
        /// </summary>
        [GLEntry("ProgramUniform4ui64vNV", Category = "NV")]
        public static GLDelegate.ProgramUniform4ui64v _ProgramUniform4ui64v = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniform4ui64v.</para>
        /// <para>Fullname: ProgramUniform4ui64vNV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void ProgramUniform4ui64v(uint program, int location, int count, ulong[] value)
        {
            if (gl._ProgramUniform4ui64v != null) gl._ProgramUniform4ui64v(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformHandleui64NV</para>
        /// </summary>
        [GLEntry("ProgramUniformHandleui64NV", Category = "NV")]
        public static GLDelegate.ProgramUniformHandleui64 _ProgramUniformHandleui64 = null;
        /// <summary>
        /// <para>This extension allows OpenGL applications to access texture objects in shaders without first binding each texture to one of a limited number of texture image units.  Using this extension, an application can query an 64-bit unsigned integer texture handle for each texture that it wants to access and then use that handle directly in GLSL or assembly-based shaders.  The ability to access textures without having to bind and/or re-bind them is similar to the capability provided by the NV_shader_buffer_load extension that allows shaders to access buffer objects without binding them.  In both cases, these extensions significantly reduce the amount of API and internal GL driver overhead needed to manage resource bindings. This extension also provides similar capability for the image load, store, and atomic functionality provided by OpenGL 4.2 and the ARB_shader_image_load_store and EXT_shader_image_load_store extensions, where a texture can be accessed without first binding it to an image unit...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformHandleui64.</para>
        /// <para>Fullname: ProgramUniformHandleui64NV</para>
        /// <para>Extensions: NV_bindless_texture</para>
        /// </summary>
        public static void ProgramUniformHandleui64(uint program, int location, ulong value)
        {
            if (gl._ProgramUniformHandleui64 != null) gl._ProgramUniformHandleui64(program, location, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformHandleui64vNV</para>
        /// </summary>
        [GLEntry("ProgramUniformHandleui64vNV", Category = "NV")]
        public static GLDelegate.ProgramUniformHandleui64v _ProgramUniformHandleui64v = null;
        /// <summary>
        /// <para>This extension allows OpenGL applications to access texture objects in shaders without first binding each texture to one of a limited number of texture image units.  Using this extension, an application can query an 64-bit unsigned integer texture handle for each texture that it wants to access and then use that handle directly in GLSL or assembly-based shaders.  The ability to access textures without having to bind and/or re-bind them is similar to the capability provided by the NV_shader_buffer_load extension that allows shaders to access buffer objects without binding them.  In both cases, these extensions significantly reduce the amount of API and internal GL driver overhead needed to manage resource bindings. This extension also provides similar capability for the image load, store, and atomic functionality provided by OpenGL 4.2 and the ARB_shader_image_load_store and EXT_shader_image_load_store extensions, where a texture can be accessed without first binding it to an image unit...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformHandleui64v.</para>
        /// <para>Fullname: ProgramUniformHandleui64vNV</para>
        /// <para>Extensions: NV_bindless_texture</para>
        /// </summary>
        public static void ProgramUniformHandleui64v(uint program, int location, int count, ulong[] values)
        {
            if (gl._ProgramUniformHandleui64v != null) gl._ProgramUniformHandleui64v(program, location, count, values); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformui64NV</para>
        /// </summary>
        [GLEntry("ProgramUniformui64NV", Category = "NV")]
        public static GLDelegate.ProgramUniformui64 _ProgramUniformui64 = null;
        /// <summary>
        /// <para>At a very coarse level, GL has evolved in a way that allows applications to replace many of the original state machine variables with blocks of user-defined data. For example, the current vertex state has been augmented by vertex buffer objects, fixed-function shading state and parameters have been replaced by shaders/programs and constant buffers, etc.. Applications switch between coarse sets of state by binding objects to the context or to other container objects (e.g. vertex array objects) instead of manipulating state variables of the context. In terms of the number of GL commands required to draw an object, modern applications are orders of magnitude more efficient than legacy applications, but this explosion of objects bound to other objects has led to a new bottleneck - pointer chasing and CPU L2 cache misses in the driver, and general L2 cache pollution. This extension provides a mechanism to read from a flat, 64-bit GPU address space from programs/shaders, to query GPU address...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformui64.</para>
        /// <para>Fullname: ProgramUniformui64NV</para>
        /// <para>Extensions: NV_shader_buffer_load</para>
        /// </summary>
        public static void ProgramUniformui64(uint program, int location, ulong value)
        {
            if (gl._ProgramUniformui64 != null) gl._ProgramUniformui64(program, location, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramUniformui64vNV</para>
        /// </summary>
        [GLEntry("ProgramUniformui64vNV", Category = "NV")]
        public static GLDelegate.ProgramUniformui64v _ProgramUniformui64v = null;
        /// <summary>
        /// <para>At a very coarse level, GL has evolved in a way that allows applications to replace many of the original state machine variables with blocks of user-defined data. For example, the current vertex state has been augmented by vertex buffer objects, fixed-function shading state and parameters have been replaced by shaders/programs and constant buffers, etc.. Applications switch between coarse sets of state by binding objects to the context or to other container objects (e.g. vertex array objects) instead of manipulating state variables of the context. In terms of the number of GL commands required to draw an object, modern applications are orders of magnitude more efficient than legacy applications, but this explosion of objects bound to other objects has led to a new bottleneck - pointer chasing and CPU L2 cache misses in the driver, and general L2 cache pollution. This extension provides a mechanism to read from a flat, 64-bit GPU address space from programs/shaders, to query GPU address...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramUniformui64v.</para>
        /// <para>Fullname: ProgramUniformui64vNV</para>
        /// <para>Extensions: NV_shader_buffer_load</para>
        /// </summary>
        public static void ProgramUniformui64v(uint program, int location, int count, ulong[] value)
        {
            if (gl._ProgramUniformui64v != null) gl._ProgramUniformui64v(program, location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: ProgramVertexLimitNV</para>
        /// </summary>
        [GLEntry("ProgramVertexLimitNV", Category = "NV")]
        public static GLDelegate.ProgramVertexLimit _ProgramVertexLimit = null;
        /// <summary>
        /// <para>NV_geometry_program4 defines a new type of program available to be run on the GPU, called a geometry program.  Geometry programs are run on full primitives after vertices are transformed, but prior to flat shading and clipping. A geometry program begins with a single primitive - a point, line, or triangle.  Quads and polygons are allowed, but are decomposed into individual triangles prior to geometry program execution.  It can read the attributes of any of the vertex in the primitive and use them to generate new primitives.  A geometry program has a fixed output primitive type, either a point, a line strip, or a triangle strip.  It emits vertices (using the EMIT opcode) to define the output primitive.  The attributes of emitted vertices are specified by writing to the same set of result bindings (e.g., "result.position") provided for vertex programs. Additionally, a geometry program can emit multiple disconnected primitives by using the ENDPRIM opcode, which is roughly equivalent to ca...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ProgramVertexLimit.</para>
        /// <para>Fullname: ProgramVertexLimitNV</para>
        /// <para>Extensions: NV_geometry_program4</para>
        /// </summary>
        public static void ProgramVertexLimit(int target, int limit)
        {
            if (gl._ProgramVertexLimit != null) gl._ProgramVertexLimit(target, limit); else { }
        }
        /// <summary>
        /// <para>Fullname: RenderbufferStorageMultisampleCoverageNV</para>
        /// </summary>
        [GLEntry("RenderbufferStorageMultisampleCoverageNV", Category = "NV")]
        public static GLDelegate.RenderbufferStorageMultisampleCoverage _RenderbufferStorageMultisampleCoverage = null;
        /// <summary>
        /// <para>This extension extends the EXT_framebuffer_multisample specification by providing a new function, RenderBufferStorageMultisampleCoverageNV, that distinguishes between color samples and coverage samples. EXT_framebuffer_multisample introduced the function RenderbufferStorageMultisampleEXT as a method of defining the storage parameters for a multisample render buffer.  This function takes a <samples> parameter.  Using rules provided by the specification, the <samples> parameter is resolved to an actual number of samples that is supported by the underlying hardware. EXT_framebuffer_multisample does not specify whether <samples> refers to coverage samples or color samples. This extension adds the function RenderbufferStorageMultisamplCoverageNV, which takes a <coverageSamples> parameter as well as a <colorSamples> parameter. These two parameters give developers more fine grained control over the quality of multisampled images. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RenderbufferStorageMultisampleCoverage.</para>
        /// <para>Fullname: RenderbufferStorageMultisampleCoverageNV</para>
        /// <para>Extensions: NV_framebuffer_multisample_coverage</para>
        /// </summary>
        public static void RenderbufferStorageMultisampleCoverage(int target, int coverageSamples, int colorSamples, int internalformat, int width, int height)
        {
            if (gl._RenderbufferStorageMultisampleCoverage != null) gl._RenderbufferStorageMultisampleCoverage(target, coverageSamples, colorSamples, internalformat, width, height); else { }
        }
        /// <summary>
        /// <para>Fullname: RequestResidentProgramsNV</para>
        /// </summary>
        [GLEntry("RequestResidentProgramsNV", Category = "NV")]
        public static GLDelegate.RequestResidentPrograms_uint _RequestResidentPrograms_uint = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RequestResidentPrograms_uint.</para>
        /// <para>Fullname: RequestResidentProgramsNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void RequestResidentPrograms(int n, ref uint programs)
        {
            if (gl._RequestResidentPrograms_uint != null) gl._RequestResidentPrograms_uint(n, ref programs); else { }
        }
        /// <summary>
        /// <para>Fullname: RequestResidentProgramsNV</para>
        /// </summary>
        [GLEntry("RequestResidentProgramsNV", Category = "NV")]
        public static GLDelegate.RequestResidentPrograms _RequestResidentPrograms = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _RequestResidentPrograms.</para>
        /// <para>Fullname: RequestResidentProgramsNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void RequestResidentPrograms(int n, uint[] programs)
        {
            if (gl._RequestResidentPrograms != null) gl._RequestResidentPrograms(n, programs); else { }
        }
        /// <summary>
        /// <para>Fullname: SampleMaskIndexedNV</para>
        /// </summary>
        [GLEntry("SampleMaskIndexedNV", Category = "NV")]
        public static GLDelegate.SampleMaskIndexed _SampleMaskIndexed = null;
        /// <summary>
        /// <para>In traditional multisample specs, the API only allows access to the samples indirectly through methods such as coverage values and downsampled readbacks. NV_explicit_multisample adds a set of new capabilities to allow more precise control over the use of multisamples. Specifically, it adds: * A query in the API to query the location of samples within the pixel * An explicit control for the multisample sample mask to augment the control provided by SampleCoverage * A new texture target to wrap a renderbuffer and allow a restricted class of accesses to the samples * The ability to fetch a specific sample from a multisampled texture from within a shader * A program option to enable the new behavior </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SampleMaskIndexed.</para>
        /// <para>Fullname: SampleMaskIndexedNV</para>
        /// <para>Extensions: NV_explicit_multisample</para>
        /// </summary>
        public static void SampleMaskIndexed(uint index, int mask)
        {
            if (gl._SampleMaskIndexed != null) gl._SampleMaskIndexed(index, mask); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColor3hNV</para>
        /// </summary>
        [GLEntry("SecondaryColor3hNV", Category = "NV")]
        public static GLDelegate.SecondaryColor3h _SecondaryColor3h = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColor3h.</para>
        /// <para>Fullname: SecondaryColor3hNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void SecondaryColor3h(ushort red, ushort green, ushort blue)
        {
            if (gl._SecondaryColor3h != null) gl._SecondaryColor3h(red, green, blue); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColor3hvNV</para>
        /// </summary>
        [GLEntry("SecondaryColor3hvNV", Category = "NV")]
        public static GLDelegate.SecondaryColor3hv _SecondaryColor3hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColor3hv.</para>
        /// <para>Fullname: SecondaryColor3hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void SecondaryColor3hv(ushort[] v)
        {
            if (gl._SecondaryColor3hv != null) gl._SecondaryColor3hv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColorFormatNV</para>
        /// </summary>
        [GLEntry("SecondaryColorFormatNV", Category = "NV")]
        public static GLDelegate.SecondaryColorFormat _SecondaryColorFormat = null;
        /// <summary>
        /// <para>This extension provides a mechanism to specify vertex attrib and element array locations using GPU addresses. Binding vertex buffers is one of the most frequent and expensive operations in many GL applications, due to the cost of chasing pointers and binding objects described in the Overview of NV_shader_buffer_load. The intent of this extension is to enable a way for the application to specify vertex attrib state that alleviates the overhead of object binds and driver memory management. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColorFormat.</para>
        /// <para>Fullname: SecondaryColorFormatNV</para>
        /// <para>Extensions: NV_vertex_buffer_unified_memory</para>
        /// </summary>
        public static void SecondaryColorFormat(int size, int type, int stride)
        {
            if (gl._SecondaryColorFormat != null) gl._SecondaryColorFormat(size, type, stride); else { }
        }
        /// <summary>
        /// <para>Fullname: SetFenceNV</para>
        /// </summary>
        [GLEntry("SetFenceNV", Category = "NV")]
        public static GLDelegate.SetFence _SetFence = null;
        /// <summary>
        /// <para>The goal of this extension is provide a finer granularity of synchronizing GL command completion than offered by standard OpenGL, which offers only two mechanisms for synchronization: Flush and Finish. Since Flush merely assures the user that the commands complete in a finite (though undetermined) amount of time, it is, thus, of only modest utility.  Finish, on the other hand, stalls CPU execution until all pending GL commands have completed.  This extension offers a middle ground - the ability to "finish" a subset of the command stream, and the ability to determine whether a given command has completed or not. This extension introduces the concept of a "fence" to the OpenGL command stream.  Once the fence is inserted into the command stream, it can be queried for a given condition - typically, its completion. Moreover, the application may also request a partial Finish -- that is, all commands prior to the fence will be forced to complete until control is returned to the calling proces...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SetFence.</para>
        /// <para>Fullname: SetFenceNV</para>
        /// <para>Extensions: NV_fence</para>
        /// </summary>
        public static void SetFence(uint fence, int condition)
        {
            if (gl._SetFence != null) gl._SetFence(fence, condition); else { }
        }
        /// <summary>
        /// <para>Fullname: StencilFillPathNV</para>
        /// </summary>
        [GLEntry("StencilFillPathNV", Category = "NV")]
        public static GLDelegate.StencilFillPath _StencilFillPath = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _StencilFillPath.</para>
        /// <para>Fullname: StencilFillPathNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void StencilFillPath(uint path, int fillMode, uint mask)
        {
            if (gl._StencilFillPath != null) gl._StencilFillPath(path, fillMode, mask); else { }
        }
        /// <summary>
        /// <para>Fullname: StencilFillPathInstancedNV</para>
        /// </summary>
        [GLEntry("StencilFillPathInstancedNV", Category = "NV")]
        public static GLDelegate.StencilFillPathInstanced _StencilFillPathInstanced = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _StencilFillPathInstanced.</para>
        /// <para>Fullname: StencilFillPathInstancedNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void StencilFillPathInstanced(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int fillMode, uint mask, int transformType, float[] transformValues)
        {
            if (gl._StencilFillPathInstanced != null) gl._StencilFillPathInstanced(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues); else { }
        }
        /// <summary>
        /// <para>Fullname: StencilStrokePathNV</para>
        /// </summary>
        [GLEntry("StencilStrokePathNV", Category = "NV")]
        public static GLDelegate.StencilStrokePath _StencilStrokePath = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _StencilStrokePath.</para>
        /// <para>Fullname: StencilStrokePathNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void StencilStrokePath(uint path, int reference, uint mask)
        {
            if (gl._StencilStrokePath != null) gl._StencilStrokePath(path, reference, mask); else { }
        }
        /// <summary>
        /// <para>Fullname: StencilStrokePathInstancedNV</para>
        /// </summary>
        [GLEntry("StencilStrokePathInstancedNV", Category = "NV")]
        public static GLDelegate.StencilStrokePathInstanced _StencilStrokePathInstanced = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _StencilStrokePathInstanced.</para>
        /// <para>Fullname: StencilStrokePathInstancedNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void StencilStrokePathInstanced(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, int transformType, float[] transformValues)
        {
            if (gl._StencilStrokePathInstanced != null) gl._StencilStrokePathInstanced(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues); else { }
        }
        /// <summary>
        /// <para>Fullname: TestFenceNV</para>
        /// </summary>
        [GLEntry("TestFenceNV", Category = "NV", Alias = "TestFenceAPPLE ")]
        public static GLDelegate.TestFence _TestFence = null;
        public static GLDelegate.TestFence TestFenceAPPLE = TestFence;
        /// <summary>
        /// <para>The goal of this extension is provide a finer granularity of synchronizing GL command completion than offered by standard OpenGL, which offers only two mechanisms for synchronization: Flush and Finish. Since Flush merely assures the user that the commands complete in a finite (though undetermined) amount of time, it is, thus, of only modest utility.  Finish, on the other hand, stalls CPU execution until all pending GL commands have completed.  This extension offers a middle ground - the ability to "finish" a subset of the command stream, and the ability to determine whether a given command has completed or not. This extension introduces the concept of a "fence" to the OpenGL command stream.  Once the fence is inserted into the command stream, it can be queried for a given condition - typically, its completion. Moreover, the application may also request a partial Finish -- that is, all commands prior to the fence will be forced to complete until control is returned to the calling proces...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TestFence.</para>
        /// <para>Fullname: TestFenceNV</para>
        /// <para>Aliases: TestFenceAPPLE, </para>
        /// <para>Extensions: NV_fence APPLE_fence</para>
        /// </summary>
        public static bool TestFence(uint fence)
        {
            if (gl._TestFence != null) return gl._TestFence(fence);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: TexCoord1hNV</para>
        /// </summary>
        [GLEntry("TexCoord1hNV", Category = "NV")]
        public static GLDelegate.TexCoord1h _TexCoord1h = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord1h.</para>
        /// <para>Fullname: TexCoord1hNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void TexCoord1h(ushort s)
        {
            if (gl._TexCoord1h != null) gl._TexCoord1h(s); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord1hvNV</para>
        /// </summary>
        [GLEntry("TexCoord1hvNV", Category = "NV")]
        public static GLDelegate.TexCoord1hv _TexCoord1hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord1hv.</para>
        /// <para>Fullname: TexCoord1hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void TexCoord1hv(ushort[] v)
        {
            if (gl._TexCoord1hv != null) gl._TexCoord1hv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2hNV</para>
        /// </summary>
        [GLEntry("TexCoord2hNV", Category = "NV")]
        public static GLDelegate.TexCoord2h _TexCoord2h = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2h.</para>
        /// <para>Fullname: TexCoord2hNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void TexCoord2h(ushort s, ushort t)
        {
            if (gl._TexCoord2h != null) gl._TexCoord2h(s, t); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord2hvNV</para>
        /// </summary>
        [GLEntry("TexCoord2hvNV", Category = "NV")]
        public static GLDelegate.TexCoord2hv _TexCoord2hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord2hv.</para>
        /// <para>Fullname: TexCoord2hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void TexCoord2hv(ushort[] v)
        {
            if (gl._TexCoord2hv != null) gl._TexCoord2hv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord3hNV</para>
        /// </summary>
        [GLEntry("TexCoord3hNV", Category = "NV")]
        public static GLDelegate.TexCoord3h _TexCoord3h = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord3h.</para>
        /// <para>Fullname: TexCoord3hNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void TexCoord3h(ushort s, ushort t, ushort r)
        {
            if (gl._TexCoord3h != null) gl._TexCoord3h(s, t, r); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord3hvNV</para>
        /// </summary>
        [GLEntry("TexCoord3hvNV", Category = "NV")]
        public static GLDelegate.TexCoord3hv _TexCoord3hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord3hv.</para>
        /// <para>Fullname: TexCoord3hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void TexCoord3hv(ushort[] v)
        {
            if (gl._TexCoord3hv != null) gl._TexCoord3hv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord4hNV</para>
        /// </summary>
        [GLEntry("TexCoord4hNV", Category = "NV")]
        public static GLDelegate.TexCoord4h _TexCoord4h = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord4h.</para>
        /// <para>Fullname: TexCoord4hNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void TexCoord4h(ushort s, ushort t, ushort r, ushort q)
        {
            if (gl._TexCoord4h != null) gl._TexCoord4h(s, t, r, q); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoord4hvNV</para>
        /// </summary>
        [GLEntry("TexCoord4hvNV", Category = "NV")]
        public static GLDelegate.TexCoord4hv _TexCoord4hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoord4hv.</para>
        /// <para>Fullname: TexCoord4hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void TexCoord4hv(ushort[] v)
        {
            if (gl._TexCoord4hv != null) gl._TexCoord4hv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoordFormatNV</para>
        /// </summary>
        [GLEntry("TexCoordFormatNV", Category = "NV")]
        public static GLDelegate.TexCoordFormat _TexCoordFormat = null;
        /// <summary>
        /// <para>This extension provides a mechanism to specify vertex attrib and element array locations using GPU addresses. Binding vertex buffers is one of the most frequent and expensive operations in many GL applications, due to the cost of chasing pointers and binding objects described in the Overview of NV_shader_buffer_load. The intent of this extension is to enable a way for the application to specify vertex attrib state that alleviates the overhead of object binds and driver memory management. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoordFormat.</para>
        /// <para>Fullname: TexCoordFormatNV</para>
        /// <para>Extensions: NV_vertex_buffer_unified_memory</para>
        /// </summary>
        public static void TexCoordFormat(int size, int type, int stride)
        {
            if (gl._TexCoordFormat != null) gl._TexCoordFormat(size, type, stride); else { }
        }
        /// <summary>
        /// <para>Fullname: TexImage2DMultisampleCoverageNV</para>
        /// </summary>
        [GLEntry("TexImage2DMultisampleCoverageNV", Category = "NV")]
        public static GLDelegate.TexImage2DMultisampleCoverage _TexImage2DMultisampleCoverage = null;
        /// <summary>
        /// <para>This specification extends NV_gpu_program4 to support per-sample fetching from multisample textures described in ARB_texture_multisample. Specifically, it adds: * The TXFMS sample fetch instruction. * Texture targets corresponding to the multisample textures added by ARB_texture_multisample. * A program option to enable these features.  This specification also extends the ARB_texture_multisample extension by adding support for EXT_direct_state_access and VCAA multisample coverage with seperate <colorSamples> and <coverageSamples> parameters. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexImage2DMultisampleCoverage.</para>
        /// <para>Fullname: TexImage2DMultisampleCoverageNV</para>
        /// <para>Extensions: NV_texture_multisample</para>
        /// </summary>
        public static void TexImage2DMultisampleCoverage(int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, bool fixedSampleLocations)
        {
            if (gl._TexImage2DMultisampleCoverage != null) gl._TexImage2DMultisampleCoverage(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations); else { }
        }
        /// <summary>
        /// <para>Fullname: TexImage3DMultisampleCoverageNV</para>
        /// </summary>
        [GLEntry("TexImage3DMultisampleCoverageNV", Category = "NV")]
        public static GLDelegate.TexImage3DMultisampleCoverage _TexImage3DMultisampleCoverage = null;
        /// <summary>
        /// <para>This specification extends NV_gpu_program4 to support per-sample fetching from multisample textures described in ARB_texture_multisample. Specifically, it adds: * The TXFMS sample fetch instruction. * Texture targets corresponding to the multisample textures added by ARB_texture_multisample. * A program option to enable these features.  This specification also extends the ARB_texture_multisample extension by adding support for EXT_direct_state_access and VCAA multisample coverage with seperate <colorSamples> and <coverageSamples> parameters. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexImage3DMultisampleCoverage.</para>
        /// <para>Fullname: TexImage3DMultisampleCoverageNV</para>
        /// <para>Extensions: NV_texture_multisample</para>
        /// </summary>
        public static void TexImage3DMultisampleCoverage(int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations)
        {
            if (gl._TexImage3DMultisampleCoverage != null) gl._TexImage3DMultisampleCoverage(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations); else { }
        }
        /// <summary>
        /// <para>Fullname: TexRenderbufferNV</para>
        /// </summary>
        [GLEntry("TexRenderbufferNV", Category = "NV")]
        public static GLDelegate.TexRenderbuffer _TexRenderbuffer = null;
        /// <summary>
        /// <para>In traditional multisample specs, the API only allows access to the samples indirectly through methods such as coverage values and downsampled readbacks. NV_explicit_multisample adds a set of new capabilities to allow more precise control over the use of multisamples. Specifically, it adds: * A query in the API to query the location of samples within the pixel * An explicit control for the multisample sample mask to augment the control provided by SampleCoverage * A new texture target to wrap a renderbuffer and allow a restricted class of accesses to the samples * The ability to fetch a specific sample from a multisampled texture from within a shader * A program option to enable the new behavior </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexRenderbuffer.</para>
        /// <para>Fullname: TexRenderbufferNV</para>
        /// <para>Extensions: NV_explicit_multisample</para>
        /// </summary>
        public static void TexRenderbuffer(int target, uint renderbuffer)
        {
            if (gl._TexRenderbuffer != null) gl._TexRenderbuffer(target, renderbuffer); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureBarrierNV</para>
        /// </summary>
        [GLEntry("TextureBarrierNV", Category = "NV")]
        public static GLDelegate.TextureBarrier _TextureBarrier = null;
        /// <summary>
        /// <para>This extension relaxes the restrictions on rendering to a currently bound texture and provides a mechanism to avoid read-after-write hazards. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureBarrier.</para>
        /// <para>Fullname: TextureBarrierNV</para>
        /// <para>Extensions: NV_texture_barrier</para>
        /// </summary>
        public static void TextureBarrier()
        {
            if (gl._TextureBarrier != null) gl._TextureBarrier(); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureImage2DMultisampleNV</para>
        /// </summary>
        [GLEntry("TextureImage2DMultisampleNV", Category = "NV")]
        public static GLDelegate.TextureImage2DMultisample _TextureImage2DMultisample = null;
        /// <summary>
        /// <para>This specification extends NV_gpu_program4 to support per-sample fetching from multisample textures described in ARB_texture_multisample. Specifically, it adds: * The TXFMS sample fetch instruction. * Texture targets corresponding to the multisample textures added by ARB_texture_multisample. * A program option to enable these features.  This specification also extends the ARB_texture_multisample extension by adding support for EXT_direct_state_access and VCAA multisample coverage with seperate <colorSamples> and <coverageSamples> parameters. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureImage2DMultisample.</para>
        /// <para>Fullname: TextureImage2DMultisampleNV</para>
        /// <para>Extensions: NV_texture_multisample</para>
        /// </summary>
        public static void TextureImage2DMultisample(uint texture, int target, int samples, int internalFormat, int width, int height, bool fixedSampleLocations)
        {
            if (gl._TextureImage2DMultisample != null) gl._TextureImage2DMultisample(texture, target, samples, internalFormat, width, height, fixedSampleLocations); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureImage2DMultisampleCoverageNV</para>
        /// </summary>
        [GLEntry("TextureImage2DMultisampleCoverageNV", Category = "NV")]
        public static GLDelegate.TextureImage2DMultisampleCoverage _TextureImage2DMultisampleCoverage = null;
        /// <summary>
        /// <para>This specification extends NV_gpu_program4 to support per-sample fetching from multisample textures described in ARB_texture_multisample. Specifically, it adds: * The TXFMS sample fetch instruction. * Texture targets corresponding to the multisample textures added by ARB_texture_multisample. * A program option to enable these features.  This specification also extends the ARB_texture_multisample extension by adding support for EXT_direct_state_access and VCAA multisample coverage with seperate <colorSamples> and <coverageSamples> parameters. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureImage2DMultisampleCoverage.</para>
        /// <para>Fullname: TextureImage2DMultisampleCoverageNV</para>
        /// <para>Extensions: NV_texture_multisample</para>
        /// </summary>
        public static void TextureImage2DMultisampleCoverage(uint texture, int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, bool fixedSampleLocations)
        {
            if (gl._TextureImage2DMultisampleCoverage != null) gl._TextureImage2DMultisampleCoverage(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureImage3DMultisampleNV</para>
        /// </summary>
        [GLEntry("TextureImage3DMultisampleNV", Category = "NV")]
        public static GLDelegate.TextureImage3DMultisample _TextureImage3DMultisample = null;
        /// <summary>
        /// <para>This specification extends NV_gpu_program4 to support per-sample fetching from multisample textures described in ARB_texture_multisample. Specifically, it adds: * The TXFMS sample fetch instruction. * Texture targets corresponding to the multisample textures added by ARB_texture_multisample. * A program option to enable these features.  This specification also extends the ARB_texture_multisample extension by adding support for EXT_direct_state_access and VCAA multisample coverage with seperate <colorSamples> and <coverageSamples> parameters. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureImage3DMultisample.</para>
        /// <para>Fullname: TextureImage3DMultisampleNV</para>
        /// <para>Extensions: NV_texture_multisample</para>
        /// </summary>
        public static void TextureImage3DMultisample(uint texture, int target, int samples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations)
        {
            if (gl._TextureImage3DMultisample != null) gl._TextureImage3DMultisample(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations); else { }
        }
        /// <summary>
        /// <para>Fullname: TextureImage3DMultisampleCoverageNV</para>
        /// </summary>
        [GLEntry("TextureImage3DMultisampleCoverageNV", Category = "NV")]
        public static GLDelegate.TextureImage3DMultisampleCoverage _TextureImage3DMultisampleCoverage = null;
        /// <summary>
        /// <para>This specification extends NV_gpu_program4 to support per-sample fetching from multisample textures described in ARB_texture_multisample. Specifically, it adds: * The TXFMS sample fetch instruction. * Texture targets corresponding to the multisample textures added by ARB_texture_multisample. * A program option to enable these features.  This specification also extends the ARB_texture_multisample extension by adding support for EXT_direct_state_access and VCAA multisample coverage with seperate <colorSamples> and <coverageSamples> parameters. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureImage3DMultisampleCoverage.</para>
        /// <para>Fullname: TextureImage3DMultisampleCoverageNV</para>
        /// <para>Extensions: NV_texture_multisample</para>
        /// </summary>
        public static void TextureImage3DMultisampleCoverage(uint texture, int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations)
        {
            if (gl._TextureImage3DMultisampleCoverage != null) gl._TextureImage3DMultisampleCoverage(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations); else { }
        }
        /// <summary>
        /// <para>Fullname: TrackMatrixNV</para>
        /// </summary>
        [GLEntry("TrackMatrixNV", Category = "NV")]
        public static GLDelegate.TrackMatrix _TrackMatrix = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TrackMatrix.</para>
        /// <para>Fullname: TrackMatrixNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void TrackMatrix(int target, uint address, int matrix, int transform)
        {
            if (gl._TrackMatrix != null) gl._TrackMatrix(target, address, matrix, transform); else { }
        }
        /// <summary>
        /// <para>Fullname: TransformFeedbackAttribsNV</para>
        /// </summary>
        [GLEntry("TransformFeedbackAttribsNV", Category = "NV")]
        public static GLDelegate.TransformFeedbackAttribs _TransformFeedbackAttribs = null;
        /// <summary>
        /// <para>This extension provides a new mode to the GL, called transform feedback, which records vertex attributes of the primitives processed by the GL. The selected attributes are written into buffer objects, and can be written with each attribute in a separate buffer object or with all attributes interleaved into a single buffer object.  If a geometry program or shader is active, the primitives recorded are those emitted by the geometry program.  Otherwise, transform feedback captures primitives whose vertex are transformed by a vertex program or shader, or by fixed-function vertex processing.  In either case, the primitives captured are those generated prior to clipping.  Transform feedback mode is capable of capturing transformed vertex data generated by fixed-function vertex processing, outputs from assembly vertex or geometry programs, or varying variables emitted from GLSL vertex or geometry shaders. The vertex data recorded in transform feedback mode is stored into buffer objects as an ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TransformFeedbackAttribs.</para>
        /// <para>Fullname: TransformFeedbackAttribsNV</para>
        /// <para>Extensions: NV_transform_feedback</para>
        /// </summary>
        public static void TransformFeedbackAttribs(uint count, int[] attribs, int bufferMode)
        {
            if (gl._TransformFeedbackAttribs != null) gl._TransformFeedbackAttribs(count, attribs, bufferMode); else { }
        }
        /// <summary>
        /// <para>Fullname: TransformFeedbackStreamAttribsNV</para>
        /// </summary>
        [GLEntry("TransformFeedbackStreamAttribsNV", Category = "NV")]
        public static GLDelegate.TransformFeedbackStreamAttribs _TransformFeedbackStreamAttribs = null;
        /// <summary>
        /// <para>This extension provides a new mode to the GL, called transform feedback, which records vertex attributes of the primitives processed by the GL. The selected attributes are written into buffer objects, and can be written with each attribute in a separate buffer object or with all attributes interleaved into a single buffer object.  If a geometry program or shader is active, the primitives recorded are those emitted by the geometry program.  Otherwise, transform feedback captures primitives whose vertex are transformed by a vertex program or shader, or by fixed-function vertex processing.  In either case, the primitives captured are those generated prior to clipping.  Transform feedback mode is capable of capturing transformed vertex data generated by fixed-function vertex processing, outputs from assembly vertex or geometry programs, or varying variables emitted from GLSL vertex or geometry shaders. The vertex data recorded in transform feedback mode is stored into buffer objects as an ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TransformFeedbackStreamAttribs.</para>
        /// <para>Fullname: TransformFeedbackStreamAttribsNV</para>
        /// <para>Extensions: NV_transform_feedback</para>
        /// </summary>
        public static void TransformFeedbackStreamAttribs(int count, int[] attribs, int nbuffers, int[] bufstreams, int bufferMode)
        {
            if (gl._TransformFeedbackStreamAttribs != null) gl._TransformFeedbackStreamAttribs(count, attribs, nbuffers, bufstreams, bufferMode); else { }
        }
        /// <summary>
        /// <para>Fullname: TransformFeedbackVaryingsNV</para>
        /// </summary>
        [GLEntry("TransformFeedbackVaryingsNV", Category = "NV")]
        public static GLDelegate.TransformFeedbackVaryingsNV _TransformFeedbackVaryingsNV = null;
        /// <summary>
        /// <para>This extension provides a new mode to the GL, called transform feedback, which records vertex attributes of the primitives processed by the GL. The selected attributes are written into buffer objects, and can be written with each attribute in a separate buffer object or with all attributes interleaved into a single buffer object.  If a geometry program or shader is active, the primitives recorded are those emitted by the geometry program.  Otherwise, transform feedback captures primitives whose vertex are transformed by a vertex program or shader, or by fixed-function vertex processing.  In either case, the primitives captured are those generated prior to clipping.  Transform feedback mode is capable of capturing transformed vertex data generated by fixed-function vertex processing, outputs from assembly vertex or geometry programs, or varying variables emitted from GLSL vertex or geometry shaders. The vertex data recorded in transform feedback mode is stored into buffer objects as an ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TransformFeedbackVaryingsNV.</para>
        /// <para>Fullname: TransformFeedbackVaryingsNV</para>
        /// <para>Extensions: NV_transform_feedback</para>
        /// </summary>
        public static void TransformFeedbackVaryingsNV(uint program, int count, int[] locations, int bufferMode)
        {
            if (gl._TransformFeedbackVaryingsNV != null) gl._TransformFeedbackVaryingsNV(program, count, locations, bufferMode); else { }
        }
        /// <summary>
        /// <para>Fullname: TransformPathNV</para>
        /// </summary>
        [GLEntry("TransformPathNV", Category = "NV")]
        public static GLDelegate.TransformPath _TransformPath = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TransformPath.</para>
        /// <para>Fullname: TransformPathNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void TransformPath(uint resultPath, uint srcPath, int transformType, float[] transformValues)
        {
            if (gl._TransformPath != null) gl._TransformPath(resultPath, srcPath, transformType, transformValues); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform1i64NV</para>
        /// </summary>
        [GLEntry("Uniform1i64NV", Category = "NV")]
        public static GLDelegate.Uniform1i64 _Uniform1i64 = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform1i64.</para>
        /// <para>Fullname: Uniform1i64NV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void Uniform1i64(int location, long x)
        {
            if (gl._Uniform1i64 != null) gl._Uniform1i64(location, x); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform1i64vNV</para>
        /// </summary>
        [GLEntry("Uniform1i64vNV", Category = "NV")]
        public static GLDelegate.Uniform1i64v _Uniform1i64v = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform1i64v.</para>
        /// <para>Fullname: Uniform1i64vNV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void Uniform1i64v(int location, int count, long[] value)
        {
            if (gl._Uniform1i64v != null) gl._Uniform1i64v(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform1ui64NV</para>
        /// </summary>
        [GLEntry("Uniform1ui64NV", Category = "NV")]
        public static GLDelegate.Uniform1ui64 _Uniform1ui64 = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform1ui64.</para>
        /// <para>Fullname: Uniform1ui64NV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void Uniform1ui64(int location, ulong x)
        {
            if (gl._Uniform1ui64 != null) gl._Uniform1ui64(location, x); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform1ui64vNV</para>
        /// </summary>
        [GLEntry("Uniform1ui64vNV", Category = "NV")]
        public static GLDelegate.Uniform1ui64v _Uniform1ui64v = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform1ui64v.</para>
        /// <para>Fullname: Uniform1ui64vNV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void Uniform1ui64v(int location, int count, ulong[] value)
        {
            if (gl._Uniform1ui64v != null) gl._Uniform1ui64v(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform2i64NV</para>
        /// </summary>
        [GLEntry("Uniform2i64NV", Category = "NV")]
        public static GLDelegate.Uniform2i64 _Uniform2i64 = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform2i64.</para>
        /// <para>Fullname: Uniform2i64NV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void Uniform2i64(int location, long x, long y)
        {
            if (gl._Uniform2i64 != null) gl._Uniform2i64(location, x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform2i64vNV</para>
        /// </summary>
        [GLEntry("Uniform2i64vNV", Category = "NV")]
        public static GLDelegate.Uniform2i64v _Uniform2i64v = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform2i64v.</para>
        /// <para>Fullname: Uniform2i64vNV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void Uniform2i64v(int location, int count, long[] value)
        {
            if (gl._Uniform2i64v != null) gl._Uniform2i64v(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform2ui64NV</para>
        /// </summary>
        [GLEntry("Uniform2ui64NV", Category = "NV")]
        public static GLDelegate.Uniform2ui64 _Uniform2ui64 = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform2ui64.</para>
        /// <para>Fullname: Uniform2ui64NV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void Uniform2ui64(int location, ulong x, ulong y)
        {
            if (gl._Uniform2ui64 != null) gl._Uniform2ui64(location, x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform2ui64vNV</para>
        /// </summary>
        [GLEntry("Uniform2ui64vNV", Category = "NV")]
        public static GLDelegate.Uniform2ui64v _Uniform2ui64v = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform2ui64v.</para>
        /// <para>Fullname: Uniform2ui64vNV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void Uniform2ui64v(int location, int count, ulong[] value)
        {
            if (gl._Uniform2ui64v != null) gl._Uniform2ui64v(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform3i64NV</para>
        /// </summary>
        [GLEntry("Uniform3i64NV", Category = "NV")]
        public static GLDelegate.Uniform3i64 _Uniform3i64 = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform3i64.</para>
        /// <para>Fullname: Uniform3i64NV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void Uniform3i64(int location, long x, long y, long z)
        {
            if (gl._Uniform3i64 != null) gl._Uniform3i64(location, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform3i64vNV</para>
        /// </summary>
        [GLEntry("Uniform3i64vNV", Category = "NV")]
        public static GLDelegate.Uniform3i64v _Uniform3i64v = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform3i64v.</para>
        /// <para>Fullname: Uniform3i64vNV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void Uniform3i64v(int location, int count, long[] value)
        {
            if (gl._Uniform3i64v != null) gl._Uniform3i64v(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform3ui64NV</para>
        /// </summary>
        [GLEntry("Uniform3ui64NV", Category = "NV")]
        public static GLDelegate.Uniform3ui64 _Uniform3ui64 = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform3ui64.</para>
        /// <para>Fullname: Uniform3ui64NV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void Uniform3ui64(int location, ulong x, ulong y, ulong z)
        {
            if (gl._Uniform3ui64 != null) gl._Uniform3ui64(location, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform3ui64vNV</para>
        /// </summary>
        [GLEntry("Uniform3ui64vNV", Category = "NV")]
        public static GLDelegate.Uniform3ui64v _Uniform3ui64v = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform3ui64v.</para>
        /// <para>Fullname: Uniform3ui64vNV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void Uniform3ui64v(int location, int count, ulong[] value)
        {
            if (gl._Uniform3ui64v != null) gl._Uniform3ui64v(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform4i64NV</para>
        /// </summary>
        [GLEntry("Uniform4i64NV", Category = "NV")]
        public static GLDelegate.Uniform4i64 _Uniform4i64 = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform4i64.</para>
        /// <para>Fullname: Uniform4i64NV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void Uniform4i64(int location, long x, long y, long z, long w)
        {
            if (gl._Uniform4i64 != null) gl._Uniform4i64(location, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform4i64vNV</para>
        /// </summary>
        [GLEntry("Uniform4i64vNV", Category = "NV")]
        public static GLDelegate.Uniform4i64v _Uniform4i64v = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform4i64v.</para>
        /// <para>Fullname: Uniform4i64vNV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void Uniform4i64v(int location, int count, long[] value)
        {
            if (gl._Uniform4i64v != null) gl._Uniform4i64v(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform4ui64NV</para>
        /// </summary>
        [GLEntry("Uniform4ui64NV", Category = "NV")]
        public static GLDelegate.Uniform4ui64 _Uniform4ui64 = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform4ui64.</para>
        /// <para>Fullname: Uniform4ui64NV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void Uniform4ui64(int location, ulong x, ulong y, ulong z, ulong w)
        {
            if (gl._Uniform4ui64 != null) gl._Uniform4ui64(location, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniform4ui64vNV</para>
        /// </summary>
        [GLEntry("Uniform4ui64vNV", Category = "NV")]
        public static GLDelegate.Uniform4ui64v _Uniform4ui64v = null;
        /// <summary>
        /// <para>This extension provides a set of new features to the OpenGL Shading Language and related APIs to support capabilities of new GPUs.  Shaders using the new functionality provided by this extension should enable this functionality via the construct #extension GL_NV_gpu_shader5 : require     (or enable) This extension was developed concurrently with the ARB_gpu_shader5 extension, and provides a superset of the features provided there.  The features common to both extensions are documented in the ARB_gpu_shader5 specification; this document describes only the addition language features not available via ARB_gpu_shader5.  A shader that enables this extension via an #extension directive also implicitly enables the common capabilities provided by ARB_gpu_shader5. In addition to the capabilities of ARB_gpu_shader5, this extension provides a variety of new features for all shader types, including: * support for a full set of 8-, 16-, 32-, and 64-bit scalar and vector data types, including unifor...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniform4ui64v.</para>
        /// <para>Fullname: Uniform4ui64vNV</para>
        /// <para>Extensions: NV_gpu_shader5</para>
        /// </summary>
        public static void Uniform4ui64v(int location, int count, ulong[] value)
        {
            if (gl._Uniform4ui64v != null) gl._Uniform4ui64v(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformHandleui64NV</para>
        /// </summary>
        [GLEntry("UniformHandleui64NV", Category = "NV")]
        public static GLDelegate.UniformHandleui64 _UniformHandleui64 = null;
        /// <summary>
        /// <para>This extension allows OpenGL applications to access texture objects in shaders without first binding each texture to one of a limited number of texture image units.  Using this extension, an application can query an 64-bit unsigned integer texture handle for each texture that it wants to access and then use that handle directly in GLSL or assembly-based shaders.  The ability to access textures without having to bind and/or re-bind them is similar to the capability provided by the NV_shader_buffer_load extension that allows shaders to access buffer objects without binding them.  In both cases, these extensions significantly reduce the amount of API and internal GL driver overhead needed to manage resource bindings. This extension also provides similar capability for the image load, store, and atomic functionality provided by OpenGL 4.2 and the ARB_shader_image_load_store and EXT_shader_image_load_store extensions, where a texture can be accessed without first binding it to an image unit...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformHandleui64.</para>
        /// <para>Fullname: UniformHandleui64NV</para>
        /// <para>Extensions: NV_bindless_texture</para>
        /// </summary>
        public static void UniformHandleui64(int location, ulong value)
        {
            if (gl._UniformHandleui64 != null) gl._UniformHandleui64(location, value); else { }
        }
        /// <summary>
        /// <para>Fullname: UniformHandleui64vNV</para>
        /// </summary>
        [GLEntry("UniformHandleui64vNV", Category = "NV")]
        public static GLDelegate.UniformHandleui64v _UniformHandleui64v = null;
        /// <summary>
        /// <para>This extension allows OpenGL applications to access texture objects in shaders without first binding each texture to one of a limited number of texture image units.  Using this extension, an application can query an 64-bit unsigned integer texture handle for each texture that it wants to access and then use that handle directly in GLSL or assembly-based shaders.  The ability to access textures without having to bind and/or re-bind them is similar to the capability provided by the NV_shader_buffer_load extension that allows shaders to access buffer objects without binding them.  In both cases, these extensions significantly reduce the amount of API and internal GL driver overhead needed to manage resource bindings. This extension also provides similar capability for the image load, store, and atomic functionality provided by OpenGL 4.2 and the ARB_shader_image_load_store and EXT_shader_image_load_store extensions, where a texture can be accessed without first binding it to an image unit...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UniformHandleui64v.</para>
        /// <para>Fullname: UniformHandleui64vNV</para>
        /// <para>Extensions: NV_bindless_texture</para>
        /// </summary>
        public static void UniformHandleui64v(int location, int count, ulong[] value)
        {
            if (gl._UniformHandleui64v != null) gl._UniformHandleui64v(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniformui64NV</para>
        /// </summary>
        [GLEntry("Uniformui64NV", Category = "NV")]
        public static GLDelegate.Uniformui64 _Uniformui64 = null;
        /// <summary>
        /// <para>At a very coarse level, GL has evolved in a way that allows applications to replace many of the original state machine variables with blocks of user-defined data. For example, the current vertex state has been augmented by vertex buffer objects, fixed-function shading state and parameters have been replaced by shaders/programs and constant buffers, etc.. Applications switch between coarse sets of state by binding objects to the context or to other container objects (e.g. vertex array objects) instead of manipulating state variables of the context. In terms of the number of GL commands required to draw an object, modern applications are orders of magnitude more efficient than legacy applications, but this explosion of objects bound to other objects has led to a new bottleneck - pointer chasing and CPU L2 cache misses in the driver, and general L2 cache pollution. This extension provides a mechanism to read from a flat, 64-bit GPU address space from programs/shaders, to query GPU address...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniformui64.</para>
        /// <para>Fullname: Uniformui64NV</para>
        /// <para>Extensions: NV_shader_buffer_load</para>
        /// </summary>
        public static void Uniformui64(int location, ulong value)
        {
            if (gl._Uniformui64 != null) gl._Uniformui64(location, value); else { }
        }
        /// <summary>
        /// <para>Fullname: Uniformui64vNV</para>
        /// </summary>
        [GLEntry("Uniformui64vNV", Category = "NV")]
        public static GLDelegate.Uniformui64v _Uniformui64v = null;
        /// <summary>
        /// <para>At a very coarse level, GL has evolved in a way that allows applications to replace many of the original state machine variables with blocks of user-defined data. For example, the current vertex state has been augmented by vertex buffer objects, fixed-function shading state and parameters have been replaced by shaders/programs and constant buffers, etc.. Applications switch between coarse sets of state by binding objects to the context or to other container objects (e.g. vertex array objects) instead of manipulating state variables of the context. In terms of the number of GL commands required to draw an object, modern applications are orders of magnitude more efficient than legacy applications, but this explosion of objects bound to other objects has led to a new bottleneck - pointer chasing and CPU L2 cache misses in the driver, and general L2 cache pollution. This extension provides a mechanism to read from a flat, 64-bit GPU address space from programs/shaders, to query GPU address...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Uniformui64v.</para>
        /// <para>Fullname: Uniformui64vNV</para>
        /// <para>Extensions: NV_shader_buffer_load</para>
        /// </summary>
        public static void Uniformui64v(int location, int count, ulong[] value)
        {
            if (gl._Uniformui64v != null) gl._Uniformui64v(location, count, value); else { }
        }
        /// <summary>
        /// <para>Fullname: VDPAUFiniNV</para>
        /// </summary>
        [GLEntry("VDPAUFiniNV", Category = "NV")]
        public static GLDelegate.VDPAUFini _VDPAUFini = null;
        /// <summary>
        /// <para>This extension allows VDPAU video and output surfaces to be used for texturing and rendering. This allows the GL to process and display the content of video streams decoded using VDPAU. Alternatively, the GL may modify VDPAU surfaces in-place, and VDPAU may then process and/or display those surfaces itself. This allows the GL to be used to combine application user-interface elements with decoded video, implement custom video-processing algorithms, etc. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VDPAUFini.</para>
        /// <para>Fullname: VDPAUFiniNV</para>
        /// <para>Extensions: NV_vdpau_interop</para>
        /// </summary>
        public static void VDPAUFini()
        {
            if (gl._VDPAUFini != null) gl._VDPAUFini(); else { }
        }
        /// <summary>
        /// <para>Fullname: VDPAUGetSurfaceivNV</para>
        /// </summary>
        [GLEntry("VDPAUGetSurfaceivNV", Category = "NV")]
        public static GLDelegate.VDPAUGetSurfaceiv _VDPAUGetSurfaceiv = null;
        /// <summary>
        /// <para>This extension allows VDPAU video and output surfaces to be used for texturing and rendering. This allows the GL to process and display the content of video streams decoded using VDPAU. Alternatively, the GL may modify VDPAU surfaces in-place, and VDPAU may then process and/or display those surfaces itself. This allows the GL to be used to combine application user-interface elements with decoded video, implement custom video-processing algorithms, etc. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VDPAUGetSurfaceiv.</para>
        /// <para>Fullname: VDPAUGetSurfaceivNV</para>
        /// <para>Extensions: NV_vdpau_interop</para>
        /// </summary>
        public static void VDPAUGetSurfaceiv(IntPtr surface, int pname, int bufSize, int[] length, int[] values)
        {
            if (gl._VDPAUGetSurfaceiv != null) gl._VDPAUGetSurfaceiv(surface, pname, bufSize, length, values); else { }
        }
        /// <summary>
        /// <para>Fullname: VDPAUInitNV</para>
        /// </summary>
        [GLEntry("VDPAUInitNV", Category = "NV")]
        public static GLDelegate.VDPAUInit _VDPAUInit = null;
        /// <summary>
        /// <para>This extension allows VDPAU video and output surfaces to be used for texturing and rendering. This allows the GL to process and display the content of video streams decoded using VDPAU. Alternatively, the GL may modify VDPAU surfaces in-place, and VDPAU may then process and/or display those surfaces itself. This allows the GL to be used to combine application user-interface elements with decoded video, implement custom video-processing algorithms, etc. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VDPAUInit.</para>
        /// <para>Fullname: VDPAUInitNV</para>
        /// <para>Extensions: NV_vdpau_interop</para>
        /// </summary>
        public static void VDPAUInit(IntPtr vdpDevice, IntPtr getProcAddress)
        {
            if (gl._VDPAUInit != null) gl._VDPAUInit(vdpDevice, getProcAddress); else { }
        }
        /// <summary>
        /// <para>Fullname: VDPAUIsSurfaceNV</para>
        /// </summary>
        [GLEntry("VDPAUIsSurfaceNV", Category = "NV")]
        public static GLDelegate.VDPAUIsSurface _VDPAUIsSurface = null;
        /// <summary>
        /// <para>This extension allows VDPAU video and output surfaces to be used for texturing and rendering. This allows the GL to process and display the content of video streams decoded using VDPAU. Alternatively, the GL may modify VDPAU surfaces in-place, and VDPAU may then process and/or display those surfaces itself. This allows the GL to be used to combine application user-interface elements with decoded video, implement custom video-processing algorithms, etc. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VDPAUIsSurface.</para>
        /// <para>Fullname: VDPAUIsSurfaceNV</para>
        /// <para>Extensions: NV_vdpau_interop</para>
        /// </summary>
        public static void VDPAUIsSurface(IntPtr surface)
        {
            if (gl._VDPAUIsSurface != null) gl._VDPAUIsSurface(surface); else { }
        }
        /// <summary>
        /// <para>Fullname: VDPAUMapSurfacesNV</para>
        /// </summary>
        [GLEntry("VDPAUMapSurfacesNV", Category = "NV")]
        public static GLDelegate.VDPAUMapSurfaces _VDPAUMapSurfaces = null;
        /// <summary>
        /// <para>This extension allows VDPAU video and output surfaces to be used for texturing and rendering. This allows the GL to process and display the content of video streams decoded using VDPAU. Alternatively, the GL may modify VDPAU surfaces in-place, and VDPAU may then process and/or display those surfaces itself. This allows the GL to be used to combine application user-interface elements with decoded video, implement custom video-processing algorithms, etc. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VDPAUMapSurfaces.</para>
        /// <para>Fullname: VDPAUMapSurfacesNV</para>
        /// <para>Extensions: NV_vdpau_interop</para>
        /// </summary>
        public static void VDPAUMapSurfaces(int numSurfaces, IntPtr[] surfaces)
        {
            if (gl._VDPAUMapSurfaces != null) gl._VDPAUMapSurfaces(numSurfaces, surfaces); else { }
        }
        /// <summary>
        /// <para>Fullname: VDPAURegisterOutputSurfaceNV</para>
        /// </summary>
        [GLEntry("VDPAURegisterOutputSurfaceNV", Category = "NV")]
        public static GLDelegate.VDPAURegisterOutputSurface _VDPAURegisterOutputSurface = null;
        /// <summary>
        /// <para>This extension allows VDPAU video and output surfaces to be used for texturing and rendering. This allows the GL to process and display the content of video streams decoded using VDPAU. Alternatively, the GL may modify VDPAU surfaces in-place, and VDPAU may then process and/or display those surfaces itself. This allows the GL to be used to combine application user-interface elements with decoded video, implement custom video-processing algorithms, etc. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VDPAURegisterOutputSurface.</para>
        /// <para>Fullname: VDPAURegisterOutputSurfaceNV</para>
        /// <para>Extensions: NV_vdpau_interop</para>
        /// </summary>
        public static IntPtr VDPAURegisterOutputSurface(IntPtr vdpSurface, int target, int numTextureNames, uint[] textureNames)
        {
            if (gl._VDPAURegisterOutputSurface != null) return gl._VDPAURegisterOutputSurface(vdpSurface, target, numTextureNames, textureNames);
            else { return (IntPtr)0; }
        }
        /// <summary>
        /// <para>Fullname: VDPAURegisterVideoSurfaceNV</para>
        /// </summary>
        [GLEntry("VDPAURegisterVideoSurfaceNV", Category = "NV")]
        public static GLDelegate.VDPAURegisterVideoSurface _VDPAURegisterVideoSurface = null;
        /// <summary>
        /// <para>This extension allows VDPAU video and output surfaces to be used for texturing and rendering. This allows the GL to process and display the content of video streams decoded using VDPAU. Alternatively, the GL may modify VDPAU surfaces in-place, and VDPAU may then process and/or display those surfaces itself. This allows the GL to be used to combine application user-interface elements with decoded video, implement custom video-processing algorithms, etc. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VDPAURegisterVideoSurface.</para>
        /// <para>Fullname: VDPAURegisterVideoSurfaceNV</para>
        /// <para>Extensions: NV_vdpau_interop</para>
        /// </summary>
        public static IntPtr VDPAURegisterVideoSurface(IntPtr vdpSurface, int target, int numTextureNames, uint[] textureNames)
        {
            if (gl._VDPAURegisterVideoSurface != null) return gl._VDPAURegisterVideoSurface(vdpSurface, target, numTextureNames, textureNames);
            else { return (IntPtr)0; }
        }
        /// <summary>
        /// <para>Fullname: VDPAUSurfaceAccessNV</para>
        /// </summary>
        [GLEntry("VDPAUSurfaceAccessNV", Category = "NV")]
        public static GLDelegate.VDPAUSurfaceAccess _VDPAUSurfaceAccess = null;
        /// <summary>
        /// <para>This extension allows VDPAU video and output surfaces to be used for texturing and rendering. This allows the GL to process and display the content of video streams decoded using VDPAU. Alternatively, the GL may modify VDPAU surfaces in-place, and VDPAU may then process and/or display those surfaces itself. This allows the GL to be used to combine application user-interface elements with decoded video, implement custom video-processing algorithms, etc. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VDPAUSurfaceAccess.</para>
        /// <para>Fullname: VDPAUSurfaceAccessNV</para>
        /// <para>Extensions: NV_vdpau_interop</para>
        /// </summary>
        public static void VDPAUSurfaceAccess(IntPtr surface, int access)
        {
            if (gl._VDPAUSurfaceAccess != null) gl._VDPAUSurfaceAccess(surface, access); else { }
        }
        /// <summary>
        /// <para>Fullname: VDPAUUnmapSurfacesNV</para>
        /// </summary>
        [GLEntry("VDPAUUnmapSurfacesNV", Category = "NV")]
        public static GLDelegate.VDPAUUnmapSurfaces _VDPAUUnmapSurfaces = null;
        /// <summary>
        /// <para>This extension allows VDPAU video and output surfaces to be used for texturing and rendering. This allows the GL to process and display the content of video streams decoded using VDPAU. Alternatively, the GL may modify VDPAU surfaces in-place, and VDPAU may then process and/or display those surfaces itself. This allows the GL to be used to combine application user-interface elements with decoded video, implement custom video-processing algorithms, etc. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VDPAUUnmapSurfaces.</para>
        /// <para>Fullname: VDPAUUnmapSurfacesNV</para>
        /// <para>Extensions: NV_vdpau_interop</para>
        /// </summary>
        public static void VDPAUUnmapSurfaces(int numSurface, IntPtr[] surfaces)
        {
            if (gl._VDPAUUnmapSurfaces != null) gl._VDPAUUnmapSurfaces(numSurface, surfaces); else { }
        }
        /// <summary>
        /// <para>Fullname: VDPAUUnregisterSurfaceNV</para>
        /// </summary>
        [GLEntry("VDPAUUnregisterSurfaceNV", Category = "NV")]
        public static GLDelegate.VDPAUUnregisterSurface _VDPAUUnregisterSurface = null;
        /// <summary>
        /// <para>This extension allows VDPAU video and output surfaces to be used for texturing and rendering. This allows the GL to process and display the content of video streams decoded using VDPAU. Alternatively, the GL may modify VDPAU surfaces in-place, and VDPAU may then process and/or display those surfaces itself. This allows the GL to be used to combine application user-interface elements with decoded video, implement custom video-processing algorithms, etc. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VDPAUUnregisterSurface.</para>
        /// <para>Fullname: VDPAUUnregisterSurfaceNV</para>
        /// <para>Extensions: NV_vdpau_interop</para>
        /// </summary>
        public static void VDPAUUnregisterSurface(IntPtr surface)
        {
            if (gl._VDPAUUnregisterSurface != null) gl._VDPAUUnregisterSurface(surface); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex2hNV</para>
        /// </summary>
        [GLEntry("Vertex2hNV", Category = "NV")]
        public static GLDelegate.Vertex2h _Vertex2h = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex2h.</para>
        /// <para>Fullname: Vertex2hNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void Vertex2h(ushort x, ushort y)
        {
            if (gl._Vertex2h != null) gl._Vertex2h(x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex2hvNV</para>
        /// </summary>
        [GLEntry("Vertex2hvNV", Category = "NV")]
        public static GLDelegate.Vertex2hv _Vertex2hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex2hv.</para>
        /// <para>Fullname: Vertex2hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void Vertex2hv(ushort[] v)
        {
            if (gl._Vertex2hv != null) gl._Vertex2hv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex3hNV</para>
        /// </summary>
        [GLEntry("Vertex3hNV", Category = "NV")]
        public static GLDelegate.Vertex3h _Vertex3h = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex3h.</para>
        /// <para>Fullname: Vertex3hNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void Vertex3h(ushort x, ushort y, ushort z)
        {
            if (gl._Vertex3h != null) gl._Vertex3h(x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex3hvNV</para>
        /// </summary>
        [GLEntry("Vertex3hvNV", Category = "NV")]
        public static GLDelegate.Vertex3hv _Vertex3hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex3hv.</para>
        /// <para>Fullname: Vertex3hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void Vertex3hv(ushort[] v)
        {
            if (gl._Vertex3hv != null) gl._Vertex3hv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex4hNV</para>
        /// </summary>
        [GLEntry("Vertex4hNV", Category = "NV")]
        public static GLDelegate.Vertex4h _Vertex4h = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex4h.</para>
        /// <para>Fullname: Vertex4hNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void Vertex4h(ushort x, ushort y, ushort z, ushort w)
        {
            if (gl._Vertex4h != null) gl._Vertex4h(x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: Vertex4hvNV</para>
        /// </summary>
        [GLEntry("Vertex4hvNV", Category = "NV")]
        public static GLDelegate.Vertex4hv _Vertex4hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _Vertex4hv.</para>
        /// <para>Fullname: Vertex4hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void Vertex4hv(ushort[] v)
        {
            if (gl._Vertex4hv != null) gl._Vertex4hv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexArrayRangeNV</para>
        /// </summary>
        [GLEntry("VertexArrayRangeNV", Category = "NV", Alias = "VertexArrayRangeAPPLE ")]
        public static GLDelegate.VertexArrayRange _VertexArrayRange = null;
        public static GLDelegate.VertexArrayRange VertexArrayRangeAPPLE = VertexArrayRange;
        /// <summary>
        /// <para>The goal of this extension is to permit extremely high vertex processing rates via OpenGL vertex arrays even when the CPU lacks the necessary data movement bandwidth to keep up with the rate at which the vertex engine can consume vertices.  CPUs can keep up if they can just pass vertex indices to the hardware and let the hardware "pull" the actual vertex data via Direct Memory Access (DMA).  Unfortunately, the current OpenGL 1.1 vertex array functionality has semantic constraints that make such an approach hard.  Hence, the vertex array range extension. This extension provides a mechanism for deferring the pulling of vertex array elements to facilitate DMAed pulling of vertices for fast, efficient vertex array transfers.  The OpenGL client need only pass vertex indices to the hardware which can DMA the actual index's vertex data directly out of the client address space. The OpenGL 1.1 vertex array functionality specifies a fairly strict coherency model for when OpenGL extracts vertex d...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexArrayRange.</para>
        /// <para>Fullname: VertexArrayRangeNV</para>
        /// <para>Aliases: VertexArrayRangeAPPLE, </para>
        /// <para>Extensions: NV_vertex_array_range APPLE_vertex_array_range</para>
        /// </summary>
        public static void VertexArrayRange(int length, IntPtr pointer)
        {
            if (gl._VertexArrayRange != null) gl._VertexArrayRange(length, pointer); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib1hNV</para>
        /// </summary>
        [GLEntry("VertexAttrib1hNV", Category = "NV")]
        public static GLDelegate.VertexAttrib1h _VertexAttrib1h = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib1h.</para>
        /// <para>Fullname: VertexAttrib1hNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void VertexAttrib1h(uint index, ushort x)
        {
            if (gl._VertexAttrib1h != null) gl._VertexAttrib1h(index, x); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib1hvNV</para>
        /// </summary>
        [GLEntry("VertexAttrib1hvNV", Category = "NV")]
        public static GLDelegate.VertexAttrib1hv _VertexAttrib1hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib1hv.</para>
        /// <para>Fullname: VertexAttrib1hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void VertexAttrib1hv(uint index, ushort[] v)
        {
            if (gl._VertexAttrib1hv != null) gl._VertexAttrib1hv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib2hNV</para>
        /// </summary>
        [GLEntry("VertexAttrib2hNV", Category = "NV")]
        public static GLDelegate.VertexAttrib2h _VertexAttrib2h = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib2h.</para>
        /// <para>Fullname: VertexAttrib2hNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void VertexAttrib2h(uint index, ushort x, ushort y)
        {
            if (gl._VertexAttrib2h != null) gl._VertexAttrib2h(index, x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib2hvNV</para>
        /// </summary>
        [GLEntry("VertexAttrib2hvNV", Category = "NV")]
        public static GLDelegate.VertexAttrib2hv _VertexAttrib2hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib2hv.</para>
        /// <para>Fullname: VertexAttrib2hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void VertexAttrib2hv(uint index, ushort[] v)
        {
            if (gl._VertexAttrib2hv != null) gl._VertexAttrib2hv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib3hNV</para>
        /// </summary>
        [GLEntry("VertexAttrib3hNV", Category = "NV")]
        public static GLDelegate.VertexAttrib3h _VertexAttrib3h = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib3h.</para>
        /// <para>Fullname: VertexAttrib3hNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void VertexAttrib3h(uint index, ushort x, ushort y, ushort z)
        {
            if (gl._VertexAttrib3h != null) gl._VertexAttrib3h(index, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib3hvNV</para>
        /// </summary>
        [GLEntry("VertexAttrib3hvNV", Category = "NV")]
        public static GLDelegate.VertexAttrib3hv _VertexAttrib3hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib3hv.</para>
        /// <para>Fullname: VertexAttrib3hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void VertexAttrib3hv(uint index, ushort[] v)
        {
            if (gl._VertexAttrib3hv != null) gl._VertexAttrib3hv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4hNV</para>
        /// </summary>
        [GLEntry("VertexAttrib4hNV", Category = "NV")]
        public static GLDelegate.VertexAttrib4h _VertexAttrib4h = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4h.</para>
        /// <para>Fullname: VertexAttrib4hNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void VertexAttrib4h(uint index, ushort x, ushort y, ushort z, ushort w)
        {
            if (gl._VertexAttrib4h != null) gl._VertexAttrib4h(index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4hvNV</para>
        /// </summary>
        [GLEntry("VertexAttrib4hvNV", Category = "NV")]
        public static GLDelegate.VertexAttrib4hv _VertexAttrib4hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4hv.</para>
        /// <para>Fullname: VertexAttrib4hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void VertexAttrib4hv(uint index, ushort[] v)
        {
            if (gl._VertexAttrib4hv != null) gl._VertexAttrib4hv(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttrib4ubNV</para>
        /// </summary>
        [GLEntry("VertexAttrib4ubNV", Category = "NV")]
        public static GLDelegate.VertexAttrib4ub _VertexAttrib4ub = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttrib4ub.</para>
        /// <para>Fullname: VertexAttrib4ubNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void VertexAttrib4ub(uint index, byte x, byte y, byte z, byte w)
        {
            if (gl._VertexAttrib4ub != null) gl._VertexAttrib4ub(index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribFormatNV</para>
        /// </summary>
        [GLEntry("VertexAttribFormatNV", Category = "NV")]
        public static GLDelegate.VertexAttribFormatNV _VertexAttribFormatNV = null;
        /// <summary>
        /// <para>This extension provides a mechanism to specify vertex attrib and element array locations using GPU addresses. Binding vertex buffers is one of the most frequent and expensive operations in many GL applications, due to the cost of chasing pointers and binding objects described in the Overview of NV_shader_buffer_load. The intent of this extension is to enable a way for the application to specify vertex attrib state that alleviates the overhead of object binds and driver memory management. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribFormatNV.</para>
        /// <para>Fullname: VertexAttribFormatNV</para>
        /// <para>Extensions: NV_vertex_buffer_unified_memory</para>
        /// </summary>
        public static void VertexAttribFormatNV(uint index, int size, int type, bool normalized, int stride)
        {
            if (gl._VertexAttribFormatNV != null) gl._VertexAttribFormatNV(index, size, type, normalized, stride); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribIFormatNV</para>
        /// </summary>
        [GLEntry("VertexAttribIFormatNV", Category = "NV")]
        public static GLDelegate.VertexAttribIFormatNV _VertexAttribIFormatNV = null;
        /// <summary>
        /// <para>This extension provides a mechanism to specify vertex attrib and element array locations using GPU addresses. Binding vertex buffers is one of the most frequent and expensive operations in many GL applications, due to the cost of chasing pointers and binding objects described in the Overview of NV_shader_buffer_load. The intent of this extension is to enable a way for the application to specify vertex attrib state that alleviates the overhead of object binds and driver memory management. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribIFormatNV.</para>
        /// <para>Fullname: VertexAttribIFormatNV</para>
        /// <para>Extensions: NV_vertex_buffer_unified_memory</para>
        /// </summary>
        public static void VertexAttribIFormatNV(uint index, int size, int type, int stride)
        {
            if (gl._VertexAttribIFormatNV != null) gl._VertexAttribIFormatNV(index, size, type, stride); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL1i64NV</para>
        /// </summary>
        [GLEntry("VertexAttribL1i64NV", Category = "NV")]
        public static GLDelegate.VertexAttribL1i64 _VertexAttribL1i64 = null;
        /// <summary>
        /// <para>This extension provides support for specifying vertex attributes with 64-bit integer components, analagous to the 64-bit floating point support added in EXT_vertex_attrib_64bit. Additionally, it provides the VertexAttribLFormatNV entry point to specify bindless vertex attribute arrays with 64-bit integer or floating-point components in conjunction with the NV_vertex_buffer_unified_memory extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL1i64.</para>
        /// <para>Fullname: VertexAttribL1i64NV</para>
        /// <para>Extensions: NV_vertex_attrib_integer_64bit</para>
        /// </summary>
        public static void VertexAttribL1i64(uint index, long x)
        {
            if (gl._VertexAttribL1i64 != null) gl._VertexAttribL1i64(index, x); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL1i64vNV</para>
        /// </summary>
        [GLEntry("VertexAttribL1i64vNV", Category = "NV")]
        public static GLDelegate.VertexAttribL1i64v _VertexAttribL1i64v = null;
        /// <summary>
        /// <para>This extension provides support for specifying vertex attributes with 64-bit integer components, analagous to the 64-bit floating point support added in EXT_vertex_attrib_64bit. Additionally, it provides the VertexAttribLFormatNV entry point to specify bindless vertex attribute arrays with 64-bit integer or floating-point components in conjunction with the NV_vertex_buffer_unified_memory extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL1i64v.</para>
        /// <para>Fullname: VertexAttribL1i64vNV</para>
        /// <para>Extensions: NV_vertex_attrib_integer_64bit</para>
        /// </summary>
        public static void VertexAttribL1i64v(uint index, long[] v)
        {
            if (gl._VertexAttribL1i64v != null) gl._VertexAttribL1i64v(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL1ui64NV</para>
        /// </summary>
        [GLEntry("VertexAttribL1ui64NV", Category = "NV")]
        public static GLDelegate.VertexAttribL1ui64 _VertexAttribL1ui64 = null;
        /// <summary>
        /// <para>This extension provides support for specifying vertex attributes with 64-bit integer components, analagous to the 64-bit floating point support added in EXT_vertex_attrib_64bit. Additionally, it provides the VertexAttribLFormatNV entry point to specify bindless vertex attribute arrays with 64-bit integer or floating-point components in conjunction with the NV_vertex_buffer_unified_memory extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL1ui64.</para>
        /// <para>Fullname: VertexAttribL1ui64NV</para>
        /// <para>Extensions: NV_vertex_attrib_integer_64bit</para>
        /// </summary>
        public static void VertexAttribL1ui64(uint index, ulong x)
        {
            if (gl._VertexAttribL1ui64 != null) gl._VertexAttribL1ui64(index, x); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL1ui64vNV</para>
        /// </summary>
        [GLEntry("VertexAttribL1ui64vNV", Category = "NV")]
        public static GLDelegate.VertexAttribL1ui64v _VertexAttribL1ui64v = null;
        /// <summary>
        /// <para>This extension provides support for specifying vertex attributes with 64-bit integer components, analagous to the 64-bit floating point support added in EXT_vertex_attrib_64bit. Additionally, it provides the VertexAttribLFormatNV entry point to specify bindless vertex attribute arrays with 64-bit integer or floating-point components in conjunction with the NV_vertex_buffer_unified_memory extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL1ui64v.</para>
        /// <para>Fullname: VertexAttribL1ui64vNV</para>
        /// <para>Extensions: NV_vertex_attrib_integer_64bit</para>
        /// </summary>
        public static void VertexAttribL1ui64v(uint index, ulong[] v)
        {
            if (gl._VertexAttribL1ui64v != null) gl._VertexAttribL1ui64v(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL2i64NV</para>
        /// </summary>
        [GLEntry("VertexAttribL2i64NV", Category = "NV")]
        public static GLDelegate.VertexAttribL2i64 _VertexAttribL2i64 = null;
        /// <summary>
        /// <para>This extension provides support for specifying vertex attributes with 64-bit integer components, analagous to the 64-bit floating point support added in EXT_vertex_attrib_64bit. Additionally, it provides the VertexAttribLFormatNV entry point to specify bindless vertex attribute arrays with 64-bit integer or floating-point components in conjunction with the NV_vertex_buffer_unified_memory extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL2i64.</para>
        /// <para>Fullname: VertexAttribL2i64NV</para>
        /// <para>Extensions: NV_vertex_attrib_integer_64bit</para>
        /// </summary>
        public static void VertexAttribL2i64(uint index, long x, long y)
        {
            if (gl._VertexAttribL2i64 != null) gl._VertexAttribL2i64(index, x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL2i64vNV</para>
        /// </summary>
        [GLEntry("VertexAttribL2i64vNV", Category = "NV")]
        public static GLDelegate.VertexAttribL2i64v _VertexAttribL2i64v = null;
        /// <summary>
        /// <para>This extension provides support for specifying vertex attributes with 64-bit integer components, analagous to the 64-bit floating point support added in EXT_vertex_attrib_64bit. Additionally, it provides the VertexAttribLFormatNV entry point to specify bindless vertex attribute arrays with 64-bit integer or floating-point components in conjunction with the NV_vertex_buffer_unified_memory extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL2i64v.</para>
        /// <para>Fullname: VertexAttribL2i64vNV</para>
        /// <para>Extensions: NV_vertex_attrib_integer_64bit</para>
        /// </summary>
        public static void VertexAttribL2i64v(uint index, long[] v)
        {
            if (gl._VertexAttribL2i64v != null) gl._VertexAttribL2i64v(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL2ui64NV</para>
        /// </summary>
        [GLEntry("VertexAttribL2ui64NV", Category = "NV")]
        public static GLDelegate.VertexAttribL2ui64 _VertexAttribL2ui64 = null;
        /// <summary>
        /// <para>This extension provides support for specifying vertex attributes with 64-bit integer components, analagous to the 64-bit floating point support added in EXT_vertex_attrib_64bit. Additionally, it provides the VertexAttribLFormatNV entry point to specify bindless vertex attribute arrays with 64-bit integer or floating-point components in conjunction with the NV_vertex_buffer_unified_memory extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL2ui64.</para>
        /// <para>Fullname: VertexAttribL2ui64NV</para>
        /// <para>Extensions: NV_vertex_attrib_integer_64bit</para>
        /// </summary>
        public static void VertexAttribL2ui64(uint index, ulong x, ulong y)
        {
            if (gl._VertexAttribL2ui64 != null) gl._VertexAttribL2ui64(index, x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL2ui64vNV</para>
        /// </summary>
        [GLEntry("VertexAttribL2ui64vNV", Category = "NV")]
        public static GLDelegate.VertexAttribL2ui64v _VertexAttribL2ui64v = null;
        /// <summary>
        /// <para>This extension provides support for specifying vertex attributes with 64-bit integer components, analagous to the 64-bit floating point support added in EXT_vertex_attrib_64bit. Additionally, it provides the VertexAttribLFormatNV entry point to specify bindless vertex attribute arrays with 64-bit integer or floating-point components in conjunction with the NV_vertex_buffer_unified_memory extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL2ui64v.</para>
        /// <para>Fullname: VertexAttribL2ui64vNV</para>
        /// <para>Extensions: NV_vertex_attrib_integer_64bit</para>
        /// </summary>
        public static void VertexAttribL2ui64v(uint index, ulong[] v)
        {
            if (gl._VertexAttribL2ui64v != null) gl._VertexAttribL2ui64v(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL3i64NV</para>
        /// </summary>
        [GLEntry("VertexAttribL3i64NV", Category = "NV")]
        public static GLDelegate.VertexAttribL3i64 _VertexAttribL3i64 = null;
        /// <summary>
        /// <para>This extension provides support for specifying vertex attributes with 64-bit integer components, analagous to the 64-bit floating point support added in EXT_vertex_attrib_64bit. Additionally, it provides the VertexAttribLFormatNV entry point to specify bindless vertex attribute arrays with 64-bit integer or floating-point components in conjunction with the NV_vertex_buffer_unified_memory extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL3i64.</para>
        /// <para>Fullname: VertexAttribL3i64NV</para>
        /// <para>Extensions: NV_vertex_attrib_integer_64bit</para>
        /// </summary>
        public static void VertexAttribL3i64(uint index, long x, long y, long z)
        {
            if (gl._VertexAttribL3i64 != null) gl._VertexAttribL3i64(index, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL3i64vNV</para>
        /// </summary>
        [GLEntry("VertexAttribL3i64vNV", Category = "NV")]
        public static GLDelegate.VertexAttribL3i64v _VertexAttribL3i64v = null;
        /// <summary>
        /// <para>This extension provides support for specifying vertex attributes with 64-bit integer components, analagous to the 64-bit floating point support added in EXT_vertex_attrib_64bit. Additionally, it provides the VertexAttribLFormatNV entry point to specify bindless vertex attribute arrays with 64-bit integer or floating-point components in conjunction with the NV_vertex_buffer_unified_memory extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL3i64v.</para>
        /// <para>Fullname: VertexAttribL3i64vNV</para>
        /// <para>Extensions: NV_vertex_attrib_integer_64bit</para>
        /// </summary>
        public static void VertexAttribL3i64v(uint index, long[] v)
        {
            if (gl._VertexAttribL3i64v != null) gl._VertexAttribL3i64v(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL3ui64NV</para>
        /// </summary>
        [GLEntry("VertexAttribL3ui64NV", Category = "NV")]
        public static GLDelegate.VertexAttribL3ui64 _VertexAttribL3ui64 = null;
        /// <summary>
        /// <para>This extension provides support for specifying vertex attributes with 64-bit integer components, analagous to the 64-bit floating point support added in EXT_vertex_attrib_64bit. Additionally, it provides the VertexAttribLFormatNV entry point to specify bindless vertex attribute arrays with 64-bit integer or floating-point components in conjunction with the NV_vertex_buffer_unified_memory extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL3ui64.</para>
        /// <para>Fullname: VertexAttribL3ui64NV</para>
        /// <para>Extensions: NV_vertex_attrib_integer_64bit</para>
        /// </summary>
        public static void VertexAttribL3ui64(uint index, ulong x, ulong y, ulong z)
        {
            if (gl._VertexAttribL3ui64 != null) gl._VertexAttribL3ui64(index, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL3ui64vNV</para>
        /// </summary>
        [GLEntry("VertexAttribL3ui64vNV", Category = "NV")]
        public static GLDelegate.VertexAttribL3ui64v _VertexAttribL3ui64v = null;
        /// <summary>
        /// <para>This extension provides support for specifying vertex attributes with 64-bit integer components, analagous to the 64-bit floating point support added in EXT_vertex_attrib_64bit. Additionally, it provides the VertexAttribLFormatNV entry point to specify bindless vertex attribute arrays with 64-bit integer or floating-point components in conjunction with the NV_vertex_buffer_unified_memory extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL3ui64v.</para>
        /// <para>Fullname: VertexAttribL3ui64vNV</para>
        /// <para>Extensions: NV_vertex_attrib_integer_64bit</para>
        /// </summary>
        public static void VertexAttribL3ui64v(uint index, ulong[] v)
        {
            if (gl._VertexAttribL3ui64v != null) gl._VertexAttribL3ui64v(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL4i64NV</para>
        /// </summary>
        [GLEntry("VertexAttribL4i64NV", Category = "NV")]
        public static GLDelegate.VertexAttribL4i64 _VertexAttribL4i64 = null;
        /// <summary>
        /// <para>This extension provides support for specifying vertex attributes with 64-bit integer components, analagous to the 64-bit floating point support added in EXT_vertex_attrib_64bit. Additionally, it provides the VertexAttribLFormatNV entry point to specify bindless vertex attribute arrays with 64-bit integer or floating-point components in conjunction with the NV_vertex_buffer_unified_memory extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL4i64.</para>
        /// <para>Fullname: VertexAttribL4i64NV</para>
        /// <para>Extensions: NV_vertex_attrib_integer_64bit</para>
        /// </summary>
        public static void VertexAttribL4i64(uint index, long x, long y, long z, long w)
        {
            if (gl._VertexAttribL4i64 != null) gl._VertexAttribL4i64(index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL4i64vNV</para>
        /// </summary>
        [GLEntry("VertexAttribL4i64vNV", Category = "NV")]
        public static GLDelegate.VertexAttribL4i64v _VertexAttribL4i64v = null;
        /// <summary>
        /// <para>This extension provides support for specifying vertex attributes with 64-bit integer components, analagous to the 64-bit floating point support added in EXT_vertex_attrib_64bit. Additionally, it provides the VertexAttribLFormatNV entry point to specify bindless vertex attribute arrays with 64-bit integer or floating-point components in conjunction with the NV_vertex_buffer_unified_memory extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL4i64v.</para>
        /// <para>Fullname: VertexAttribL4i64vNV</para>
        /// <para>Extensions: NV_vertex_attrib_integer_64bit</para>
        /// </summary>
        public static void VertexAttribL4i64v(uint index, long[] v)
        {
            if (gl._VertexAttribL4i64v != null) gl._VertexAttribL4i64v(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL4ui64NV</para>
        /// </summary>
        [GLEntry("VertexAttribL4ui64NV", Category = "NV")]
        public static GLDelegate.VertexAttribL4ui64 _VertexAttribL4ui64 = null;
        /// <summary>
        /// <para>This extension provides support for specifying vertex attributes with 64-bit integer components, analagous to the 64-bit floating point support added in EXT_vertex_attrib_64bit. Additionally, it provides the VertexAttribLFormatNV entry point to specify bindless vertex attribute arrays with 64-bit integer or floating-point components in conjunction with the NV_vertex_buffer_unified_memory extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL4ui64.</para>
        /// <para>Fullname: VertexAttribL4ui64NV</para>
        /// <para>Extensions: NV_vertex_attrib_integer_64bit</para>
        /// </summary>
        public static void VertexAttribL4ui64(uint index, ulong x, ulong y, ulong z, ulong w)
        {
            if (gl._VertexAttribL4ui64 != null) gl._VertexAttribL4ui64(index, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribL4ui64vNV</para>
        /// </summary>
        [GLEntry("VertexAttribL4ui64vNV", Category = "NV")]
        public static GLDelegate.VertexAttribL4ui64v _VertexAttribL4ui64v = null;
        /// <summary>
        /// <para>This extension provides support for specifying vertex attributes with 64-bit integer components, analagous to the 64-bit floating point support added in EXT_vertex_attrib_64bit. Additionally, it provides the VertexAttribLFormatNV entry point to specify bindless vertex attribute arrays with 64-bit integer or floating-point components in conjunction with the NV_vertex_buffer_unified_memory extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribL4ui64v.</para>
        /// <para>Fullname: VertexAttribL4ui64vNV</para>
        /// <para>Extensions: NV_vertex_attrib_integer_64bit</para>
        /// </summary>
        public static void VertexAttribL4ui64v(uint index, ulong[] v)
        {
            if (gl._VertexAttribL4ui64v != null) gl._VertexAttribL4ui64v(index, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribLFormatNV</para>
        /// </summary>
        [GLEntry("VertexAttribLFormatNV", Category = "NV")]
        public static GLDelegate.VertexAttribLFormatNV _VertexAttribLFormatNV = null;
        /// <summary>
        /// <para>This extension provides support for specifying vertex attributes with 64-bit integer components, analagous to the 64-bit floating point support added in EXT_vertex_attrib_64bit. Additionally, it provides the VertexAttribLFormatNV entry point to specify bindless vertex attribute arrays with 64-bit integer or floating-point components in conjunction with the NV_vertex_buffer_unified_memory extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribLFormatNV.</para>
        /// <para>Fullname: VertexAttribLFormatNV</para>
        /// <para>Extensions: NV_vertex_attrib_integer_64bit</para>
        /// </summary>
        public static void VertexAttribLFormatNV(uint index, int size, int type, int stride)
        {
            if (gl._VertexAttribLFormatNV != null) gl._VertexAttribLFormatNV(index, size, type, stride); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribPointerNV</para>
        /// </summary>
        [GLEntry("VertexAttribPointerNV", Category = "NV")]
        public static GLDelegate.VertexAttribPointerNV _VertexAttribPointerNV = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribPointerNV.</para>
        /// <para>Fullname: VertexAttribPointerNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void VertexAttribPointerNV(uint index, int fsize, int type, int stride, IntPtr pointer)
        {
            if (gl._VertexAttribPointerNV != null) gl._VertexAttribPointerNV(index, fsize, type, stride, pointer); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribs1dvNV</para>
        /// </summary>
        [GLEntry("VertexAttribs1dvNV", Category = "NV")]
        public static GLDelegate.VertexAttribs1dv _VertexAttribs1dv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribs1dv.</para>
        /// <para>Fullname: VertexAttribs1dvNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void VertexAttribs1dv(uint index, int count, double[] v)
        {
            if (gl._VertexAttribs1dv != null) gl._VertexAttribs1dv(index, count, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribs1fvNV</para>
        /// </summary>
        [GLEntry("VertexAttribs1fvNV", Category = "NV")]
        public static GLDelegate.VertexAttribs1fv _VertexAttribs1fv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribs1fv.</para>
        /// <para>Fullname: VertexAttribs1fvNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void VertexAttribs1fv(uint index, int count, float[] v)
        {
            if (gl._VertexAttribs1fv != null) gl._VertexAttribs1fv(index, count, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribs1hvNV</para>
        /// </summary>
        [GLEntry("VertexAttribs1hvNV", Category = "NV")]
        public static GLDelegate.VertexAttribs1hv _VertexAttribs1hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribs1hv.</para>
        /// <para>Fullname: VertexAttribs1hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void VertexAttribs1hv(uint index, int n, ushort[] v)
        {
            if (gl._VertexAttribs1hv != null) gl._VertexAttribs1hv(index, n, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribs1svNV</para>
        /// </summary>
        [GLEntry("VertexAttribs1svNV", Category = "NV")]
        public static GLDelegate.VertexAttribs1sv _VertexAttribs1sv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribs1sv.</para>
        /// <para>Fullname: VertexAttribs1svNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void VertexAttribs1sv(uint index, int count, short[] v)
        {
            if (gl._VertexAttribs1sv != null) gl._VertexAttribs1sv(index, count, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribs2dvNV</para>
        /// </summary>
        [GLEntry("VertexAttribs2dvNV", Category = "NV")]
        public static GLDelegate.VertexAttribs2dv _VertexAttribs2dv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribs2dv.</para>
        /// <para>Fullname: VertexAttribs2dvNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void VertexAttribs2dv(uint index, int count, double[] v)
        {
            if (gl._VertexAttribs2dv != null) gl._VertexAttribs2dv(index, count, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribs2fvNV</para>
        /// </summary>
        [GLEntry("VertexAttribs2fvNV", Category = "NV")]
        public static GLDelegate.VertexAttribs2fv _VertexAttribs2fv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribs2fv.</para>
        /// <para>Fullname: VertexAttribs2fvNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void VertexAttribs2fv(uint index, int count, float[] v)
        {
            if (gl._VertexAttribs2fv != null) gl._VertexAttribs2fv(index, count, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribs2hvNV</para>
        /// </summary>
        [GLEntry("VertexAttribs2hvNV", Category = "NV")]
        public static GLDelegate.VertexAttribs2hv _VertexAttribs2hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribs2hv.</para>
        /// <para>Fullname: VertexAttribs2hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void VertexAttribs2hv(uint index, int n, ushort[] v)
        {
            if (gl._VertexAttribs2hv != null) gl._VertexAttribs2hv(index, n, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribs2svNV</para>
        /// </summary>
        [GLEntry("VertexAttribs2svNV", Category = "NV")]
        public static GLDelegate.VertexAttribs2sv _VertexAttribs2sv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribs2sv.</para>
        /// <para>Fullname: VertexAttribs2svNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void VertexAttribs2sv(uint index, int count, short[] v)
        {
            if (gl._VertexAttribs2sv != null) gl._VertexAttribs2sv(index, count, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribs3dvNV</para>
        /// </summary>
        [GLEntry("VertexAttribs3dvNV", Category = "NV")]
        public static GLDelegate.VertexAttribs3dv _VertexAttribs3dv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribs3dv.</para>
        /// <para>Fullname: VertexAttribs3dvNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void VertexAttribs3dv(uint index, int count, double[] v)
        {
            if (gl._VertexAttribs3dv != null) gl._VertexAttribs3dv(index, count, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribs3fvNV</para>
        /// </summary>
        [GLEntry("VertexAttribs3fvNV", Category = "NV")]
        public static GLDelegate.VertexAttribs3fv _VertexAttribs3fv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribs3fv.</para>
        /// <para>Fullname: VertexAttribs3fvNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void VertexAttribs3fv(uint index, int count, float[] v)
        {
            if (gl._VertexAttribs3fv != null) gl._VertexAttribs3fv(index, count, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribs3hvNV</para>
        /// </summary>
        [GLEntry("VertexAttribs3hvNV", Category = "NV")]
        public static GLDelegate.VertexAttribs3hv _VertexAttribs3hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribs3hv.</para>
        /// <para>Fullname: VertexAttribs3hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void VertexAttribs3hv(uint index, int n, ushort[] v)
        {
            if (gl._VertexAttribs3hv != null) gl._VertexAttribs3hv(index, n, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribs3svNV</para>
        /// </summary>
        [GLEntry("VertexAttribs3svNV", Category = "NV")]
        public static GLDelegate.VertexAttribs3sv _VertexAttribs3sv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribs3sv.</para>
        /// <para>Fullname: VertexAttribs3svNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void VertexAttribs3sv(uint index, int count, short[] v)
        {
            if (gl._VertexAttribs3sv != null) gl._VertexAttribs3sv(index, count, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribs4dvNV</para>
        /// </summary>
        [GLEntry("VertexAttribs4dvNV", Category = "NV")]
        public static GLDelegate.VertexAttribs4dv _VertexAttribs4dv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribs4dv.</para>
        /// <para>Fullname: VertexAttribs4dvNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void VertexAttribs4dv(uint index, int count, double[] v)
        {
            if (gl._VertexAttribs4dv != null) gl._VertexAttribs4dv(index, count, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribs4fvNV</para>
        /// </summary>
        [GLEntry("VertexAttribs4fvNV", Category = "NV")]
        public static GLDelegate.VertexAttribs4fv _VertexAttribs4fv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribs4fv.</para>
        /// <para>Fullname: VertexAttribs4fvNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void VertexAttribs4fv(uint index, int count, float[] v)
        {
            if (gl._VertexAttribs4fv != null) gl._VertexAttribs4fv(index, count, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribs4hvNV</para>
        /// </summary>
        [GLEntry("VertexAttribs4hvNV", Category = "NV")]
        public static GLDelegate.VertexAttribs4hv _VertexAttribs4hv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribs4hv.</para>
        /// <para>Fullname: VertexAttribs4hvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void VertexAttribs4hv(uint index, int n, ushort[] v)
        {
            if (gl._VertexAttribs4hv != null) gl._VertexAttribs4hv(index, n, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribs4svNV</para>
        /// </summary>
        [GLEntry("VertexAttribs4svNV", Category = "NV")]
        public static GLDelegate.VertexAttribs4sv _VertexAttribs4sv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribs4sv.</para>
        /// <para>Fullname: VertexAttribs4svNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void VertexAttribs4sv(uint index, int count, short[] v)
        {
            if (gl._VertexAttribs4sv != null) gl._VertexAttribs4sv(index, count, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribs4ubvNV</para>
        /// </summary>
        [GLEntry("VertexAttribs4ubvNV", Category = "NV")]
        public static GLDelegate.VertexAttribs4ubv _VertexAttribs4ubv = null;
        /// <summary>
        /// <para>Unextended OpenGL mandates a certain set of configurable per-vertex computations defining vertex transformation, texture coordinate generation and transformation, and lighting.  Several extensions have added further per-vertex computations to OpenGL.  For example, extensions have defined new texture coordinate generation modes (ARB_texture_cube_map, NV_texgen_reflection, NV_texgen_emboss), new vertex transformation modes (EXT_vertex_weighting), new lighting modes (OpenGL 1.2's separate specular and rescale normal functionality), several modes for fog distance generation (NV_fog_distance), and eye-distance point size attenuation (EXT_point_parameters). Each such extension adds a small set of relatively inflexible per-vertex computations. This inflexibility is in contrast to the typical flexibility provided by the underlying programmable floating point engines (whether micro-coded vertex engines, DSPs, or CPUs) that are traditionally used to implement OpenGL's per-vertex computations.  T...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribs4ubv.</para>
        /// <para>Fullname: VertexAttribs4ubvNV</para>
        /// <para>Extensions: NV_vertex_program</para>
        /// </summary>
        public static void VertexAttribs4ubv(uint index, int count, byte[] v)
        {
            if (gl._VertexAttribs4ubv != null) gl._VertexAttribs4ubv(index, count, v); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexFormatNV</para>
        /// </summary>
        [GLEntry("VertexFormatNV", Category = "NV")]
        public static GLDelegate.VertexFormat _VertexFormat = null;
        /// <summary>
        /// <para>This extension provides a mechanism to specify vertex attrib and element array locations using GPU addresses. Binding vertex buffers is one of the most frequent and expensive operations in many GL applications, due to the cost of chasing pointers and binding objects described in the Overview of NV_shader_buffer_load. The intent of this extension is to enable a way for the application to specify vertex attrib state that alleviates the overhead of object binds and driver memory management. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexFormat.</para>
        /// <para>Fullname: VertexFormatNV</para>
        /// <para>Extensions: NV_vertex_buffer_unified_memory</para>
        /// </summary>
        public static void VertexFormat(int size, int type, int stride)
        {
            if (gl._VertexFormat != null) gl._VertexFormat(size, type, stride); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexWeighthNV</para>
        /// </summary>
        [GLEntry("VertexWeighthNV", Category = "NV")]
        public static GLDelegate.VertexWeighth _VertexWeighth = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexWeighth.</para>
        /// <para>Fullname: VertexWeighthNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void VertexWeighth(ushort weight)
        {
            if (gl._VertexWeighth != null) gl._VertexWeighth(weight); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexWeighthvNV</para>
        /// </summary>
        [GLEntry("VertexWeighthvNV", Category = "NV")]
        public static GLDelegate.VertexWeighthv _VertexWeighthv = null;
        /// <summary>
        /// <para>This extension introduces a new storage format and data type for half-precision (16-bit) floating-point quantities.  The floating-point format is very similar to the IEEE single-precision floating-point standard, except that it has only 5 exponent bits and 10 mantissa bits. Half-precision floats are smaller than full precision floats and provide a larger dynamic range than similarly-sized normalized scalar data types. This extension allows applications to use half-precision floating point data when specifying vertices or pixel data.  It adds new commands to specify vertex attributes using the new data type, and extends the existing vertex array and image specification commands to accept the new data type. This storage format is also used to represent 16-bit components in the floating-point frame buffers, as defined in the NV_float_buffer extension. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexWeighthv.</para>
        /// <para>Fullname: VertexWeighthvNV</para>
        /// <para>Extensions: NV_half_float</para>
        /// </summary>
        public static void VertexWeighthv(ushort[] weight)
        {
            if (gl._VertexWeighthv != null) gl._VertexWeighthv(weight); else { }
        }
        /// <summary>
        /// <para>Fullname: VideoCaptureNV</para>
        /// </summary>
        [GLEntry("VideoCaptureNV", Category = "NV")]
        public static GLDelegate.VideoCapture _VideoCapture = null;
        /// <summary>
        /// <para>This extension provides a mechanism for streaming video data directly into texture objects and buffer objects.  Applications can then display video streams in interactive 3D scenes and/or manipulate the video data using the GL's image processing capabilities. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VideoCapture.</para>
        /// <para>Fullname: VideoCaptureNV</para>
        /// <para>Extensions: NV_video_capture</para>
        /// </summary>
        public static int VideoCapture(uint video_capture_slot, uint[] sequence_num, ulong[] capture_time)
        {
            if (gl._VideoCapture != null) return gl._VideoCapture(video_capture_slot, sequence_num, capture_time);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: VideoCaptureStreamParameterdvNV</para>
        /// </summary>
        [GLEntry("VideoCaptureStreamParameterdvNV", Category = "NV")]
        public static GLDelegate.VideoCaptureStreamParameterdv _VideoCaptureStreamParameterdv = null;
        /// <summary>
        /// <para>This extension provides a mechanism for streaming video data directly into texture objects and buffer objects.  Applications can then display video streams in interactive 3D scenes and/or manipulate the video data using the GL's image processing capabilities. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VideoCaptureStreamParameterdv.</para>
        /// <para>Fullname: VideoCaptureStreamParameterdvNV</para>
        /// <para>Extensions: NV_video_capture</para>
        /// </summary>
        public static void VideoCaptureStreamParameterdv(uint video_capture_slot, uint stream, int pname, double[] param)
        {
            if (gl._VideoCaptureStreamParameterdv != null) gl._VideoCaptureStreamParameterdv(video_capture_slot, stream, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: VideoCaptureStreamParameterfvNV</para>
        /// </summary>
        [GLEntry("VideoCaptureStreamParameterfvNV", Category = "NV")]
        public static GLDelegate.VideoCaptureStreamParameterfv _VideoCaptureStreamParameterfv = null;
        /// <summary>
        /// <para>This extension provides a mechanism for streaming video data directly into texture objects and buffer objects.  Applications can then display video streams in interactive 3D scenes and/or manipulate the video data using the GL's image processing capabilities. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VideoCaptureStreamParameterfv.</para>
        /// <para>Fullname: VideoCaptureStreamParameterfvNV</para>
        /// <para>Extensions: NV_video_capture</para>
        /// </summary>
        public static void VideoCaptureStreamParameterfv(uint video_capture_slot, uint stream, int pname, float[] param)
        {
            if (gl._VideoCaptureStreamParameterfv != null) gl._VideoCaptureStreamParameterfv(video_capture_slot, stream, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: VideoCaptureStreamParameterivNV</para>
        /// </summary>
        [GLEntry("VideoCaptureStreamParameterivNV", Category = "NV")]
        public static GLDelegate.VideoCaptureStreamParameteriv _VideoCaptureStreamParameteriv = null;
        /// <summary>
        /// <para>This extension provides a mechanism for streaming video data directly into texture objects and buffer objects.  Applications can then display video streams in interactive 3D scenes and/or manipulate the video data using the GL's image processing capabilities. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VideoCaptureStreamParameteriv.</para>
        /// <para>Fullname: VideoCaptureStreamParameterivNV</para>
        /// <para>Extensions: NV_video_capture</para>
        /// </summary>
        public static void VideoCaptureStreamParameteriv(uint video_capture_slot, uint stream, int pname, int[] param)
        {
            if (gl._VideoCaptureStreamParameteriv != null) gl._VideoCaptureStreamParameteriv(video_capture_slot, stream, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: WeightPathsNV</para>
        /// </summary>
        [GLEntry("WeightPathsNV", Category = "NV")]
        public static GLDelegate.WeightPaths _WeightPaths = null;
        /// <summary>
        /// <para>Conventional OpenGL supports rendering images (pixel rectangles and bitmaps) and simple geometric primitives (points, lines, polygons). This extension adds a new rendering paradigm, known as path rendering, for rendering filled and stroked paths.  Path rendering is not novel but rather a standard part of most resolution-independent 2D rendering systems such as Flash, PDF, Silverlight, SVG, Java 2D, Office drawings, TrueType fonts, PostScript and its fonts, Quartz 2D, XML Paper Specification (XPS), and OpenVG.  What is novel is the ability to mix path rendering with arbitrary OpenGL 3D rendering and imaging. With this extension, path rendering becomes a first-class rendering mode within the OpenGL graphics system that can be arbitrarily mixed with existing OpenGL rendering and can take advantage of OpenGL's existing mechanisms for texturing, programmability, and per-fragment operations. Unlike geometric primitive rendering, paths are specified on a 2D (non-projective) plane rather than ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WeightPaths.</para>
        /// <para>Fullname: WeightPathsNV</para>
        /// <para>Extensions: NV_path_rendering</para>
        /// </summary>
        public static void WeightPaths(uint resultPath, int numPaths, uint[] paths, float[] weights)
        {
            if (gl._WeightPaths != null) gl._WeightPaths(resultPath, numPaths, paths, weights); else { }
        }
        /// <summary>
        /// <para>Fullname: ResizeBuffersMESA</para>
        /// </summary>
        [GLEntry("ResizeBuffersMESA", Category = "MESA")]
        public static GLDelegate.ResizeBuffers _ResizeBuffers = null;
        /// <summary>
        /// <para>Mesa is often used as a client library with no integration with the computer's window system (an X server, for example).  And since Mesa does not have an event loop nor window system callbacks, it cannot properly respond to window system events.  In particular, Mesa cannot automatically detect when a window has been resized. Mesa's glViewport command queries the current window size and updates its internal data structors accordingly.  This normally works fine since most applications call glViewport in responce to window size changes. In some situations, however, the application may not call glViewport when a window size changes but would still like Mesa to adjust to the new window size.  This extension exports a new function to solve this problem. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ResizeBuffers.</para>
        /// <para>Fullname: ResizeBuffersMESA</para>
        /// <para>Extensions: MESA_resize_buffers</para>
        /// </summary>
        public static void ResizeBuffers()
        {
            if (gl._ResizeBuffers != null) gl._ResizeBuffers(); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos4dMESA</para>
        /// </summary>
        [GLEntry("WindowPos4dMESA", Category = "MESA")]
        public static GLDelegate.WindowPos4d _WindowPos4d = null;
        /// <summary>
        /// <para>In order to set the current raster position to a specific window coordinate with the RasterPos command, the modelview matrix, projection matrix and viewport must be set very carefully.  Furthermore, if the desired window coordinate is outside of the window's bounds one must rely on a subtle side-effect of the Bitmap command in order to circumvent frustum clipping. This extension provides a set of functions to directly set the current raster position, bypassing the modelview matrix, the projection matrix and the viewport to window mapping.  Furthermore, clip testing is not performed. This greatly simplifies the process of setting the current raster position to a specific window coordinate prior to calling DrawPixels, CopyPixels or Bitmap. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos4d.</para>
        /// <para>Fullname: WindowPos4dMESA</para>
        /// <para>Extensions: MESA_window_pos</para>
        /// </summary>
        public static void WindowPos4d(double x, double y, double z, double w)
        {
            if (gl._WindowPos4d != null) gl._WindowPos4d(x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos4dvMESA</para>
        /// </summary>
        [GLEntry("WindowPos4dvMESA", Category = "MESA")]
        public static GLDelegate.WindowPos4dv _WindowPos4dv = null;
        /// <summary>
        /// <para>In order to set the current raster position to a specific window coordinate with the RasterPos command, the modelview matrix, projection matrix and viewport must be set very carefully.  Furthermore, if the desired window coordinate is outside of the window's bounds one must rely on a subtle side-effect of the Bitmap command in order to circumvent frustum clipping. This extension provides a set of functions to directly set the current raster position, bypassing the modelview matrix, the projection matrix and the viewport to window mapping.  Furthermore, clip testing is not performed. This greatly simplifies the process of setting the current raster position to a specific window coordinate prior to calling DrawPixels, CopyPixels or Bitmap. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos4dv.</para>
        /// <para>Fullname: WindowPos4dvMESA</para>
        /// <para>Extensions: MESA_window_pos</para>
        /// </summary>
        public static void WindowPos4dv(double[] v)
        {
            if (gl._WindowPos4dv != null) gl._WindowPos4dv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos4fMESA</para>
        /// </summary>
        [GLEntry("WindowPos4fMESA", Category = "MESA")]
        public static GLDelegate.WindowPos4f _WindowPos4f = null;
        /// <summary>
        /// <para>In order to set the current raster position to a specific window coordinate with the RasterPos command, the modelview matrix, projection matrix and viewport must be set very carefully.  Furthermore, if the desired window coordinate is outside of the window's bounds one must rely on a subtle side-effect of the Bitmap command in order to circumvent frustum clipping. This extension provides a set of functions to directly set the current raster position, bypassing the modelview matrix, the projection matrix and the viewport to window mapping.  Furthermore, clip testing is not performed. This greatly simplifies the process of setting the current raster position to a specific window coordinate prior to calling DrawPixels, CopyPixels or Bitmap. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos4f.</para>
        /// <para>Fullname: WindowPos4fMESA</para>
        /// <para>Extensions: MESA_window_pos</para>
        /// </summary>
        public static void WindowPos4f(float x, float y, float z, float w)
        {
            if (gl._WindowPos4f != null) gl._WindowPos4f(x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos4fvMESA</para>
        /// </summary>
        [GLEntry("WindowPos4fvMESA", Category = "MESA")]
        public static GLDelegate.WindowPos4fv _WindowPos4fv = null;
        /// <summary>
        /// <para>In order to set the current raster position to a specific window coordinate with the RasterPos command, the modelview matrix, projection matrix and viewport must be set very carefully.  Furthermore, if the desired window coordinate is outside of the window's bounds one must rely on a subtle side-effect of the Bitmap command in order to circumvent frustum clipping. This extension provides a set of functions to directly set the current raster position, bypassing the modelview matrix, the projection matrix and the viewport to window mapping.  Furthermore, clip testing is not performed. This greatly simplifies the process of setting the current raster position to a specific window coordinate prior to calling DrawPixels, CopyPixels or Bitmap. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos4fv.</para>
        /// <para>Fullname: WindowPos4fvMESA</para>
        /// <para>Extensions: MESA_window_pos</para>
        /// </summary>
        public static void WindowPos4fv(float[] v)
        {
            if (gl._WindowPos4fv != null) gl._WindowPos4fv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos4iMESA</para>
        /// </summary>
        [GLEntry("WindowPos4iMESA", Category = "MESA")]
        public static GLDelegate.WindowPos4i _WindowPos4i = null;
        /// <summary>
        /// <para>In order to set the current raster position to a specific window coordinate with the RasterPos command, the modelview matrix, projection matrix and viewport must be set very carefully.  Furthermore, if the desired window coordinate is outside of the window's bounds one must rely on a subtle side-effect of the Bitmap command in order to circumvent frustum clipping. This extension provides a set of functions to directly set the current raster position, bypassing the modelview matrix, the projection matrix and the viewport to window mapping.  Furthermore, clip testing is not performed. This greatly simplifies the process of setting the current raster position to a specific window coordinate prior to calling DrawPixels, CopyPixels or Bitmap. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos4i.</para>
        /// <para>Fullname: WindowPos4iMESA</para>
        /// <para>Extensions: MESA_window_pos</para>
        /// </summary>
        public static void WindowPos4i(int x, int y, int z, int w)
        {
            if (gl._WindowPos4i != null) gl._WindowPos4i(x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos4ivMESA</para>
        /// </summary>
        [GLEntry("WindowPos4ivMESA", Category = "MESA")]
        public static GLDelegate.WindowPos4iv _WindowPos4iv = null;
        /// <summary>
        /// <para>In order to set the current raster position to a specific window coordinate with the RasterPos command, the modelview matrix, projection matrix and viewport must be set very carefully.  Furthermore, if the desired window coordinate is outside of the window's bounds one must rely on a subtle side-effect of the Bitmap command in order to circumvent frustum clipping. This extension provides a set of functions to directly set the current raster position, bypassing the modelview matrix, the projection matrix and the viewport to window mapping.  Furthermore, clip testing is not performed. This greatly simplifies the process of setting the current raster position to a specific window coordinate prior to calling DrawPixels, CopyPixels or Bitmap. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos4iv.</para>
        /// <para>Fullname: WindowPos4ivMESA</para>
        /// <para>Extensions: MESA_window_pos</para>
        /// </summary>
        public static void WindowPos4iv(int[] v)
        {
            if (gl._WindowPos4iv != null) gl._WindowPos4iv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos4sMESA</para>
        /// </summary>
        [GLEntry("WindowPos4sMESA", Category = "MESA")]
        public static GLDelegate.WindowPos4s _WindowPos4s = null;
        /// <summary>
        /// <para>In order to set the current raster position to a specific window coordinate with the RasterPos command, the modelview matrix, projection matrix and viewport must be set very carefully.  Furthermore, if the desired window coordinate is outside of the window's bounds one must rely on a subtle side-effect of the Bitmap command in order to circumvent frustum clipping. This extension provides a set of functions to directly set the current raster position, bypassing the modelview matrix, the projection matrix and the viewport to window mapping.  Furthermore, clip testing is not performed. This greatly simplifies the process of setting the current raster position to a specific window coordinate prior to calling DrawPixels, CopyPixels or Bitmap. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos4s.</para>
        /// <para>Fullname: WindowPos4sMESA</para>
        /// <para>Extensions: MESA_window_pos</para>
        /// </summary>
        public static void WindowPos4s(short x, short y, short z, short w)
        {
            if (gl._WindowPos4s != null) gl._WindowPos4s(x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: WindowPos4svMESA</para>
        /// </summary>
        [GLEntry("WindowPos4svMESA", Category = "MESA")]
        public static GLDelegate.WindowPos4sv _WindowPos4sv = null;
        /// <summary>
        /// <para>In order to set the current raster position to a specific window coordinate with the RasterPos command, the modelview matrix, projection matrix and viewport must be set very carefully.  Furthermore, if the desired window coordinate is outside of the window's bounds one must rely on a subtle side-effect of the Bitmap command in order to circumvent frustum clipping. This extension provides a set of functions to directly set the current raster position, bypassing the modelview matrix, the projection matrix and the viewport to window mapping.  Furthermore, clip testing is not performed. This greatly simplifies the process of setting the current raster position to a specific window coordinate prior to calling DrawPixels, CopyPixels or Bitmap. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _WindowPos4sv.</para>
        /// <para>Fullname: WindowPos4svMESA</para>
        /// <para>Extensions: MESA_window_pos</para>
        /// </summary>
        public static void WindowPos4sv(short[] v)
        {
            if (gl._WindowPos4sv != null) gl._WindowPos4sv(v); else { }
        }
        /// <summary>
        /// <para>Fullname: ColorPointerListIBM</para>
        /// </summary>
        [GLEntry("ColorPointerListIBM", Category = "IBM")]
        public static GLDelegate.ColorPointerList _ColorPointerList = null;
        /// <summary>
        /// <para>This extension introduces seven (7) new functions that set the vertex array pointers. However, instead of a single pointer, these functions provide a list of array pointers that can be used by the EXT_multi_draw_arrays and IBM_multimode_draw_arrays extension functions to draw from multiple of vertex arrays. The first primitive will use the first array in the list, the second primitive will use the second array in the list, and so forth. If a glDrawArray, DrawElements, or DrawRangeElements function is used, then only the first vertex array in the list is used. When a vertex array list is specified, only the list pointer is kept by the underlying OpenGL function. Therefore, the list must be staticly defined for the entire duration of its usage, much in the same manner as the vertex arrays themselves. Also note that the list function can therefore also be used to change array pointers without making a OpenGL API function call. A <ptrstride> value of zero (0) can be used to force all primi...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorPointerList.</para>
        /// <para>Fullname: ColorPointerListIBM</para>
        /// <para>Extensions: IBM_vertex_array_lists</para>
        /// </summary>
        public static void ColorPointerList(int size, int type, int stride, IntPtr pointer, int ptrstride)
        {
            if (gl._ColorPointerList != null) gl._ColorPointerList(size, type, stride, pointer, ptrstride); else { }
        }
        /// <summary>
        /// <para>Fullname: EdgeFlagPointerListIBM</para>
        /// </summary>
        [GLEntry("EdgeFlagPointerListIBM", Category = "IBM")]
        public static GLDelegate.EdgeFlagPointerList _EdgeFlagPointerList = null;
        /// <summary>
        /// <para>This extension introduces seven (7) new functions that set the vertex array pointers. However, instead of a single pointer, these functions provide a list of array pointers that can be used by the EXT_multi_draw_arrays and IBM_multimode_draw_arrays extension functions to draw from multiple of vertex arrays. The first primitive will use the first array in the list, the second primitive will use the second array in the list, and so forth. If a glDrawArray, DrawElements, or DrawRangeElements function is used, then only the first vertex array in the list is used. When a vertex array list is specified, only the list pointer is kept by the underlying OpenGL function. Therefore, the list must be staticly defined for the entire duration of its usage, much in the same manner as the vertex arrays themselves. Also note that the list function can therefore also be used to change array pointers without making a OpenGL API function call. A <ptrstride> value of zero (0) can be used to force all primi...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EdgeFlagPointerList.</para>
        /// <para>Fullname: EdgeFlagPointerListIBM</para>
        /// <para>Extensions: IBM_vertex_array_lists</para>
        /// </summary>
        public static void EdgeFlagPointerList(int stride, IntPtr pointer, int ptrstride)
        {
            if (gl._EdgeFlagPointerList != null) gl._EdgeFlagPointerList(stride, pointer, ptrstride); else { }
        }
        /// <summary>
        /// <para>Fullname: FogCoordPointerListIBM</para>
        /// </summary>
        [GLEntry("FogCoordPointerListIBM", Category = "IBM")]
        public static GLDelegate.FogCoordPointerList _FogCoordPointerList = null;
        /// <summary>
        /// <para>This extension introduces seven (7) new functions that set the vertex array pointers. However, instead of a single pointer, these functions provide a list of array pointers that can be used by the EXT_multi_draw_arrays and IBM_multimode_draw_arrays extension functions to draw from multiple of vertex arrays. The first primitive will use the first array in the list, the second primitive will use the second array in the list, and so forth. If a glDrawArray, DrawElements, or DrawRangeElements function is used, then only the first vertex array in the list is used. When a vertex array list is specified, only the list pointer is kept by the underlying OpenGL function. Therefore, the list must be staticly defined for the entire duration of its usage, much in the same manner as the vertex arrays themselves. Also note that the list function can therefore also be used to change array pointers without making a OpenGL API function call. A <ptrstride> value of zero (0) can be used to force all primi...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FogCoordPointerList.</para>
        /// <para>Fullname: FogCoordPointerListIBM</para>
        /// <para>Extensions: IBM_vertex_array_lists</para>
        /// </summary>
        public static void FogCoordPointerList(int type, int stride, IntPtr pointer, int ptrstride)
        {
            if (gl._FogCoordPointerList != null) gl._FogCoordPointerList(type, stride, pointer, ptrstride); else { }
        }
        /// <summary>
        /// <para>Fullname: IndexPointerListIBM</para>
        /// </summary>
        [GLEntry("IndexPointerListIBM", Category = "IBM")]
        public static GLDelegate.IndexPointerList _IndexPointerList = null;
        /// <summary>
        /// <para>This extension introduces seven (7) new functions that set the vertex array pointers. However, instead of a single pointer, these functions provide a list of array pointers that can be used by the EXT_multi_draw_arrays and IBM_multimode_draw_arrays extension functions to draw from multiple of vertex arrays. The first primitive will use the first array in the list, the second primitive will use the second array in the list, and so forth. If a glDrawArray, DrawElements, or DrawRangeElements function is used, then only the first vertex array in the list is used. When a vertex array list is specified, only the list pointer is kept by the underlying OpenGL function. Therefore, the list must be staticly defined for the entire duration of its usage, much in the same manner as the vertex arrays themselves. Also note that the list function can therefore also be used to change array pointers without making a OpenGL API function call. A <ptrstride> value of zero (0) can be used to force all primi...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IndexPointerList.</para>
        /// <para>Fullname: IndexPointerListIBM</para>
        /// <para>Extensions: IBM_vertex_array_lists</para>
        /// </summary>
        public static void IndexPointerList(int type, int stride, IntPtr pointer, int ptrstride)
        {
            if (gl._IndexPointerList != null) gl._IndexPointerList(type, stride, pointer, ptrstride); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiModeDrawArraysIBM</para>
        /// </summary>
        [GLEntry("MultiModeDrawArraysIBM", Category = "IBM")]
        public static GLDelegate.MultiModeDrawArrays _MultiModeDrawArrays = null;
        /// <summary>
        /// <para>These functions behave identically to the standard OpenGL 1.1 functions glDrawArrays() and glDrawElements() except they handle multiple lists of vertices and multiple primitive modes in one call. Their main purpose is to allow one function call to render more than one primitive regardless of the primitive mode. This extension is similar to the EXT_multi_draw_arrays extension except that it accomodates the specification of a  unique mode for each primitive. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiModeDrawArrays.</para>
        /// <para>Fullname: MultiModeDrawArraysIBM</para>
        /// <para>Extensions: IBM_multimode_draw_arrays</para>
        /// </summary>
        public static void MultiModeDrawArrays(int[] mode, int[] first, int[] count, int primcount, int modestride)
        {
            if (gl._MultiModeDrawArrays != null) gl._MultiModeDrawArrays(mode, first, count, primcount, modestride); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiModeDrawElementsIBM</para>
        /// </summary>
        [GLEntry("MultiModeDrawElementsIBM", Category = "IBM")]
        public static GLDelegate.MultiModeDrawElements _MultiModeDrawElements = null;
        /// <summary>
        /// <para>These functions behave identically to the standard OpenGL 1.1 functions glDrawArrays() and glDrawElements() except they handle multiple lists of vertices and multiple primitive modes in one call. Their main purpose is to allow one function call to render more than one primitive regardless of the primitive mode. This extension is similar to the EXT_multi_draw_arrays extension except that it accomodates the specification of a  unique mode for each primitive. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiModeDrawElements.</para>
        /// <para>Fullname: MultiModeDrawElementsIBM</para>
        /// <para>Extensions: IBM_multimode_draw_arrays</para>
        /// </summary>
        public static void MultiModeDrawElements(int[] mode, int[] count, int type, IntPtr indices, int primcount, int modestride)
        {
            if (gl._MultiModeDrawElements != null) gl._MultiModeDrawElements(mode, count, type, indices, primcount, modestride); else { }
        }
        /// <summary>
        /// <para>Fullname: NormalPointerListIBM</para>
        /// </summary>
        [GLEntry("NormalPointerListIBM", Category = "IBM")]
        public static GLDelegate.NormalPointerList _NormalPointerList = null;
        /// <summary>
        /// <para>This extension introduces seven (7) new functions that set the vertex array pointers. However, instead of a single pointer, these functions provide a list of array pointers that can be used by the EXT_multi_draw_arrays and IBM_multimode_draw_arrays extension functions to draw from multiple of vertex arrays. The first primitive will use the first array in the list, the second primitive will use the second array in the list, and so forth. If a glDrawArray, DrawElements, or DrawRangeElements function is used, then only the first vertex array in the list is used. When a vertex array list is specified, only the list pointer is kept by the underlying OpenGL function. Therefore, the list must be staticly defined for the entire duration of its usage, much in the same manner as the vertex arrays themselves. Also note that the list function can therefore also be used to change array pointers without making a OpenGL API function call. A <ptrstride> value of zero (0) can be used to force all primi...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NormalPointerList.</para>
        /// <para>Fullname: NormalPointerListIBM</para>
        /// <para>Extensions: IBM_vertex_array_lists</para>
        /// </summary>
        public static void NormalPointerList(int type, int stride, IntPtr pointer, int ptrstride)
        {
            if (gl._NormalPointerList != null) gl._NormalPointerList(type, stride, pointer, ptrstride); else { }
        }
        /// <summary>
        /// <para>Fullname: SecondaryColorPointerListIBM</para>
        /// </summary>
        [GLEntry("SecondaryColorPointerListIBM", Category = "IBM")]
        public static GLDelegate.SecondaryColorPointerList _SecondaryColorPointerList = null;
        /// <summary>
        /// <para>This extension introduces seven (7) new functions that set the vertex array pointers. However, instead of a single pointer, these functions provide a list of array pointers that can be used by the EXT_multi_draw_arrays and IBM_multimode_draw_arrays extension functions to draw from multiple of vertex arrays. The first primitive will use the first array in the list, the second primitive will use the second array in the list, and so forth. If a glDrawArray, DrawElements, or DrawRangeElements function is used, then only the first vertex array in the list is used. When a vertex array list is specified, only the list pointer is kept by the underlying OpenGL function. Therefore, the list must be staticly defined for the entire duration of its usage, much in the same manner as the vertex arrays themselves. Also note that the list function can therefore also be used to change array pointers without making a OpenGL API function call. A <ptrstride> value of zero (0) can be used to force all primi...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SecondaryColorPointerList.</para>
        /// <para>Fullname: SecondaryColorPointerListIBM</para>
        /// <para>Extensions: IBM_vertex_array_lists</para>
        /// </summary>
        public static void SecondaryColorPointerList(int size, int type, int stride, IntPtr pointer, int ptrstride)
        {
            if (gl._SecondaryColorPointerList != null) gl._SecondaryColorPointerList(size, type, stride, pointer, ptrstride); else { }
        }
        /// <summary>
        /// <para>Fullname: TexCoordPointerListIBM</para>
        /// </summary>
        [GLEntry("TexCoordPointerListIBM", Category = "IBM")]
        public static GLDelegate.TexCoordPointerList _TexCoordPointerList = null;
        /// <summary>
        /// <para>This extension introduces seven (7) new functions that set the vertex array pointers. However, instead of a single pointer, these functions provide a list of array pointers that can be used by the EXT_multi_draw_arrays and IBM_multimode_draw_arrays extension functions to draw from multiple of vertex arrays. The first primitive will use the first array in the list, the second primitive will use the second array in the list, and so forth. If a glDrawArray, DrawElements, or DrawRangeElements function is used, then only the first vertex array in the list is used. When a vertex array list is specified, only the list pointer is kept by the underlying OpenGL function. Therefore, the list must be staticly defined for the entire duration of its usage, much in the same manner as the vertex arrays themselves. Also note that the list function can therefore also be used to change array pointers without making a OpenGL API function call. A <ptrstride> value of zero (0) can be used to force all primi...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexCoordPointerList.</para>
        /// <para>Fullname: TexCoordPointerListIBM</para>
        /// <para>Extensions: IBM_vertex_array_lists</para>
        /// </summary>
        public static void TexCoordPointerList(int size, int type, int stride, IntPtr pointer, int ptrstride)
        {
            if (gl._TexCoordPointerList != null) gl._TexCoordPointerList(size, type, stride, pointer, ptrstride); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexPointerListIBM</para>
        /// </summary>
        [GLEntry("VertexPointerListIBM", Category = "IBM")]
        public static GLDelegate.VertexPointerList _VertexPointerList = null;
        /// <summary>
        /// <para>This extension introduces seven (7) new functions that set the vertex array pointers. However, instead of a single pointer, these functions provide a list of array pointers that can be used by the EXT_multi_draw_arrays and IBM_multimode_draw_arrays extension functions to draw from multiple of vertex arrays. The first primitive will use the first array in the list, the second primitive will use the second array in the list, and so forth. If a glDrawArray, DrawElements, or DrawRangeElements function is used, then only the first vertex array in the list is used. When a vertex array list is specified, only the list pointer is kept by the underlying OpenGL function. Therefore, the list must be staticly defined for the entire duration of its usage, much in the same manner as the vertex arrays themselves. Also note that the list function can therefore also be used to change array pointers without making a OpenGL API function call. A <ptrstride> value of zero (0) can be used to force all primi...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexPointerList.</para>
        /// <para>Fullname: VertexPointerListIBM</para>
        /// <para>Extensions: IBM_vertex_array_lists</para>
        /// </summary>
        public static void VertexPointerList(int size, int type, int stride, IntPtr pointer, int ptrstride)
        {
            if (gl._VertexPointerList != null) gl._VertexPointerList(size, type, stride, pointer, ptrstride); else { }
        }
        /// <summary>
        /// <para>Fullname: TbufferMask3DFX</para>
        /// </summary>
        [GLEntry("TbufferMask3DFX", Category = "3DFX")]
        public static GLDelegate.TbufferMask _TbufferMask = null;
        /// <summary>
        /// <para>This extension allows a write mask to be defined for the fragment mask which is created during multisample rendering. This can be used to create effects such as motion blur and depth of field. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TbufferMask.</para>
        /// <para>Fullname: TbufferMask3DFX</para>
        /// <para>Extensions: 3DFX_tbuffer</para>
        /// </summary>
        public static void TbufferMask(uint mask)
        {
            if (gl._TbufferMask != null) gl._TbufferMask(mask); else { }
        }
        /// <summary>
        /// <para>Fullname: AlphaFragmentOp1ATI</para>
        /// </summary>
        [GLEntry("AlphaFragmentOp1ATI", Category = "ATI")]
        public static GLDelegate.AlphaFragmentOp1 _AlphaFragmentOp1 = null;
        /// <summary>
        /// <para>This extension exposes a powerful fragment shading model which provides a very general means of expressing fragment color blending and dependent texture address modification.  The programming is a register-based model in which there is a fixed number of instructions, texture lookups, read/write registers, and constants. The fragment shader extension provides a unified instruction set for operating on address or color data and eliminates the distinction between the two.  This extension provides all the interfaces necessary to fully expose this programmable fragment shader in GL. Although conceived as a device-independent extension which would expose the capabilities of future generations of hardware, changing trends in programmable hardware have affected the lifespan of this extension.  For this reason you will now find a fixed set of features and resources exposed, and the queries to determine this set have been deprecated. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _AlphaFragmentOp1.</para>
        /// <para>Fullname: AlphaFragmentOp1ATI</para>
        /// <para>Extensions: ATI_fragment_shader</para>
        /// </summary>
        public static void AlphaFragmentOp1(int op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod)
        {
            if (gl._AlphaFragmentOp1 != null) gl._AlphaFragmentOp1(op, dst, dstMod, arg1, arg1Rep, arg1Mod); else { }
        }
        /// <summary>
        /// <para>Fullname: AlphaFragmentOp2ATI</para>
        /// </summary>
        [GLEntry("AlphaFragmentOp2ATI", Category = "ATI")]
        public static GLDelegate.AlphaFragmentOp2 _AlphaFragmentOp2 = null;
        /// <summary>
        /// <para>This extension exposes a powerful fragment shading model which provides a very general means of expressing fragment color blending and dependent texture address modification.  The programming is a register-based model in which there is a fixed number of instructions, texture lookups, read/write registers, and constants. The fragment shader extension provides a unified instruction set for operating on address or color data and eliminates the distinction between the two.  This extension provides all the interfaces necessary to fully expose this programmable fragment shader in GL. Although conceived as a device-independent extension which would expose the capabilities of future generations of hardware, changing trends in programmable hardware have affected the lifespan of this extension.  For this reason you will now find a fixed set of features and resources exposed, and the queries to determine this set have been deprecated. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _AlphaFragmentOp2.</para>
        /// <para>Fullname: AlphaFragmentOp2ATI</para>
        /// <para>Extensions: ATI_fragment_shader</para>
        /// </summary>
        public static void AlphaFragmentOp2(int op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod)
        {
            if (gl._AlphaFragmentOp2 != null) gl._AlphaFragmentOp2(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod); else { }
        }
        /// <summary>
        /// <para>Fullname: AlphaFragmentOp3ATI</para>
        /// </summary>
        [GLEntry("AlphaFragmentOp3ATI", Category = "ATI")]
        public static GLDelegate.AlphaFragmentOp3 _AlphaFragmentOp3 = null;
        /// <summary>
        /// <para>This extension exposes a powerful fragment shading model which provides a very general means of expressing fragment color blending and dependent texture address modification.  The programming is a register-based model in which there is a fixed number of instructions, texture lookups, read/write registers, and constants. The fragment shader extension provides a unified instruction set for operating on address or color data and eliminates the distinction between the two.  This extension provides all the interfaces necessary to fully expose this programmable fragment shader in GL. Although conceived as a device-independent extension which would expose the capabilities of future generations of hardware, changing trends in programmable hardware have affected the lifespan of this extension.  For this reason you will now find a fixed set of features and resources exposed, and the queries to determine this set have been deprecated. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _AlphaFragmentOp3.</para>
        /// <para>Fullname: AlphaFragmentOp3ATI</para>
        /// <para>Extensions: ATI_fragment_shader</para>
        /// </summary>
        public static void AlphaFragmentOp3(int op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod, uint arg3, uint arg3Rep, uint arg3Mod)
        {
            if (gl._AlphaFragmentOp3 != null) gl._AlphaFragmentOp3(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod); else { }
        }
        /// <summary>
        /// <para>Fullname: ArrayObjectATI</para>
        /// </summary>
        [GLEntry("ArrayObjectATI", Category = "ATI")]
        public static GLDelegate.ArrayObject _ArrayObject = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of vertex array data to be cached in persistent server-side memory. It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ArrayObject.</para>
        /// <para>Fullname: ArrayObjectATI</para>
        /// <para>Extensions: ATI_vertex_array_object</para>
        /// </summary>
        public static void ArrayObject(int array, int size, int type, int stride, uint buffer, uint offset)
        {
            if (gl._ArrayObject != null) gl._ArrayObject(array, size, type, stride, buffer, offset); else { }
        }
        /// <summary>
        /// <para>Fullname: BeginFragmentShaderATI</para>
        /// </summary>
        [GLEntry("BeginFragmentShaderATI", Category = "ATI")]
        public static GLDelegate.BeginFragmentShader _BeginFragmentShader = null;
        /// <summary>
        /// <para>This extension exposes a powerful fragment shading model which provides a very general means of expressing fragment color blending and dependent texture address modification.  The programming is a register-based model in which there is a fixed number of instructions, texture lookups, read/write registers, and constants. The fragment shader extension provides a unified instruction set for operating on address or color data and eliminates the distinction between the two.  This extension provides all the interfaces necessary to fully expose this programmable fragment shader in GL. Although conceived as a device-independent extension which would expose the capabilities of future generations of hardware, changing trends in programmable hardware have affected the lifespan of this extension.  For this reason you will now find a fixed set of features and resources exposed, and the queries to determine this set have been deprecated. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BeginFragmentShader.</para>
        /// <para>Fullname: BeginFragmentShaderATI</para>
        /// <para>Extensions: ATI_fragment_shader</para>
        /// </summary>
        public static void BeginFragmentShader()
        {
            if (gl._BeginFragmentShader != null) gl._BeginFragmentShader(); else { }
        }
        /// <summary>
        /// <para>Fullname: BindFragmentShaderATI</para>
        /// </summary>
        [GLEntry("BindFragmentShaderATI", Category = "ATI")]
        public static GLDelegate.BindFragmentShader _BindFragmentShader = null;
        /// <summary>
        /// <para>This extension exposes a powerful fragment shading model which provides a very general means of expressing fragment color blending and dependent texture address modification.  The programming is a register-based model in which there is a fixed number of instructions, texture lookups, read/write registers, and constants. The fragment shader extension provides a unified instruction set for operating on address or color data and eliminates the distinction between the two.  This extension provides all the interfaces necessary to fully expose this programmable fragment shader in GL. Although conceived as a device-independent extension which would expose the capabilities of future generations of hardware, changing trends in programmable hardware have affected the lifespan of this extension.  For this reason you will now find a fixed set of features and resources exposed, and the queries to determine this set have been deprecated. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BindFragmentShader.</para>
        /// <para>Fullname: BindFragmentShaderATI</para>
        /// <para>Extensions: ATI_fragment_shader</para>
        /// </summary>
        public static void BindFragmentShader(uint id)
        {
            if (gl._BindFragmentShader != null) gl._BindFragmentShader(id); else { }
        }
        /// <summary>
        /// <para>Fullname: ClientActiveVertexStreamATI</para>
        /// </summary>
        [GLEntry("ClientActiveVertexStreamATI", Category = "ATI")]
        public static GLDelegate.ClientActiveVertexStream _ClientActiveVertexStream = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ClientActiveVertexStream.</para>
        /// <para>Fullname: ClientActiveVertexStreamATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void ClientActiveVertexStream(int stream)
        {
            if (gl._ClientActiveVertexStream != null) gl._ClientActiveVertexStream(stream); else { }
        }
        /// <summary>
        /// <para>Fullname: ColorFragmentOp1ATI</para>
        /// </summary>
        [GLEntry("ColorFragmentOp1ATI", Category = "ATI")]
        public static GLDelegate.ColorFragmentOp1 _ColorFragmentOp1 = null;
        /// <summary>
        /// <para>This extension exposes a powerful fragment shading model which provides a very general means of expressing fragment color blending and dependent texture address modification.  The programming is a register-based model in which there is a fixed number of instructions, texture lookups, read/write registers, and constants. The fragment shader extension provides a unified instruction set for operating on address or color data and eliminates the distinction between the two.  This extension provides all the interfaces necessary to fully expose this programmable fragment shader in GL. Although conceived as a device-independent extension which would expose the capabilities of future generations of hardware, changing trends in programmable hardware have affected the lifespan of this extension.  For this reason you will now find a fixed set of features and resources exposed, and the queries to determine this set have been deprecated. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorFragmentOp1.</para>
        /// <para>Fullname: ColorFragmentOp1ATI</para>
        /// <para>Extensions: ATI_fragment_shader</para>
        /// </summary>
        public static void ColorFragmentOp1(int op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod)
        {
            if (gl._ColorFragmentOp1 != null) gl._ColorFragmentOp1(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod); else { }
        }
        /// <summary>
        /// <para>Fullname: ColorFragmentOp2ATI</para>
        /// </summary>
        [GLEntry("ColorFragmentOp2ATI", Category = "ATI")]
        public static GLDelegate.ColorFragmentOp2 _ColorFragmentOp2 = null;
        /// <summary>
        /// <para>This extension exposes a powerful fragment shading model which provides a very general means of expressing fragment color blending and dependent texture address modification.  The programming is a register-based model in which there is a fixed number of instructions, texture lookups, read/write registers, and constants. The fragment shader extension provides a unified instruction set for operating on address or color data and eliminates the distinction between the two.  This extension provides all the interfaces necessary to fully expose this programmable fragment shader in GL. Although conceived as a device-independent extension which would expose the capabilities of future generations of hardware, changing trends in programmable hardware have affected the lifespan of this extension.  For this reason you will now find a fixed set of features and resources exposed, and the queries to determine this set have been deprecated. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorFragmentOp2.</para>
        /// <para>Fullname: ColorFragmentOp2ATI</para>
        /// <para>Extensions: ATI_fragment_shader</para>
        /// </summary>
        public static void ColorFragmentOp2(int op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod)
        {
            if (gl._ColorFragmentOp2 != null) gl._ColorFragmentOp2(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod); else { }
        }
        /// <summary>
        /// <para>Fullname: ColorFragmentOp3ATI</para>
        /// </summary>
        [GLEntry("ColorFragmentOp3ATI", Category = "ATI")]
        public static GLDelegate.ColorFragmentOp3 _ColorFragmentOp3 = null;
        /// <summary>
        /// <para>This extension exposes a powerful fragment shading model which provides a very general means of expressing fragment color blending and dependent texture address modification.  The programming is a register-based model in which there is a fixed number of instructions, texture lookups, read/write registers, and constants. The fragment shader extension provides a unified instruction set for operating on address or color data and eliminates the distinction between the two.  This extension provides all the interfaces necessary to fully expose this programmable fragment shader in GL. Although conceived as a device-independent extension which would expose the capabilities of future generations of hardware, changing trends in programmable hardware have affected the lifespan of this extension.  For this reason you will now find a fixed set of features and resources exposed, and the queries to determine this set have been deprecated. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ColorFragmentOp3.</para>
        /// <para>Fullname: ColorFragmentOp3ATI</para>
        /// <para>Extensions: ATI_fragment_shader</para>
        /// </summary>
        public static void ColorFragmentOp3(int op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod, uint arg3, uint arg3Rep, uint arg3Mod)
        {
            if (gl._ColorFragmentOp3 != null) gl._ColorFragmentOp3(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteFragmentShaderATI</para>
        /// </summary>
        [GLEntry("DeleteFragmentShaderATI", Category = "ATI")]
        public static GLDelegate.DeleteFragmentShader _DeleteFragmentShader = null;
        /// <summary>
        /// <para>This extension exposes a powerful fragment shading model which provides a very general means of expressing fragment color blending and dependent texture address modification.  The programming is a register-based model in which there is a fixed number of instructions, texture lookups, read/write registers, and constants. The fragment shader extension provides a unified instruction set for operating on address or color data and eliminates the distinction between the two.  This extension provides all the interfaces necessary to fully expose this programmable fragment shader in GL. Although conceived as a device-independent extension which would expose the capabilities of future generations of hardware, changing trends in programmable hardware have affected the lifespan of this extension.  For this reason you will now find a fixed set of features and resources exposed, and the queries to determine this set have been deprecated. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteFragmentShader.</para>
        /// <para>Fullname: DeleteFragmentShaderATI</para>
        /// <para>Extensions: ATI_fragment_shader</para>
        /// </summary>
        public static void DeleteFragmentShader(uint id)
        {
            if (gl._DeleteFragmentShader != null) gl._DeleteFragmentShader(id); else { }
        }
        /// <summary>
        /// <para>Fullname: DrawElementArrayATI</para>
        /// </summary>
        [GLEntry("DrawElementArrayATI", Category = "ATI")]
        public static GLDelegate.DrawElementArray _DrawElementArray = null;
        /// <summary>
        /// <para>This extension provides a mechanism for an application to create an array of index data for use in specifying geometric primitives.  This extension is most useful when used in conjunction with the ATI_vertex_array_object extension. ATI_vertex_array_object provides an interface for storing vertex array data in persistent, hardware-addressable memory. In cases where large amounts of vertex data are in use, the index data used to construct primitives (typically as passed to the GL through DrawElements) can impose a significant bandwidth burden. ATI_element_array allows the application to specify independent arrays of elements, which can then be cached using ATI_vertex_array_object.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawElementArray.</para>
        /// <para>Fullname: DrawElementArrayATI</para>
        /// <para>Extensions: ATI_element_array</para>
        /// </summary>
        public static void DrawElementArray(int mode, int count)
        {
            if (gl._DrawElementArray != null) gl._DrawElementArray(mode, count); else { }
        }
        /// <summary>
        /// <para>Fullname: DrawRangeElementArrayATI</para>
        /// </summary>
        [GLEntry("DrawRangeElementArrayATI", Category = "ATI")]
        public static GLDelegate.DrawRangeElementArray _DrawRangeElementArray = null;
        /// <summary>
        /// <para>This extension provides a mechanism for an application to create an array of index data for use in specifying geometric primitives.  This extension is most useful when used in conjunction with the ATI_vertex_array_object extension. ATI_vertex_array_object provides an interface for storing vertex array data in persistent, hardware-addressable memory. In cases where large amounts of vertex data are in use, the index data used to construct primitives (typically as passed to the GL through DrawElements) can impose a significant bandwidth burden. ATI_element_array allows the application to specify independent arrays of elements, which can then be cached using ATI_vertex_array_object.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawRangeElementArray.</para>
        /// <para>Fullname: DrawRangeElementArrayATI</para>
        /// <para>Extensions: ATI_element_array</para>
        /// </summary>
        public static void DrawRangeElementArray(int mode, uint start, uint end, int count)
        {
            if (gl._DrawRangeElementArray != null) gl._DrawRangeElementArray(mode, start, end, count); else { }
        }
        /// <summary>
        /// <para>Fullname: ElementPointerATI</para>
        /// </summary>
        [GLEntry("ElementPointerATI", Category = "ATI", Alias = "ElementPointerAPPLE ")]
        public static GLDelegate.ElementPointer _ElementPointer = null;
        public static GLDelegate.ElementPointer ElementPointerAPPLE = ElementPointer;
        /// <summary>
        /// <para>This extension provides a mechanism for an application to create an array of index data for use in specifying geometric primitives.  This extension is most useful when used in conjunction with the ATI_vertex_array_object extension. ATI_vertex_array_object provides an interface for storing vertex array data in persistent, hardware-addressable memory. In cases where large amounts of vertex data are in use, the index data used to construct primitives (typically as passed to the GL through DrawElements) can impose a significant bandwidth burden. ATI_element_array allows the application to specify independent arrays of elements, which can then be cached using ATI_vertex_array_object.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ElementPointer.</para>
        /// <para>Fullname: ElementPointerATI</para>
        /// <para>Aliases: ElementPointerAPPLE, </para>
        /// <para>Extensions: ATI_element_array APPLE_element_array</para>
        /// </summary>
        public static void ElementPointer(int type, IntPtr pointer)
        {
            if (gl._ElementPointer != null) gl._ElementPointer(type, pointer); else { }
        }
        /// <summary>
        /// <para>Fullname: EndFragmentShaderATI</para>
        /// </summary>
        [GLEntry("EndFragmentShaderATI", Category = "ATI")]
        public static GLDelegate.EndFragmentShader _EndFragmentShader = null;
        /// <summary>
        /// <para>This extension exposes a powerful fragment shading model which provides a very general means of expressing fragment color blending and dependent texture address modification.  The programming is a register-based model in which there is a fixed number of instructions, texture lookups, read/write registers, and constants. The fragment shader extension provides a unified instruction set for operating on address or color data and eliminates the distinction between the two.  This extension provides all the interfaces necessary to fully expose this programmable fragment shader in GL. Although conceived as a device-independent extension which would expose the capabilities of future generations of hardware, changing trends in programmable hardware have affected the lifespan of this extension.  For this reason you will now find a fixed set of features and resources exposed, and the queries to determine this set have been deprecated. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EndFragmentShader.</para>
        /// <para>Fullname: EndFragmentShaderATI</para>
        /// <para>Extensions: ATI_fragment_shader</para>
        /// </summary>
        public static void EndFragmentShader()
        {
            if (gl._EndFragmentShader != null) gl._EndFragmentShader(); else { }
        }
        /// <summary>
        /// <para>Fullname: FreeObjectBufferATI</para>
        /// </summary>
        [GLEntry("FreeObjectBufferATI", Category = "ATI")]
        public static GLDelegate.FreeObjectBuffer _FreeObjectBuffer = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of vertex array data to be cached in persistent server-side memory. It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FreeObjectBuffer.</para>
        /// <para>Fullname: FreeObjectBufferATI</para>
        /// <para>Extensions: ATI_vertex_array_object</para>
        /// </summary>
        public static void FreeObjectBuffer(uint buffer)
        {
            if (gl._FreeObjectBuffer != null) gl._FreeObjectBuffer(buffer); else { }
        }
        /// <summary>
        /// <para>Fullname: GenFragmentShadersATI</para>
        /// </summary>
        [GLEntry("GenFragmentShadersATI", Category = "ATI")]
        public static GLDelegate.GenFragmentShaders _GenFragmentShaders = null;
        /// <summary>
        /// <para>This extension exposes a powerful fragment shading model which provides a very general means of expressing fragment color blending and dependent texture address modification.  The programming is a register-based model in which there is a fixed number of instructions, texture lookups, read/write registers, and constants. The fragment shader extension provides a unified instruction set for operating on address or color data and eliminates the distinction between the two.  This extension provides all the interfaces necessary to fully expose this programmable fragment shader in GL. Although conceived as a device-independent extension which would expose the capabilities of future generations of hardware, changing trends in programmable hardware have affected the lifespan of this extension.  For this reason you will now find a fixed set of features and resources exposed, and the queries to determine this set have been deprecated. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenFragmentShaders.</para>
        /// <para>Fullname: GenFragmentShadersATI</para>
        /// <para>Extensions: ATI_fragment_shader</para>
        /// </summary>
        public static uint GenFragmentShaders(uint range)
        {
            if (gl._GenFragmentShaders != null) return gl._GenFragmentShaders(range);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: GetArrayObjectfvATI</para>
        /// </summary>
        [GLEntry("GetArrayObjectfvATI", Category = "ATI")]
        public static GLDelegate.GetArrayObjectfv_float _GetArrayObjectfv_float = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of vertex array data to be cached in persistent server-side memory. It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetArrayObjectfv_float.</para>
        /// <para>Fullname: GetArrayObjectfvATI</para>
        /// <para>Extensions: ATI_vertex_array_object</para>
        /// </summary>
        public static void GetArrayObjectfv(int array, int pname, out float param)
        {
            if (gl._GetArrayObjectfv_float != null) gl._GetArrayObjectfv_float(array, pname, out param); else { param = new float(); }
        }
        /// <summary>
        /// <para>Fullname: GetArrayObjectfvATI</para>
        /// </summary>
        [GLEntry("GetArrayObjectfvATI", Category = "ATI")]
        public static GLDelegate.GetArrayObjectfv _GetArrayObjectfv = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of vertex array data to be cached in persistent server-side memory. It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetArrayObjectfv.</para>
        /// <para>Fullname: GetArrayObjectfvATI</para>
        /// <para>Extensions: ATI_vertex_array_object</para>
        /// </summary>
        public static void GetArrayObjectfv(int array, int pname, float[] param)
        {
            if (gl._GetArrayObjectfv != null) gl._GetArrayObjectfv(array, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetArrayObjectivATI</para>
        /// </summary>
        [GLEntry("GetArrayObjectivATI", Category = "ATI")]
        public static GLDelegate.GetArrayObjectiv_int _GetArrayObjectiv_int = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of vertex array data to be cached in persistent server-side memory. It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetArrayObjectiv_int.</para>
        /// <para>Fullname: GetArrayObjectivATI</para>
        /// <para>Extensions: ATI_vertex_array_object</para>
        /// </summary>
        public static void GetArrayObjectiv(int array, int pname, out int param)
        {
            if (gl._GetArrayObjectiv_int != null) gl._GetArrayObjectiv_int(array, pname, out param); else { param = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetArrayObjectivATI</para>
        /// </summary>
        [GLEntry("GetArrayObjectivATI", Category = "ATI")]
        public static GLDelegate.GetArrayObjectiv _GetArrayObjectiv = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of vertex array data to be cached in persistent server-side memory. It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetArrayObjectiv.</para>
        /// <para>Fullname: GetArrayObjectivATI</para>
        /// <para>Extensions: ATI_vertex_array_object</para>
        /// </summary>
        public static void GetArrayObjectiv(int array, int pname, int[] param)
        {
            if (gl._GetArrayObjectiv != null) gl._GetArrayObjectiv(array, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetObjectBufferfvATI</para>
        /// </summary>
        [GLEntry("GetObjectBufferfvATI", Category = "ATI")]
        public static GLDelegate.GetObjectBufferfv _GetObjectBufferfv = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of vertex array data to be cached in persistent server-side memory. It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetObjectBufferfv.</para>
        /// <para>Fullname: GetObjectBufferfvATI</para>
        /// <para>Extensions: ATI_vertex_array_object</para>
        /// </summary>
        public static void GetObjectBufferfv(uint buffer, int pname, float[] param)
        {
            if (gl._GetObjectBufferfv != null) gl._GetObjectBufferfv(buffer, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetObjectBufferfvATI</para>
        /// </summary>
        [GLEntry("GetObjectBufferfvATI", Category = "ATI")]
        public static GLDelegate.GetObjectBufferfv_float _GetObjectBufferfv_float = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of vertex array data to be cached in persistent server-side memory. It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetObjectBufferfv_float.</para>
        /// <para>Fullname: GetObjectBufferfvATI</para>
        /// <para>Extensions: ATI_vertex_array_object</para>
        /// </summary>
        public static void GetObjectBufferfv(uint buffer, int pname, out float param)
        {
            if (gl._GetObjectBufferfv_float != null) gl._GetObjectBufferfv_float(buffer, pname, out param); else { param = new float(); }
        }
        /// <summary>
        /// <para>Fullname: GetObjectBufferivATI</para>
        /// </summary>
        [GLEntry("GetObjectBufferivATI", Category = "ATI")]
        public static GLDelegate.GetObjectBufferiv _GetObjectBufferiv = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of vertex array data to be cached in persistent server-side memory. It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetObjectBufferiv.</para>
        /// <para>Fullname: GetObjectBufferivATI</para>
        /// <para>Extensions: ATI_vertex_array_object</para>
        /// </summary>
        public static void GetObjectBufferiv(uint buffer, int pname, int[] param)
        {
            if (gl._GetObjectBufferiv != null) gl._GetObjectBufferiv(buffer, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetObjectBufferivATI</para>
        /// </summary>
        [GLEntry("GetObjectBufferivATI", Category = "ATI")]
        public static GLDelegate.GetObjectBufferiv_int _GetObjectBufferiv_int = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of vertex array data to be cached in persistent server-side memory. It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetObjectBufferiv_int.</para>
        /// <para>Fullname: GetObjectBufferivATI</para>
        /// <para>Extensions: ATI_vertex_array_object</para>
        /// </summary>
        public static void GetObjectBufferiv(uint buffer, int pname, out int param)
        {
            if (gl._GetObjectBufferiv_int != null) gl._GetObjectBufferiv_int(buffer, pname, out param); else { param = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetTexBumpParameterfvATI</para>
        /// </summary>
        [GLEntry("GetTexBumpParameterfvATI", Category = "ATI")]
        public static GLDelegate.GetTexBumpParameterfv _GetTexBumpParameterfv = null;
        /// <summary>
        /// <para>This extension adds environment mapped bump mapping (EMBM) to the GL. The method exposed by this extension is to use a dependent texture read on a bumpmap (du,dv) texture to offset the texture coordinates read into a map on another texture unit.  This (du,dv) offset is also rotated through a user-specified rotation matrix to get the texture coordinates into the appropriate space. A new texture format is introduced in order for specifying the (du,dv) bumpmap texture.  This map represents -1 <= du,dv <= 1 offsets to be applied to the texture coordinates used to read into the base map.  Additionally, the (du,dv) offsets are transformed by a rotation matrix that this extension allows the user to specify.  Further, a new color operation is added to EXT_texture_env_combine to specify both that bumpmapping is enabled and which texture unit to apply the bump offset to.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTexBumpParameterfv.</para>
        /// <para>Fullname: GetTexBumpParameterfvATI</para>
        /// <para>Extensions: ATI_envmap_bumpmap</para>
        /// </summary>
        public static void GetTexBumpParameterfv(int pname, float[] param)
        {
            if (gl._GetTexBumpParameterfv != null) gl._GetTexBumpParameterfv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTexBumpParameterivATI</para>
        /// </summary>
        [GLEntry("GetTexBumpParameterivATI", Category = "ATI")]
        public static GLDelegate.GetTexBumpParameteriv _GetTexBumpParameteriv = null;
        /// <summary>
        /// <para>This extension adds environment mapped bump mapping (EMBM) to the GL. The method exposed by this extension is to use a dependent texture read on a bumpmap (du,dv) texture to offset the texture coordinates read into a map on another texture unit.  This (du,dv) offset is also rotated through a user-specified rotation matrix to get the texture coordinates into the appropriate space. A new texture format is introduced in order for specifying the (du,dv) bumpmap texture.  This map represents -1 <= du,dv <= 1 offsets to be applied to the texture coordinates used to read into the base map.  Additionally, the (du,dv) offsets are transformed by a rotation matrix that this extension allows the user to specify.  Further, a new color operation is added to EXT_texture_env_combine to specify both that bumpmapping is enabled and which texture unit to apply the bump offset to.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTexBumpParameteriv.</para>
        /// <para>Fullname: GetTexBumpParameterivATI</para>
        /// <para>Extensions: ATI_envmap_bumpmap</para>
        /// </summary>
        public static void GetTexBumpParameteriv(int pname, int[] param)
        {
            if (gl._GetTexBumpParameteriv != null) gl._GetTexBumpParameteriv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVariantArrayObjectfvATI</para>
        /// </summary>
        [GLEntry("GetVariantArrayObjectfvATI", Category = "ATI")]
        public static GLDelegate.GetVariantArrayObjectfv_float _GetVariantArrayObjectfv_float = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of vertex array data to be cached in persistent server-side memory. It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVariantArrayObjectfv_float.</para>
        /// <para>Fullname: GetVariantArrayObjectfvATI</para>
        /// <para>Extensions: ATI_vertex_array_object</para>
        /// </summary>
        public static void GetVariantArrayObjectfv(uint id, int pname, out float param)
        {
            if (gl._GetVariantArrayObjectfv_float != null) gl._GetVariantArrayObjectfv_float(id, pname, out param); else { param = new float(); }
        }
        /// <summary>
        /// <para>Fullname: GetVariantArrayObjectfvATI</para>
        /// </summary>
        [GLEntry("GetVariantArrayObjectfvATI", Category = "ATI")]
        public static GLDelegate.GetVariantArrayObjectfv _GetVariantArrayObjectfv = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of vertex array data to be cached in persistent server-side memory. It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVariantArrayObjectfv.</para>
        /// <para>Fullname: GetVariantArrayObjectfvATI</para>
        /// <para>Extensions: ATI_vertex_array_object</para>
        /// </summary>
        public static void GetVariantArrayObjectfv(uint id, int pname, float[] param)
        {
            if (gl._GetVariantArrayObjectfv != null) gl._GetVariantArrayObjectfv(id, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVariantArrayObjectivATI</para>
        /// </summary>
        [GLEntry("GetVariantArrayObjectivATI", Category = "ATI")]
        public static GLDelegate.GetVariantArrayObjectiv_int _GetVariantArrayObjectiv_int = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of vertex array data to be cached in persistent server-side memory. It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVariantArrayObjectiv_int.</para>
        /// <para>Fullname: GetVariantArrayObjectivATI</para>
        /// <para>Extensions: ATI_vertex_array_object</para>
        /// </summary>
        public static void GetVariantArrayObjectiv(uint id, int pname, out int param)
        {
            if (gl._GetVariantArrayObjectiv_int != null) gl._GetVariantArrayObjectiv_int(id, pname, out param); else { param = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetVariantArrayObjectivATI</para>
        /// </summary>
        [GLEntry("GetVariantArrayObjectivATI", Category = "ATI")]
        public static GLDelegate.GetVariantArrayObjectiv _GetVariantArrayObjectiv = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of vertex array data to be cached in persistent server-side memory. It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVariantArrayObjectiv.</para>
        /// <para>Fullname: GetVariantArrayObjectivATI</para>
        /// <para>Extensions: ATI_vertex_array_object</para>
        /// </summary>
        public static void GetVariantArrayObjectiv(uint id, int pname, int[] param)
        {
            if (gl._GetVariantArrayObjectiv != null) gl._GetVariantArrayObjectiv(id, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVertexAttribArrayObjectfvATI</para>
        /// </summary>
        [GLEntry("GetVertexAttribArrayObjectfvATI", Category = "ATI")]
        public static GLDelegate.GetVertexAttribArrayObjectfv _GetVertexAttribArrayObjectfv = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of generic vertex attribute data to be cached in persistent server-side memory.  It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVertexAttribArrayObjectfv.</para>
        /// <para>Fullname: GetVertexAttribArrayObjectfvATI</para>
        /// <para>Extensions: ATI_vertex_attrib_array_object</para>
        /// </summary>
        public static void GetVertexAttribArrayObjectfv(uint index, int pname, float[] param)
        {
            if (gl._GetVertexAttribArrayObjectfv != null) gl._GetVertexAttribArrayObjectfv(index, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetVertexAttribArrayObjectivATI</para>
        /// </summary>
        [GLEntry("GetVertexAttribArrayObjectivATI", Category = "ATI")]
        public static GLDelegate.GetVertexAttribArrayObjectiv _GetVertexAttribArrayObjectiv = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of generic vertex attribute data to be cached in persistent server-side memory.  It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetVertexAttribArrayObjectiv.</para>
        /// <para>Fullname: GetVertexAttribArrayObjectivATI</para>
        /// <para>Extensions: ATI_vertex_attrib_array_object</para>
        /// </summary>
        public static void GetVertexAttribArrayObjectiv(uint index, int pname, int[] param)
        {
            if (gl._GetVertexAttribArrayObjectiv != null) gl._GetVertexAttribArrayObjectiv(index, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: IsObjectBufferATI</para>
        /// </summary>
        [GLEntry("IsObjectBufferATI", Category = "ATI")]
        public static GLDelegate.IsObjectBuffer _IsObjectBuffer = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of vertex array data to be cached in persistent server-side memory. It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsObjectBuffer.</para>
        /// <para>Fullname: IsObjectBufferATI</para>
        /// <para>Extensions: ATI_vertex_array_object</para>
        /// </summary>
        public static bool IsObjectBuffer(uint buffer)
        {
            if (gl._IsObjectBuffer != null) return gl._IsObjectBuffer(buffer);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: MapObjectBufferATI</para>
        /// </summary>
        [GLEntry("MapObjectBufferATI", Category = "ATI")]
        public static GLDelegate.MapObjectBuffer _MapObjectBuffer = null;
        /// <summary>
        /// <para>This extension provides a mechanism for an application to obtain the virtual address of an object buffer. This allows the application to directly update the contents of an object buffer and avoid any intermediate copies.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MapObjectBuffer.</para>
        /// <para>Fullname: MapObjectBufferATI</para>
        /// <para>Extensions: ATI_map_object_buffer</para>
        /// </summary>
        public static IntPtr MapObjectBuffer(uint buffer)
        {
            if (gl._MapObjectBuffer != null) return gl._MapObjectBuffer(buffer);
            else { return (IntPtr)0; }
        }
        /// <summary>
        /// <para>Fullname: NewObjectBufferATI</para>
        /// </summary>
        [GLEntry("NewObjectBufferATI", Category = "ATI")]
        public static GLDelegate.NewObjectBuffer _NewObjectBuffer = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of vertex array data to be cached in persistent server-side memory. It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NewObjectBuffer.</para>
        /// <para>Fullname: NewObjectBufferATI</para>
        /// <para>Extensions: ATI_vertex_array_object</para>
        /// </summary>
        public static uint NewObjectBuffer(int size, IntPtr pointer, int usage)
        {
            if (gl._NewObjectBuffer != null) return gl._NewObjectBuffer(size, pointer, usage);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: NormalStream3bATI</para>
        /// </summary>
        [GLEntry("NormalStream3bATI", Category = "ATI")]
        public static GLDelegate.NormalStream3b _NormalStream3b = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NormalStream3b.</para>
        /// <para>Fullname: NormalStream3bATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void NormalStream3b(int stream, byte nx, byte ny, byte nz)
        {
            if (gl._NormalStream3b != null) gl._NormalStream3b(stream, nx, ny, nz); else { }
        }
        /// <summary>
        /// <para>Fullname: NormalStream3bvATI</para>
        /// </summary>
        [GLEntry("NormalStream3bvATI", Category = "ATI")]
        public static GLDelegate.NormalStream3bv _NormalStream3bv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NormalStream3bv.</para>
        /// <para>Fullname: NormalStream3bvATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void NormalStream3bv(int stream, byte[] coords)
        {
            if (gl._NormalStream3bv != null) gl._NormalStream3bv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: NormalStream3dATI</para>
        /// </summary>
        [GLEntry("NormalStream3dATI", Category = "ATI")]
        public static GLDelegate.NormalStream3d _NormalStream3d = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NormalStream3d.</para>
        /// <para>Fullname: NormalStream3dATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void NormalStream3d(int stream, double nx, double ny, double nz)
        {
            if (gl._NormalStream3d != null) gl._NormalStream3d(stream, nx, ny, nz); else { }
        }
        /// <summary>
        /// <para>Fullname: NormalStream3dvATI</para>
        /// </summary>
        [GLEntry("NormalStream3dvATI", Category = "ATI")]
        public static GLDelegate.NormalStream3dv _NormalStream3dv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NormalStream3dv.</para>
        /// <para>Fullname: NormalStream3dvATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void NormalStream3dv(int stream, double[] coords)
        {
            if (gl._NormalStream3dv != null) gl._NormalStream3dv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: NormalStream3fATI</para>
        /// </summary>
        [GLEntry("NormalStream3fATI", Category = "ATI")]
        public static GLDelegate.NormalStream3f _NormalStream3f = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NormalStream3f.</para>
        /// <para>Fullname: NormalStream3fATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void NormalStream3f(int stream, float nx, float ny, float nz)
        {
            if (gl._NormalStream3f != null) gl._NormalStream3f(stream, nx, ny, nz); else { }
        }
        /// <summary>
        /// <para>Fullname: NormalStream3fvATI</para>
        /// </summary>
        [GLEntry("NormalStream3fvATI", Category = "ATI")]
        public static GLDelegate.NormalStream3fv _NormalStream3fv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NormalStream3fv.</para>
        /// <para>Fullname: NormalStream3fvATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void NormalStream3fv(int stream, float[] coords)
        {
            if (gl._NormalStream3fv != null) gl._NormalStream3fv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: NormalStream3iATI</para>
        /// </summary>
        [GLEntry("NormalStream3iATI", Category = "ATI")]
        public static GLDelegate.NormalStream3i _NormalStream3i = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NormalStream3i.</para>
        /// <para>Fullname: NormalStream3iATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void NormalStream3i(int stream, int nx, int ny, int nz)
        {
            if (gl._NormalStream3i != null) gl._NormalStream3i(stream, nx, ny, nz); else { }
        }
        /// <summary>
        /// <para>Fullname: NormalStream3ivATI</para>
        /// </summary>
        [GLEntry("NormalStream3ivATI", Category = "ATI")]
        public static GLDelegate.NormalStream3iv _NormalStream3iv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NormalStream3iv.</para>
        /// <para>Fullname: NormalStream3ivATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void NormalStream3iv(int stream, int[] coords)
        {
            if (gl._NormalStream3iv != null) gl._NormalStream3iv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: NormalStream3sATI</para>
        /// </summary>
        [GLEntry("NormalStream3sATI", Category = "ATI")]
        public static GLDelegate.NormalStream3s _NormalStream3s = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NormalStream3s.</para>
        /// <para>Fullname: NormalStream3sATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void NormalStream3s(int stream, short nx, short ny, short nz)
        {
            if (gl._NormalStream3s != null) gl._NormalStream3s(stream, nx, ny, nz); else { }
        }
        /// <summary>
        /// <para>Fullname: NormalStream3svATI</para>
        /// </summary>
        [GLEntry("NormalStream3svATI", Category = "ATI")]
        public static GLDelegate.NormalStream3sv _NormalStream3sv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _NormalStream3sv.</para>
        /// <para>Fullname: NormalStream3svATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void NormalStream3sv(int stream, short[] coords)
        {
            if (gl._NormalStream3sv != null) gl._NormalStream3sv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: PassTexCoordATI</para>
        /// </summary>
        [GLEntry("PassTexCoordATI", Category = "ATI")]
        public static GLDelegate.PassTexCoord _PassTexCoord = null;
        /// <summary>
        /// <para>This extension exposes a powerful fragment shading model which provides a very general means of expressing fragment color blending and dependent texture address modification.  The programming is a register-based model in which there is a fixed number of instructions, texture lookups, read/write registers, and constants. The fragment shader extension provides a unified instruction set for operating on address or color data and eliminates the distinction between the two.  This extension provides all the interfaces necessary to fully expose this programmable fragment shader in GL. Although conceived as a device-independent extension which would expose the capabilities of future generations of hardware, changing trends in programmable hardware have affected the lifespan of this extension.  For this reason you will now find a fixed set of features and resources exposed, and the queries to determine this set have been deprecated. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PassTexCoord.</para>
        /// <para>Fullname: PassTexCoordATI</para>
        /// <para>Extensions: ATI_fragment_shader</para>
        /// </summary>
        public static void PassTexCoord(uint dst, uint coord, int swizzle)
        {
            if (gl._PassTexCoord != null) gl._PassTexCoord(dst, coord, swizzle); else { }
        }
        /// <summary>
        /// <para>Fullname: PNTrianglesfATI</para>
        /// </summary>
        [GLEntry("PNTrianglesfATI", Category = "ATI")]
        public static GLDelegate.PNTrianglesf _PNTrianglesf = null;
        /// <summary>
        /// <para>ATI_pn_triangles provides a path for enabling the GL to internally tessellate input geometry into curved patches.  The extension allows the user to tune the amount of tessellation to be performed on each triangle as a global state value.  The intent of PN Triangle tessellation is typically to produce geometry with a smoother silhouette and more organic shape. The tessellated patch will replace the triangles input into the GL. The GL will generate new vertices in object-space, prior to geometry transformation.  Only the vertices and normals are required to produce proper results, and the rest of the information per vertex is interpolated linearly across the patch. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PNTrianglesf.</para>
        /// <para>Fullname: PNTrianglesfATI</para>
        /// <para>Extensions: ATI_pn_triangles</para>
        /// </summary>
        public static void PNTrianglesf(int pname, float param)
        {
            if (gl._PNTrianglesf != null) gl._PNTrianglesf(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: PNTrianglesiATI</para>
        /// </summary>
        [GLEntry("PNTrianglesiATI", Category = "ATI")]
        public static GLDelegate.PNTrianglesi _PNTrianglesi = null;
        /// <summary>
        /// <para>ATI_pn_triangles provides a path for enabling the GL to internally tessellate input geometry into curved patches.  The extension allows the user to tune the amount of tessellation to be performed on each triangle as a global state value.  The intent of PN Triangle tessellation is typically to produce geometry with a smoother silhouette and more organic shape. The tessellated patch will replace the triangles input into the GL. The GL will generate new vertices in object-space, prior to geometry transformation.  Only the vertices and normals are required to produce proper results, and the rest of the information per vertex is interpolated linearly across the patch. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _PNTrianglesi.</para>
        /// <para>Fullname: PNTrianglesiATI</para>
        /// <para>Extensions: ATI_pn_triangles</para>
        /// </summary>
        public static void PNTrianglesi(int pname, int param)
        {
            if (gl._PNTrianglesi != null) gl._PNTrianglesi(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: SampleMapATI</para>
        /// </summary>
        [GLEntry("SampleMapATI", Category = "ATI")]
        public static GLDelegate.SampleMap _SampleMap = null;
        /// <summary>
        /// <para>This extension exposes a powerful fragment shading model which provides a very general means of expressing fragment color blending and dependent texture address modification.  The programming is a register-based model in which there is a fixed number of instructions, texture lookups, read/write registers, and constants. The fragment shader extension provides a unified instruction set for operating on address or color data and eliminates the distinction between the two.  This extension provides all the interfaces necessary to fully expose this programmable fragment shader in GL. Although conceived as a device-independent extension which would expose the capabilities of future generations of hardware, changing trends in programmable hardware have affected the lifespan of this extension.  For this reason you will now find a fixed set of features and resources exposed, and the queries to determine this set have been deprecated. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SampleMap.</para>
        /// <para>Fullname: SampleMapATI</para>
        /// <para>Extensions: ATI_fragment_shader</para>
        /// </summary>
        public static void SampleMap(uint dst, uint interp, int swizzle)
        {
            if (gl._SampleMap != null) gl._SampleMap(dst, interp, swizzle); else { }
        }
        /// <summary>
        /// <para>Fullname: SetFragmentShaderConstantATI</para>
        /// </summary>
        [GLEntry("SetFragmentShaderConstantATI", Category = "ATI")]
        public static GLDelegate.SetFragmentShaderConstant _SetFragmentShaderConstant = null;
        /// <summary>
        /// <para>This extension exposes a powerful fragment shading model which provides a very general means of expressing fragment color blending and dependent texture address modification.  The programming is a register-based model in which there is a fixed number of instructions, texture lookups, read/write registers, and constants. The fragment shader extension provides a unified instruction set for operating on address or color data and eliminates the distinction between the two.  This extension provides all the interfaces necessary to fully expose this programmable fragment shader in GL. Although conceived as a device-independent extension which would expose the capabilities of future generations of hardware, changing trends in programmable hardware have affected the lifespan of this extension.  For this reason you will now find a fixed set of features and resources exposed, and the queries to determine this set have been deprecated. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SetFragmentShaderConstant.</para>
        /// <para>Fullname: SetFragmentShaderConstantATI</para>
        /// <para>Extensions: ATI_fragment_shader</para>
        /// </summary>
        public static void SetFragmentShaderConstant(uint dst, float[] value)
        {
            if (gl._SetFragmentShaderConstant != null) gl._SetFragmentShaderConstant(dst, value); else { }
        }
        /// <summary>
        /// <para>Fullname: TexBumpParameterfvATI</para>
        /// </summary>
        [GLEntry("TexBumpParameterfvATI", Category = "ATI")]
        public static GLDelegate.TexBumpParameterfv _TexBumpParameterfv = null;
        /// <summary>
        /// <para>This extension adds environment mapped bump mapping (EMBM) to the GL. The method exposed by this extension is to use a dependent texture read on a bumpmap (du,dv) texture to offset the texture coordinates read into a map on another texture unit.  This (du,dv) offset is also rotated through a user-specified rotation matrix to get the texture coordinates into the appropriate space. A new texture format is introduced in order for specifying the (du,dv) bumpmap texture.  This map represents -1 <= du,dv <= 1 offsets to be applied to the texture coordinates used to read into the base map.  Additionally, the (du,dv) offsets are transformed by a rotation matrix that this extension allows the user to specify.  Further, a new color operation is added to EXT_texture_env_combine to specify both that bumpmapping is enabled and which texture unit to apply the bump offset to.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexBumpParameterfv.</para>
        /// <para>Fullname: TexBumpParameterfvATI</para>
        /// <para>Extensions: ATI_envmap_bumpmap</para>
        /// </summary>
        public static void TexBumpParameterfv(int pname, float[] param)
        {
            if (gl._TexBumpParameterfv != null) gl._TexBumpParameterfv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: TexBumpParameterivATI</para>
        /// </summary>
        [GLEntry("TexBumpParameterivATI", Category = "ATI")]
        public static GLDelegate.TexBumpParameteriv _TexBumpParameteriv = null;
        /// <summary>
        /// <para>This extension adds environment mapped bump mapping (EMBM) to the GL. The method exposed by this extension is to use a dependent texture read on a bumpmap (du,dv) texture to offset the texture coordinates read into a map on another texture unit.  This (du,dv) offset is also rotated through a user-specified rotation matrix to get the texture coordinates into the appropriate space. A new texture format is introduced in order for specifying the (du,dv) bumpmap texture.  This map represents -1 <= du,dv <= 1 offsets to be applied to the texture coordinates used to read into the base map.  Additionally, the (du,dv) offsets are transformed by a rotation matrix that this extension allows the user to specify.  Further, a new color operation is added to EXT_texture_env_combine to specify both that bumpmapping is enabled and which texture unit to apply the bump offset to.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TexBumpParameteriv.</para>
        /// <para>Fullname: TexBumpParameterivATI</para>
        /// <para>Extensions: ATI_envmap_bumpmap</para>
        /// </summary>
        public static void TexBumpParameteriv(int pname, int[] param)
        {
            if (gl._TexBumpParameteriv != null) gl._TexBumpParameteriv(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: UnmapObjectBufferATI</para>
        /// </summary>
        [GLEntry("UnmapObjectBufferATI", Category = "ATI")]
        public static GLDelegate.UnmapObjectBuffer _UnmapObjectBuffer = null;
        /// <summary>
        /// <para>This extension provides a mechanism for an application to obtain the virtual address of an object buffer. This allows the application to directly update the contents of an object buffer and avoid any intermediate copies.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UnmapObjectBuffer.</para>
        /// <para>Fullname: UnmapObjectBufferATI</para>
        /// <para>Extensions: ATI_map_object_buffer</para>
        /// </summary>
        public static void UnmapObjectBuffer(uint buffer)
        {
            if (gl._UnmapObjectBuffer != null) gl._UnmapObjectBuffer(buffer); else { }
        }
        /// <summary>
        /// <para>Fullname: UpdateObjectBufferATI</para>
        /// </summary>
        [GLEntry("UpdateObjectBufferATI", Category = "ATI")]
        public static GLDelegate.UpdateObjectBuffer _UpdateObjectBuffer = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of vertex array data to be cached in persistent server-side memory. It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _UpdateObjectBuffer.</para>
        /// <para>Fullname: UpdateObjectBufferATI</para>
        /// <para>Extensions: ATI_vertex_array_object</para>
        /// </summary>
        public static void UpdateObjectBuffer(uint buffer, uint offset, int size, IntPtr pointer, int preserve)
        {
            if (gl._UpdateObjectBuffer != null) gl._UpdateObjectBuffer(buffer, offset, size, pointer, preserve); else { }
        }
        /// <summary>
        /// <para>Fullname: VariantArrayObjectATI</para>
        /// </summary>
        [GLEntry("VariantArrayObjectATI", Category = "ATI")]
        public static GLDelegate.VariantArrayObject _VariantArrayObject = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of vertex array data to be cached in persistent server-side memory. It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VariantArrayObject.</para>
        /// <para>Fullname: VariantArrayObjectATI</para>
        /// <para>Extensions: ATI_vertex_array_object</para>
        /// </summary>
        public static void VariantArrayObject(uint id, int type, int stride, uint buffer, uint offset)
        {
            if (gl._VariantArrayObject != null) gl._VariantArrayObject(id, type, stride, buffer, offset); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexAttribArrayObjectATI</para>
        /// </summary>
        [GLEntry("VertexAttribArrayObjectATI", Category = "ATI")]
        public static GLDelegate.VertexAttribArrayObject _VertexAttribArrayObject = null;
        /// <summary>
        /// <para>This extension defines an interface that allows multiple sets of generic vertex attribute data to be cached in persistent server-side memory.  It is intended to allow client data to be stored in memory that can be directly accessed by graphics hardware. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexAttribArrayObject.</para>
        /// <para>Fullname: VertexAttribArrayObjectATI</para>
        /// <para>Extensions: ATI_vertex_attrib_array_object</para>
        /// </summary>
        public static void VertexAttribArrayObject(uint index, int size, int type, bool normalized, int stride, uint buffer, uint offset)
        {
            if (gl._VertexAttribArrayObject != null) gl._VertexAttribArrayObject(index, size, type, normalized, stride, buffer, offset); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexBlendEnvfATI</para>
        /// </summary>
        [GLEntry("VertexBlendEnvfATI", Category = "ATI")]
        public static GLDelegate.VertexBlendEnvf _VertexBlendEnvf = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexBlendEnvf.</para>
        /// <para>Fullname: VertexBlendEnvfATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexBlendEnvf(int pname, float param)
        {
            if (gl._VertexBlendEnvf != null) gl._VertexBlendEnvf(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexBlendEnviATI</para>
        /// </summary>
        [GLEntry("VertexBlendEnviATI", Category = "ATI")]
        public static GLDelegate.VertexBlendEnvi _VertexBlendEnvi = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexBlendEnvi.</para>
        /// <para>Fullname: VertexBlendEnviATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexBlendEnvi(int pname, int param)
        {
            if (gl._VertexBlendEnvi != null) gl._VertexBlendEnvi(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream1dATI</para>
        /// </summary>
        [GLEntry("VertexStream1dATI", Category = "ATI")]
        public static GLDelegate.VertexStream1d _VertexStream1d = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream1d.</para>
        /// <para>Fullname: VertexStream1dATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream1d(int stream, double x)
        {
            if (gl._VertexStream1d != null) gl._VertexStream1d(stream, x); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream1dvATI</para>
        /// </summary>
        [GLEntry("VertexStream1dvATI", Category = "ATI")]
        public static GLDelegate.VertexStream1dv _VertexStream1dv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream1dv.</para>
        /// <para>Fullname: VertexStream1dvATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream1dv(int stream, double[] coords)
        {
            if (gl._VertexStream1dv != null) gl._VertexStream1dv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream1dvATI</para>
        /// </summary>
        [GLEntry("VertexStream1dvATI", Category = "ATI")]
        public static GLDelegate.VertexStream1dv_double _VertexStream1dv_double = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream1dv_double.</para>
        /// <para>Fullname: VertexStream1dvATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream1dv(int stream, ref double coords)
        {
            if (gl._VertexStream1dv_double != null) gl._VertexStream1dv_double(stream, ref coords); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream1fATI</para>
        /// </summary>
        [GLEntry("VertexStream1fATI", Category = "ATI")]
        public static GLDelegate.VertexStream1f _VertexStream1f = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream1f.</para>
        /// <para>Fullname: VertexStream1fATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream1f(int stream, float x)
        {
            if (gl._VertexStream1f != null) gl._VertexStream1f(stream, x); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream1fvATI</para>
        /// </summary>
        [GLEntry("VertexStream1fvATI", Category = "ATI")]
        public static GLDelegate.VertexStream1fv _VertexStream1fv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream1fv.</para>
        /// <para>Fullname: VertexStream1fvATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream1fv(int stream, float[] coords)
        {
            if (gl._VertexStream1fv != null) gl._VertexStream1fv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream1fvATI</para>
        /// </summary>
        [GLEntry("VertexStream1fvATI", Category = "ATI")]
        public static GLDelegate.VertexStream1fv_float _VertexStream1fv_float = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream1fv_float.</para>
        /// <para>Fullname: VertexStream1fvATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream1fv(int stream, ref float coords)
        {
            if (gl._VertexStream1fv_float != null) gl._VertexStream1fv_float(stream, ref coords); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream1iATI</para>
        /// </summary>
        [GLEntry("VertexStream1iATI", Category = "ATI")]
        public static GLDelegate.VertexStream1i _VertexStream1i = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream1i.</para>
        /// <para>Fullname: VertexStream1iATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream1i(int stream, int x)
        {
            if (gl._VertexStream1i != null) gl._VertexStream1i(stream, x); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream1ivATI</para>
        /// </summary>
        [GLEntry("VertexStream1ivATI", Category = "ATI")]
        public static GLDelegate.VertexStream1iv_int _VertexStream1iv_int = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream1iv_int.</para>
        /// <para>Fullname: VertexStream1ivATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream1iv(int stream, ref int coords)
        {
            if (gl._VertexStream1iv_int != null) gl._VertexStream1iv_int(stream, ref coords); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream1ivATI</para>
        /// </summary>
        [GLEntry("VertexStream1ivATI", Category = "ATI")]
        public static GLDelegate.VertexStream1iv _VertexStream1iv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream1iv.</para>
        /// <para>Fullname: VertexStream1ivATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream1iv(int stream, int[] coords)
        {
            if (gl._VertexStream1iv != null) gl._VertexStream1iv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream1sATI</para>
        /// </summary>
        [GLEntry("VertexStream1sATI", Category = "ATI")]
        public static GLDelegate.VertexStream1s _VertexStream1s = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream1s.</para>
        /// <para>Fullname: VertexStream1sATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream1s(int stream, short x)
        {
            if (gl._VertexStream1s != null) gl._VertexStream1s(stream, x); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream1svATI</para>
        /// </summary>
        [GLEntry("VertexStream1svATI", Category = "ATI")]
        public static GLDelegate.VertexStream1sv _VertexStream1sv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream1sv.</para>
        /// <para>Fullname: VertexStream1svATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream1sv(int stream, short[] coords)
        {
            if (gl._VertexStream1sv != null) gl._VertexStream1sv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream2dATI</para>
        /// </summary>
        [GLEntry("VertexStream2dATI", Category = "ATI")]
        public static GLDelegate.VertexStream2d _VertexStream2d = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream2d.</para>
        /// <para>Fullname: VertexStream2dATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream2d(int stream, double x, double y)
        {
            if (gl._VertexStream2d != null) gl._VertexStream2d(stream, x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream2dvATI</para>
        /// </summary>
        [GLEntry("VertexStream2dvATI", Category = "ATI")]
        public static GLDelegate.VertexStream2dv _VertexStream2dv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream2dv.</para>
        /// <para>Fullname: VertexStream2dvATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream2dv(int stream, double[] coords)
        {
            if (gl._VertexStream2dv != null) gl._VertexStream2dv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream2fATI</para>
        /// </summary>
        [GLEntry("VertexStream2fATI", Category = "ATI")]
        public static GLDelegate.VertexStream2f _VertexStream2f = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream2f.</para>
        /// <para>Fullname: VertexStream2fATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream2f(int stream, float x, float y)
        {
            if (gl._VertexStream2f != null) gl._VertexStream2f(stream, x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream2fvATI</para>
        /// </summary>
        [GLEntry("VertexStream2fvATI", Category = "ATI")]
        public static GLDelegate.VertexStream2fv _VertexStream2fv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream2fv.</para>
        /// <para>Fullname: VertexStream2fvATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream2fv(int stream, float[] coords)
        {
            if (gl._VertexStream2fv != null) gl._VertexStream2fv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream2iATI</para>
        /// </summary>
        [GLEntry("VertexStream2iATI", Category = "ATI")]
        public static GLDelegate.VertexStream2i _VertexStream2i = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream2i.</para>
        /// <para>Fullname: VertexStream2iATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream2i(int stream, int x, int y)
        {
            if (gl._VertexStream2i != null) gl._VertexStream2i(stream, x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream2ivATI</para>
        /// </summary>
        [GLEntry("VertexStream2ivATI", Category = "ATI")]
        public static GLDelegate.VertexStream2iv _VertexStream2iv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream2iv.</para>
        /// <para>Fullname: VertexStream2ivATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream2iv(int stream, int[] coords)
        {
            if (gl._VertexStream2iv != null) gl._VertexStream2iv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream2sATI</para>
        /// </summary>
        [GLEntry("VertexStream2sATI", Category = "ATI")]
        public static GLDelegate.VertexStream2s _VertexStream2s = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream2s.</para>
        /// <para>Fullname: VertexStream2sATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream2s(int stream, short x, short y)
        {
            if (gl._VertexStream2s != null) gl._VertexStream2s(stream, x, y); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream2svATI</para>
        /// </summary>
        [GLEntry("VertexStream2svATI", Category = "ATI")]
        public static GLDelegate.VertexStream2sv _VertexStream2sv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream2sv.</para>
        /// <para>Fullname: VertexStream2svATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream2sv(int stream, short[] coords)
        {
            if (gl._VertexStream2sv != null) gl._VertexStream2sv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream3dATI</para>
        /// </summary>
        [GLEntry("VertexStream3dATI", Category = "ATI")]
        public static GLDelegate.VertexStream3d _VertexStream3d = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream3d.</para>
        /// <para>Fullname: VertexStream3dATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream3d(int stream, double x, double y, double z)
        {
            if (gl._VertexStream3d != null) gl._VertexStream3d(stream, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream3dvATI</para>
        /// </summary>
        [GLEntry("VertexStream3dvATI", Category = "ATI")]
        public static GLDelegate.VertexStream3dv _VertexStream3dv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream3dv.</para>
        /// <para>Fullname: VertexStream3dvATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream3dv(int stream, double[] coords)
        {
            if (gl._VertexStream3dv != null) gl._VertexStream3dv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream3fATI</para>
        /// </summary>
        [GLEntry("VertexStream3fATI", Category = "ATI")]
        public static GLDelegate.VertexStream3f _VertexStream3f = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream3f.</para>
        /// <para>Fullname: VertexStream3fATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream3f(int stream, float x, float y, float z)
        {
            if (gl._VertexStream3f != null) gl._VertexStream3f(stream, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream3fvATI</para>
        /// </summary>
        [GLEntry("VertexStream3fvATI", Category = "ATI")]
        public static GLDelegate.VertexStream3fv _VertexStream3fv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream3fv.</para>
        /// <para>Fullname: VertexStream3fvATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream3fv(int stream, float[] coords)
        {
            if (gl._VertexStream3fv != null) gl._VertexStream3fv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream3iATI</para>
        /// </summary>
        [GLEntry("VertexStream3iATI", Category = "ATI")]
        public static GLDelegate.VertexStream3i _VertexStream3i = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream3i.</para>
        /// <para>Fullname: VertexStream3iATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream3i(int stream, int x, int y, int z)
        {
            if (gl._VertexStream3i != null) gl._VertexStream3i(stream, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream3ivATI</para>
        /// </summary>
        [GLEntry("VertexStream3ivATI", Category = "ATI")]
        public static GLDelegate.VertexStream3iv _VertexStream3iv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream3iv.</para>
        /// <para>Fullname: VertexStream3ivATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream3iv(int stream, int[] coords)
        {
            if (gl._VertexStream3iv != null) gl._VertexStream3iv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream3sATI</para>
        /// </summary>
        [GLEntry("VertexStream3sATI", Category = "ATI")]
        public static GLDelegate.VertexStream3s _VertexStream3s = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream3s.</para>
        /// <para>Fullname: VertexStream3sATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream3s(int stream, short x, short y, short z)
        {
            if (gl._VertexStream3s != null) gl._VertexStream3s(stream, x, y, z); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream3svATI</para>
        /// </summary>
        [GLEntry("VertexStream3svATI", Category = "ATI")]
        public static GLDelegate.VertexStream3sv _VertexStream3sv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream3sv.</para>
        /// <para>Fullname: VertexStream3svATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream3sv(int stream, short[] coords)
        {
            if (gl._VertexStream3sv != null) gl._VertexStream3sv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream4dATI</para>
        /// </summary>
        [GLEntry("VertexStream4dATI", Category = "ATI")]
        public static GLDelegate.VertexStream4d _VertexStream4d = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream4d.</para>
        /// <para>Fullname: VertexStream4dATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream4d(int stream, double x, double y, double z, double w)
        {
            if (gl._VertexStream4d != null) gl._VertexStream4d(stream, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream4dvATI</para>
        /// </summary>
        [GLEntry("VertexStream4dvATI", Category = "ATI")]
        public static GLDelegate.VertexStream4dv _VertexStream4dv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream4dv.</para>
        /// <para>Fullname: VertexStream4dvATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream4dv(int stream, double[] coords)
        {
            if (gl._VertexStream4dv != null) gl._VertexStream4dv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream4fATI</para>
        /// </summary>
        [GLEntry("VertexStream4fATI", Category = "ATI")]
        public static GLDelegate.VertexStream4f _VertexStream4f = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream4f.</para>
        /// <para>Fullname: VertexStream4fATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream4f(int stream, float x, float y, float z, float w)
        {
            if (gl._VertexStream4f != null) gl._VertexStream4f(stream, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream4fvATI</para>
        /// </summary>
        [GLEntry("VertexStream4fvATI", Category = "ATI")]
        public static GLDelegate.VertexStream4fv _VertexStream4fv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream4fv.</para>
        /// <para>Fullname: VertexStream4fvATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream4fv(int stream, float[] coords)
        {
            if (gl._VertexStream4fv != null) gl._VertexStream4fv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream4iATI</para>
        /// </summary>
        [GLEntry("VertexStream4iATI", Category = "ATI")]
        public static GLDelegate.VertexStream4i _VertexStream4i = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream4i.</para>
        /// <para>Fullname: VertexStream4iATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream4i(int stream, int x, int y, int z, int w)
        {
            if (gl._VertexStream4i != null) gl._VertexStream4i(stream, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream4ivATI</para>
        /// </summary>
        [GLEntry("VertexStream4ivATI", Category = "ATI")]
        public static GLDelegate.VertexStream4iv _VertexStream4iv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream4iv.</para>
        /// <para>Fullname: VertexStream4ivATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream4iv(int stream, int[] coords)
        {
            if (gl._VertexStream4iv != null) gl._VertexStream4iv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream4sATI</para>
        /// </summary>
        [GLEntry("VertexStream4sATI", Category = "ATI")]
        public static GLDelegate.VertexStream4s _VertexStream4s = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream4s.</para>
        /// <para>Fullname: VertexStream4sATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream4s(int stream, short x, short y, short z, short w)
        {
            if (gl._VertexStream4s != null) gl._VertexStream4s(stream, x, y, z, w); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexStream4svATI</para>
        /// </summary>
        [GLEntry("VertexStream4svATI", Category = "ATI")]
        public static GLDelegate.VertexStream4sv _VertexStream4sv = null;
        /// <summary>
        /// <para>This extension adds the ability to handle sets of auxilliary vertex and normal coordinates. These sets of auxilliary coordinates are termed streams, and can be routed selectively into the blend stages provided by the vertex blending extension. This functionality enables software animation techniques such as keyframe vertex morphing.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexStream4sv.</para>
        /// <para>Fullname: VertexStream4svATI</para>
        /// <para>Extensions: ATI_vertex_streams</para>
        /// </summary>
        public static void VertexStream4sv(int stream, short[] coords)
        {
            if (gl._VertexStream4sv != null) gl._VertexStream4sv(stream, coords); else { }
        }
        /// <summary>
        /// <para>Fullname: BufferParameteriAPPLE</para>
        /// </summary>
        [GLEntry("BufferParameteriAPPLE", Category = "APPLE")]
        public static GLDelegate.BufferParameteri _BufferParameteri = null;
        /// <summary>
        /// <para>APPLE_flush_buffer_range expands the buffer object API to allow greater performance when a client application only needs to write to a sub-range of a buffer object. To that end, this extension introduces two new buffer object features: non-serialized buffer modification and explicit sub-range flushing for mapped buffer objects. OpenGL requires that commands occur in a FIFO manner meaning that any changes to buffer objects either block until the data has been processed by the OpenGL pipeline or else create extra copies to avoid such a block.  By providing a method to asynchronously modify buffer object data, an application is then able to manage the synchronization points themselves and modify ranges of data contained by a buffer object even though OpenGL might still be using other parts of it. This extension also provides a method for explicitly flushing ranges of a mapped buffer object so OpenGL does not have to assume that the entire range may have been modified. Affects ARB_vertex_b...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BufferParameteri.</para>
        /// <para>Fullname: BufferParameteriAPPLE</para>
        /// <para>Extensions: APPLE_flush_buffer_range</para>
        /// </summary>
        public static void BufferParameteri(int target, int pname, int param)
        {
            if (gl._BufferParameteri != null) gl._BufferParameteri(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: DisableVertexAttribAPPLE</para>
        /// </summary>
        [GLEntry("DisableVertexAttribAPPLE", Category = "APPLE")]
        public static GLDelegate.DisableVertexAttrib _DisableVertexAttrib = null;
        /// <summary>
        /// <para>This extension allows the one- and two-dimensional evaluators to be used with vertex program attributes.  The operation of this extension is precisely analogous to the operation of the normal evaluators. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DisableVertexAttrib.</para>
        /// <para>Fullname: DisableVertexAttribAPPLE</para>
        /// <para>Extensions: APPLE_vertex_program_evaluators</para>
        /// </summary>
        public static void DisableVertexAttrib(uint index, int pname)
        {
            if (gl._DisableVertexAttrib != null) gl._DisableVertexAttrib(index, pname); else { }
        }
        /// <summary>
        /// <para>Fullname: DrawElementArrayAPPLE</para>
        /// </summary>
        [GLEntry("DrawElementArrayAPPLE", Category = "APPLE")]
        public static GLDelegate.DrawElementArrayAPPLE _DrawElementArrayAPPLE = null;
        /// <summary>
        /// <para>This extension provides facilities to improve DrawElements style vertex indices submission performance by allowing index arrays.  Using this extension these arrays can be contained inside a vertex array range and thus pulled directly by the graphics processor, avoiding the CPU overhead of touching the index data. This extension is most useful when used in conjunction with the APPLE_vertex_array_range extension. APPLE_vertex_array_range provides an interface for storing vertex array data. In cases where large amounts of vertex data are in use, the index data used to construct primitives (typically as passed to the GL through DrawElements) can impose a significant bandwidth burden. APPLE_element_array allows the application to specify independent arrays of elements, which can then be cached using APPLE_vertex_array_range.  In effect this creates a more orthogonal interface for both vertex indices and data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawElementArrayAPPLE.</para>
        /// <para>Fullname: DrawElementArrayAPPLE</para>
        /// <para>Extensions: APPLE_element_array</para>
        /// </summary>
        public static void DrawElementArrayAPPLE(int mode, int first, int count)
        {
            if (gl._DrawElementArrayAPPLE != null) gl._DrawElementArrayAPPLE(mode, first, count); else { }
        }
        /// <summary>
        /// <para>Fullname: DrawRangeElementArrayAPPLE</para>
        /// </summary>
        [GLEntry("DrawRangeElementArrayAPPLE", Category = "APPLE")]
        public static GLDelegate.DrawRangeElementArrayAPPLE _DrawRangeElementArrayAPPLE = null;
        /// <summary>
        /// <para>This extension provides facilities to improve DrawElements style vertex indices submission performance by allowing index arrays.  Using this extension these arrays can be contained inside a vertex array range and thus pulled directly by the graphics processor, avoiding the CPU overhead of touching the index data. This extension is most useful when used in conjunction with the APPLE_vertex_array_range extension. APPLE_vertex_array_range provides an interface for storing vertex array data. In cases where large amounts of vertex data are in use, the index data used to construct primitives (typically as passed to the GL through DrawElements) can impose a significant bandwidth burden. APPLE_element_array allows the application to specify independent arrays of elements, which can then be cached using APPLE_vertex_array_range.  In effect this creates a more orthogonal interface for both vertex indices and data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DrawRangeElementArrayAPPLE.</para>
        /// <para>Fullname: DrawRangeElementArrayAPPLE</para>
        /// <para>Extensions: APPLE_element_array</para>
        /// </summary>
        public static void DrawRangeElementArrayAPPLE(int mode, uint start, uint end, int first, int count)
        {
            if (gl._DrawRangeElementArrayAPPLE != null) gl._DrawRangeElementArrayAPPLE(mode, start, end, first, count); else { }
        }
        /// <summary>
        /// <para>Fullname: EnableVertexAttribAPPLE</para>
        /// </summary>
        [GLEntry("EnableVertexAttribAPPLE", Category = "APPLE")]
        public static GLDelegate.EnableVertexAttrib _EnableVertexAttrib = null;
        /// <summary>
        /// <para>This extension allows the one- and two-dimensional evaluators to be used with vertex program attributes.  The operation of this extension is precisely analogous to the operation of the normal evaluators. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EnableVertexAttrib.</para>
        /// <para>Fullname: EnableVertexAttribAPPLE</para>
        /// <para>Extensions: APPLE_vertex_program_evaluators</para>
        /// </summary>
        public static void EnableVertexAttrib(uint index, int pname)
        {
            if (gl._EnableVertexAttrib != null) gl._EnableVertexAttrib(index, pname); else { }
        }
        /// <summary>
        /// <para>Fullname: FinishObjectAPPLE</para>
        /// </summary>
        [GLEntry("FinishObjectAPPLE", Category = "APPLE")]
        public static GLDelegate.FinishObject _FinishObject = null;
        /// <summary>
        /// <para>This extension is provided a finer granularity of synchronizing GL command completion than offered by standard OpenGL, which currently offers only two mechanisms for synchronization: Flush and Finish. Since Flush merely assures the user that the commands complete in a finite (though undetermined) amount of time, it is, thus, of only modest utility.  Finish, on the other hand, stalls CPU execution until all pending GL commands have completed forcing completely synchronous operation, which most often not the desired result. This extension offers a middle ground - the ability to "finish" a subset of the command stream, and the ability to determine whether a given command has completed or not. This extension introduces the concept of a "fence" to the OpenGL command stream with SetFenceAPPLE.  Once the fence is inserted into the command stream, it can be tested for its completion with TestFenceAPPLE. Moreover, the application may also request a partial Finish up to a particular "fence" usin...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FinishObject.</para>
        /// <para>Fullname: FinishObjectAPPLE</para>
        /// <para>Extensions: APPLE_fence</para>
        /// </summary>
        public static void FinishObject(int obj, int name)
        {
            if (gl._FinishObject != null) gl._FinishObject(obj, name); else { }
        }
        /// <summary>
        /// <para>Fullname: FlushVertexArrayRangeAPPLE</para>
        /// </summary>
        [GLEntry("FlushVertexArrayRangeAPPLE", Category = "APPLE")]
        public static GLDelegate.FlushVertexArrayRangeAPPLE _FlushVertexArrayRangeAPPLE = null;
        /// <summary>
        /// <para>This extension is designed to allow very high vertex processing rates which are facilitated both by relieving the CPU of as much processing burden as possible and by allowing graphics hardware to directly access vertex data. Because this extension is implemented as an addition to the vertex array specification provided by OpenGL 1.1, applications can continue to use existing vertex submission logic while taking advantage of vertex array ranges to more efficiently process those arrays. The vertex array coherency model provided by OpenGL 1.1 requires that vertex data specified in vertex arrays be transferred from system memory each time Begin, DrawArrays, or DrawElements is called.  Further, OpenGL 1.1 requires that the transfer of data be completed by the time End, DrawArrays, or DrawElements returns.  Both of these requirements are relaxed by the vertex array range extension.  Vertex data may be cached by the GL so there is no guarantee that changes to the vertex data will be reflected...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FlushVertexArrayRangeAPPLE.</para>
        /// <para>Fullname: FlushVertexArrayRangeAPPLE</para>
        /// <para>Extensions: APPLE_vertex_array_range</para>
        /// </summary>
        public static void FlushVertexArrayRangeAPPLE(int length, IntPtr pointer)
        {
            if (gl._FlushVertexArrayRangeAPPLE != null) gl._FlushVertexArrayRangeAPPLE(length, pointer); else { }
        }
        /// <summary>
        /// <para>Fullname: GetObjectParameterivAPPLE</para>
        /// </summary>
        [GLEntry("GetObjectParameterivAPPLE", Category = "APPLE")]
        public static GLDelegate.GetObjectParameterivAPPLE _GetObjectParameterivAPPLE = null;
        /// <summary>
        /// <para>This extension provides the ability to mark the storage of OpenGL objects as "purgeable". Many of today's modern virtual memory systems include the concept of purgeability in order to avoid unnecessary paging when the object contents are no longer needed.  In OpenGL, objects such as textures, vertex buffers, pixel buffers, and renderbuffers all have significant storage requirements.  By default, the OpenGL is required to preserve the contents of these objects regardless of system resource stress, such as vram shortage or physical memory shortage.  Often this is accomplished by temporarily paging the contents of objects that are not currently needed to some kind of secondary storage area.  This paging operation can be an unnecessary computational expense in the cases where the data is not going to be used again or where the content can be reproduced by the application with less expense than the paging operation would require.  This extension defines a mechanism for the application to ma...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetObjectParameterivAPPLE.</para>
        /// <para>Fullname: GetObjectParameterivAPPLE</para>
        /// <para>Extensions: APPLE_object_purgeable</para>
        /// </summary>
        public static void GetObjectParameterivAPPLE(int objectType, uint name, int pname, int[] param)
        {
            if (gl._GetObjectParameterivAPPLE != null) gl._GetObjectParameterivAPPLE(objectType, name, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: GetTexParameterPointervAPPLE</para>
        /// </summary>
        [GLEntry("GetTexParameterPointervAPPLE", Category = "APPLE")]
        public static GLDelegate.GetTexParameterPointerv _GetTexParameterPointerv = null;
        /// <summary>
        /// <para>This extension provides a method to specify the range of client address space that may be used by a texture.  In general, the storage size of a texture may be easily determined by the texture's data type and geometry. However, driver optimizations may be realized if an extended address range is specified to encompass the storage of multiple textures, or to encompass potential future changes in the size of a texture.  A typical usage of this extension is to specify an identical address range for several textures in a particular working set that encompasses the storage of all the textures in the set.  This allows the driver to make a single memory mapping for all of the textures. Further, a mechanism is provided to allow the application to give the GL driver a hint regarding the storage requirements of the texture data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetTexParameterPointerv.</para>
        /// <para>Fullname: GetTexParameterPointervAPPLE</para>
        /// <para>Extensions: APPLE_texture_range</para>
        /// </summary>
        public static void GetTexParameterPointerv(int target, int pname, IntPtr[] param)
        {
            if (gl._GetTexParameterPointerv != null) gl._GetTexParameterPointerv(target, pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: IsVertexAttribEnabledAPPLE</para>
        /// </summary>
        [GLEntry("IsVertexAttribEnabledAPPLE", Category = "APPLE")]
        public static GLDelegate.IsVertexAttribEnabled _IsVertexAttribEnabled = null;
        /// <summary>
        /// <para>This extension allows the one- and two-dimensional evaluators to be used with vertex program attributes.  The operation of this extension is precisely analogous to the operation of the normal evaluators. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsVertexAttribEnabled.</para>
        /// <para>Fullname: IsVertexAttribEnabledAPPLE</para>
        /// <para>Extensions: APPLE_vertex_program_evaluators</para>
        /// </summary>
        public static bool IsVertexAttribEnabled(uint index, int pname)
        {
            if (gl._IsVertexAttribEnabled != null) return gl._IsVertexAttribEnabled(index, pname);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: MapVertexAttrib1dAPPLE</para>
        /// </summary>
        [GLEntry("MapVertexAttrib1dAPPLE", Category = "APPLE")]
        public static GLDelegate.MapVertexAttrib1d _MapVertexAttrib1d = null;
        /// <summary>
        /// <para>This extension allows the one- and two-dimensional evaluators to be used with vertex program attributes.  The operation of this extension is precisely analogous to the operation of the normal evaluators. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MapVertexAttrib1d.</para>
        /// <para>Fullname: MapVertexAttrib1dAPPLE</para>
        /// <para>Extensions: APPLE_vertex_program_evaluators</para>
        /// </summary>
        public static void MapVertexAttrib1d(uint index, uint size, double u1, double u2, int stride, int order, double[] points)
        {
            if (gl._MapVertexAttrib1d != null) gl._MapVertexAttrib1d(index, size, u1, u2, stride, order, points); else { }
        }
        /// <summary>
        /// <para>Fullname: MapVertexAttrib1fAPPLE</para>
        /// </summary>
        [GLEntry("MapVertexAttrib1fAPPLE", Category = "APPLE")]
        public static GLDelegate.MapVertexAttrib1f _MapVertexAttrib1f = null;
        /// <summary>
        /// <para>This extension allows the one- and two-dimensional evaluators to be used with vertex program attributes.  The operation of this extension is precisely analogous to the operation of the normal evaluators. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MapVertexAttrib1f.</para>
        /// <para>Fullname: MapVertexAttrib1fAPPLE</para>
        /// <para>Extensions: APPLE_vertex_program_evaluators</para>
        /// </summary>
        public static void MapVertexAttrib1f(uint index, uint size, float u1, float u2, int stride, int order, float[] points)
        {
            if (gl._MapVertexAttrib1f != null) gl._MapVertexAttrib1f(index, size, u1, u2, stride, order, points); else { }
        }
        /// <summary>
        /// <para>Fullname: MapVertexAttrib2dAPPLE</para>
        /// </summary>
        [GLEntry("MapVertexAttrib2dAPPLE", Category = "APPLE")]
        public static GLDelegate.MapVertexAttrib2d _MapVertexAttrib2d = null;
        /// <summary>
        /// <para>This extension allows the one- and two-dimensional evaluators to be used with vertex program attributes.  The operation of this extension is precisely analogous to the operation of the normal evaluators. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MapVertexAttrib2d.</para>
        /// <para>Fullname: MapVertexAttrib2dAPPLE</para>
        /// <para>Extensions: APPLE_vertex_program_evaluators</para>
        /// </summary>
        public static void MapVertexAttrib2d(uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double[] points)
        {
            if (gl._MapVertexAttrib2d != null) gl._MapVertexAttrib2d(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points); else { }
        }
        /// <summary>
        /// <para>Fullname: MapVertexAttrib2fAPPLE</para>
        /// </summary>
        [GLEntry("MapVertexAttrib2fAPPLE", Category = "APPLE")]
        public static GLDelegate.MapVertexAttrib2f _MapVertexAttrib2f = null;
        /// <summary>
        /// <para>This extension allows the one- and two-dimensional evaluators to be used with vertex program attributes.  The operation of this extension is precisely analogous to the operation of the normal evaluators. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MapVertexAttrib2f.</para>
        /// <para>Fullname: MapVertexAttrib2fAPPLE</para>
        /// <para>Extensions: APPLE_vertex_program_evaluators</para>
        /// </summary>
        public static void MapVertexAttrib2f(uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float[] points)
        {
            if (gl._MapVertexAttrib2f != null) gl._MapVertexAttrib2f(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiDrawElementArrayAPPLE</para>
        /// </summary>
        [GLEntry("MultiDrawElementArrayAPPLE", Category = "APPLE")]
        public static GLDelegate.MultiDrawElementArray _MultiDrawElementArray = null;
        /// <summary>
        /// <para>This extension provides facilities to improve DrawElements style vertex indices submission performance by allowing index arrays.  Using this extension these arrays can be contained inside a vertex array range and thus pulled directly by the graphics processor, avoiding the CPU overhead of touching the index data. This extension is most useful when used in conjunction with the APPLE_vertex_array_range extension. APPLE_vertex_array_range provides an interface for storing vertex array data. In cases where large amounts of vertex data are in use, the index data used to construct primitives (typically as passed to the GL through DrawElements) can impose a significant bandwidth burden. APPLE_element_array allows the application to specify independent arrays of elements, which can then be cached using APPLE_vertex_array_range.  In effect this creates a more orthogonal interface for both vertex indices and data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiDrawElementArray.</para>
        /// <para>Fullname: MultiDrawElementArrayAPPLE</para>
        /// <para>Extensions: APPLE_element_array</para>
        /// </summary>
        public static void MultiDrawElementArray(int mode, int[] first, int[] count, int primcount)
        {
            if (gl._MultiDrawElementArray != null) gl._MultiDrawElementArray(mode, first, count, primcount); else { }
        }
        /// <summary>
        /// <para>Fullname: MultiDrawRangeElementArrayAPPLE</para>
        /// </summary>
        [GLEntry("MultiDrawRangeElementArrayAPPLE", Category = "APPLE")]
        public static GLDelegate.MultiDrawRangeElementArray _MultiDrawRangeElementArray = null;
        /// <summary>
        /// <para>This extension provides facilities to improve DrawElements style vertex indices submission performance by allowing index arrays.  Using this extension these arrays can be contained inside a vertex array range and thus pulled directly by the graphics processor, avoiding the CPU overhead of touching the index data. This extension is most useful when used in conjunction with the APPLE_vertex_array_range extension. APPLE_vertex_array_range provides an interface for storing vertex array data. In cases where large amounts of vertex data are in use, the index data used to construct primitives (typically as passed to the GL through DrawElements) can impose a significant bandwidth burden. APPLE_element_array allows the application to specify independent arrays of elements, which can then be cached using APPLE_vertex_array_range.  In effect this creates a more orthogonal interface for both vertex indices and data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _MultiDrawRangeElementArray.</para>
        /// <para>Fullname: MultiDrawRangeElementArrayAPPLE</para>
        /// <para>Extensions: APPLE_element_array</para>
        /// </summary>
        public static void MultiDrawRangeElementArray(int mode, uint start, uint end, int[] first, int[] count, int primcount)
        {
            if (gl._MultiDrawRangeElementArray != null) gl._MultiDrawRangeElementArray(mode, start, end, first, count, primcount); else { }
        }
        /// <summary>
        /// <para>Fullname: ObjectPurgeableAPPLE</para>
        /// </summary>
        [GLEntry("ObjectPurgeableAPPLE", Category = "APPLE")]
        public static GLDelegate.ObjectPurgeable _ObjectPurgeable = null;
        /// <summary>
        /// <para>This extension provides the ability to mark the storage of OpenGL objects as "purgeable". Many of today's modern virtual memory systems include the concept of purgeability in order to avoid unnecessary paging when the object contents are no longer needed.  In OpenGL, objects such as textures, vertex buffers, pixel buffers, and renderbuffers all have significant storage requirements.  By default, the OpenGL is required to preserve the contents of these objects regardless of system resource stress, such as vram shortage or physical memory shortage.  Often this is accomplished by temporarily paging the contents of objects that are not currently needed to some kind of secondary storage area.  This paging operation can be an unnecessary computational expense in the cases where the data is not going to be used again or where the content can be reproduced by the application with less expense than the paging operation would require.  This extension defines a mechanism for the application to ma...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ObjectPurgeable.</para>
        /// <para>Fullname: ObjectPurgeableAPPLE</para>
        /// <para>Extensions: APPLE_object_purgeable</para>
        /// </summary>
        public static int ObjectPurgeable(int objectType, uint name, int option)
        {
            if (gl._ObjectPurgeable != null) return gl._ObjectPurgeable(objectType, name, option);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: ObjectUnpurgeableAPPLE</para>
        /// </summary>
        [GLEntry("ObjectUnpurgeableAPPLE", Category = "APPLE")]
        public static GLDelegate.ObjectUnpurgeable _ObjectUnpurgeable = null;
        /// <summary>
        /// <para>This extension provides the ability to mark the storage of OpenGL objects as "purgeable". Many of today's modern virtual memory systems include the concept of purgeability in order to avoid unnecessary paging when the object contents are no longer needed.  In OpenGL, objects such as textures, vertex buffers, pixel buffers, and renderbuffers all have significant storage requirements.  By default, the OpenGL is required to preserve the contents of these objects regardless of system resource stress, such as vram shortage or physical memory shortage.  Often this is accomplished by temporarily paging the contents of objects that are not currently needed to some kind of secondary storage area.  This paging operation can be an unnecessary computational expense in the cases where the data is not going to be used again or where the content can be reproduced by the application with less expense than the paging operation would require.  This extension defines a mechanism for the application to ma...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _ObjectUnpurgeable.</para>
        /// <para>Fullname: ObjectUnpurgeableAPPLE</para>
        /// <para>Extensions: APPLE_object_purgeable</para>
        /// </summary>
        public static int ObjectUnpurgeable(int objectType, uint name, int option)
        {
            if (gl._ObjectUnpurgeable != null) return gl._ObjectUnpurgeable(objectType, name, option);
            else { return (int)0; }
        }
        /// <summary>
        /// <para>Fullname: SetFenceAPPLE</para>
        /// </summary>
        [GLEntry("SetFenceAPPLE", Category = "APPLE")]
        public static GLDelegate.SetFenceAPPLE _SetFenceAPPLE = null;
        /// <summary>
        /// <para>This extension is provided a finer granularity of synchronizing GL command completion than offered by standard OpenGL, which currently offers only two mechanisms for synchronization: Flush and Finish. Since Flush merely assures the user that the commands complete in a finite (though undetermined) amount of time, it is, thus, of only modest utility.  Finish, on the other hand, stalls CPU execution until all pending GL commands have completed forcing completely synchronous operation, which most often not the desired result. This extension offers a middle ground - the ability to "finish" a subset of the command stream, and the ability to determine whether a given command has completed or not. This extension introduces the concept of a "fence" to the OpenGL command stream with SetFenceAPPLE.  Once the fence is inserted into the command stream, it can be tested for its completion with TestFenceAPPLE. Moreover, the application may also request a partial Finish up to a particular "fence" usin...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SetFenceAPPLE.</para>
        /// <para>Fullname: SetFenceAPPLE</para>
        /// <para>Extensions: APPLE_fence</para>
        /// </summary>
        public static void SetFenceAPPLE(uint fence)
        {
            if (gl._SetFenceAPPLE != null) gl._SetFenceAPPLE(fence); else { }
        }
        /// <summary>
        /// <para>Fullname: TestObjectAPPLE</para>
        /// </summary>
        [GLEntry("TestObjectAPPLE", Category = "APPLE")]
        public static GLDelegate.TestObject _TestObject = null;
        /// <summary>
        /// <para>This extension is provided a finer granularity of synchronizing GL command completion than offered by standard OpenGL, which currently offers only two mechanisms for synchronization: Flush and Finish. Since Flush merely assures the user that the commands complete in a finite (though undetermined) amount of time, it is, thus, of only modest utility.  Finish, on the other hand, stalls CPU execution until all pending GL commands have completed forcing completely synchronous operation, which most often not the desired result. This extension offers a middle ground - the ability to "finish" a subset of the command stream, and the ability to determine whether a given command has completed or not. This extension introduces the concept of a "fence" to the OpenGL command stream with SetFenceAPPLE.  Once the fence is inserted into the command stream, it can be tested for its completion with TestFenceAPPLE. Moreover, the application may also request a partial Finish up to a particular "fence" usin...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TestObject.</para>
        /// <para>Fullname: TestObjectAPPLE</para>
        /// <para>Extensions: APPLE_fence</para>
        /// </summary>
        public static bool TestObject(int obj, uint name)
        {
            if (gl._TestObject != null) return gl._TestObject(obj, name);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: TextureRangeAPPLE</para>
        /// </summary>
        [GLEntry("TextureRangeAPPLE", Category = "APPLE")]
        public static GLDelegate.TextureRange _TextureRange = null;
        /// <summary>
        /// <para>This extension provides a method to specify the range of client address space that may be used by a texture.  In general, the storage size of a texture may be easily determined by the texture's data type and geometry. However, driver optimizations may be realized if an extended address range is specified to encompass the storage of multiple textures, or to encompass potential future changes in the size of a texture.  A typical usage of this extension is to specify an identical address range for several textures in a particular working set that encompasses the storage of all the textures in the set.  This allows the driver to make a single memory mapping for all of the textures. Further, a mechanism is provided to allow the application to give the GL driver a hint regarding the storage requirements of the texture data. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TextureRange.</para>
        /// <para>Fullname: TextureRangeAPPLE</para>
        /// <para>Extensions: APPLE_texture_range</para>
        /// </summary>
        public static void TextureRange(int target, int length, IntPtr pointer)
        {
            if (gl._TextureRange != null) gl._TextureRange(target, length, pointer); else { }
        }
        /// <summary>
        /// <para>Fullname: VertexArrayParameteriAPPLE</para>
        /// </summary>
        [GLEntry("VertexArrayParameteriAPPLE", Category = "APPLE")]
        public static GLDelegate.VertexArrayParameteri _VertexArrayParameteri = null;
        /// <summary>
        /// <para>This extension is designed to allow very high vertex processing rates which are facilitated both by relieving the CPU of as much processing burden as possible and by allowing graphics hardware to directly access vertex data. Because this extension is implemented as an addition to the vertex array specification provided by OpenGL 1.1, applications can continue to use existing vertex submission logic while taking advantage of vertex array ranges to more efficiently process those arrays. The vertex array coherency model provided by OpenGL 1.1 requires that vertex data specified in vertex arrays be transferred from system memory each time Begin, DrawArrays, or DrawElements is called.  Further, OpenGL 1.1 requires that the transfer of data be completed by the time End, DrawArrays, or DrawElements returns.  Both of these requirements are relaxed by the vertex array range extension.  Vertex data may be cached by the GL so there is no guarantee that changes to the vertex data will be reflected...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _VertexArrayParameteri.</para>
        /// <para>Fullname: VertexArrayParameteriAPPLE</para>
        /// <para>Extensions: APPLE_vertex_array_range</para>
        /// </summary>
        public static void VertexArrayParameteri(int pname, int param)
        {
            if (gl._VertexArrayParameteri != null) gl._VertexArrayParameteri(pname, param); else { }
        }
        /// <summary>
        /// <para>Fullname: FrameTerminatorGREMEDY</para>
        /// </summary>
        [GLEntry("FrameTerminatorGREMEDY", Category = "GREMEDY")]
        public static GLDelegate.FrameTerminator _FrameTerminator = null;
        /// <summary>
        /// <para>This extension defines a mechanism that enables marking the end of render frames within the OpenGL stream.  When debugging or profiling an OpenGL application, the debuggers and profilers needs to know when a render frame is ended. This is important for frame per second measurements, statistical analysis, marking and clearing stream loggers logs, performance counters sampling and more.  When an application uses off screen buffers, the debugger / profiler cannot be guaranteed that the application will call a certain function at the end of each off-screen frame (e.g: SwapBuffers / glClear / etc). This extension enables the application to notify the debugger / profiler whenever a render frame is ended.  This extension is mainly useful for debuggers and profilers. It is not expected that standard drivers would implement this extension. The main point of having this extension is to allow applications to have a clean way of accessing this functionality only when they are run under the control...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _FrameTerminator.</para>
        /// <para>Fullname: FrameTerminatorGREMEDY</para>
        /// <para>Extensions: GREMEDY_frame_terminator</para>
        /// </summary>
        public static void FrameTerminator()
        {
            if (gl._FrameTerminator != null) gl._FrameTerminator(); else { }
        }
        /// <summary>
        /// <para>Fullname: StringMarkerGREMEDY</para>
        /// </summary>
        [GLEntry("StringMarkerGREMEDY", Category = "GREMEDY")]
        public static GLDelegate.StringMarker _StringMarker = null;
        /// <summary>
        /// <para>This extension defines a mechanism to insert textual markers into the OpenGL stream. When debugging or profiling an OpenGL application some of the most important tools are stream loggers, which just output a list of the called OpenGL commands, and profilers, which show at which points the pipeline is bottlenecked for a given part of the frame. The problem in using these is that there is a definite loss of information between the application and the used debugger/profiler. The application generally has a pretty good idea what is rendered when (e.g. rendering background, landscape, building, players, particle effects, bullets etc.), but the debugger/profiler only sees the OpenGL stream. To analyze the stream developers have to guess what is done when by following the program code and the log output in parallel, which can get difficult for systems that restructure their internal pipeline or do lazy changes. This extension is really only useful for these debuggers and profilers, and not fo...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _StringMarker.</para>
        /// <para>Fullname: StringMarkerGREMEDY</para>
        /// <para>Extensions: GREMEDY_string_marker</para>
        /// </summary>
        public static void StringMarker(int len, IntPtr str)
        {
            if (gl._StringMarker != null) gl._StringMarker(len, str); else { }
        }
        /// <summary>
        /// <para>Fullname: BeginPerfMonitorAMD</para>
        /// </summary>
        [GLEntry("BeginPerfMonitorAMD", Category = "AMD")]
        public static GLDelegate.BeginPerfMonitor _BeginPerfMonitor = null;
        /// <summary>
        /// <para>This extension enables the capture and reporting of performance monitors. Performance monitors contain groups of counters which hold arbitrary counted data.  Typically, the counters hold information on performance-related counters in the underlying hardware.  The extension is general enough to allow the implementation to choose which counters to expose and pick the data type and range of the counters.  The extension also allows counting to start and end on arbitrary boundaries during rendering. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BeginPerfMonitor.</para>
        /// <para>Fullname: BeginPerfMonitorAMD</para>
        /// <para>Extensions: AMD_performance_monitor</para>
        /// </summary>
        public static void BeginPerfMonitor(uint monitor)
        {
            if (gl._BeginPerfMonitor != null) gl._BeginPerfMonitor(monitor); else { }
        }
        /// <summary>
        /// <para>Fullname: BlendEquationIndexedAMD</para>
        /// </summary>
        [GLEntry("BlendEquationIndexedAMD", Category = "AMD")]
        public static GLDelegate.BlendEquationIndexed _BlendEquationIndexed = null;
        /// <summary>
        /// <para>This extension builds upon the ARB_draw_buffers and EXT_draw_buffers2 extensions. In ARB_draw_buffers (part of OpenGL 2.0), separate values could be written to each color buffer.  This was further enhanced by EXT_draw_buffers2 by adding in the ability to enable blending and to set color write masks independently per color output. This extension provides the ability to set individual blend equations and blend functions for each color output. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BlendEquationIndexed.</para>
        /// <para>Fullname: BlendEquationIndexedAMD</para>
        /// <para>Extensions: AMD_draw_buffers_blend</para>
        /// </summary>
        public static void BlendEquationIndexed(uint buf, int mode)
        {
            if (gl._BlendEquationIndexed != null) gl._BlendEquationIndexed(buf, mode); else { }
        }
        /// <summary>
        /// <para>Fullname: BlendEquationSeparateIndexedAMD</para>
        /// </summary>
        [GLEntry("BlendEquationSeparateIndexedAMD", Category = "AMD")]
        public static GLDelegate.BlendEquationSeparateIndexed _BlendEquationSeparateIndexed = null;
        /// <summary>
        /// <para>This extension builds upon the ARB_draw_buffers and EXT_draw_buffers2 extensions. In ARB_draw_buffers (part of OpenGL 2.0), separate values could be written to each color buffer.  This was further enhanced by EXT_draw_buffers2 by adding in the ability to enable blending and to set color write masks independently per color output. This extension provides the ability to set individual blend equations and blend functions for each color output. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BlendEquationSeparateIndexed.</para>
        /// <para>Fullname: BlendEquationSeparateIndexedAMD</para>
        /// <para>Extensions: AMD_draw_buffers_blend</para>
        /// </summary>
        public static void BlendEquationSeparateIndexed(uint buf, int modeRGB, int modeAlpha)
        {
            if (gl._BlendEquationSeparateIndexed != null) gl._BlendEquationSeparateIndexed(buf, modeRGB, modeAlpha); else { }
        }
        /// <summary>
        /// <para>Fullname: BlendFuncIndexedAMD</para>
        /// </summary>
        [GLEntry("BlendFuncIndexedAMD", Category = "AMD")]
        public static GLDelegate.BlendFuncIndexed _BlendFuncIndexed = null;
        /// <summary>
        /// <para>This extension builds upon the ARB_draw_buffers and EXT_draw_buffers2 extensions. In ARB_draw_buffers (part of OpenGL 2.0), separate values could be written to each color buffer.  This was further enhanced by EXT_draw_buffers2 by adding in the ability to enable blending and to set color write masks independently per color output. This extension provides the ability to set individual blend equations and blend functions for each color output. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BlendFuncIndexed.</para>
        /// <para>Fullname: BlendFuncIndexedAMD</para>
        /// <para>Extensions: AMD_draw_buffers_blend</para>
        /// </summary>
        public static void BlendFuncIndexed(uint buf, int src, int dst)
        {
            if (gl._BlendFuncIndexed != null) gl._BlendFuncIndexed(buf, src, dst); else { }
        }
        /// <summary>
        /// <para>Fullname: BlendFuncSeparateIndexedAMD</para>
        /// </summary>
        [GLEntry("BlendFuncSeparateIndexedAMD", Category = "AMD")]
        public static GLDelegate.BlendFuncSeparateIndexed _BlendFuncSeparateIndexed = null;
        /// <summary>
        /// <para>This extension builds upon the ARB_draw_buffers and EXT_draw_buffers2 extensions. In ARB_draw_buffers (part of OpenGL 2.0), separate values could be written to each color buffer.  This was further enhanced by EXT_draw_buffers2 by adding in the ability to enable blending and to set color write masks independently per color output. This extension provides the ability to set individual blend equations and blend functions for each color output. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _BlendFuncSeparateIndexed.</para>
        /// <para>Fullname: BlendFuncSeparateIndexedAMD</para>
        /// <para>Extensions: AMD_draw_buffers_blend</para>
        /// </summary>
        public static void BlendFuncSeparateIndexed(uint buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha)
        {
            if (gl._BlendFuncSeparateIndexed != null) gl._BlendFuncSeparateIndexed(buf, srcRGB, dstRGB, srcAlpha, dstAlpha); else { }
        }
        /// <summary>
        /// <para>Fullname: DebugMessageCallbackAMD</para>
        /// </summary>
        [GLEntry("DebugMessageCallbackAMD", Category = "AMD")]
        public static GLDelegate.DebugMessageCallbackAMD _DebugMessageCallbackAMD = null;
        /// <summary>
        /// <para>This extension allows the GL to notify applications when various debug events occur in contexts that have been created with the debug flag, as provided by WGL_ARB_create_context and GLX_ARB_create_context.  These events are represented in the form of enumerable messages with an included human-readable translation.  Examples of debug events include incorrect use of the GL, warnings of undefined behavior, and performance warnings.  A message is uniquely identified by a category and an implementation- dependent ID within that category.  Message categories are general and are used to organize large groups of similar messages together.  Examples of categories include GL errors, performance warnings, and deprecated functionality warnings.  Each message is also assigned a severity level that denotes roughly how "important" that message is in comparison to other messages across all categories.  For example, notification of a GL error would have a higher severity than a performance warning due ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DebugMessageCallbackAMD.</para>
        /// <para>Fullname: DebugMessageCallbackAMD</para>
        /// <para>Extensions: AMD_debug_output</para>
        /// </summary>
        public static void DebugMessageCallbackAMD(GLDEBUGPROCAMD callback, IntPtr userParam)
        {
            if (gl._DebugMessageCallbackAMD != null) gl._DebugMessageCallbackAMD(callback, userParam); else { }
        }
        /// <summary>
        /// <para>Fullname: DebugMessageEnableAMD</para>
        /// </summary>
        [GLEntry("DebugMessageEnableAMD", Category = "AMD")]
        public static GLDelegate.DebugMessageEnable _DebugMessageEnable = null;
        /// <summary>
        /// <para>This extension allows the GL to notify applications when various debug events occur in contexts that have been created with the debug flag, as provided by WGL_ARB_create_context and GLX_ARB_create_context.  These events are represented in the form of enumerable messages with an included human-readable translation.  Examples of debug events include incorrect use of the GL, warnings of undefined behavior, and performance warnings.  A message is uniquely identified by a category and an implementation- dependent ID within that category.  Message categories are general and are used to organize large groups of similar messages together.  Examples of categories include GL errors, performance warnings, and deprecated functionality warnings.  Each message is also assigned a severity level that denotes roughly how "important" that message is in comparison to other messages across all categories.  For example, notification of a GL error would have a higher severity than a performance warning due ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DebugMessageEnable.</para>
        /// <para>Fullname: DebugMessageEnableAMD</para>
        /// <para>Extensions: AMD_debug_output</para>
        /// </summary>
        public static void DebugMessageEnable(int category, int severity, int count, uint[] ids, bool enabled)
        {
            if (gl._DebugMessageEnable != null) gl._DebugMessageEnable(category, severity, count, ids, enabled); else { }
        }
        /// <summary>
        /// <para>Fullname: DebugMessageInsertAMD</para>
        /// </summary>
        [GLEntry("DebugMessageInsertAMD", Category = "AMD")]
        public static GLDelegate.DebugMessageInsertAMD _DebugMessageInsertAMD = null;
        /// <summary>
        /// <para>This extension allows the GL to notify applications when various debug events occur in contexts that have been created with the debug flag, as provided by WGL_ARB_create_context and GLX_ARB_create_context.  These events are represented in the form of enumerable messages with an included human-readable translation.  Examples of debug events include incorrect use of the GL, warnings of undefined behavior, and performance warnings.  A message is uniquely identified by a category and an implementation- dependent ID within that category.  Message categories are general and are used to organize large groups of similar messages together.  Examples of categories include GL errors, performance warnings, and deprecated functionality warnings.  Each message is also assigned a severity level that denotes roughly how "important" that message is in comparison to other messages across all categories.  For example, notification of a GL error would have a higher severity than a performance warning due ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DebugMessageInsertAMD.</para>
        /// <para>Fullname: DebugMessageInsertAMD</para>
        /// <para>Extensions: AMD_debug_output</para>
        /// </summary>
        public static void DebugMessageInsertAMD(int category, int severity, uint id, int length, StringBuilder buf)
        {
            if (gl._DebugMessageInsertAMD != null) gl._DebugMessageInsertAMD(category, severity, id, length, buf); else { }
        }
        /// <summary>
        /// <para>Fullname: DeleteNamesAMD</para>
        /// </summary>
        [GLEntry("DeleteNamesAMD", Category = "AMD")]
        public static GLDelegate.DeleteNames _DeleteNames = null;
        /// <summary>
        /// <para>This extension simply creates 2 new entry-points that name generic creation and deletion of names.  The intent is to go away from API functionality that provides a create/delete function for each specific object. For example: glGenTextures/glDeleteTextures/glIsTexture glGenBuffers/glDeleteBuffers/IsBuffer glGenFramebuffers/glDeleteFramebuffers/IsFramebuffer Instead, everything is created using one entry-point GenNamesAMD and everything is now deleted with another entry-point DeleteNamesAMD with the appropriate identifier set.  In addition, everything can now be queried with IsNameAMD. This alleviates the problem we may eventually encounter where we have many Gen/Delete/Is functions where 3 might suffice.  All that is needed in the new case is to add a valid identifier to the accepted parameters list.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeleteNames.</para>
        /// <para>Fullname: DeleteNamesAMD</para>
        /// <para>Extensions: AMD_name_gen_delete</para>
        /// </summary>
        public static void DeleteNames(int identifier, uint num, uint[] names)
        {
            if (gl._DeleteNames != null) gl._DeleteNames(identifier, num, names); else { }
        }
        /// <summary>
        /// <para>Fullname: DeletePerfMonitorsAMD</para>
        /// </summary>
        [GLEntry("DeletePerfMonitorsAMD", Category = "AMD")]
        public static GLDelegate.DeletePerfMonitors_uint _DeletePerfMonitors_uint = null;
        /// <summary>
        /// <para>This extension enables the capture and reporting of performance monitors. Performance monitors contain groups of counters which hold arbitrary counted data.  Typically, the counters hold information on performance-related counters in the underlying hardware.  The extension is general enough to allow the implementation to choose which counters to expose and pick the data type and range of the counters.  The extension also allows counting to start and end on arbitrary boundaries during rendering. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeletePerfMonitors_uint.</para>
        /// <para>Fullname: DeletePerfMonitorsAMD</para>
        /// <para>Extensions: AMD_performance_monitor</para>
        /// </summary>
        public static void DeletePerfMonitors(int n, out uint monitors)
        {
            if (gl._DeletePerfMonitors_uint != null) gl._DeletePerfMonitors_uint(n, out monitors); else { monitors = new uint(); }
        }
        /// <summary>
        /// <para>Fullname: DeletePerfMonitorsAMD</para>
        /// </summary>
        [GLEntry("DeletePerfMonitorsAMD", Category = "AMD")]
        public static GLDelegate.DeletePerfMonitors _DeletePerfMonitors = null;
        /// <summary>
        /// <para>This extension enables the capture and reporting of performance monitors. Performance monitors contain groups of counters which hold arbitrary counted data.  Typically, the counters hold information on performance-related counters in the underlying hardware.  The extension is general enough to allow the implementation to choose which counters to expose and pick the data type and range of the counters.  The extension also allows counting to start and end on arbitrary boundaries during rendering. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _DeletePerfMonitors.</para>
        /// <para>Fullname: DeletePerfMonitorsAMD</para>
        /// <para>Extensions: AMD_performance_monitor</para>
        /// </summary>
        public static void DeletePerfMonitors(int n, uint[] monitors)
        {
            if (gl._DeletePerfMonitors != null) gl._DeletePerfMonitors(n, monitors); else { }
        }
        /// <summary>
        /// <para>Fullname: EndPerfMonitorAMD</para>
        /// </summary>
        [GLEntry("EndPerfMonitorAMD", Category = "AMD")]
        public static GLDelegate.EndPerfMonitor _EndPerfMonitor = null;
        /// <summary>
        /// <para>This extension enables the capture and reporting of performance monitors. Performance monitors contain groups of counters which hold arbitrary counted data.  Typically, the counters hold information on performance-related counters in the underlying hardware.  The extension is general enough to allow the implementation to choose which counters to expose and pick the data type and range of the counters.  The extension also allows counting to start and end on arbitrary boundaries during rendering. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _EndPerfMonitor.</para>
        /// <para>Fullname: EndPerfMonitorAMD</para>
        /// <para>Extensions: AMD_performance_monitor</para>
        /// </summary>
        public static void EndPerfMonitor(uint monitor)
        {
            if (gl._EndPerfMonitor != null) gl._EndPerfMonitor(monitor); else { }
        }
        /// <summary>
        /// <para>Fullname: GenNamesAMD</para>
        /// </summary>
        [GLEntry("GenNamesAMD", Category = "AMD")]
        public static GLDelegate.GenNames _GenNames = null;
        /// <summary>
        /// <para>This extension simply creates 2 new entry-points that name generic creation and deletion of names.  The intent is to go away from API functionality that provides a create/delete function for each specific object. For example: glGenTextures/glDeleteTextures/glIsTexture glGenBuffers/glDeleteBuffers/IsBuffer glGenFramebuffers/glDeleteFramebuffers/IsFramebuffer Instead, everything is created using one entry-point GenNamesAMD and everything is now deleted with another entry-point DeleteNamesAMD with the appropriate identifier set.  In addition, everything can now be queried with IsNameAMD. This alleviates the problem we may eventually encounter where we have many Gen/Delete/Is functions where 3 might suffice.  All that is needed in the new case is to add a valid identifier to the accepted parameters list.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenNames.</para>
        /// <para>Fullname: GenNamesAMD</para>
        /// <para>Extensions: AMD_name_gen_delete</para>
        /// </summary>
        public static void GenNames(int identifier, uint num, uint[] names)
        {
            if (gl._GenNames != null) gl._GenNames(identifier, num, names); else { }
        }
        /// <summary>
        /// <para>Fullname: GenPerfMonitorsAMD</para>
        /// </summary>
        [GLEntry("GenPerfMonitorsAMD", Category = "AMD")]
        public static GLDelegate.GenPerfMonitors _GenPerfMonitors = null;
        /// <summary>
        /// <para>This extension enables the capture and reporting of performance monitors. Performance monitors contain groups of counters which hold arbitrary counted data.  Typically, the counters hold information on performance-related counters in the underlying hardware.  The extension is general enough to allow the implementation to choose which counters to expose and pick the data type and range of the counters.  The extension also allows counting to start and end on arbitrary boundaries during rendering. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenPerfMonitors.</para>
        /// <para>Fullname: GenPerfMonitorsAMD</para>
        /// <para>Extensions: AMD_performance_monitor</para>
        /// </summary>
        public static void GenPerfMonitors(int n, uint[] monitors)
        {
            if (gl._GenPerfMonitors != null) gl._GenPerfMonitors(n, monitors); else { }
        }
        /// <summary>
        /// <para>Fullname: GenPerfMonitorsAMD</para>
        /// </summary>
        [GLEntry("GenPerfMonitorsAMD", Category = "AMD")]
        public static GLDelegate.GenPerfMonitors_uint _GenPerfMonitors_uint = null;
        /// <summary>
        /// <para>This extension enables the capture and reporting of performance monitors. Performance monitors contain groups of counters which hold arbitrary counted data.  Typically, the counters hold information on performance-related counters in the underlying hardware.  The extension is general enough to allow the implementation to choose which counters to expose and pick the data type and range of the counters.  The extension also allows counting to start and end on arbitrary boundaries during rendering. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GenPerfMonitors_uint.</para>
        /// <para>Fullname: GenPerfMonitorsAMD</para>
        /// <para>Extensions: AMD_performance_monitor</para>
        /// </summary>
        public static void GenPerfMonitors(int n, out uint monitors)
        {
            if (gl._GenPerfMonitors_uint != null) gl._GenPerfMonitors_uint(n, out monitors); else { monitors = new uint(); }
        }
        /// <summary>
        /// <para>Fullname: GetDebugMessageLogAMD</para>
        /// </summary>
        [GLEntry("GetDebugMessageLogAMD", Category = "AMD")]
        public static GLDelegate.GetDebugMessageLogAMD _GetDebugMessageLogAMD = null;
        /// <summary>
        /// <para>This extension allows the GL to notify applications when various debug events occur in contexts that have been created with the debug flag, as provided by WGL_ARB_create_context and GLX_ARB_create_context.  These events are represented in the form of enumerable messages with an included human-readable translation.  Examples of debug events include incorrect use of the GL, warnings of undefined behavior, and performance warnings.  A message is uniquely identified by a category and an implementation- dependent ID within that category.  Message categories are general and are used to organize large groups of similar messages together.  Examples of categories include GL errors, performance warnings, and deprecated functionality warnings.  Each message is also assigned a severity level that denotes roughly how "important" that message is in comparison to other messages across all categories.  For example, notification of a GL error would have a higher severity than a performance warning due ...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetDebugMessageLogAMD.</para>
        /// <para>Fullname: GetDebugMessageLogAMD</para>
        /// <para>Extensions: AMD_debug_output</para>
        /// </summary>
        public static uint GetDebugMessageLogAMD(uint count, int bufsize, int[] categories, uint[] severities, uint[] ids, int[] lengths, StringBuilder message)
        {
            if (gl._GetDebugMessageLogAMD != null) return gl._GetDebugMessageLogAMD(count, bufsize, categories, severities, ids, lengths, message);
            else { return (uint)0; }
        }
        /// <summary>
        /// <para>Fullname: GetPerfMonitorCounterDataAMD</para>
        /// </summary>
        [GLEntry("GetPerfMonitorCounterDataAMD", Category = "AMD")]
        public static GLDelegate.GetPerfMonitorCounterData _GetPerfMonitorCounterData = null;
        /// <summary>
        /// <para>This extension enables the capture and reporting of performance monitors. Performance monitors contain groups of counters which hold arbitrary counted data.  Typically, the counters hold information on performance-related counters in the underlying hardware.  The extension is general enough to allow the implementation to choose which counters to expose and pick the data type and range of the counters.  The extension also allows counting to start and end on arbitrary boundaries during rendering. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPerfMonitorCounterData.</para>
        /// <para>Fullname: GetPerfMonitorCounterDataAMD</para>
        /// <para>Extensions: AMD_performance_monitor</para>
        /// </summary>
        public static void GetPerfMonitorCounterData(uint monitor, int pname, int dataSize, uint[] data, int[] bytesWritten)
        {
            if (gl._GetPerfMonitorCounterData != null) gl._GetPerfMonitorCounterData(monitor, pname, dataSize, data, bytesWritten); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPerfMonitorCounterDataAMD</para>
        /// </summary>
        [GLEntry("GetPerfMonitorCounterDataAMD", Category = "AMD")]
        public static GLDelegate.GetPerfMonitorCounterData_int _GetPerfMonitorCounterData_int = null;
        /// <summary>
        /// <para>This extension enables the capture and reporting of performance monitors. Performance monitors contain groups of counters which hold arbitrary counted data.  Typically, the counters hold information on performance-related counters in the underlying hardware.  The extension is general enough to allow the implementation to choose which counters to expose and pick the data type and range of the counters.  The extension also allows counting to start and end on arbitrary boundaries during rendering. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPerfMonitorCounterData_int.</para>
        /// <para>Fullname: GetPerfMonitorCounterDataAMD</para>
        /// <para>Extensions: AMD_performance_monitor</para>
        /// </summary>
        public static void GetPerfMonitorCounterData(uint monitor, int pname, int dataSize, uint[] data, out int bytesWritten)
        {
            if (gl._GetPerfMonitorCounterData_int != null) gl._GetPerfMonitorCounterData_int(monitor, pname, dataSize, data, out bytesWritten); else { bytesWritten = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetPerfMonitorCounterInfoAMD</para>
        /// </summary>
        [GLEntry("GetPerfMonitorCounterInfoAMD", Category = "AMD")]
        public static GLDelegate.GetPerfMonitorCounterInfo _GetPerfMonitorCounterInfo = null;
        /// <summary>
        /// <para>This extension enables the capture and reporting of performance monitors. Performance monitors contain groups of counters which hold arbitrary counted data.  Typically, the counters hold information on performance-related counters in the underlying hardware.  The extension is general enough to allow the implementation to choose which counters to expose and pick the data type and range of the counters.  The extension also allows counting to start and end on arbitrary boundaries during rendering. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPerfMonitorCounterInfo.</para>
        /// <para>Fullname: GetPerfMonitorCounterInfoAMD</para>
        /// <para>Extensions: AMD_performance_monitor</para>
        /// </summary>
        public static void GetPerfMonitorCounterInfo(uint group, uint counter, int pname, IntPtr data)
        {
            if (gl._GetPerfMonitorCounterInfo != null) gl._GetPerfMonitorCounterInfo(group, counter, pname, data); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPerfMonitorCountersAMD</para>
        /// </summary>
        [GLEntry("GetPerfMonitorCountersAMD", Category = "AMD")]
        public static GLDelegate.GetPerfMonitorCounters _GetPerfMonitorCounters = null;
        /// <summary>
        /// <para>This extension enables the capture and reporting of performance monitors. Performance monitors contain groups of counters which hold arbitrary counted data.  Typically, the counters hold information on performance-related counters in the underlying hardware.  The extension is general enough to allow the implementation to choose which counters to expose and pick the data type and range of the counters.  The extension also allows counting to start and end on arbitrary boundaries during rendering. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPerfMonitorCounters.</para>
        /// <para>Fullname: GetPerfMonitorCountersAMD</para>
        /// <para>Extensions: AMD_performance_monitor</para>
        /// </summary>
        public static void GetPerfMonitorCounters(uint group, int[] numCounters, int[] maxActiveCounters, int counterSize, uint[] counters)
        {
            if (gl._GetPerfMonitorCounters != null) gl._GetPerfMonitorCounters(group, numCounters, maxActiveCounters, counterSize, counters); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPerfMonitorCountersAMD</para>
        /// </summary>
        [GLEntry("GetPerfMonitorCountersAMD", Category = "AMD")]
        public static GLDelegate.GetPerfMonitorCounters_int_int _GetPerfMonitorCounters_int_int = null;
        /// <summary>
        /// <para>This extension enables the capture and reporting of performance monitors. Performance monitors contain groups of counters which hold arbitrary counted data.  Typically, the counters hold information on performance-related counters in the underlying hardware.  The extension is general enough to allow the implementation to choose which counters to expose and pick the data type and range of the counters.  The extension also allows counting to start and end on arbitrary boundaries during rendering. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPerfMonitorCounters_int_int.</para>
        /// <para>Fullname: GetPerfMonitorCountersAMD</para>
        /// <para>Extensions: AMD_performance_monitor</para>
        /// </summary>
        public static void GetPerfMonitorCounters(uint group, out int numCounters, out int maxActiveCounters, int counterSize, uint[] counters)
        {
            if (gl._GetPerfMonitorCounters_int_int != null) gl._GetPerfMonitorCounters_int_int(group, out numCounters, out maxActiveCounters, counterSize, counters); else { numCounters = new int(); maxActiveCounters = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetPerfMonitorCounterStringAMD</para>
        /// </summary>
        [GLEntry("GetPerfMonitorCounterStringAMD", Category = "AMD")]
        public static GLDelegate.GetPerfMonitorCounterString _GetPerfMonitorCounterString = null;
        /// <summary>
        /// <para>This extension enables the capture and reporting of performance monitors. Performance monitors contain groups of counters which hold arbitrary counted data.  Typically, the counters hold information on performance-related counters in the underlying hardware.  The extension is general enough to allow the implementation to choose which counters to expose and pick the data type and range of the counters.  The extension also allows counting to start and end on arbitrary boundaries during rendering. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPerfMonitorCounterString.</para>
        /// <para>Fullname: GetPerfMonitorCounterStringAMD</para>
        /// <para>Extensions: AMD_performance_monitor</para>
        /// </summary>
        public static void GetPerfMonitorCounterString(uint group, uint counter, int bufSize, int[] length, StringBuilder counterString)
        {
            if (gl._GetPerfMonitorCounterString != null) gl._GetPerfMonitorCounterString(group, counter, bufSize, length, counterString); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPerfMonitorCounterStringAMD</para>
        /// </summary>
        [GLEntry("GetPerfMonitorCounterStringAMD", Category = "AMD")]
        public static GLDelegate.GetPerfMonitorCounterString_int _GetPerfMonitorCounterString_int = null;
        /// <summary>
        /// <para>This extension enables the capture and reporting of performance monitors. Performance monitors contain groups of counters which hold arbitrary counted data.  Typically, the counters hold information on performance-related counters in the underlying hardware.  The extension is general enough to allow the implementation to choose which counters to expose and pick the data type and range of the counters.  The extension also allows counting to start and end on arbitrary boundaries during rendering. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPerfMonitorCounterString_int.</para>
        /// <para>Fullname: GetPerfMonitorCounterStringAMD</para>
        /// <para>Extensions: AMD_performance_monitor</para>
        /// </summary>
        public static void GetPerfMonitorCounterString(uint group, uint counter, int bufSize, out int length, StringBuilder counterString)
        {
            if (gl._GetPerfMonitorCounterString_int != null) gl._GetPerfMonitorCounterString_int(group, counter, bufSize, out length, counterString); else { length = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetPerfMonitorGroupsAMD</para>
        /// </summary>
        [GLEntry("GetPerfMonitorGroupsAMD", Category = "AMD")]
        public static GLDelegate.GetPerfMonitorGroups_int _GetPerfMonitorGroups_int = null;
        /// <summary>
        /// <para>This extension enables the capture and reporting of performance monitors. Performance monitors contain groups of counters which hold arbitrary counted data.  Typically, the counters hold information on performance-related counters in the underlying hardware.  The extension is general enough to allow the implementation to choose which counters to expose and pick the data type and range of the counters.  The extension also allows counting to start and end on arbitrary boundaries during rendering. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPerfMonitorGroups_int.</para>
        /// <para>Fullname: GetPerfMonitorGroupsAMD</para>
        /// <para>Extensions: AMD_performance_monitor</para>
        /// </summary>
        public static void GetPerfMonitorGroups(out int numGroups, int groupsSize, uint[] groups)
        {
            if (gl._GetPerfMonitorGroups_int != null) gl._GetPerfMonitorGroups_int(out numGroups, groupsSize, groups); else { numGroups = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetPerfMonitorGroupsAMD</para>
        /// </summary>
        [GLEntry("GetPerfMonitorGroupsAMD", Category = "AMD")]
        public static GLDelegate.GetPerfMonitorGroups _GetPerfMonitorGroups = null;
        /// <summary>
        /// <para>This extension enables the capture and reporting of performance monitors. Performance monitors contain groups of counters which hold arbitrary counted data.  Typically, the counters hold information on performance-related counters in the underlying hardware.  The extension is general enough to allow the implementation to choose which counters to expose and pick the data type and range of the counters.  The extension also allows counting to start and end on arbitrary boundaries during rendering. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPerfMonitorGroups.</para>
        /// <para>Fullname: GetPerfMonitorGroupsAMD</para>
        /// <para>Extensions: AMD_performance_monitor</para>
        /// </summary>
        public static void GetPerfMonitorGroups(int[] numGroups, int groupsSize, uint[] groups)
        {
            if (gl._GetPerfMonitorGroups != null) gl._GetPerfMonitorGroups(numGroups, groupsSize, groups); else { }
        }
        /// <summary>
        /// <para>Fullname: GetPerfMonitorGroupStringAMD</para>
        /// </summary>
        [GLEntry("GetPerfMonitorGroupStringAMD", Category = "AMD")]
        public static GLDelegate.GetPerfMonitorGroupString_int _GetPerfMonitorGroupString_int = null;
        /// <summary>
        /// <para>This extension enables the capture and reporting of performance monitors. Performance monitors contain groups of counters which hold arbitrary counted data.  Typically, the counters hold information on performance-related counters in the underlying hardware.  The extension is general enough to allow the implementation to choose which counters to expose and pick the data type and range of the counters.  The extension also allows counting to start and end on arbitrary boundaries during rendering. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPerfMonitorGroupString_int.</para>
        /// <para>Fullname: GetPerfMonitorGroupStringAMD</para>
        /// <para>Extensions: AMD_performance_monitor</para>
        /// </summary>
        public static void GetPerfMonitorGroupString(uint group, int bufSize, out int length, StringBuilder groupString)
        {
            if (gl._GetPerfMonitorGroupString_int != null) gl._GetPerfMonitorGroupString_int(group, bufSize, out length, groupString); else { length = new int(); }
        }
        /// <summary>
        /// <para>Fullname: GetPerfMonitorGroupStringAMD</para>
        /// </summary>
        [GLEntry("GetPerfMonitorGroupStringAMD", Category = "AMD")]
        public static GLDelegate.GetPerfMonitorGroupString _GetPerfMonitorGroupString = null;
        /// <summary>
        /// <para>This extension enables the capture and reporting of performance monitors. Performance monitors contain groups of counters which hold arbitrary counted data.  Typically, the counters hold information on performance-related counters in the underlying hardware.  The extension is general enough to allow the implementation to choose which counters to expose and pick the data type and range of the counters.  The extension also allows counting to start and end on arbitrary boundaries during rendering. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _GetPerfMonitorGroupString.</para>
        /// <para>Fullname: GetPerfMonitorGroupStringAMD</para>
        /// <para>Extensions: AMD_performance_monitor</para>
        /// </summary>
        public static void GetPerfMonitorGroupString(uint group, int bufSize, int[] length, StringBuilder groupString)
        {
            if (gl._GetPerfMonitorGroupString != null) gl._GetPerfMonitorGroupString(group, bufSize, length, groupString); else { }
        }
        /// <summary>
        /// <para>Fullname: IsNameAMD</para>
        /// </summary>
        [GLEntry("IsNameAMD", Category = "AMD")]
        public static GLDelegate.IsName _IsName = null;
        /// <summary>
        /// <para>This extension simply creates 2 new entry-points that name generic creation and deletion of names.  The intent is to go away from API functionality that provides a create/delete function for each specific object. For example: glGenTextures/glDeleteTextures/glIsTexture glGenBuffers/glDeleteBuffers/IsBuffer glGenFramebuffers/glDeleteFramebuffers/IsFramebuffer Instead, everything is created using one entry-point GenNamesAMD and everything is now deleted with another entry-point DeleteNamesAMD with the appropriate identifier set.  In addition, everything can now be queried with IsNameAMD. This alleviates the problem we may eventually encounter where we have many Gen/Delete/Is functions where 3 might suffice.  All that is needed in the new case is to add a valid identifier to the accepted parameters list.  </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _IsName.</para>
        /// <para>Fullname: IsNameAMD</para>
        /// <para>Extensions: AMD_name_gen_delete</para>
        /// </summary>
        public static bool IsName(int identifier, uint name)
        {
            if (gl._IsName != null) return gl._IsName(identifier, name);
            else { return false; }
        }
        /// <summary>
        /// <para>Fullname: SelectPerfMonitorCountersAMD</para>
        /// </summary>
        [GLEntry("SelectPerfMonitorCountersAMD", Category = "AMD")]
        public static GLDelegate.SelectPerfMonitorCounters _SelectPerfMonitorCounters = null;
        /// <summary>
        /// <para>This extension enables the capture and reporting of performance monitors. Performance monitors contain groups of counters which hold arbitrary counted data.  Typically, the counters hold information on performance-related counters in the underlying hardware.  The extension is general enough to allow the implementation to choose which counters to expose and pick the data type and range of the counters.  The extension also allows counting to start and end on arbitrary boundaries during rendering. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SelectPerfMonitorCounters.</para>
        /// <para>Fullname: SelectPerfMonitorCountersAMD</para>
        /// <para>Extensions: AMD_performance_monitor</para>
        /// </summary>
        public static void SelectPerfMonitorCounters(uint monitor, bool enable, uint group, int numCounters, uint[] counterList)
        {
            if (gl._SelectPerfMonitorCounters != null) gl._SelectPerfMonitorCounters(monitor, enable, group, numCounters, counterList); else { }
        }
        /// <summary>
        /// <para>Fullname: SetMultisamplefvAMD</para>
        /// </summary>
        [GLEntry("SetMultisamplefvAMD", Category = "AMD")]
        public static GLDelegate.SetMultisamplefv _SetMultisamplefv = null;
        /// <summary>
        /// <para>This extension provides a mechanism to explicitly set sample positions for a FBO with multi-sampled attachments. The FBO will use identical sample locations for all pixels in each attachment. This forces TEXTURE_FIXED_SAMPLE_LOCATIONS to TRUE if a multi-sampled texture is specified using TexImage2DMultisample or TexImage3DMultisample. That is, using GetTexLevelParameter to query TEXTURE_FIXED_SAMPLE_LOCATIONS will always return TRUE if the mechanism is explicitly used to set the sample positions. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _SetMultisamplefv.</para>
        /// <para>Fullname: SetMultisamplefvAMD</para>
        /// <para>Extensions: AMD_sample_positions</para>
        /// </summary>
        public static void SetMultisamplefv(int pname, uint index, float[] val)
        {
            if (gl._SetMultisamplefv != null) gl._SetMultisamplefv(pname, index, val); else { }
        }
        /// <summary>
        /// <para>Fullname: StencilOpValueAMD</para>
        /// </summary>
        [GLEntry("StencilOpValueAMD", Category = "AMD")]
        public static GLDelegate.StencilOpValue _StencilOpValue = null;
        /// <summary>
        /// <para>Stencil buffers are special buffers that allow tests to be made against an incoming value and action taken based on that value. The stencil buffer is updated during rasterization, and the operation used to update the stencil buffer is chosen based on whether the fragment passes the stencil test, and if it does, whether it passes the depth test. Traditional OpenGL includes support for several primitive operations, such as incrementing, or clearing the content of the stencil buffer, or replacing it with a specified reference value. This extension adds support for an additional set of operations that may be performed on the stencil buffer under each circumstance. Additionally, this extension separates the value used as the source for stencil operations from the reference value, allowing different values to be used in the stencil test, and in the update of the stencil buffer. </para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _StencilOpValue.</para>
        /// <para>Fullname: StencilOpValueAMD</para>
        /// <para>Extensions: AMD_stencil_operation_extended</para>
        /// </summary>
        public static void StencilOpValue(int face, uint value)
        {
            if (gl._StencilOpValue != null) gl._StencilOpValue(face, value); else { }
        }
        /// <summary>
        /// <para>Fullname: TessellationFactorAMD</para>
        /// </summary>
        [GLEntry("TessellationFactorAMD", Category = "AMD")]
        public static GLDelegate.TessellationFactor _TessellationFactor = null;
        /// <summary>
        /// <para>The vertex shader tessellator gives new flexibility to the shader author to shade at a tessellated vertex, rather than just at a provided vertex. In unextended vertex shading, the built-in attributes such as gl_Vertex, gl_Normal, and gl_MultiTexcoord0, together with the user defined attributes, are system provided values which are initialized prior to vertex shader invocation. With vertex shading tessellation, additional vertex shader special values are available: ivec3 gl_VertexTriangleIndex; // indices of the three control // points for the vertex vec3 gl_BarycentricCoord;     // barycentric coordinates // of the vertex i o |\ | \ *--* |\ |\ | \| \ *--*--* |\ |\ |\ | \| \| \ j o--*--*--o k Figure 1  A Tessellated Triangle o = control point (and tessellated vertex) * = tessellated vertex ivec4 gl_VertexQuadIndex;   // indices for the four control // points for the vertex vec2 gl_UVCoord;            // UV coordinates of the vertex i o--*--*--o k |\ |\ |\ | | \| \| \| *--*--*--* |\ |\ |...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TessellationFactor.</para>
        /// <para>Fullname: TessellationFactorAMD</para>
        /// <para>Extensions: AMD_vertex_shader_tesselator</para>
        /// </summary>
        public static void TessellationFactor(float factor)
        {
            if (gl._TessellationFactor != null) gl._TessellationFactor(factor); else { }
        }
        /// <summary>
        /// <para>Fullname: TessellationModeAMD</para>
        /// </summary>
        [GLEntry("TessellationModeAMD", Category = "AMD")]
        public static GLDelegate.TessellationMode _TessellationMode = null;
        /// <summary>
        /// <para>The vertex shader tessellator gives new flexibility to the shader author to shade at a tessellated vertex, rather than just at a provided vertex. In unextended vertex shading, the built-in attributes such as gl_Vertex, gl_Normal, and gl_MultiTexcoord0, together with the user defined attributes, are system provided values which are initialized prior to vertex shader invocation. With vertex shading tessellation, additional vertex shader special values are available: ivec3 gl_VertexTriangleIndex; // indices of the three control // points for the vertex vec3 gl_BarycentricCoord;     // barycentric coordinates // of the vertex i o |\ | \ *--* |\ |\ | \| \ *--*--* |\ |\ |\ | \| \| \ j o--*--*--o k Figure 1  A Tessellated Triangle o = control point (and tessellated vertex) * = tessellated vertex ivec4 gl_VertexQuadIndex;   // indices for the four control // points for the vertex vec2 gl_UVCoord;            // UV coordinates of the vertex i o--*--*--o k |\ |\ |\ | | \| \| \| *--*--*--* |\ |\ |...</para>
        /// <para>Wrapped gl function. If the function is not provided by the GL, nothing happens. If you'd like to call the function directly, use _TessellationMode.</para>
        /// <para>Fullname: TessellationModeAMD</para>
        /// <para>Extensions: AMD_vertex_shader_tesselator</para>
        /// </summary>
        public static void TessellationMode(int mode)
        {
            if (gl._TessellationMode != null) gl._TessellationMode(mode); else { }
        }
    }
}
